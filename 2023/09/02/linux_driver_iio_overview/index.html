<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>参考网站: <a href="https://wiki.analog.com/software/linux/docs/iio/iio">Analog</a>，<a href="https://bootlin.com/blog/the-backbone-of-a-linux-industrial-i-o-driver/">the-backbone-of-a-linux-industrial-i-o-driver</a></p>
<p>参考文档: <code>Documentation/iio/</code>     <code>Documentation/ABI/testing/sysfs-bus-iio*</code></p>
<p>参考代码: <code>drivers/iio/**</code></p>
<span id="more"></span>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>IIO 子系统主要包含一些传感器，AD，DA 等器件的操作。<br>此系统的目的是为了填补hwmon 和 input 子系统之间的空隙。</p>
<p>一般此子系统下的设备是通过 SPI 或者 I2C 通信。</p>
<ul>
<li>hwmon(硬件监视) : 主要用于低速的设备监视</li>
<li>input(输入子系统): 主要专注于与用户交互的设备(比如: 按键, 鼠标, 触摸等)</li>
</ul>
<p>此子系统为这类设备提供了统一的函数接口和数据结构, 这些的具体实现位置是 <code>drivers/iio/industrialio-xxx.c</code>。</p>
<p>包含以下种类:</p>
<ul>
<li>ADC 以及 DAC</li>
<li>加速度计</li>
<li>陀螺仪</li>
<li>惯性测量仪</li>
<li>电容-数字转换器</li>
<li>气压计</li>
<li>颜色，光，距离传感器</li>
<li>温度传感器</li>
<li>磁力计</li>
<li>直接数字合成器(DDS)</li>
<li>锁相环(PLL)</li>
<li>可变/可编程增益放大器(VGA, PGA)</li>
<li>FPGA外设</li>
<li>由DMA传输的高速串口或并口</li>
</ul>
<p>包含以下功能:</p>
<ul>
<li>设备的注册及处理操作.</li>
<li>可以通过 <code>sysfs</code> 来访问设备</li>
<li>事件机制: 将设备的一些事件发送给用户空间。</li>
<li>支持硬件环形队列</li>
<li>ring buffer 存储事件，可以查看 buffer 填充状态</li>
</ul>
<p>这些设备都有一些共同点：</p>
<ul>
<li>在采集数据前，需要先对采集进行配置</li>
<li>部分设备还具备采集的触发机制</li>
<li>采集到的数据通过统一的机制发送给用户空间</li>
</ul>
<h3 id="ring-buffer"><a href="#ring-buffer" class="headerlink" title="ring buffer"></a>ring buffer</h3><p>环形队列缓存，也就是先进先出缓存，从尾部写入，从头部读出。iio 使用 <code>kfifo</code> 来实现，以应对生产者消费者模型。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--IIO/overview/IIO_ringBuffer.jpg?raw=true"></p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>可以认为是一些标识，以向用户表示一些状态发生了。</p>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>一个引导信号，只要此信号产生后便会导致另一些处理程序的运行(类似于中断)，比如产生一个事件标志。</p>
<p>有如下几种 trigger：</p>
<ul>
<li>数据已准备好</li>
<li>GPIO触发<ul>
<li>iio中使用 <code>iio-trig-gpio</code> 来完成此支持</li>
</ul>
</li>
<li>内部周期性触发<ul>
<li>iio中使用 <code>iio-trig-rtc</code> 来完成此支持</li>
</ul>
</li>
<li>用户空间读取特定文件的触发<ul>
<li>iio中使用 <code>iio-trig-sysfs</code> 来完成此支持</li>
</ul>
</li>
</ul>
<p>IIO中使用 trigger 来填充ring buffer。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>一个通道，代表一种信号(数据)。比如气压计具有测量气压和温度的功能，则它具有一个气压通道和一个温度通道。</p>
<h2 id="构架"><a href="#构架" class="headerlink" title="构架"></a>构架</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--IIO/overview/IIO_overview.jpg?raw=true"><br>根据设备驱动思想以及上面的说明可以知道需要以下软件的支持才能使用此子系统:</p>
<ul>
<li>总线控制器驱动及设备树</li>
<li>芯片驱动(总线客户端驱动)及设备树</li>
<li>IIO子系统的接口填充</li>
</ul>
<p>一般来讲，<code>BUS Driver</code> 的驱动都有芯片厂商提供，用户需要：</p>
<ul>
<li>在设备树中对应总线方式增加设备节点</li>
<li>实现设备驱动</li>
<li>在设备驱动中使用 iio 提供的接口将配置映射到字符设备和 <code>sysfs</code> 中</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在驱动正常的情况下，子系统会将设备映射到 :</p>
<ol>
<li><code>sysfs</code> 下，用于配置设备以及读取原始数据。</li>
<li>字符设备，用于访问内核缓存事件等</li>
</ol>
<h2 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h2><p>路径位于: <code>/sys/bus/iio/devices/iio:deviceX</code> ，其目录下具有以下文件:</p>
<ul>
<li>name: 设备号</li>
<li>dev: 设备节点(major:minor)</li>
<li>device configuration attributes (sampling_frequency_avaliables)</li>
<li>data channel access attributes(in_resistance_raw)</li>
<li>buffer/，events/，trigger/，scan_elements/</li>
</ul>
<p>通过读取 <code>iio:deviceX</code> 中的对应文件，其实会对应调用设备的回调函数</p>
<p>(比如读取 “xxx_raw” 文件, 会调用 read_raw 函数).</p>
<h2 id="character-device"><a href="#character-device" class="headerlink" title="character device"></a>character device</h2><p>路径位于: <code>/dev/iio:deviceX</code></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="驱动编写步骤"><a href="#驱动编写步骤" class="headerlink" title="驱动编写步骤"></a>驱动编写步骤</h2><p>驱动的编写步骤为:</p>
<ol>
<li><p>根据设备所属的通信总线，实现其总线驱动，以及对应的设备树节点。</p>
</li>
<li><p>创建 <code>struct iio_dev</code> 结构（通过 <code>devm_iio_device_alloc</code>申请），并填充其内容</p>
<ul>
<li><p>设备名称</p>
</li>
<li><p>私有数据填充</p>
</li>
<li><p>设备 <code>iio_info</code> 结构体填充</p>
</li>
<li><p>设备 <code>channel</code> 结构体填充</p>
</li>
<li><p>设备所支持的模式</p>
</li>
<li><p>如果设备只有特定的通道能用，则需要初始化<code>available_scan_masks</code>，在实际工作中，当前正在获取的通道会在<code>active_scan_mask</code>中表示</p>
</li>
<li><p>初始化设备的每个通道的类型，比如（<code>IIO_VOLTAGE</code>，<code>IIO_TEMPERATURE</code>）</p>
</li>
</ul>
</li>
<li><p>使用 <code>devm_iio_device_register</code> 将此设备注册至IIO框架.</p>
</li>
<li><p>完成对应的卸载功能函数</p>
</li>
</ol>
<h2 id="iio-dev"><a href="#iio-dev" class="headerlink" title="iio_dev"></a>iio_dev</h2><p><code>iio_dev</code> 是最主要的结构体，用于设备驱动，主要提供一些信息和操作函数:</p>
<ul>
<li>该设备有多少通道可用</li>
<li>此设置支持哪些操作模式</li>
<li>此驱动支持的一些回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief struct iio_dev - industrial I/O device</span></span><br><span class="line"><span class="comment"> * @param modes: 此设备支持的模式</span></span><br><span class="line"><span class="comment"> * @param dev: 设备结构体，说明 iio_dev 继承自 struct device</span></span><br><span class="line"><span class="comment"> * @param buffer: 当前设备的数据缓存</span></span><br><span class="line"><span class="comment"> * @param scan_bytes: 被捕获的字节数</span></span><br><span class="line"><span class="comment"> * @param mlock: 用于互斥操作的锁</span></span><br><span class="line"><span class="comment"> * @param available_scan_masks: 允许的通道 mask</span></span><br><span class="line"><span class="comment"> * @param masklength: mask长度</span></span><br><span class="line"><span class="comment"> * @param active_scan_mask: 缓存所需要的mask</span></span><br><span class="line"><span class="comment"> * @param scan_timestamp: 缓存与时间戳</span></span><br><span class="line"><span class="comment"> * @param trig: 当前设备的触发设置</span></span><br><span class="line"><span class="comment"> * @param pollfunc: 触发被接收到后, 用于运行的功能</span></span><br><span class="line"><span class="comment"> * @param pollfunc_event: 当事件触发被接收到后, 运行</span></span><br><span class="line"><span class="comment"> * @param channels: 对通道的定义</span></span><br><span class="line"><span class="comment"> * @param num_channels: 定义的通道数</span></span><br><span class="line"><span class="comment"> * @param name: 设备的名称</span></span><br><span class="line"><span class="comment"> * @param label : 标识设备的唯一名称</span></span><br><span class="line"><span class="comment"> * @param info: 驱动的回调和固定信息</span></span><br><span class="line"><span class="comment"> * @param setup_ops: 在缓存使能和关闭时的回调</span></span><br><span class="line"><span class="comment"> * @param priv: 每个驱动的私有数据结构的指针，通过 iio_priv 获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>                modes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>            <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span>        *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                scan_bytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            <span class="title">mlock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>        *available_scan_masks;</span><br><span class="line">    <span class="keyword">unsigned</span>            masklength;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>        *active_scan_mask;</span><br><span class="line">    <span class="keyword">bool</span>                scan_timestamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span>        *<span class="title">trig</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>        *<span class="title">pollfunc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>        *<span class="title">pollfunc_event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">const</span>    *<span class="title">channels</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                num_channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *label;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span>        *<span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span>    *<span class="title">setup_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief chardev interface for an event lines</span></span><br><span class="line"><span class="comment"> * @param wait : 阻塞读取队列</span></span><br><span class="line"><span class="comment"> * @param det_events: 已经检测到的事件链表</span></span><br><span class="line"><span class="comment"> * @param dev_attr_list: 属性链表</span></span><br><span class="line"><span class="comment"> * @param flags:相应的文件操作标记</span></span><br><span class="line"><span class="comment"> * @param group: 属性组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_event_interface</span>&#123;</span></span><br><span class="line">        <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">        DECLARE_KFIFO(det_events, struct iio_event_data, <span class="number">16</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_attr_list</span>;</span></span><br><span class="line">        unsigend <span class="keyword">long</span> flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">group</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">read_lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备的通道"><a href="#设备的通道" class="headerlink" title="设备的通道"></a>设备的通道</h2><p>通道的描述用 <code>channel</code> 结构体来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 定义一个通道</span></span><br><span class="line"><span class="comment">   * @param info_mask_separate : 对于当前通道，在 sysfs 中的展现信息 </span></span><br><span class="line"><span class="comment">   * @param scan_type : 指定当前通道的数据类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span>    <span class="title">type</span>;</span></span><br><span class="line">    <span class="keyword">int</span>            channel;</span><br><span class="line">    <span class="keyword">int</span>            channel2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        address;</span><br><span class="line">    <span class="keyword">int</span>            scan_index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span>    sign;</span><br><span class="line">        u8    realbits;</span><br><span class="line">        u8    storagebits;</span><br><span class="line">        u8    shift;</span><br><span class="line">        u8    repeat;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">iio_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    &#125; scan_type;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_separate;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_separate_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_type;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_type_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_dir;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_dir_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_all;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_all_available;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_spec</span> *<span class="title">event_spec</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        num_event_specs;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec_ext_info</span> *<span class="title">ext_info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *extend_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *datasheet_name;</span><br><span class="line">    <span class="keyword">unsigned</span>        modified:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        indexed:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        output:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        differential:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里初始化了 ms5611 的气压和温度通道</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">ms5611_channels</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .type = IIO_PRESSURE,</span><br><span class="line">        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_SCALE) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),</span><br><span class="line">        .scan_index = <span class="number">0</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">            .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            .realbits = <span class="number">32</span>,</span><br><span class="line">            .storagebits = <span class="number">32</span>,</span><br><span class="line">            .endianness = IIO_CPU,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .type = IIO_TEMP,</span><br><span class="line">        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_SCALE) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),</span><br><span class="line">        .scan_index = <span class="number">1</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">            .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            .realbits = <span class="number">32</span>,</span><br><span class="line">            .storagebits = <span class="number">32</span>,</span><br><span class="line">            .endianness = IIO_CPU,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    IIO_CHAN_SOFT_TIMESTAMP(<span class="number">2</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当具有多个通道的时候, 有两种方式来生成不同的通道:</p>
<ul>
<li>设置 <code>.modified</code> 值为1, 对应的设置 <code>.channel2</code> 来区分不同的通道.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">light_channels</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_INTENSITY,</span><br><span class="line">                .modified = <span class="number">1</span>,</span><br><span class="line">                .channel2 = IIO_MOD_LIGHT_IR,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_INTENSITY,</span><br><span class="line">                .modified = <span class="number">1</span>,</span><br><span class="line">                .channel2 = IIO_MOD_LIGHT_BOTH,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_LIGHT,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用上面的配置,得到的 <code>sysfs</code> 文件为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/sys/bus/iio/device/iio:deviceX/in_intensity_ir_raw </span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/in_intensity_both_raw</span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/in_illuminance_input </span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/sampling_frequency </span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <code>.indexed</code> 值为1, 对应的设置 <code>.channel</code> 来区分不同的通道</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">light_channels</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_VOLTAGE,</span><br><span class="line">                .indexed = <span class="number">1</span>,</span><br><span class="line">                .channel = <span class="number">0</span>,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_VOLTAGE,</span><br><span class="line">                .indexed = <span class="number">1</span>,</span><br><span class="line">                .channel = <span class="number">1</span>,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用上面的配置, 得到的 <code>sysfs</code> 文件为:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sys/bus/iio/devices/iio:deviceX/in_voltage0_raw,</span><br><span class="line"></span><br><span class="line">/sys/bus/iio/devices/iio:deviceX/in_voltage1_raw,</span><br></pre></td></tr></table></figure>

<h2 id="缩放因子"><a href="#缩放因子" class="headerlink" title="缩放因子"></a>缩放因子</h2><p>当在<code>sysfs</code>中读取 raw 或 scale 的值时，内核回调函数<code>int (*read_raw)(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask)</code>将会被调用。</p>
<p>对于<code>info_mask_separate</code>是<code>IIO_CHAN_INFO_RAW</code>的通道，就会直接返回原始数据。而对于<code>IIO_CHAN_INFO_SCALE</code>的通道，会返回原始数据和缩放因子。</p>
<p>IIO 驱动的内核则会除以该缩放因子，得到最终的值返回给用户空间。</p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>采样的值可以简单粗暴的通过读<code>/sys/bus/devices/iio:device/in_&lt;type&gt;&lt;index&gt;_raw</code>，对应到驱动的<code>read_raw()</code>回调来完成。这种读取就是单次的读数据。</p>
<p>也可以通过触发的方式，来获取数据。</p>
<h2 id="设备缓存"><a href="#设备缓存" class="headerlink" title="设备缓存"></a>设备缓存</h2><p>当使用缓存时, 会在 <code>sysfs</code> 下建立文件夹 <code>/sys/bus/iio/device/iio:deviceX/buffer/</code> , 此目录下具有文件:</p>
<ul>
<li>length : 缓存的大小</li>
<li>enable : 使能 buffer 捕捉事件</li>
</ul>
<p>一个通道读取原始数据以后, 放在缓存中, 称为 <code>scan element</code>, 此属性在 <code>iio_chan_spec</code> 的 <code>scan_type</code> 中设置.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">accel_channels</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line">        .type = IIO_ACCEL,</span><br><span class="line">        .modified = <span class="number">1</span>,</span><br><span class="line">        .channel2 = IIO_MOD_X,</span><br><span class="line">        <span class="comment">/// 指定此通道的优先级,越低优先级越高, 为 -1 代表不支持放入buffer</span></span><br><span class="line">        .scan_index = <span class="number">0</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">                .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">                .realbits = <span class="number">13</span>,</span><br><span class="line">                .storgebits = <span class="number">16</span>,</span><br><span class="line">                .shift = <span class="number">4</span>,</span><br><span class="line">                .endianness = IIO_LE,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置 <code>scan element</code> 的对应文件位于 <code>sys/bus/iio/device/iio:deviceX/scan_elements/</code>, 具有以下文件:</p>
<ul>
<li>enable : 用于使能一个通道, 此值不为 0 时则存入捕获的结果</li>
<li>type : 用于表述数据的类型,格式为 <code>[be/le]:[s/u]bits/storagebitsRepeat[&gt;&gt;shift]</code>.<ul>
<li>be -&gt; 大端模式, le -&gt; 小端模式</li>
<li>s -&gt; 有符号型, u -&gt; 无符号型</li>
<li>bits -&gt; 有效数据位数</li>
<li>storagebits -&gt; 一个数据以多少位来表示</li>
<li>repeat -&gt; 指定数据重复次数</li>
<li>shift -&gt; 数据 <strong>需要偏移的位数以得到正确的数据</strong>.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief buffer 用于存储接收到的数据, 用户通过 /dev/iio:deviceX 来读取即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span>                         length;</span><br><span class="line">        <span class="keyword">int</span>                         bytes_per_datum;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      *<span class="title">scan_el_attrs</span>;</span></span><br><span class="line">        <span class="keyword">long</span>                        *scan_mask;</span><br><span class="line">        <span class="keyword">bool</span>                        scan_timestamp;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_access_funcs</span> *<span class="title">access</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">scan_el_dev_attr_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      <span class="title">buffer_group</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      <span class="title">scan_el_group</span>;</span></span><br><span class="line">        <span class="keyword">wait_queue_head_t</span>           pollq;</span><br><span class="line">        <span class="keyword">bool</span>                        stufftoread;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>      *<span class="title">attrs</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">demux_list</span>;</span></span><br><span class="line">        <span class="keyword">void</span>                        *demux_bounce;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">buffer_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>                 <span class="title">ref</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>                waitermark;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备触发"><a href="#设备触发" class="headerlink" title="设备触发"></a>设备触发</h2><p>通过触发来存储数据，比用轮询的方式更加科学。</p>
<p>触发对应的 <code>sysfs</code> 文件夹有两个位置:</p>
<ul>
<li><code>/sys/bus/iio/devices/triggerY</code> : 当 IIO 触发使用了注册函数后, 此文件夹便建立了, 具有以下两个属性文件。<ul>
<li>name –&gt; 触发的名称</li>
<li>sampling_frequency –&gt; 基于定时器的触发， 具有扫瞄频率</li>
</ul>
</li>
<li><code>/sys/bus/iio/devices/iio:deviceX/trigger/</code> : 当一个设备支持触发时, 此文件夹便出现。为了将设备与触发连接起来， 在 <code>current_trigger</code> 文件中写入触发名称即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span>    *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>            *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>            <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">alloc_list</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>            use_count;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>            <span class="title">subirq_chip</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                subirq_base;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_subirq</span> <span class="title">subirqs</span>[<span class="title">CONFIG_IIO_CONSUMERS_PER_TRIGGER</span>];</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pool[BITS_TO_LONGS(CONFIG_IIO_CONSUMERS_PER_TRIGGER)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            <span class="title">pool_lock</span>;</span></span><br><span class="line">    <span class="keyword">bool</span>                attached_own_device;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>        <span class="title">reenable_work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span> <span class="title">zpa2326_trigger_ops</span> =</span> &#123;</span><br><span class="line">    .set_trigger_state = zpa2326_set_trigger_state,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zpa2326_init_managed_trigger</span><span class="params">(struct device          *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct iio_dev         *indio_dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct zpa2326_private *<span class="keyword">private</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span>                     irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> *<span class="title">trigger</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                 ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (irq &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    trigger = devm_iio_trigger_alloc(parent, <span class="string">&quot;%s-dev%d&quot;</span>,</span><br><span class="line">                     indio_dev-&gt;name,</span><br><span class="line">                     iio_device_id(indio_dev));</span><br><span class="line">    <span class="keyword">if</span> (!trigger)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic setup. */</span></span><br><span class="line">    trigger-&gt;ops = &amp;zpa2326_trigger_ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>-&gt;trigger = trigger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register to triggers space. */</span></span><br><span class="line">    ret = devm_iio_trigger_register(parent, trigger);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        dev_err(parent, <span class="string">&quot;failed to register hardware trigger (%d)&quot;</span>,</span><br><span class="line">            ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发与缓存连接"><a href="#触发与缓存连接" class="headerlink" title="触发与缓存连接"></a>触发与缓存连接</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note 用于在 buffer 在使能和失能前后的操作</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> <span class="title">zpa2326_buffer_setup_ops</span> =</span> &#123;</span><br><span class="line">	.preenable   = zpa2326_preenable_buffer,</span><br><span class="line">	.postenable  = zpa2326_postenable_buffer,</span><br><span class="line">	.postdisable = zpa2326_postdisable_buffer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note 用于中断的底半处理, 用于将设备的数据存入缓存, 并且还有此数据的时间标记</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">zpa2326_trigger_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span>         *<span class="title">indio_dev</span> =</span> ((struct iio_poll_func *)</span><br><span class="line">					     data)-&gt;indio_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zpa2326_private</span> *<span class="title">priv</span> =</span> iio_priv(indio_dev);</span><br><span class="line">	<span class="keyword">bool</span>                    cont;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have been dispatched, meaning we are in triggered buffer mode.</span></span><br><span class="line"><span class="comment">	 * Using our own internal trigger implies we are currently in continuous</span></span><br><span class="line"><span class="comment">	 * hardware sampling mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cont = iio_trigger_using_own(indio_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cont) &#123;</span><br><span class="line">		<span class="comment">/* On demand sampling : start a one shot cycle. */</span></span><br><span class="line">		<span class="keyword">if</span> (zpa2326_start_oneshot(indio_dev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for sampling cycle to complete. */</span></span><br><span class="line">		<span class="keyword">if</span> (priv-&gt;irq &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* No interrupt available: poll for completion. */</span></span><br><span class="line">			<span class="keyword">if</span> (zpa2326_poll_oneshot_completion(indio_dev))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Only timestamp sample once it is ready. */</span></span><br><span class="line">			priv-&gt;timestamp = iio_get_time_ns(indio_dev);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Interrupt handlers will timestamp for us. */</span></span><br><span class="line">			<span class="keyword">if</span> (zpa2326_wait_oneshot_completion(indio_dev, priv))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enqueue to IIO buffer / userspace. */</span></span><br><span class="line">	zpa2326_fill_sample_buffer(indio_dev, priv);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!cont)</span><br><span class="line">		<span class="comment">/* Don&#x27;t switch to low power if sampling continuously. */</span></span><br><span class="line">		zpa2326_sleep(indio_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Inform attached trigger we are done. */</span></span><br><span class="line">	iio_trigger_notify_done(indio_dev-&gt;trig);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*setup triggered buffer, usually in probe function */</span></span><br><span class="line">err = devm_iio_triggered_buffer_setup(parent, indio_dev, <span class="literal">NULL</span>,</span><br><span class="line">					      zpa2326_trigger_handler,</span><br><span class="line">					      &amp;zpa2326_buffer_setup_ops)</span><br></pre></td></tr></table></figure>

<h2 id="设备的具体操作"><a href="#设备的具体操作" class="headerlink" title="设备的具体操作"></a>设备的具体操作</h2><p>设备的操作便是接收一个触发信号, 然后调用自己定义的回调函数, 回调函数通过 <code>iio_info</code> 来提供给框架.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 关于设备的信息</span></span><br><span class="line"><span class="comment"> ,* @param read_raw: 从设备获取一个值, mask 用于指明读取那个数值, 函数返回值的类型</span></span><br><span class="line"><span class="comment"> ,* @param read_raw_multi: 读取一些值</span></span><br><span class="line"><span class="comment"> ,* @param write_raw: 写一个值</span></span><br><span class="line"><span class="comment"> ,* @param write_raw_get_fmt: 查询可以写入的格式</span></span><br><span class="line"><span class="comment"> ,* @param read_event_config: 查看是否事件已经使能</span></span><br><span class="line"><span class="comment"> ,* @param write_event_config: 设置事件使能</span></span><br><span class="line"><span class="comment"> ,* @param read_event_value: 读取一个事件的配置</span></span><br><span class="line"><span class="comment"> ,* @param write_event_value: 写入一个事件的配置</span></span><br><span class="line"><span class="comment"> ,* @param validate_trigger: 确认有触发产生</span></span><br><span class="line"><span class="comment"> ,* @param update_scan_mode: 配置设备和扫描缓存</span></span><br><span class="line"><span class="comment"> ,* @param debugfs_reg_access: 读写设备的寄存器值</span></span><br><span class="line"><span class="comment"> ,* @param of_xlate: 获取对应通道的索引</span></span><br><span class="line"><span class="comment"> ,* @param </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span>                   *<span class="title">driver_module</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>          *<span class="title">event_attrs</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>    *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*read_raw)(struct iio_dev *indio_dev,</span><br><span class="line">                        struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                        <span class="keyword">int</span> *val,</span><br><span class="line">                        <span class="keyword">int</span> *val2,</span><br><span class="line">                        <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span> (*read_raw_multi)(struct iio_dev *indio_dev,</span><br><span class="line">                              struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                              <span class="keyword">int</span> max_len,</span><br><span class="line">                              <span class="keyword">int</span> *vals,</span><br><span class="line">                              <span class="keyword">int</span> *val_len,</span><br><span class="line">                              <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*write_raw)(struct iio_dev *indio_dev,</span><br><span class="line">                        struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                        <span class="keyword">int</span> val,</span><br><span class="line">                        <span class="keyword">int</span> val2,</span><br><span class="line">                        <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*write_raw_get_fmt)(struct iio_dev *indio_dev,</span><br><span class="line">                                struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                                <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*read_event_config)(struct iio_dev *indio_dev,</span><br><span class="line">                                <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                <span class="keyword">enum</span> iio_event_direction dir);</span><br><span class="line">        <span class="keyword">int</span>(*write_event_config)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">int</span> state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>(*read_event_value)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_info info,</span><br><span class="line">                               <span class="keyword">int</span> *val, <span class="keyword">int</span> *val2);</span><br><span class="line">        <span class="keyword">int</span>(*write_event_value)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_info info,</span><br><span class="line">                               <span class="keyword">int</span> *val, <span class="keyword">int</span> *val2);</span><br><span class="line">        <span class="keyword">int</span>(*validate_trigger)(struct iio_dev *indio_dev,</span><br><span class="line">                               struct iio_trigger *trig);</span><br><span class="line">        <span class="keyword">int</span>(*update_scan_mode)(struct iio_dev *indio_dev,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *scan_mask);</span><br><span class="line">        <span class="keyword">int</span>(*debugfs_reg_access)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">unsigned</span> reg, <span class="keyword">unsigned</span> writeval,</span><br><span class="line">                                 <span class="keyword">unsigned</span> *readval);</span><br><span class="line">        <span class="keyword">int</span>(*of_xlate)(struct iio_dev *indio_dev,</span><br><span class="line">                       <span class="keyword">const</span> struct of_phandle_args *iiospec);</span><br><span class="line">        <span class="keyword">int</span>(*hwfifo_set_watermark)(struct iio_dev *indio_dev, <span class="keyword">unsigned</span> val);</span><br><span class="line">        <span class="keyword">int</span> (*hwfifo_flush_to_buffer)(struct iio_dev *indio_dev, <span class="keyword">unsigned</span> count);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> sturct iio_info ms5611_info = </span><br><span class="line">&#123;</span><br><span class="line">    .read_raw = &amp;ms5611_read_raw,</span><br><span class="line">    .driver_module = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备模式"><a href="#设备模式" class="headerlink" title="设备模式"></a>设备模式</h2><p>在 <code>linux/iio/iio.h</code> 中列出了设备所支持的模式:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">+BEGIN_SRC c</span></span><br><span class="line">//设备可用于软件触发</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_DIRECT_MODE          0X01</span></span><br><span class="line">//设备可用于硬件触发</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_TRIGGERED     0X02</span></span><br><span class="line">//设备使用软件缓存</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_SOFTWARE      0X04</span></span><br><span class="line">//设备使用硬件缓存</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_HARDWARE      0X08</span></span><br><span class="line">//设备使用事件触发机制</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_EVENT_TEIGGERED      0X10</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_ALL_BUFFER_MODES \</span></span><br><span class="line"><span class="bash">        (INDIO_BUFFER_TRIGGERED | INDIO_BUFFER_HARDWARE | INDIO_BUFFER_SOFTWARE)</span></span><br></pre></td></tr></table></figure>

<h2 id="申请一个设备"><a href="#申请一个设备" class="headerlink" title="申请一个设备"></a>申请一个设备</h2><p>申请设备时,就需要申请一个 <code>iio_dev</code> 结构并存放其私有数据, 用于代表此设备,然后调用注册函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 申请并管理IIO申请的设备内存(可以在驱动退出时自动卸载)</span></span><br><span class="line"><span class="comment"> ,* @param sizeof_priv: 私有数据的大小</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_dev *<span class="title">devm_iio_device_alloc</span><span class="params">(struct device *dev, <span class="keyword">int</span> sizeof_priv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 注册设备到IIO子系统中</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">devm_iio_device_register</span><span class="params">(struct device *dev, struct iio_dev *indio_dev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 示例</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ms5611_i2c_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ms5611_state</span> *<span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span></span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">    indio_dev = devm_iio_device_alloc(&amp;client-&gt;dev, <span class="keyword">sizeof</span>(*st));</span><br><span class="line">    <span class="keyword">if</span>(!indio_dev)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    st = iio_priv(indio_dev);</span><br><span class="line">    st-&gt;reset = ms5611_i2c_reset;</span><br><span class="line">    st-&gt;read_prom_word = ms5611_i2c_read_prom_word;</span><br><span class="line">    .....</span><br><span class="line">    st-&gt;client = client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ms5611_probe(indio_dev, &amp;client-&gt;dev, id-&gt;driver_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ms5611_probe</span><span class="params">(struct iio_dev *indio_dev, struct device *dev, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ms5611_state</span> *<span class="title">st</span> =</span> iio_priv(indio_dev);</span><br><span class="line"></span><br><span class="line">        st-&gt;chip_info = &amp;chip_info_tbl[type];</span><br><span class="line">        indio_dev-&gt;dev.parent = dev;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">        indio_dev-&gt;modes = INDIO_DIRECT_MODE;</span><br><span class="line">        indio_dev-&gt;channels = &amp;ms5611_channels;</span><br><span class="line">        indio_dev-&gt;num_channels = ARRAY_SIZE(ms5611_channels);</span><br><span class="line">        indio_dev-&gt;info = &amp;ms5611_info;</span><br><span class="line"></span><br><span class="line">        ret = ms5611_init(indio_dev);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">return</span> devm_iio_device_register(dev, indio_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
