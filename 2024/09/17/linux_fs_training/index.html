<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kcmetercec.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录从上层用户操作到底层文件系统之间的调用流程以及数据流。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux文件系统基本脉络">
<meta property="og:url" content="http://kcmetercec.top/2024/09/17/linux_fs_training/index.html">
<meta property="og:site_name" content="explorer">
<meta property="og:description" content="记录从上层用户操作到底层文件系统之间的调用流程以及数据流。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true">
<meta property="og:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/struct_super_block.jpg?raw=true">
<meta property="og:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/fuse.jpg?raw=true">
<meta property="article:published_time" content="2024-09-16T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-16T16:00:00.000Z">
<meta property="article:author" content="kcmetercec">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true">

<link rel="canonical" href="http://kcmetercec.top/2024/09/17/linux_fs_training/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux文件系统基本脉络 | explorer</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112423075-1# <app_id>"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-112423075-1# <app_id>');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="explorer" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">explorer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">万丈高楼平地起，勿在浮沙筑高台</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kcmetercec.top/2024/09/17/linux_fs_training/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/16881795?s=400&u=f62971f44f59d17d823044e709d4668debec7c02&v=4">
      <meta itemprop="name" content="kcmetercec">
      <meta itemprop="description" content="Qt, C++, linux, CS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="explorer">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux文件系统基本脉络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-09-17T00:00:00+08:00">2024-09-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/fs/" itemprop="url" rel="index"><span itemprop="name">fs</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/fs/overview/" itemprop="url" rel="index"><span itemprop="name">overview</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>记录从上层用户操作到底层文件系统之间的调用流程以及数据流。<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true"></p>
<span id="more"></span>

<h1 id="simplefs-实战"><a href="#simplefs-实战" class="headerlink" title="simplefs 实战"></a>simplefs 实战</h1><p>[simplefs][<a target="_blank" rel="noopener" href="https://github.com/psankar/simplefs]">https://github.com/psankar/simplefs]</a> 用最少的代码实现了文件系统的基本操作。</p>
<h2 id="基本体验"><a href="#基本体验" class="headerlink" title="基本体验"></a>基本体验</h2><h3 id="创建一个硬盘"><a href="#创建一个硬盘" class="headerlink" title="创建一个硬盘"></a>创建一个硬盘</h3><p>目前使用 <code>dd</code> 命令创建一个块大小为 4096字节，共100个块的硬盘文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">bs 指定一个块的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">count 指定块数目</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> 输入文件内容， /dev/zero 会不断输出0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">of 输出文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此命令可以用来测试内存的操作速度</span></span><br><span class="line">dd bs=4096 count=100 if=/dev/zero of=image</span><br></pre></td></tr></table></figure>

<h3 id="格式化并挂载"><a href="#格式化并挂载" class="headerlink" title="格式化并挂载"></a>格式化并挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">./mkfs-simplefs image</span><br><span class="line">mkdir mount</span><br><span class="line">sudo insmod simplefs.ko </span><br><span class="line">mount -o loop -t simplefs image ./mount</span><br></pre></td></tr></table></figure>

<h3 id="查看内容"><a href="#查看内容" class="headerlink" title="查看内容"></a>查看内容</h3><p>接下来就是以root的身份进入到 <code>mount</code> 文件夹，便可以查看其文件及文件内容。</p>
<h2 id="格式化代码分析-mkfs-simplefs-c"><a href="#格式化代码分析-mkfs-simplefs-c" class="headerlink" title="格式化代码分析(mkfs-simplefs.c)"></a>格式化代码分析(mkfs-simplefs.c)</h2><p>其格式化的步骤为：</p>
<ol>
<li>写入superblock 的内容</li>
<li>写根目录inode</li>
<li>写文件inode</li>
<li>写根目录block</li>
<li>写文件block</li>
</ol>
<h3 id="写-superblock"><a href="#写-superblock" class="headerlink" title="写 superblock"></a>写 superblock</h3><p>此函数将一个block来保存superblock的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_MAGIC 0x10032013</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> version; <span class="comment">//版本号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> magic; <span class="comment">//魔数</span></span><br><span class="line">        <span class="keyword">uint64_t</span> block_size;<span class="comment">//super block 信息所占用的块大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This should be moved to the inode store and not part of the sb */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inodes_count;<span class="comment">//目前已经使用了多少个inode</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> free_blocks;<span class="comment">//目前还剩下多少个block</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此部分是为了填充结构体，使整个结构体大小为4096字节</span></span><br><span class="line">        <span class="keyword">char</span> padding[SIMPLEFS_DEFAULT_BLOCK_SIZE - (<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>))];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_superblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> <span class="title">sb</span> =</span> &#123;</span><br><span class="line">                .version = <span class="number">1</span>,</span><br><span class="line">                .magic = SIMPLEFS_MAGIC,</span><br><span class="line">                .block_size = SIMPLEFS_DEFAULT_BLOCK_SIZE,</span><br><span class="line">                <span class="comment">/* One inode for rootdirectory and another for a welcome file that we are going to create */</span></span><br><span class="line">                .inodes_count = <span class="number">2</span>,<span class="comment">//使用一个inode对应根目录，一个inode对应一个文件</span></span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> Free blocks management is not implemented yet */</span></span><br><span class="line">                .free_blocks = (~<span class="number">0</span>) &amp; ~(<span class="number">1</span> &lt;&lt; WELCOMEFILE_DATABLOCK_NUMBER),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;sb, <span class="keyword">sizeof</span>(sb));</span><br><span class="line">        <span class="keyword">if</span> (ret != SIMPLEFS_DEFAULT_BLOCK_SIZE) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;bytes written [%d] are not equal to the default block size\n&quot;</span>,</span><br><span class="line">                         (<span class="keyword">int</span>)ret);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Super block written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写根文件inode"><a href="#写根文件inode" class="headerlink" title="写根文件inode"></a>写根文件inode</h3><p>根文件的inode紧接着superblock 往后填充，也就是在第2个block中存储inode.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode; <span class="comment">//此inode表示的档案类型</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//inode的索引号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> data_block_number;<span class="comment">//与inode对应的block的索引号</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//文件大小或是目录对应的内容对</span></span><br><span class="line">                <span class="keyword">uint64_t</span> file_size;</span><br><span class="line">                <span class="keyword">uint64_t</span> dir_children_count;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_INODE_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_INODESTORE_BLOCK_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode_store</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">root_inode</span>;</span></span><br><span class="line"></span><br><span class="line">        root_inode.mode = S_IFDIR;</span><br><span class="line">        root_inode.inode_no = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        root_inode.data_block_number = SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER;</span><br><span class="line">        root_inode.dir_children_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;root_inode, <span class="keyword">sizeof</span>(root_inode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(root_inode)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The inode store was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;root directory inode written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件inode"><a href="#写文件inode" class="headerlink" title="写文件inode"></a>写文件inode</h3><p>通过此函数可以看出：所有的inode都存储在一个block中，而一个inode大小为 <code>28</code> 字节。<br>也就是说，此文件系统最多支持文件和文件夹的总数为 <code>4096 / 28 = 146 </code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_INODE_NUMBER = <span class="number">2</span>;<span class="comment">//文件inode为2号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_DATABLOCK_NUMBER = <span class="number">3</span>;<span class="comment">//文件内容block</span></span><br><span class="line"><span class="keyword">char</span> welcomefile_body[] = <span class="string">&quot;Love is God. God is Love. Anbe Murugan.\n&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">welcome</span> =</span> &#123;</span><br><span class="line">        .mode = S_IFREG,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">        .data_block_number = WELCOMEFILE_DATABLOCK_NUMBER,</span><br><span class="line">        .file_size = <span class="keyword">sizeof</span>(welcomefile_body),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_inode *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">off_t</span> nbytes;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, i, <span class="keyword">sizeof</span>(*i));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(*i)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The welcomefile inode was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;welcomefile inode written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算出需要移动到block尾需要多少字节(依次减去root inode 和 welcome inode)</span></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*i) - <span class="keyword">sizeof</span>(*i);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);</span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The padding bytes are not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;inode store padding bytes (after the two inodes) written sucessfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写根目录block"><a href="#写根目录block" class="headerlink" title="写根目录block"></a>写根目录block</h3><p>写根目录block就是写文件名以及其inode的索引,一个名称对的大小为 <code>264</code> 字节，<br>也就是说一个目录最多可以存储的名称对为 <code>4096 / 264 = 15</code> 个，也就是说一个目录<br>最多存储15个文件或目录名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_FILENAME_MAXLEN 255 <span class="comment">//文件名的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> filename[SIMPLEFS_FILENAME_MAXLEN];</span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//文件名以及其对应的block索引</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> <span class="title">record</span> =</span> &#123;</span><br><span class="line">        .filename = <span class="string">&quot;vanakkam&quot;</span>,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_dirent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_dir_record *record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> nbytes = <span class="keyword">sizeof</span>(*record), ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, record, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (ret != nbytes) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the rootdirectory datablock (name+inode_no pair for welcomefile) has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;root directory datablocks (name+inode_no pair for welcomefile) written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*record);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);<span class="comment">//移动到下一个block</span></span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the padding for rootdirectory children datablock has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;padding after the rootdirectory children written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件block"><a href="#写文件block" class="headerlink" title="写文件block"></a>写文件block</h3><p>写文件block就是把文件内容写进去即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_block</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *block, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, block, len);</span><br><span class="line">        <span class="keyword">if</span> (ret != len) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Writing file body has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block has been written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>根据上面的格式化代码，可以知道其结构如下图：</p>
<p>！<a href="./simplefs_struct.jpg"></a></p>
<p>可以看出此文件系统的确是足够的简单：</p>
<ol>
<li>superblock描述极为简单</li>
<li>并不具备block bitmap 和 inode bitmap</li>
<li>最多支持的文件和文件夹总数为146个(因为仅用了一个block来存储inode)</li>
<li>一个文件夹中可以存储的文件和文件夹总数为15个</li>
<li>一个文件的内容不能超过一个block</li>
</ol>
<h3 id="文件系统操作逻辑"><a href="#文件系统操作逻辑" class="headerlink" title="文件系统操作逻辑"></a>文件系统操作逻辑</h3><p>根据以上简单结构的分析，可以猜测出其基本的文件操作逻辑：</p>
<ol>
<li>新建文件夹</li>
</ol>
<ul>
<li>从inode table 中填充一个文件夹类型的inode并获取其索引</li>
<li>为此索引的inode分配一个block并写入对应的inode</li>
<li>将新建文件夹的名称和inode索引对应存储在当前文件夹的block中</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="2">
<li>新建文件</li>
</ol>
<ul>
<li>从inode table 中填充一个文件类型的inode并获取其索引</li>
<li>为此索引的inode分配一个block并写入对应的inode</li>
<li>将文件内容写入其block中</li>
<li>将新建文件的名称和inode索引对应存储在当前文件夹的block中</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="3">
<li>删除文件或文件夹</li>
</ol>
<ul>
<li>去除当前文件夹中对应此文件或文件夹的描述字符串</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="4">
<li>建立硬链接</li>
</ol>
<ul>
<li>在当前文件夹下拷贝一份目标文件所在的文件夹中对于此文件的描述字符串</li>
</ul>
<ol start="5">
<li>建立符号链接</li>
</ol>
<ul>
<li>首先新建一个文件</li>
<li>然后新建文件的内容指向目标文件所在的文件夹的inode</li>
</ul>
<p>基于这些猜测，接下来分析其文件系统操作代码。</p>
<h2 id="操作代码分析-simple-c"><a href="#操作代码分析-simple-c" class="headerlink" title="操作代码分析(simple.c)"></a>操作代码分析(simple.c)</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>在载入模块时，会首先使用函数 ·kmem_cache_create· ，用于为文件系统的inode申请缓存以便达到快速访问的目的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sfs_inode_cachep = kmem_cache_create(<span class="string">&quot;sfs_inode_cache&quot;</span>,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct simplefs_inode),</span><br><span class="line">                                     <span class="number">0</span>,</span><br><span class="line">                                     (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD),</span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>在挂载文件时，会调用函数 <code>simplefs_fill_super</code> 函数，此函数的主要目的就是填充 <code>super_block</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function, as the name implies, Makes the super_block valid and</span></span><br><span class="line"><span class="comment"> ,* fills filesystem specific information in the super block */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb_disk</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret = -EPERM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从存储super block 描述的block(0)中读取数据</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到 simplefs_super_block 具体内容</span></span><br><span class="line">        sb_disk = (struct simplefs_super_block *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;The magic number obtained in disk is: [%llu]\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;magic);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;magic != SIMPLEFS_MAGIC)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;simplefs seem to be formatted using a non-standard block size.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO</span><br><span class="line">               <span class="string">&quot;simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;version, sb_disk-&gt;block_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A magic number that uniquely identifies our filesystem type */</span></span><br><span class="line">        sb-&gt;s_magic = SIMPLEFS_MAGIC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For all practical purposes, we will be using this s_fs_info as the super block */</span></span><br><span class="line">        <span class="comment">//设为私有地址，以便后面使用</span></span><br><span class="line">        sb-&gt;s_fs_info = sb_disk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大的文件大小就是为一个block</span></span><br><span class="line">        sb-&gt;s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;</span><br><span class="line">        <span class="comment">//super block 操作</span></span><br><span class="line">        sb-&gt;s_op = &amp;simplefs_sops;</span><br><span class="line"></span><br><span class="line">        root_inode = new_inode(sb);</span><br><span class="line">        <span class="comment">//跟目录的inode位置</span></span><br><span class="line">        root_inode-&gt;i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        inode_init_owner(root_inode, <span class="literal">NULL</span>, S_IFDIR);</span><br><span class="line">        root_inode-&gt;i_sb = sb;</span><br><span class="line">        <span class="comment">//根目录inode操作</span></span><br><span class="line">        root_inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        <span class="comment">//根目录操作</span></span><br><span class="line">        root_inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        root_inode-&gt;i_atime = root_inode-&gt;i_mtime = root_inode-&gt;i_ctime =</span><br><span class="line">                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到根目录的inode内容(并且会将此inode放入inode cache 中)</span></span><br><span class="line">        root_inode-&gt;i_private =</span><br><span class="line">                simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> move such stuff into separate header. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 3, 0)</span></span><br><span class="line">        sb-&gt;s_root = d_make_root(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        sb-&gt;s_root = d_alloc_root(root_inode);</span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">                iput(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">release:</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其数据填充结果如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/struct_super_block.jpg?raw=true"><br>在 <code>super.h</code> 中有以下两个操作,对照上图就可以看出其意义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 simplefs_super_block 结构体地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_super_block *<span class="title">SIMPLEFS_SB</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb-&gt;s_fs_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件或目录 inode的地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_inode *<span class="title">SIMPLEFS_INODE</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inode-&gt;i_private;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件夹内容"><a href="#读取文件夹内容" class="headerlink" title="读取文件夹内容"></a>读取文件夹内容</h3><p>为了获取文件夹的内容得先从目录inode找到其对应的block。</p>
<p>当在 <code>mount</code> 文件夹下使用命令 <code>ls</code> 时，其执行路径依次为：</p>
<ul>
<li>simplefs_iterate : 用于扫描目录中的文件或文件夹名称以及其对应的inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_iterate</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_readdir</span><span class="params">(struct file *filp, <span class="keyword">void</span> *dirent, <span class="keyword">filldir_t</span> filldir)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">loff_t</span> pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">        pos = ctx-&gt;pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pos = filp-&gt;f_pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        inode = filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> We use a hack of reading pos to figure if we have filled in all data.</span></span><br><span class="line"><span class="comment">                 ,* We should probably fix this to work in a cursor based model and</span></span><br><span class="line"><span class="comment">                 ,* use the tokens correctly to not fill too many data in each cursor based call */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的inode</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!S_ISDIR(sfs_inode-&gt;mode))) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;inode [%llu][%lu] for fs object [%s] not a directory\n&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;inode_no, inode-&gt;i_ino,</span><br><span class="line">                       filp-&gt;f_dentry-&gt;d_name.name);</span><br><span class="line">                <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的block</span></span><br><span class="line">        bh = sb_bread(sb, sfs_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取目录blockc内容</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="comment">//根据目录中含有的条目进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_inode-&gt;dir_children_count; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">                <span class="comment">//返回文件名以及其对应的inode</span></span><br><span class="line">                dir_emit(ctx, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN,</span><br><span class="line">                         record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                ctx-&gt;pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                filldir(dirent, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN, pos,</span><br><span class="line">                        record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                filp-&gt;f_pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_lookup : 得到文件或文件夹的inode内容并初始化系统的 inode结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dentry *<span class="title">simplefs_lookup</span><span class="params">(struct inode *parent_inode,</span></span></span><br><span class="line"><span class="params"><span class="function">                               struct dentry *child_dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取目录inode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent</span> =</span> SIMPLEFS_INODE(parent_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> parent_inode-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的block</span></span><br><span class="line">        bh = sb_bread(sb, parent-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的blockå����</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parent-&gt;dir_children_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(record-&gt;filename, child_dentry-&gt;d_name.name)) &#123;</span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> There is a corner case where if an allocated inode,</span></span><br><span class="line"><span class="comment">                         ,* is not written to the inode store, but the inodes_count is</span></span><br><span class="line"><span class="comment">                         ,* incremented. Then if the random string on the disk matches</span></span><br><span class="line"><span class="comment">                         ,* with the filename that we are comparing above, then we</span></span><br><span class="line"><span class="comment">                         ,* will use an invalid uninitialized inode */</span></span><br><span class="line"></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//根据文件inode号获取其内容</span></span><br><span class="line">                        sfs_inode = simplefs_get_inode(sb, record-&gt;inode_no);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//初始化inode结构体以及其对应的文件或文件夹操作</span></span><br><span class="line">                        inode = new_inode(sb);</span><br><span class="line">                        inode-&gt;i_ino = record-&gt;inode_no;</span><br><span class="line">                        inode_init_owner(inode, parent_inode, sfs_inode-&gt;mode);</span><br><span class="line">                        inode-&gt;i_sb = sb;</span><br><span class="line">                        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                printk(KERN_ERR</span><br><span class="line">                                       <span class="string">&quot;Unknown inode type. Neither a directory nor a file&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> We should store these times to disk and retrieve them */</span></span><br><span class="line">                        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =</span><br><span class="line">                                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">                        inode-&gt;i_private = sfs_inode;</span><br><span class="line"></span><br><span class="line">                        d_add(child_dentry, inode);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_ERR</span><br><span class="line">               <span class="string">&quot;No inode found for the filename [%s]\n&quot;</span>,</span><br><span class="line">               child_dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_get_inode : 得到请求的inode号码的内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This functions returns a simplefs_inode with the given inode_no</span></span><br><span class="line"><span class="comment"> ,* from the inode store, if it exists. */</span></span><br><span class="line"><span class="function">struct simplefs_inode *<span class="title">simplefs_get_inode</span><span class="params">(struct super_block *sb,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">uint64_t</span> inode_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sfs_sb</span> =</span> SIMPLEFS_SB(sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_buffer</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The inode store can be read once and kept in memory permanently while mounting.</span></span><br><span class="line"><span class="comment">         ,* But such a model will not be scalable in a filesystem with</span></span><br><span class="line"><span class="comment">         ,* millions or billions of files (inodes) */</span></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        sfs_inode = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Failed to acquire mutex lock %s +%d\n&quot;</span>,</span><br><span class="line">                       __FILE__, __LINE__);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//扫描inode table 是否有与要求的序号匹配的Inode</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_sb-&gt;inodes_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sfs_inode-&gt;inode_no == inode_no) &#123;</span><br><span class="line">                        <span class="comment">//申请cache</span></span><br><span class="line">                        inode_buffer = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">                        <span class="built_in">memcpy</span>(inode_buffer, sfs_inode, <span class="keyword">sizeof</span>(*inode_buffer));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sfs_inode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span></span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line">        <span class="keyword">return</span> inode_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_iterate</li>
</ul>
<p>可以看出其基本思路是：</p>
<ol>
<li>通过文件夹的inode获取其block</li>
<li>扫描block有哪些文件或文件夹</li>
<li>获取这些扫描到的文件或文件夹的inode内容，为其操作做好准备</li>
</ol>
<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>可以猜测为了读取文件内容，首先要获取其inode才能找到其block.</p>
<p>当执行 <code>cat vanakkam</code> 时，执行的函数依次是：</p>
<ul>
<li>simplefs_iterate : 重复执行了8次</li>
<li>simplefs_read</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_read</span><span class="params">(struct file * filp, <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode</span> =</span></span><br><span class="line">                SIMPLEFS_INODE(filp-&gt;f_path.dentry-&gt;d_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line">        <span class="keyword">int</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*ppos &gt;= inode-&gt;file_size) &#123;</span><br><span class="line">                <span class="comment">/* Read request with offset beyond the filesize */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取block</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line">        nbytes = min((<span class="keyword">size_t</span>) inode-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, buffer, nbytes)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents to the userspace buffer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        ,*ppos += nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_read</li>
</ul>
<p>可以看出其思路为：</p>
<ol>
<li>从目录inode获取目录block，进而获取到文件的inode</li>
</ol>
<ul>
<li>所以当你对一个目录都没有读权限时，是无法通过其inode来获取文件内容的</li>
</ul>
<ol start="2">
<li>从文件inode找到其对应block再读取其内容</li>
</ol>
<h3 id="写文件内容"><a href="#写文件内容" class="headerlink" title="写文件内容"></a>写文件内容</h3><p>可以猜测其与读文件内容的思路是一样的：</p>
<ol>
<li>从目录inode获取目录block，进而获取到文件的inode</li>
<li>从文件inode找到其对应block再写入对应的内容</li>
<li>更新inode描述(因为inode中具有文件信息)</li>
</ol>
<p>执行 echo “Hello world!” &gt; vanakkam 其执行路径为：</p>
<ul>
<li>simplefs_iterate : 重复执行了12次，没看懂为什么</li>
<li>simplefs_write : 写入数据并同步</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_write</span><span class="params">(struct file * filp, <span class="keyword">const</span> <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        retval = generic_write_checks(filp, ppos, &amp;len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line">        <span class="comment">//获取block地址</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      sfs_inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move the pointer until the required byte offset */</span></span><br><span class="line">        buffer += *ppos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(buffer, buf, len)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents from the userspace buffer to the kernel space\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        ,*ppos += len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步数据到硬盘</span></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set new size</span></span><br><span class="line"><span class="comment">         ,* sfs_inode-&gt;file_size = max(sfs_inode-&gt;file_size, *ppos);</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* <span class="doctag">FIXME:</span> What to do if someone writes only some parts in between ?</span></span><br><span class="line"><span class="comment">         ,* The above code will also fail in case a file is overwritten with</span></span><br><span class="line"><span class="comment">         ,* a shorter buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sfs_inode-&gt;file_size = *ppos;</span><br><span class="line">        retval = simplefs_inode_save(sb, sfs_inode);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                len = retval;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_inode_save : 更新inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_inode_save</span><span class="params">(struct super_block *sb, struct simplefs_inode *sfs_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从inode table 起始遍历出对应inode的内容</span></span><br><span class="line">        inode_iterator = simplefs_inode_search(sb,</span><br><span class="line">                                               (struct simplefs_inode *)bh-&gt;b_data,</span><br><span class="line">                                               sfs_inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(inode_iterator)) &#123;</span><br><span class="line">                <span class="comment">//更新 inode</span></span><br><span class="line">                <span class="built_in">memcpy</span>(inode_iterator, sfs_inode, <span class="keyword">sizeof</span>(*inode_iterator));</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;The inode updated\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//与硬盘同步</span></span><br><span class="line">                mark_buffer_dirty(bh);</span><br><span class="line">                sync_dirty_buffer(bh);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The new filesize could not be stored to the inode.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_inode_search : 从inode table 中找到对应序列的inode</li>
</ul>
<h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>先来猜测新建文件夹的步骤：</p>
<ol>
<li>根据文件夹inode找到其block</li>
<li>为新建的文件夹在inode table 中获取一个inode</li>
<li>为新建的文件夹分配一个block</li>
<li>将新申请到的文件夹名称以及其inode号写入父文件夹的block中</li>
<li>更新父文件夹inode</li>
<li>与硬盘同步</li>
</ol>
<p>执行命令 <code>mkdir hello</code> 其调用函数依次为：</p>
<ul>
<li>simplefs_iterate : 浏览目录获取其档案及对应inode</li>
<li>simplefs_lookup : 查看当前目录是否已有此档案名</li>
<li>simplefs_mkdir : 新建文件夹</li>
<li>simplefs_create_fs_object : 新建档案</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_create_fs_object</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent_dir_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">dir_contents_datablock</span>;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> count;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_directory_children_update_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sb = dir-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 super block 中记录的 inode 数目</span></span><br><span class="line">        ret = simplefs_sb_get_objects_count(sb, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(count &gt;= SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                <span class="comment">/* The above condition can be just == insted of the &gt;= */</span></span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Maximum number of objects supported by simplefs is already reached&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!S_ISDIR(mode) &amp;&amp; !S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Creation request but for neither a file nor a directory&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_sb = sb;</span><br><span class="line">        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_ino = (count + SIMPLEFS_START_INO - SIMPLEFS_RESERVED_INODES + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sfs_inode = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">        sfs_inode-&gt;inode_no = inode-&gt;i_ino;</span><br><span class="line">        inode-&gt;i_private = sfs_inode;</span><br><span class="line">        sfs_inode-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New directory creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;dir_children_count = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New file creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First get a free block and update the free map,</span></span><br><span class="line"><span class="comment">         ,* Then add inode to the inode store and update the sb inodes_count,</span></span><br><span class="line"><span class="comment">         ,* Then update the parent directory&#x27;s inode with the new child.</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* The above ordering helps us to maintain fs consistency</span></span><br><span class="line"><span class="comment">         ,* even in most crashes</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="comment">//申请一个空闲的block</span></span><br><span class="line">        ret = simplefs_sb_get_a_freeblock(sb, &amp;sfs_inode-&gt;data_block_number);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;simplefs could not get a freeblock&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//申请一个空闲的inode</span></span><br><span class="line">        simplefs_inode_add(sb, sfs_inode);</span><br><span class="line"></span><br><span class="line">        parent_dir_inode = SIMPLEFS_INODE(dir);</span><br><span class="line">        bh = sb_bread(sb, parent_dir_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到父目录的block</span></span><br><span class="line">        dir_contents_datablock = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Navigate to the last record in the directory contents */</span></span><br><span class="line">        dir_contents_datablock += parent_dir_inode-&gt;dir_children_count;</span><br><span class="line">        <span class="comment">//在父目录的blockä������������������inode对</span></span><br><span class="line">        dir_contents_datablock-&gt;inode_no = sfs_inode-&gt;inode_no;</span><br><span class="line">        <span class="built_in">strcpy</span>(dir_contents_datablock-&gt;filename, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存父目录inode</span></span><br><span class="line">        parent_dir_inode-&gt;dir_children_count++;</span><br><span class="line">        ret = simplefs_inode_save(sb, parent_dir_inode);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* <span class="doctag">TODO:</span> Remove the newly created inode from the disk and in-memory inode store</span></span><br><span class="line"><span class="comment">                 ,* and also update the superblock, freemaps etc. to reflect the same.</span></span><br><span class="line"><span class="comment">                 ,* Basically, Undo all actions done during this create call */</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">        inode_init_owner(inode, dir, mode);</span><br><span class="line">        d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li>
<li>simplefs_sb_get_a_freeblock : 获取空闲block</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_sb_get_a_freeblock</span><span class="params">(struct super_block *vsb, <span class="keyword">uint64_t</span> * out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                ret = -EINTR;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Loop until we find a free block. We start the loop from 3,</span></span><br><span class="line"><span class="comment">         ,* as all prior blocks will always be in use */</span></span><br><span class="line">        <span class="comment">//从第三个block 开始寻找，前两个分别是(super block 和 inode table)</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED; i++) &#123;</span><br><span class="line">                <span class="comment">//通过位与的方式来获取空位，这也就是为什么最多支持64个block(free_blocks 是64位)</span></span><br><span class="line">                <span class="keyword">if</span> (sb-&gt;free_blocks &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(i == SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;No more free blocks available&quot;</span>);</span><br><span class="line">                ret = -ENOSPC;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ,*out = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新super block 中记录的空闲blockå��</span></span><br><span class="line">        <span class="comment">/* Remove the identified block from the free list */</span></span><br><span class="line">        sb-&gt;free_blocks &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步super block 与硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_sb_sync : 同步super block 与硬盘</li>
<li>simplefs_inode_add : 获取一个inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simplefs_inode_add</span><span class="params">(struct super_block *vsb, struct simplefs_inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bh = sb_bread(vsb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取inode table 内容</span></span><br><span class="line">        inode_iterator = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the new inode in the end in the inode store */</span></span><br><span class="line">        <span class="comment">//移动到inode table 的第一个空闲处</span></span><br><span class="line">        inode_iterator += sb-&gt;inodes_count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(inode_iterator, inode, <span class="keyword">sizeof</span>(struct simplefs_inode));</span><br><span class="line">        <span class="comment">//更新super block 计数</span></span><br><span class="line">        sb-&gt;inodes_count++;</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        <span class="comment">//同步super block 到硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>simplefs_sb_sync </li>
<li>simplefs_inode_save </li>
<li>simplefs_inode_search </li>
</ul>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>还是先来猜测一下新建文件的步骤：</p>
<ol>
<li>根据文件夹inode找到对应的block</li>
<li>从inode table 中为新建文件获取一个inode</li>
<li>从block 中为新建文件获取一个block，并填充其内容</li>
<li>更新文件的inode</li>
<li>更新文件夹的inode,以及block</li>
<li>更新super block 的 inode</li>
</ol>
<p>下面执行 <code>echo &quot;hello world!&quot; &gt; hello/hello.txt</code> 其条用函数依次为：</p>
<ul>
<li>simplefs_iterate : 首先通过根目录扫描其所包含的条目</li>
<li>simplefs_iterate : 然后通过扫描 =hello= 目录扫描其所包含的条目</li>
<li>simplefs_lookup : 查找是否存在 =hello.txt= 的inode</li>
<li>simplefs_create_fs_object: 新建文件</li>
<li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li>
<li>simplefs_sb_get_a_freeblock : 获取空闲block</li>
<li>simplefs_sb_sync : 同步super block 与硬盘</li>
<li>simplefs_inode_add : 获取一个inode</li>
<li>simplefs_sb_sync </li>
<li>simplefs_inode_save </li>
<li>simplefs_inode_search </li>
<li>simplefs_write : 写入文件内容</li>
<li>simplefs_inode_save : 更新inode</li>
<li>simplefs_inode_search </li>
</ul>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>通过查看其代码可以发现，此文件系统还有以下功能未能实现：</p>
<ul>
<li>删除文件</li>
<li>删除文件夹</li>
<li>建立符号链接</li>
<li>建立硬链接</li>
</ul>
<p>下面来尝试一一实现：</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>前面已经新建了文件 <code>/hello/hello.txt</code> ，下面尝试将它删除。</p>
<p>根据已有的知识先来猜测一下如何以最简单的方式删除一个文件，<br>为了能够使得操作步骤尽量的少，其实没有必要去擦除文件block的内容，而只需要对其inode操作即可。</p>
<p>也就是说涉及以下几个部分：</p>
<ol>
<li>文件夹block的字符串和inode对擦除</li>
<li>文件夹inode中的描述修改</li>
<li>inode table 修改</li>
<li>super block 修改</li>
</ol>
<p>通过 <code>strace rm -f hello.txt</code> 观察到有这么一行输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlinkat(AT_FDCWD, &quot;hello.txt&quot;, 0)      = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure>

<p>对应驱动的调用接口应该是 <code>struct inode_operations</code> 下的 <code>unlink</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br></pre></td></tr></table></figure>

<ul>
<li>在实现的过程中发现，其在增加inode 和 dir content 时是直接简单粗暴的在尾部增加，很明显在删除文件时会产生漏洞，所以此bug也需要修复。</li>
</ul>
<h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/fuse.jpg?raw=true"><br>如上图所示，FUSE仅仅在内核中实现了一个简单的模块，用于接口VFS和用户空间，文件系统的操作细节则存在于用户空间中。</p>
<ul>
<li>这种方式导致操作效率低但便于调试</li>
</ul>
<h1 id="比较重要的数据结构"><a href="#比较重要的数据结构" class="headerlink" title="比较重要的数据结构"></a>比较重要的数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 文件系统总览</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT8<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_DEV_MOUNT16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_VISIBLE32<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE32768<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">        <span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief super block 信息及操作结构体</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_list</span>;</span><span class="comment">/* Keep this first */</span></span><br><span class="line">        dev_ts_dev;<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">        <span class="keyword">unsigned</span> chars_blocksize_bits;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_blocksize;</span><br><span class="line">        loff_ts_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_flags;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_iflags;<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_magic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphores_umount</span>;</span></span><br><span class="line">        ints_count;</span><br><span class="line">        atomic_ts_active;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                    *s_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_heads_anon</span>;</span><span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_mounts</span>;</span><span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nodes_instances</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_quota_types;<span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">quota_infos_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sb_writerss_writers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line">        u8 s_uuid[<span class="number">16</span>];<span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_max_links;</span><br><span class="line">        fmode_ts_mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">           Cannot be worse than a second */</span></span><br><span class="line">        u32   s_time_gran;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">         ,* even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">         ,* in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved mount options for lazy filesystems using</span></span><br><span class="line"><span class="comment">         ,* generic_show_options()</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> __rcu *s_options;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved pool identifier for cleancache (-1 means none)</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> cleancache_poolid;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span><span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">        <span class="keyword">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Being remounted read-only */</span></span><br><span class="line">        <span class="keyword">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">s_dio_done_wq</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">s_pins</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Keep the lru lists last in the structure so they always sit on their</span></span><br><span class="line"><span class="comment">         ,* own individual cachelines.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_dentry_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_inode_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_headrcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_structdestroy_work</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutexs_sync_lock</span>;</span><span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">        spinlock_ts_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> ,* the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> ,* of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">umode_t</span>                i_mode;</span><br><span class="line">        <span class="keyword">unsigned</span>               shorti_opflags;</span><br><span class="line">        <span class="keyword">kuid_t</span>                 i_uid;</span><br><span class="line">        <span class="keyword">kgid_t</span>                 i_gid;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_flags;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_acl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_default_acl</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>  *<span class="title">i_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>             *<span class="title">i_sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                           *i_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>                  i_ino;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">         ,* following functions for modification:</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,*    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">         ,*    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">dev_t</span>                  i_rdev;</span><br><span class="line">        <span class="keyword">loff_t</span>                 i_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span></span><br><span class="line">        spinlock_ti_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>         i_bytes;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_blkbits;</span><br><span class="line">        <span class="keyword">blkcnt_t</span>               i_blocks;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">        <span class="keyword">seqcount_t</span>             i_size_seqcount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Misc */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          i_state;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>           <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_time_when;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>      <span class="title">i_hash</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>       <span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>   *<span class="title">i_wb</span>;</span><span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">        <span class="keyword">int</span>                     i_wb_frn_winner;</span><br><span class="line">        u16                     i_wb_frn_avg_time;</span><br><span class="line">        u16                     i_wb_frn_history;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_sb_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>  <span class="title">i_dentry</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">i_rcu</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        u64                        i_version;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_dio_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_writecount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>   *<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>       *<span class="title">i_flctx</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           <span class="title">i_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>               <span class="title">i_devices</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">i_pipe</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">i_bdev</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>            *<span class="title">i_cdev</span>;</span></span><br><span class="line">                <span class="keyword">char</span>                   *i_link;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __u32                          i_generation;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">        __u32                          i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>              <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>                           *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * (*follow_link) (struct dentry *, <span class="keyword">void</span> **);</span><br><span class="line">        <span class="keyword">int</span> (*permission) (struct inode *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*readlink) (struct dentry *, <span class="keyword">char</span> __user *,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">void</span> (*put_link) (struct inode *, <span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*create) (struct inode *,struct dentry *, <span class="keyword">umode_t</span>, <span class="keyword">bool</span>);</span><br><span class="line">        <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*mkdir) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rmdir) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*mknod) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>,<span class="keyword">dev_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rename) (struct inode *, struct dentry *,</span><br><span class="line">                       struct inode *, struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*rename2) (struct inode *, struct dentry *,</span><br><span class="line">                        struct inode *, struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*setattr) (struct dentry *, struct iattr *);</span><br><span class="line">        <span class="keyword">int</span> (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</span><br><span class="line">        <span class="keyword">int</span> (*setxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">size_t</span>,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*getxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*listxattr) (struct dentry *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*removexattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,</span><br><span class="line">                      u64 len);</span><br><span class="line">        <span class="keyword">int</span> (*update_time)(struct inode *, struct timespec *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*atomic_open)(struct inode *, struct dentry *,</span><br><span class="line">                           struct file *, <span class="keyword">unsigned</span> open_flag,</span><br><span class="line">                           <span class="keyword">umode_t</span> create_mode, <span class="keyword">int</span> *opened);</span><br><span class="line">        <span class="keyword">int</span> (*tmpfile) (struct inode *, struct dentry *, <span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*set_acl)(struct inode *, struct posix_acl *, <span class="keyword">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表的是一个路径</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">        <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line">        <span class="keyword">seqcount_t</span> d_seq;<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">                               ,* negative */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span><span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">        <span class="keyword">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">        &#125; d_u;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表一个文件的引用（一个文件可以被打开多次就有多个引用，但inode却是仅有一个）</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>     <span class="title">fu_llist</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>       <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">        &#125; f_u;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                   <span class="title">f_path</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                  *<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>  *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">         ,* Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>                    f_lock;</span><br><span class="line">        <span class="keyword">atomic_long_t</span>                 f_count;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>                  f_flags;</span><br><span class="line">        <span class="keyword">fmode_t</span>                       f_mode;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>                  <span class="title">f_pos_lock</span>;</span></span><br><span class="line">        <span class="keyword">loff_t</span>                        f_pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>            <span class="title">f_owner</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>             *<span class="title">f_cred</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>          <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">        u64                           f_version;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                          *f_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">        <span class="keyword">void</span>                          *private_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">        <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_ep_links</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>          *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>

<p>inode Tab 存在于硬盘中，如果每次CPU从硬盘中读取那么效率会比较低下，<br>所以内核会为inode Table 申请一段内存以作为缓存，称为 <strong>对应文件系统的 inode cache</strong>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_inodecache</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ext4_inode_cachep = kmem_cache_create(<span class="string">&quot;ext4_inode_cache&quot;</span>,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(struct ext4_inode_info),</span><br><span class="line">                                              <span class="number">0</span>, (SLAB_RECLAIM_ACCOUNT|</span><br><span class="line">                                                  SLAB_MEM_SPREAD),</span><br><span class="line">                                              init_once);</span><br><span class="line">        <span class="keyword">if</span> (ext4_inode_cachep == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样在VFS层面上，也会对抽象出来的 inode 和 路径进行缓存(dentry), 分别称为 icache 和 dcache.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">dcache_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* A constructor could be added for stable state like the lists,</span></span><br><span class="line"><span class="comment">         ,* but it is probably not worth it because of the cache nature</span></span><br><span class="line"><span class="comment">         ,* of the dcache.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        dentry_cache = KMEM_CACHE(dentry,</span><br><span class="line">                                  SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in dcache_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dentry_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Dentry cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_bl_head),</span><br><span class="line">                                        dhash_entries,</span><br><span class="line">                                        <span class="number">13</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;d_hash_shift,</span><br><span class="line">                                        &amp;d_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; d_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_BL_HEAD(dentry_hashtable + loop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">inode_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* inode slab cache */</span></span><br><span class="line">        inode_cachep = kmem_cache_create(<span class="string">&quot;inode_cache&quot;</span>,</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct inode),</span><br><span class="line">                                         <span class="number">0</span>,</span><br><span class="line">                                         (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|</span><br><span class="line">                                          SLAB_MEM_SPREAD),</span><br><span class="line">                                         init_once);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in inode_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inode_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Inode-cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_head),</span><br><span class="line">                                        ihash_entries,</span><br><span class="line">                                        <span class="number">14</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;i_hash_shift,</span><br><span class="line">                                        &amp;i_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; i_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_HEAD(&amp;inode_hashtable[loop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这些申请的缓存都是内核通过LRU算法进行回收的(内核通过 shrink方法来回收slab内存)</p>
<ul>
<li>shrink 方法需要驱动编写者来主动实现</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>kcmetercec
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://kcmetercec.top/2024/09/17/linux_fs_training/" title="Linux文件系统基本脉络">http://kcmetercec.top/2024/09/17/linux_fs_training/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"> <i class="fa fa-tag"></i> linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/13/linux_fs_detail/" rel="prev" title="Linux文件系统基本实现">
      <i class="fa fa-chevron-left"></i> Linux文件系统基本实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/21/professional_cpp_fmt/" rel="next" title="认识 fmt">
      认识 fmt <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#simplefs-%E5%AE%9E%E6%88%98"><span class="nav-number">1.</span> <span class="nav-text">simplefs 实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%93%E9%AA%8C"><span class="nav-number">1.1.</span> <span class="nav-text">基本体验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A1%AC%E7%9B%98"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建一个硬盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B9%B6%E6%8C%82%E8%BD%BD"><span class="nav-number">1.1.2.</span> <span class="nav-text">格式化并挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9"><span class="nav-number">1.1.3.</span> <span class="nav-text">查看内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-mkfs-simplefs-c"><span class="nav-number">1.2.</span> <span class="nav-text">格式化代码分析(mkfs-simplefs.c)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99-superblock"><span class="nav-number">1.2.1.</span> <span class="nav-text">写 superblock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%A0%B9%E6%96%87%E4%BB%B6inode"><span class="nav-number">1.2.2.</span> <span class="nav-text">写根文件inode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6inode"><span class="nav-number">1.2.3.</span> <span class="nav-text">写文件inode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%A0%B9%E7%9B%AE%E5%BD%95block"><span class="nav-number">1.2.4.</span> <span class="nav-text">写根目录block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6block"><span class="nav-number">1.2.5.</span> <span class="nav-text">写文件block</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">文件系统的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91"><span class="nav-number">1.3.1.</span> <span class="nav-text">文件系统操作逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-simple-c"><span class="nav-number">1.4.</span> <span class="nav-text">操作代码分析(simple.c)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%BD%BD"><span class="nav-number">1.4.1.</span> <span class="nav-text">挂载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E5%86%85%E5%AE%B9"><span class="nav-number">1.4.2.</span> <span class="nav-text">读取文件夹内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">1.4.3.</span> <span class="nav-text">读取文件内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">1.4.4.</span> <span class="nav-text">写文件内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="nav-number">1.4.5.</span> <span class="nav-text">新建文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="nav-number">1.4.6.</span> <span class="nav-text">新建文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text">功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.1.</span> <span class="nav-text">删除文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FUSE"><span class="nav-number">2.</span> <span class="nav-text">FUSE</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">比较重要的数据结构</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kcmetercec"
      src="https://avatars.githubusercontent.com/u/16881795?s=400&u=f62971f44f59d17d823044e709d4668debec7c02&v=4">
  <p class="site-author-name" itemprop="name">kcmetercec</p>
  <div class="site-description" itemprop="description">Qt, C++, linux, CS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/KcMeterCEC" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KcMeterCEC" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kcmeter.cec@gmail.com" title="E-Mail → mailto:kcmeter.cec@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kcmetercec</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">206k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f938893867df78f94802',
      clientSecret: 'b6d8470939c53d26c98c4e3b9d4c9ceb55d6e78e',
      repo        : 'kcmetercec.github.io',
      owner       : 'KcMeterCEC',
      admin       : ['KcMeterCEC'],
      id          : '5241b177089e211ece005d7902d564e7',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
