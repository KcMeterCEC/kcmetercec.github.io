<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kcmetercec.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="kernel version arch    v5.4.0 arm32">
<meta property="og:type" content="article">
<meta property="og:title" content="初步认识 Linux 内存管理">
<meta property="og:url" content="http://kcmetercec.top/2024/08/05/linux_memory_hello/index.html">
<meta property="og:site_name" content="explorer">
<meta property="og:description" content="kernel version arch    v5.4.0 arm32">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/%5BWhat%5DLinux--mem_IO/mem_area.jpg?raw=true">
<meta property="article:published_time" content="2024-08-04T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-04T16:00:00.000Z">
<meta property="article:author" content="kcmetercec">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/%5BWhat%5DLinux--mem_IO/mem_area.jpg?raw=true">

<link rel="canonical" href="http://kcmetercec.top/2024/08/05/linux_memory_hello/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>初步认识 Linux 内存管理 | explorer</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112423075-1# <app_id>"></script>
    <script data-pjax>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-112423075-1# <app_id>');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="explorer" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">explorer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">万丈高楼平地起，勿在浮沙筑高台</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://kcmetercec.top/2024/08/05/linux_memory_hello/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/16881795?s=400&u=f62971f44f59d17d823044e709d4668debec7c02&v=4">
      <meta itemprop="name" content="kcmetercec">
      <meta itemprop="description" content="Qt, C++, linux, CS">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="explorer">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          初步认识 Linux 内存管理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-05 00:00:00" itemprop="dateCreated datePublished" datetime="2024-08-05T00:00:00+08:00">2024-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/memory/" itemprop="url" rel="index"><span itemprop="name">memory</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/memory/overview/" itemprop="url" rel="index"><span itemprop="name">overview</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="CPU-与内存-I-O"><a href="#CPU-与内存-I-O" class="headerlink" title="CPU 与内存,I/O"></a>CPU 与内存,I/O</h1><h2 id="内存空间与I-O空间的区别"><a href="#内存空间与I-O空间的区别" class="headerlink" title="内存空间与I/O空间的区别"></a>内存空间与I/O空间的区别</h2><p>I/O 空间的概念是存在于 X86 架构中的，与内存空间做区分，它通过特定的指令<code>in</code>,<code>out</code>来访问外设寄存器的地址。</p>
<p>但是在实际使用时，我们也可以将外设设计在 X86 架构的内存空间中，直接访问寄存器地址，所以 <strong>I/O空间是可选的</strong> 。</p>
<p>在大多数嵌入式微控制器中没有I/O空间，仅有内存空间。内存空间可以直接通过地址，指针来访问，程序以及其他数据都是存在于内存空间中的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">再次强调：无论是在内核态还是在用户态，CPU 看到的都是虚拟地址！</span><br><span class="line"></span><br><span class="line">无论是内存条还是寄存器的访问，内核都是通过虚拟地址去访问的，内核中所有的指针操作</span><br><span class="line">都是虚拟地址。</span><br><span class="line"></span><br><span class="line">在内核中，物理地址对于 Linux 来说就是一个整数，如下物理地址在内核中的定义：</span><br><span class="line">//file: include/linux/types.h</span><br><span class="line"><span class="meta">#</span><span class="bash">ifdef CONFIG_PHYS_ADDR_T_64BIT</span></span><br><span class="line">typedef u64 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line">typedef u32 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br></pre></td></tr></table></figure>

<h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>MMU提供虚拟地址和物理地址的映射，内存访问权限保护和 Cache 缓存控制等硬件支持，<br>用户在编写实际程序时不用考虑实际物理地址有多大，以及是否会与其他程序地址冲突等等。</p>
<ul>
<li>具体MMU工作参考 <a href="https://kcmetercec.top/2023/04/06/linux_mm_hardware_mmu/">MMU基本原理</a></li>
</ul>
<h3 id="MMU操作原理"><a href="#MMU操作原理" class="headerlink" title="MMU操作原理"></a>MMU操作原理</h3><p>MMU中比较重要的两个概念：</p>
<ul>
<li>TLB(Translation Lookaside Buffer)<ul>
<li>转换旁路缓存，TLB 是 MMU 的核心部件，它缓存少量的虚拟地址与物理地址的转换关系，是转换表的Cache，因此也经常被称为”快表”。</li>
</ul>
</li>
<li>TTW(Translation Table wale)<ul>
<li>转换表漫游，当TLB中没有缓冲对应的地址转换对应关系时，需要通过对内存中转换表的访问来获得虚拟地址和物理地址的对应关系。TTW成功后，结果应写入TLB中。</li>
</ul>
</li>
</ul>
<p>MMU操作的原则都是以最快的速度来读写 CPU 所需要的数据或指令:</p>
<ol>
<li>所以它会首先访问 TLB 以保证最快的速度找到映射关系然后进行存取，如果此时打开了Cache并且Cache命中，那也会直接取Cache的数据否则取内存的数据并且更新Cache</li>
<li>如果TLB没有命中那么就会访问 TTW 找到映射关系并反过来更新 TLB。</li>
</ol>
<h3 id="MMU的权限管理"><a href="#MMU的权限管理" class="headerlink" title="MMU的权限管理"></a>MMU的权限管理</h3><p>MMU的权限管理主要包含以下两个方面：</p>
<ol>
<li>这段内存是否具有RWX权限(比如代码段只有RX权限，避免被改写)</li>
<li>这段内存是仅有内核才可访问，还是内核和用户都可访问<ul>
<li>仅有内核可访问的内存，避免用户获取到内核的数据</li>
</ul>
</li>
</ol>
<p>权限管理使用下面程序进行体验：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    access();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">,* @note : 此处新建一个文件，就是让编译器在预编译、编译、汇编的过程中，无法察觉变量 a的类型，</span></span><br><span class="line"><span class="comment">,* 以保证编译通过。</span></span><br><span class="line"><span class="comment">,* 但实际上 a 的内存权限为可读，所以当执行写时，就会触发page fault</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="meltdown漏洞"><a href="#meltdown漏洞" class="headerlink" title="meltdown漏洞"></a>meltdown漏洞</h3><p>meltdown漏洞使得用户空间可以访问内核空间中的内容，详细解释参考 <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YjKoay39rtKQXGbWN6qfug">格友</a> 。</p>
<p>简单解释就是：</p>
<ol>
<li>用户空间先申请一个大数组，这个大数组的每个元素的大小即为内存页表的大小，这是为了每个页可以覆盖整个 cache，便于后期测试不被干扰</li>
<li>用户空间发送读取内核空间中 <strong>一个字节的请求</strong> ，一个字节的值为 0~255，假设该值为 N</li>
<li>由于CPU的分支预测执行功能，将用户空间大数组的第 N 个块进行读取操作（此时 N 的值依然存在于寄存器中）</li>
<li>虽然MMU进行了权限检查，但此时用户空间中数组的第 N 个块的部分数据已经存在于 cache 中了，此时 cache hit</li>
<li>由于读取Cache的速度要远远快于读取内存的速度，用户通过依次扫描 0~255 块的读取速度，识别出读取最快的那个块，便知道这第 N 个块代表内核地址的值为 N</li>
</ol>
<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">由于这个漏洞是由硬件造成的，而执行的入口是用户空间和内核空间共用了一个页表（这样用户空间才可以通过虚拟地址去访问内核）。</span><br><span class="line">所以如果将用户空间和内核空间的页表进行分离，大家各用各的页表那么用户空间就无法通过虚拟地址访问到内核了。(无论用户空间如何访问，它都是访问自己的页表，对应自己代码的物理地址或者就干脆是没有命中的地址)</span><br><span class="line"></span><br><span class="line">但这样相当于MMU将内核空间和用户空间隔离为了两个进程一样，当用户空间调用内核空间接口函数时，在切换为特权模式的同时还要切换一次页表。同理，内核处理完成后回到用户空间还要切换一次页表。这样就会消耗很多时间，性能损耗比较大。</span><br><span class="line"></span><br><span class="line">需要注意的是：</span><br><span class="line">并不是说进程页表一丁点都不覆盖内核空间了，当进程进行正常合法的系统调用时，这部分逻辑是应该正常运行的。</span><br><span class="line">也就是说进程的页表要进程内核空间的系统调用接口部分以实现正常的访问。</span><br><span class="line">- 而进入到内核这部分代码之后，它会切换到内核页表，内核的页表便是覆盖所有空间的。当调用完成后，又切换回用户态的页表。</span><br></pre></td></tr></table></figure>

<p>实例体验:实际代码及操作位于 <a target="_blank" rel="noopener" href="https://github.com/21cnbao/meltdown-example">宋宝华老师github</a></p>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><ul>
<li>在Linux系统中,进程的 <strong>虚拟4GB内存空间</strong> 被分为两个部分—用户空间和内核空间.</li>
<li>用户空间的地址一般分布为0<del>3GB(即PAGE_OFFSET),剩下的3</del>4GB为内核空间.  <ul>
<li><strong>用户进程只有通过系统调用(代表用户进程在内核态执行)等方式才可以访问到内核空间</strong>.</li>
<li>每个进程的用户空间都是完全独立，互不相干的。**<strong>用户进程各自有不同的页表</strong>。而内核空间是由内核负责映射，它并不会跟着进程改变,是固定的。</li>
<li>*<em>内核空间的虚拟地址到物理地址的映射是被所有进程共享的，内核虚拟空间独立于其他程序</em>***。</li>
</ul>
</li>
</ul>
<p>在menuconfig中 <code>Kernel Features -&gt; Memory split(..)</code> 可以选择设置 <code>CONFIG_PAGE_OFFSET</code> ，默认内核空间就是位于3G~4G空间的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:arch/arm/include/asm/memory.h</span></span><br><span class="line"><span class="comment">/* PAGE_OFFSET - the virtual address of the start of the kernel image */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET        UL(CONFIG_PAGE_OFFSET)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由上面代码也可以知道内核中可以使用 <code>PAGE_OFFSET</code> 宏来判断内核虚拟空间的起始地址</li>
</ul>
<h2 id="对物理内存条的分配"><a href="#对物理内存条的分配" class="headerlink" title="对物理内存条的分配"></a>对物理内存条的分配</h2><ul>
<li>请注意： <strong>这里说的是物理内存条，不是内存空间</strong></li>
</ul>
<p>Linux一般将内存条分为DMA_ZONE, NORMAL_ZONE, HIGH_ZONE3个区,<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5K7rlPXo2yIcoIXXgqqLfQ">阅码场</a> 上有清晰的说明,<br><a target="_blank" rel="noopener" href="https://www.quora.com/In-reference-to-Linux-Kernel-what-is-the-difference-between-high-memory-and-normal-memory">quora</a> 上对此也有解释。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/%5BWhat%5DLinux--mem_IO/mem_area.jpg?raw=true"></p>
<h3 id="DMA-ZONE"><a href="#DMA-ZONE" class="headerlink" title="DMA_ZONE"></a>DMA_ZONE</h3><p>DMA_ZONE 是为特定 DMA 划分的区域，某些芯片的 DMA 控制器无法访问全部内存条(有些仅能访问有限的十几兆空间)，所以 Linux 为此类 DMA 规划一片内存.</p>
<p>当实际编写内核代码时，申请 DMA 缓存时使用 <code>GFP_DMA</code> 标记，以告知 Linux 在那片固定区域申请。</p>
<p>在内核代码中也有关于此标记的注释(提到了还可以作为紧急后备内存来使用):</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GFP_DMA exists for historical reasons and should be avoided where possible.</span><br><span class="line">The flags indicates that the caller requires that the lowest zone be</span><br><span class="line">used (ZONE_DMA or 16M on x86-64). Ideally, this would be removed but</span><br><span class="line">it would require careful auditing as some users really require it and</span><br><span class="line">others use the flag to avoid lowmem reserves in ZONE_DMA and treat the</span><br><span class="line">lowest zone as a type of emergency reserve.</span><br></pre></td></tr></table></figure>

<p>DMA_ZONE 的设置一般在构架目录下的Kconfig中设置，比如 <code>arch/arm/Kconfig</code> 具有其使能标记，但在设置前一定要搞清楚具体硬件！</p>
<h3 id="NORMAL-ZONE"><a href="#NORMAL-ZONE" class="headerlink" title="NORMAL_ZONE"></a>NORMAL_ZONE</h3><p>前面说过，在虚拟地址中3<del>4G为内核空间。 **Linux将物理内存的0</del>1G线性映射到3G~4G虚拟地址空间** ，而这1G的空间减去 DMA_ZONE 剩下的部分就是 NORMAL_ZONE。 </p>
<p>所谓的线性映射指的就是页表的简单映射关系，一般这种情况下仅仅是一个简单的偏移即可转换，内核提供了函数以相互转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note ： 在内核中物理地址都是一个数值，它能以指针操作的只有虚拟地址，</span></span><br><span class="line"><span class="comment"> ,* 所以此处物理地址都是 unsigned long 型</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">virt_to_phys</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> *address)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">phys_to_virt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意： <strong>线性映射并不是内核已经占用了内存，而是提前映射好以便后面操作,而无需使用时再来映射。</strong></p>
<h3 id="HIGH-ZONE"><a href="#HIGH-ZONE" class="headerlink" title="HIGH_ZONE"></a>HIGH_ZONE</h3><p>当实际的物理内存大于1G时，多于的部分就是HIGH_ZONE.</p>
<p>当内核空间要使用此段内存时，由于没有提前映射，则需要经过以下步骤使用：</p>
<ol>
<li>映射HIGH_ZONE到 高端页面映射区</li>
<li>使用</li>
<li>释放映射</li>
</ol>
<p>注意： 内核对HIGH_ZONE 不能使用 <code>virt_to_phys,phys_to_virt</code> 来转换，因为它们不是简单的线性映射!</p>
<p>对于用户空间而言，用户申请内存时，Linux搜寻内存的路径为： HIGH_ZONE -&gt; NORMAL_ZONE -&gt; DMA_ZONE.</p>
<h2 id="对内核虚拟空间的分配"><a href="#对内核虚拟空间的分配" class="headerlink" title="对内核虚拟空间的分配"></a>对内核虚拟空间的分配</h2><h3 id="x86-32-架构下的分配"><a href="#x86-32-架构下的分配" class="headerlink" title="x86-32 架构下的分配"></a>x86-32 架构下的分配</h3><p>Linux中1GB的虚拟内核地址空间又被划分为:</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>虚拟地址位置</th>
<th>相关代码</th>
</tr>
</thead>
<tbody><tr>
<td>保留区</td>
<td>FIXADDR_TOP ~ 4GB</td>
<td>搜索宏 FIXADDR_TOP</td>
</tr>
<tr>
<td>专用页面映射区</td>
<td>FIXADDR_START ~ FIXADDR_TOP</td>
<td>搜索宏 FIXADDR_START</td>
</tr>
<tr>
<td>高端内存映射区</td>
<td>PKMAP_BASE ~ FIXADDR_START</td>
<td>搜索宏 PKMAP_BASE</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vmalloc虚拟内存分配区</td>
<td>VMALLOC_START ~ VMALLOC_END</td>
<td>搜索宏 VMALLOC_START</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理内存映射区</td>
<td>3GB起始最大长度896M(对应物理内存的896M)</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接映射的最大896M物理内存分为两个区域：</span><br><span class="line">- 0 ~ 16M : ISA设备用作DMA申请</span><br><span class="line">- 16M ~ 896M : 常规区域</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统物理内存超过4GB时，必须使用CPU的扩展分页(PAE)模式所提供的64位页目录才能取到4GB以上的物理内存。</li>
</ul>
<p>由上表可以看出：此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<br><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></p>
<h3 id="arm32-linux-下的分配"><a href="#arm32-linux-下的分配" class="headerlink" title="arm32 linux 下的分配"></a>arm32 linux 下的分配</h3><table>
<thead>
<tr>
<th>区域名称</th>
<th>虚拟地址位置</th>
<th>相关代码</th>
</tr>
</thead>
<tbody><tr>
<td>向量表</td>
<td>0xfff0000~0xfff0fff</td>
<td>文档 Documentation/arm/memory.txt</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vmalloc和ioremap区域</td>
<td>VMALLOC_START ~ VMALLOC_END -1</td>
<td>宏 VMALLOC_START</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DMA和常规区域映射区</td>
<td>PAGE_OFFSET ~ high_memory -1</td>
<td>宏 PAGE_OFFSET 以及变量 high_memory</td>
</tr>
<tr>
<td>高端内存映射区</td>
<td>PKMAP_BASE ~ PAGE_OFFSET -1</td>
<td>宏 PKMAP_BASE</td>
</tr>
<tr>
<td>内核模块</td>
<td>MODULES_VADDR ~ MODULES_END -1</td>
<td>宏 MODULES_VADDR</td>
</tr>
</tbody></table>
<p>由上表可以看出: </p>
<ul>
<li>对于arm32 来说， <strong>从内核模块开始的地方就已经是内核空间了！</strong></li>
<li>此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<ul>
<li><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在编译内核的时候可以选择：</span><br><span class="line">- VMSPLIT_3G : 用户空间3G，内核空间1G。内核模块范围为 3GB-16MB ~ 3GB-2MB,高端内存映射 3GB-2MB ~ 3GB</span><br><span class="line">- VMSPLIT_2G : 用户空间2G，内核空间2G。内核模块范围为 2GB-16MB ~ 2GB-2MB,高端内存映射 2GB-2MB ~ 2GB</span><br><span class="line"></span><br><span class="line">ARM系统的Linux之所以把内核模块放在16MB范围内，是因为ARM指令在32M以内是短跳转。</span><br><span class="line"></span><br><span class="line">而内核代码位于 3G~3G+6M 的位置，所以将内核模块放在3G-2M ~ 3G-16M之间的内存差异在32M以内，</span><br><span class="line">这样就实现了内核模块和内核本身的代码段之间的短跳转，以最小的开销实现函数的调用.</span><br></pre></td></tr></table></figure>

<h2 id="DMA、常规、高端内存分布"><a href="#DMA、常规、高端内存分布" class="headerlink" title="DMA、常规、高端内存分布"></a>DMA、常规、高端内存分布</h2><p>有以下4种可能的情况分布(地址由低到高)：</p>
<ul>
<li>DMA区域 | 常规区域 | 高端内存区域 <ul>
<li>内存较大，硬件DMA只能访问一部分地址，并且内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li>
</ul>
</li>
<li>DMA区域(常规区域) | 高端内存区域<ul>
<li>内存较大，硬件DMA可以访问全部地址，但内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li>
</ul>
</li>
<li>DMA区域 | 常规区域<ul>
<li>内存较小，硬件DMA只能访问一部分地址，且内核可以完全映射物理内存</li>
</ul>
</li>
<li>DMA区域(常规区域)<ul>
<li>内存较小，硬件DMA可以访问全部地址，且内核可以完全映射物理内存</li>
</ul>
</li>
</ul>
<h3 id="buddy-算法"><a href="#buddy-算法" class="headerlink" title="buddy 算法"></a>buddy 算法</h3><p>DMA、常规、高端内存分布区 <strong>最底层</strong> 使用的是 <code>buddy</code> 算法进行管理，它将空闲 <strong>页</strong> 面以 2 的 n次方进行分配，而内存申请也是也 2 的 n 次方申请。</p>
<ul>
<li>buddy 在不断的拆分和合并，其空闲页面以 1,2,4,8,16… 这种形式组织起来<ul>
<li>从16个页面中取出一页后，buddy会拆分为 1,2,4,8 空闲页</li>
<li>如果原来是1,2,8的空闲，现在又释放了2页, <strong>如果这2页和原来空闲的2页内存连续</strong> ，buddy会合并为1,4,8空闲页</li>
</ul>
</li>
<li>与此同时， <strong>用户每次申请也只能是2的n次方！</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 /proc/buddyinfo 会显示这些区域的空闲页面分布情况,依次从左到右显示 1,2,4,8,16 空闲页数量</span><br></pre></td></tr></table></figure>

<p>在内核编程时，可以使用以下函数来申请buddy页(一般不会直接使用)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief file: /include/linux/gfp.h</span></span><br><span class="line"><span class="comment"> ,* @note 此处的order就代表2的次方</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct page * <span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="内存申请实际操作"><a href="#内存申请实际操作" class="headerlink" title="内存申请实际操作"></a>内存申请实际操作</h1><h2 id="用户空间内存动态申请"><a href="#用户空间内存动态申请" class="headerlink" title="用户空间内存动态申请"></a>用户空间内存动态申请</h2><p>用户空间的内存申请和释放使用标准的c库即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Linux内核总是采用按需调页(Demand Paging)，因此当malloc()返回的时候，虽然是成功返回，但是内核并没有真正给这个进程内存。这个时候如果去读申请的内存，内容全部是0，这个页面的映射是只读的。只有当写到某个页面的时候，内核才在页错误后，真正把这个页面给这个进程。</strong></p>
<h2 id="内核空间内存动态申请"><a href="#内核空间内存动态申请" class="headerlink" title="内核空间内存动态申请"></a>内核空间内存动态申请</h2><h3 id="物理内存连续申请"><a href="#物理内存连续申请" class="headerlink" title="物理内存连续申请"></a>物理内存连续申请</h3><p>函数 <code>kmalloc() 和 __get_free_pages()以及类似函数</code> 申请的区域位于 <code>DMA和常规区域的映射区</code> ，在物理上是连续的，与真实物理地址只有一个固定的偏移。</p>
<ul>
<li>kmalloc() 底层依赖于 <code>__get_free_pages()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 申请内存地址</span></span><br><span class="line"><span class="comment"> ,* @param size: 要申请的字节数</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请的内存类型</span></span><br><span class="line"><span class="comment"> ,* @note flags 一般有以下取值：</span></span><br><span class="line"><span class="comment"> ,* GFP_USER -&gt; 为用户空间页分配内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_KERNEL -&gt; 为内核空间申请内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_ATOMIC -&gt; 原子方式申请内存，若不存在则直接返回而不阻塞(用于中断、tasklet、内核定时器等非进程上下文环境中)</span></span><br><span class="line"><span class="comment"> ,* GFP_HIGHUSER -&gt; 从高端区域中为用户空间分配</span></span><br><span class="line"><span class="comment"> ,* GFP_NOIO -&gt; 申请期间，不允许任何 I/O 初始化</span></span><br><span class="line"><span class="comment"> ,* GFP_NOFS -&gt; 申请期间，不允许任何文件系统调用</span></span><br><span class="line"><span class="comment"> ,* GFP_NOWAIT -&gt; 若不存在空闲页则不等待</span></span><br><span class="line"><span class="comment"> ,* GFP_DMA -&gt; 从DMA区域分配内存</span></span><br><span class="line"><span class="comment"> ,* 还有其他取值请参考文件 include/linux/slab.h</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kzalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放kmalloc对应申请的内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 内存的申请管理设备，当设备被释放时内存也跟着自动释放</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kmalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在 devm_kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kzalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="物理内存不一定连续申请"><a href="#物理内存不一定连续申请" class="headerlink" title="物理内存不一定连续申请"></a>物理内存不一定连续申请</h3><p>函数 <code>vmalloc()</code> 申请区域位于 <code>vmalloc区域</code> ，在物理上不一定是连续的，与真实物理地址转换关系也不简单。</p>
<ul>
<li>vmalloc() 一般只为存在于软件中的(没有对应硬件访问)较大的内存分配</li>
<li>vmalloc() 效率没有 kmalloc() 高，不适合用来分配小内存<ul>
<li>在申请时会内存映射并修改页表</li>
</ul>
</li>
<li>vmalloc() <strong>不能用在原子上下文中</strong> ，因为它内存实现使用了标志为 <code>GFP_KERNEL</code> 的 kmalloc，可能会导致睡眠</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="slab机制提高少量字节申请效率"><a href="#slab机制提高少量字节申请效率" class="headerlink" title="slab机制提高少量字节申请效率"></a>slab机制提高少量字节申请效率</h3><p>slab机制使得内核中的小对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，大大提高分配效率。</p>
<ul>
<li>kmalloc() 就是使用 slab 机制实现的</li>
<li>使用 slab机制申请的内存与物理内存之间也是简单的线性偏移关系</li>
<li>查看 <code>/proc/slabinfo</code> 可以得到当前 slab 分配和使用情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 创建一个slab缓存，保留任意数据且全部大小相同的后备缓存</span></span><br><span class="line"><span class="comment"> ,* @param name: 缓存名称，最终会映射在 /proc/slabinfo 中</span></span><br><span class="line"><span class="comment"> ,* @param size: 每个数据结构的大小</span></span><br><span class="line"><span class="comment"> ,* @param aligh: 数据的对齐方式</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请标记：</span></span><br><span class="line"><span class="comment"> ,* - SLAB_POISON</span></span><br><span class="line"><span class="comment"> ,* - SLAB_RED_ZONE : </span></span><br><span class="line"><span class="comment"> ,* - SLAB_HWCACHE_ALIGH : 每个数据对象被对齐到一个缓存行</span></span><br><span class="line"><span class="comment"> ,* @param ctor: 对象的构造函数</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmem_cache_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cache, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cache,<span class="keyword">void</span> *objp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放 slab 缓存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">kmem_cache_t</span> *xxx_cachep;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 申请slab缓存池</span></span><br><span class="line">xxx_cachep = kmem_cache_create(<span class="string">&quot;xxx&quot;</span>, <span class="keyword">sizeof</span>(struct xxx), <span class="number">0</span>, SLAB_HWCACHE_ALIGH | SLAB_PANIC,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//! 分配对象内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">ctx = kmem_cache_alloc(xxx_cachep, GFP_KERNEL);</span><br><span class="line"><span class="comment">//! 使用对象内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放对象内存</span></span><br><span class="line">kmem_cache_free(xxx_cachep, ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放slab缓存池</span></span><br><span class="line">kmem_cache_destroy(xxx_cachep);</span><br></pre></td></tr></table></figure>

<p>内存池技术也是用于分配大量小对象的后备缓存技术。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mempool_t</span> *<span class="title">mempool_create</span><span class="params">(<span class="keyword">int</span> min_nr, <span class="keyword">mempool_alloc_t</span> *alloc_fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">mempool_free_t</span> *free_fn, <span class="keyword">void</span> *pool_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mempool_alloc</span><span class="params">(<span class="keyword">mempool_t</span> *pool, <span class="keyword">gfp_t</span> gfp_mask)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_free</span><span class="params">(<span class="keyword">void</span> *element, <span class="keyword">mempool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_destroy</span><span class="params">(<span class="keyword">mempool_t</span> *pool)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="设备-I-O-端口和-I-O-内存的访问"><a href="#设备-I-O-端口和-I-O-内存的访问" class="headerlink" title="设备 I/O 端口和 I/O 内存的访问"></a>设备 I/O 端口和 I/O 内存的访问</h1><p>设备通常会提供一组寄存器来控制设备,读写设备和获取设备状态,这些寄存器可能位于 I/O 空间中,也可能位于内存空间中.</p>
<ul>
<li>当位于I/O 空间时,通常被称为 <strong>I/O端口</strong>;</li>
<li>当位于内存空间时,对应的内存空间被称为 <strong>I/O内存</strong>.</li>
<li>在使用I/O区域时,需要 <strong>申请该区域</strong> ,以表明驱动要访问这片区域.</li>
</ul>
<h2 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h2><p>I/O 端口的具体操作流程为：</p>
<ol>
<li>申请I/O端口资源</li>
<li>使用读写函数操作I/O端口</li>
<li>释放I/O端口资源</li>
</ol>
<h3 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 向内核申请 n 个端口,这些端口从 start开始,name 参数为设备的名称</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_region(start,n,name) __request_region(&amp;ioport_resource,(start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_region(start,n) __release_region(&amp;ioport_resource, (start), (n))</span></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_region(dev,start,n,name) __devm_request_region(dev,&amp;ioport_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure>

<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!读写一字节端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写16位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写32位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(<span class="keyword">unsigned</span> longword, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串32位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="I-O-内存"><a href="#I-O-内存" class="headerlink" title="I/O 内存"></a>I/O 内存</h2><p>I/O内存的操作流程为：</p>
<ol>
<li>申请I/O内存资源</li>
<li>将资源地址映射到内核虚拟空间</li>
<li>使用读写函数操作</li>
<li>释放I/O内存资源</li>
</ol>
<h3 id="申请与释放-1"><a href="#申请与释放-1" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 申请以start为开始的,n字节的I/O内存区域，名字为name</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_mem_region(start,n,name) __request_region(&amp;iomem_resource, (start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放申请的内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_mem_region(start,n) __release_region(&amp;iomem_resource, (start),(n))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_mem_region(dev,start,n,name) __devm_request_region(dev,&amp;iomem_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从物理地址 offset处映射size字节内存到内核虚拟内存</span></span><br><span class="line"><span class="comment"> ,* @note ioremap() 与 vmalloc() 类似，也需要新建页表，但不进行内存分配行为。</span></span><br><span class="line"><span class="comment"> ,* 所映射的虚拟地址区为 vmalloc 映射区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">ioremap</span><span class="params">(<span class="keyword">phys_addr_t</span> offset, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//! 取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span><span class="params">(<span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="comment">//! 当设备资源释放后自动取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">devm_ioremap</span><span class="params">(struct device *dev, <span class="keyword">resource_size_t</span> offset, <span class="keyword">resource_size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="读写操作函数"><a href="#读写操作函数" class="headerlink" title="读写操作函数"></a>读写操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 分别读写 8,16,32,64 位</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">u8  <span class="title">readb</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u16 <span class="title">readw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u32 <span class="title">readl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u64 <span class="title">readq</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeb</span><span class="params">(u8  value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeq</span><span class="params">(u64 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="将设备地址映射到用户空间"><a href="#将设备地址映射到用户空间" class="headerlink" title="将设备地址映射到用户空间"></a>将设备地址映射到用户空间</h2><p>驱动可以通过mmap()函数来给用户空间提供设备的虚拟地址，以达到间接访问的目的。</p>
<p>mmap()实现这样一个映射的过程：将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，<br>实际上会转化为对设备的访问。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般这样做的目的并不是为了用户空间来直接控制寄存器，因为这就破坏了分层的原则。</span><br><span class="line"></span><br><span class="line">一般就用于将内核空间申请的内存映射到用户空间，这样用户可以直接高效的参与内存读写，避免再进行一次数据搬移。</span><br><span class="line">比如：用户空间直接读写DMA收发的数据。</span><br></pre></td></tr></table></figure>

<h3 id="内存映射与VMA"><a href="#内存映射与VMA" class="headerlink" title="内存映射与VMA"></a>内存映射与VMA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 内核 file_operatoins 中的 mmap()</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct file *, struct vm_area_struct *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 用户空间的 mmap()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从内核空间映射一段内存到用户空间</span></span><br><span class="line"><span class="comment"> ,* @param addr : 映射到用户空间以 addr 为起始，为NULL则自动分配</span></span><br><span class="line"><span class="comment"> ,* @param length: 映射的字节数</span></span><br><span class="line"><span class="comment"> ,* @param prot: 内存访问权限</span></span><br><span class="line"><span class="comment"> ,* - PROT_NONE : 不可访问</span></span><br><span class="line"><span class="comment"> ,* - PROT_EXEC : 可以执行</span></span><br><span class="line"><span class="comment"> ,* - PROT_READ : 可读</span></span><br><span class="line"><span class="comment"> ,* - PROT_WRITE: 可写</span></span><br><span class="line"><span class="comment"> ,* @param flags : 内存状态</span></span><br><span class="line"><span class="comment"> ,* - MAP_SHARED : 可被进程共享</span></span><br><span class="line"><span class="comment"> ,* - MAP_PRIVATE: 非共享</span></span><br><span class="line"><span class="comment"> ,* @param fd: 打开的文件索引</span></span><br><span class="line"><span class="comment"> ,* @param offset: 从内核的 offset 偏移处开始映射</span></span><br><span class="line"><span class="comment"> ,* @return 申请的地址</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 取消映射</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当用户调用 mmap()的时候,内核会进行如下处理.</p>
<ol>
<li>在进程的虚拟空间查找一块 VMA</li>
<li>将这块VMA进行映射</li>
<li>如果设备驱动程序或者文件系统的file_operations定义了mmap()操作,则调用它</li>
<li>将这个VMA插入进程的VMA链表中</li>
</ol>
<p>驱动中的mmap()的实现机制是建立页表,并填充VMA结构体中 <code>vm_operations_struct</code> 指针.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 用于描述一个虚拟内存区域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*The first cache line has the info for VMA tree walking.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;<span class="comment">/*Our start address within vm_mm.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;<span class="comment">/*The first byte after our end address within vm_mm*/</span></span><br><span class="line">        <span class="comment">/* lnked list of VM areas per task, sorted by address*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>,*<span class="title">vm_prev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>VMA结构体描述的虚拟地址介于 vm_start 和 vm_end之间,其 vm_ops 成员指向这个VMA的操作集, 针对VMA的操作都被包含在 vm_operations_struct 结构体中.</p>
<p>操作范例:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_mmap</span><span class="params">(stuct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建页表项</span></span><br><span class="line">        <span class="keyword">if</span>(remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff, vma-&gt;vm_end -</span><br><span class="line">                           vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        vma-&gt;vm_ops = &amp;xxx_remap_vm_ops;</span><br><span class="line">        xxx_vma_open(vma);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户空间使用 mmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_open</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA open, virt %lx, phys %lx\n&quot;</span>, vma-&gt;vm_start, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在用户空间使用 munmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_close</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA close.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">xxx_remap_vm_ops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">        .open = xxx_vma_open,</span><br><span class="line">        .close = xxx_vma_close,</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="fault-函数"><a href="#fault-函数" class="headerlink" title="fault() 函数"></a>fault() 函数</h3><p>fault() 函数可以为设备提供更加灵活的内存映射途径。<br>当访问的页不在内存时，fault()会被内核自动调用。</p>
<p>当发生缺页时，流程为：</p>
<ol>
<li>找到缺页的虚拟地址所在的VMA</li>
<li>如果必要分配中间页目录表和页表</li>
<li>如果页表项对应的物理页面不存在，则调用 fault() 函数，它返回物理页面的页描述符</li>
<li>将物理页面地址填充到页表中</li>
</ol>
<h1 id="I-O内存静态映射"><a href="#I-O内存静态映射" class="headerlink" title="I/O内存静态映射"></a>I/O内存静态映射</h1><p>在将linux移植到目标电路板的过程中,有的会建立外设I/O内存物理地址到虚拟地址的静态映射,这个映射通过在与电路板对应的 map_desc 结构体数组中添加新的成员完成.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">virtual</span>;  <span class="comment">//虚拟地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn;     <span class="comment">//__phys_to_pfn(phy_addr)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">//内存大小</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> type;     <span class="comment">//内存类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="DMA内存"><a href="#DMA内存" class="headerlink" title="DMA内存"></a>DMA内存</h1><h2 id="DMA与硬件Cache一致性"><a href="#DMA与硬件Cache一致性" class="headerlink" title="DMA与硬件Cache一致性"></a>DMA与硬件Cache一致性</h2><ol>
<li>在DMA不工作的情况下或者DMA与Cache相对应的主存没有重叠区, 那么Cache 与主存中的数据具有一致性特点.二者并不会起冲突.</li>
<li>*<strong>当DMA与Cache相对应的主存有重叠区时,当DMA更新了重叠区的内容,而Cache并没有对应的更新.此时CPU仍然使用的是陈旧的cache的数据,就会发生Cache与内存之间数据”不一致性”的错误!</strong><ul>
<li>当CPU向内存写数据时，此时也是先写到了cache，DMA传输数据到外设依然是原来陈旧的数据</li>
<li>在发生Cache与内存不一致性错误后,驱动将无法正常运行.</li>
</ul>
</li>
<li>Cache的不一致问题并不是只发生在DMA的情况下,实际上,它还存在于Cache使能和关闭的时刻.例如,对于带MMU功能的ARM处理器,在开启 <em>MMU之前需要先置Cache无效,否则在开启MMU之后,Cache里面有可能保存的还是之前的物理地址,这也会造成不一致性的错误!</em>.</li>
</ol>
<h2 id="Linux-下的DMA编程-DMA只是一种外设与内存的交互方式"><a href="#Linux-下的DMA编程-DMA只是一种外设与内存的交互方式" class="headerlink" title="Linux 下的DMA编程(DMA只是一种外设与内存的交互方式)"></a>Linux 下的DMA编程(<em>DMA只是一种外设与内存的交互方式</em>)</h2><p>内存中用于外设交互数据的一块区域称为 DMA 缓冲区, <em><strong>在设备不支持scatter/gather操作的情况下,DMA缓冲区在物理上必须上连续的.</strong></em></p>
<ul>
<li>当硬件支持 <code>IOMMU</code> 时，缓冲区也可以不连续</li>
</ul>
<h3 id="DMA区域"><a href="#DMA区域" class="headerlink" title="DMA区域"></a>DMA区域</h3><p>对于大多数现代嵌入式处理器而言,DMA操作可以在整个常规内存区域进行,因此DMA区域就直接覆盖了常规内存.</p>
<h3 id="虚拟地址-物理地址-总线地址"><a href="#虚拟地址-物理地址-总线地址" class="headerlink" title="虚拟地址,物理地址,总线地址"></a>虚拟地址,物理地址,总线地址</h3><ul>
<li>总线地址： 基于DMA硬件使用的是总线地址而不是物理地址，是从设备角度上看到的内存地址</li>
<li>物理地址：是从CPU MMU 控制器外围角度上看到的内存地址</li>
<li>虚拟地址：CPU看到的是MMU反映给它的地址</li>
</ul>
<h3 id="DMA地址掩码"><a href="#DMA地址掩码" class="headerlink" title="DMA地址掩码"></a>DMA地址掩码</h3><p>设备不一定能在所有的内存地址上执行DMA操作,在这种情况下需要设置DMA能够操作的地址总线宽度.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask</span><span class="params">(struct device *dev, u64 mask)</span></span></span><br></pre></td></tr></table></figure>

<p>如果DMA只能操作24位地址,那么就应该调用 <code>dma_set_mask(dev,0xffffff)</code></p>
<ul>
<li><p>此时内核会为申请增加 <code>GFP_DMA</code> 标记，以从 DMA_ZONE 中申请内存</p>
<h3 id="一致性DMA缓冲区"><a href="#一致性DMA缓冲区" class="headerlink" title="一致性DMA缓冲区"></a>一致性DMA缓冲区</h3><p>为了能够避免 <em>DMA与Cache一致性问题</em>,使用如下函数分配一个DMA一致性的内存区域:</p>
</li>
<li><p>操作此函数的过程是不用关心CMA区域设置，这个是内核底层完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  申请一致性DMA缓冲区(一般不带cache, 但如果有 cache coherent interconnect 硬件支持，则就可以带cache)</span></span><br><span class="line"><span class="comment">  note: 这段缓存区一般是连续的，但如果硬件带IOMMU,则也可以是不连续的</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="comment">//返回申请到的DMA缓冲区的虚拟地址</span></span><br><span class="line"><span class="comment">//handle 代表总线地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_coherent</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放申请的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_coherent</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  分配一个写合并(writecombining)的DMA缓冲区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_writecombine</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_writecombine</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  PCI设备申请缓冲区</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pci_alloc_consistent</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *dma_addrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_free_consisten</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> dma_addr)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>:</p>
<p><code>dma_alloc_xxx()</code> 函数虽然是以 dma_alloc_开头, <strong>但是其申请的区域不一定在DMA区域里面</strong>.以32位ARM处理器为例,当conherent_dma_mask小于0xffffffff时,才会设置GFP_DMA标记,并从DMA区域去申请内存.</p>
<h3 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h3><p>在许多情况下缓冲区来自内核的较上层，上层很可能以普通的 kmalloc() 等方式申请内存，<br>也就是说这段内存是具有硬件cache的，这时就需要使用流式DMA。</p>
<p>流式DMA操作在本质上大多就是进行flush或invalidate Cache操作，以解决一致性问题。</p>
<ul>
<li>flush 是指将cache内容写入内存，invalidate是指让CPU再次从内存读取数据来刷新一次cache</li>
<li>如果有 <code>cache coherent interconnect</code> 硬件，则不需要关闭cache，从应用编程的角度来讲，只要按照规矩来操作即可。</li>
</ul>
<p>操作步骤为：</p>
<ol>
<li>进行流式DMA映射</li>
<li>执行DMA操作</li>
<li>取消映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一片内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多片非连续内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>kcmetercec
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://kcmetercec.top/2024/08/05/linux_memory_hello/" title="初步认识 Linux 内存管理">http://kcmetercec.top/2024/08/05/linux_memory_hello/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"> <i class="fa fa-tag"></i> linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/09/linux_make_yocto_buildroot/" rel="prev" title="Buildroot 的定制化使用">
      <i class="fa fa-chevron-left"></i> Buildroot 的定制化使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/08/13/linux_memory_overview_allocAndFree/" rel="next" title="Linux 内存的申请与释放">
      Linux 内存的申请与释放 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CPU-%E4%B8%8E%E5%86%85%E5%AD%98-I-O"><span class="nav-number">1.</span> <span class="nav-text">CPU 与内存,I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E4%B8%8EI-O%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.</span> <span class="nav-text">内存空间与I&#x2F;O空间的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83MMU"><span class="nav-number">1.2.</span> <span class="nav-text">内存管理单元MMU</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MMU%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">MMU操作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMU%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">MMU的权限管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#meltdown%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.2.3.</span> <span class="nav-text">meltdown漏洞</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%9D%A1%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">2.1.</span> <span class="nav-text">对物理内存条的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA-ZONE"><span class="nav-number">2.1.1.</span> <span class="nav-text">DMA_ZONE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NORMAL-ZONE"><span class="nav-number">2.1.2.</span> <span class="nav-text">NORMAL_ZONE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HIGH-ZONE"><span class="nav-number">2.1.3.</span> <span class="nav-text">HIGH_ZONE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">2.2.</span> <span class="nav-text">对内核虚拟空间的分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-32-%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">x86-32 架构下的分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arm32-linux-%E4%B8%8B%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">2.2.2.</span> <span class="nav-text">arm32 linux 下的分配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E3%80%81%E5%B8%B8%E8%A7%84%E3%80%81%E9%AB%98%E7%AB%AF%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="nav-number">2.3.</span> <span class="nav-text">DMA、常规、高端内存分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#buddy-%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.</span> <span class="nav-text">buddy 算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">内存申请实际操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7"><span class="nav-number">3.1.</span> <span class="nav-text">用户空间内存动态申请</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7"><span class="nav-number">3.2.</span> <span class="nav-text">内核空间内存动态申请</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E8%BF%9E%E7%BB%AD%E7%94%B3%E8%AF%B7"><span class="nav-number">3.2.1.</span> <span class="nav-text">物理内存连续申请</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%8D%E4%B8%80%E5%AE%9A%E8%BF%9E%E7%BB%AD%E7%94%B3%E8%AF%B7"><span class="nav-number">3.2.2.</span> <span class="nav-text">物理内存不一定连续申请</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slab%E6%9C%BA%E5%88%B6%E6%8F%90%E9%AB%98%E5%B0%91%E9%87%8F%E5%AD%97%E8%8A%82%E7%94%B3%E8%AF%B7%E6%95%88%E7%8E%87"><span class="nav-number">3.2.3.</span> <span class="nav-text">slab机制提高少量字节申请效率</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87-I-O-%E7%AB%AF%E5%8F%A3%E5%92%8C-I-O-%E5%86%85%E5%AD%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">4.</span> <span class="nav-text">设备 I&#x2F;O 端口和 I&#x2F;O 内存的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E7%AB%AF%E5%8F%A3"><span class="nav-number">4.1.</span> <span class="nav-text">I&#x2F;O 端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">4.1.1.</span> <span class="nav-text">申请与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">4.1.2.</span> <span class="nav-text">读写操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E5%86%85%E5%AD%98"><span class="nav-number">4.2.</span> <span class="nav-text">I&#x2F;O 内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E4%B8%8E%E9%87%8A%E6%94%BE-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">申请与释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text">读写操作函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="nav-number">4.3.</span> <span class="nav-text">将设备地址映射到用户空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E4%B8%8EVMA"><span class="nav-number">4.3.1.</span> <span class="nav-text">内存映射与VMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fault-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">fault() 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-O%E5%86%85%E5%AD%98%E9%9D%99%E6%80%81%E6%98%A0%E5%B0%84"><span class="nav-number">5.</span> <span class="nav-text">I&#x2F;O内存静态映射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DMA%E5%86%85%E5%AD%98"><span class="nav-number">6.</span> <span class="nav-text">DMA内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DMA%E4%B8%8E%E7%A1%AC%E4%BB%B6Cache%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">6.1.</span> <span class="nav-text">DMA与硬件Cache一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E4%B8%8B%E7%9A%84DMA%E7%BC%96%E7%A8%8B-DMA%E5%8F%AA%E6%98%AF%E4%B8%80%E7%A7%8D%E5%A4%96%E8%AE%BE%E4%B8%8E%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">Linux 下的DMA编程(DMA只是一种外设与内存的交互方式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E5%8C%BA%E5%9F%9F"><span class="nav-number">6.2.1.</span> <span class="nav-text">DMA区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E6%80%BB%E7%BA%BF%E5%9C%B0%E5%9D%80"><span class="nav-number">6.2.2.</span> <span class="nav-text">虚拟地址,物理地址,总线地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA%E5%9C%B0%E5%9D%80%E6%8E%A9%E7%A0%81"><span class="nav-number">6.2.3.</span> <span class="nav-text">DMA地址掩码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7DMA%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">6.2.4.</span> <span class="nav-text">一致性DMA缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%BC%8FDMA%E6%98%A0%E5%B0%84"><span class="nav-number">6.2.5.</span> <span class="nav-text">流式DMA映射</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kcmetercec"
      src="https://avatars.githubusercontent.com/u/16881795?s=400&u=f62971f44f59d17d823044e709d4668debec7c02&v=4">
  <p class="site-author-name" itemprop="name">kcmetercec</p>
  <div class="site-description" itemprop="description">Qt, C++, linux, CS</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">107</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">55</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/KcMeterCEC" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KcMeterCEC" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:kcmeter.cec@gmail.com" title="E-Mail → mailto:kcmeter.cec@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kcmetercec</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">206k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f938893867df78f94802',
      clientSecret: 'b6d8470939c53d26c98c4e3b9d4c9ceb55d6e78e',
      repo        : 'kcmetercec.github.io',
      owner       : 'KcMeterCEC',
      admin       : ['KcMeterCEC'],
      id          : 'bbc7f15b27a3ec706fb0ca28c66533b2',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
