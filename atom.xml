<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>explorer</title>
  
  <subtitle>万丈高楼平地起，勿在浮沙筑高台</subtitle>
  <link href="http://kcmetercec.top/atom.xml" rel="self"/>
  
  <link href="http://kcmetercec.top/"/>
  <updated>2025-02-26T16:00:00.000Z</updated>
  <id>http://kcmetercec.top/</id>
  
  <author>
    <name>kcmetercec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux framebuffer logo的显示</title>
    <link href="http://kcmetercec.top/2025/02/27/logo/"/>
    <id>http://kcmetercec.top/2025/02/27/logo/</id>
    <published>2025-02-26T16:00:00.000Z</published>
    <updated>2025-02-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理logo显示的理论。</p><span id="more"></span><h1 id="logo的格式"><a href="#logo的格式" class="headerlink" title="logo的格式"></a>logo的格式</h1><h2 id="pnm-portable-any-map"><a href="#pnm-portable-any-map" class="headerlink" title="pnm(portable any map)"></a>pnm(portable any map)</h2><p>查看网上的说明，一般我们需要将事先准备好的 logo 图片转换为 pnm 格式，比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bmptopnm logo.bmp &gt; logo.pnm</span><br></pre></td></tr></table></figure><p>工具 <code>bmptopnm</code> 会根据bmp的分辨率转换为对应格式:</p><ul><li>当只有黑白色时，输出PBM格式</li><li>当有黑白灰时，输出PGM格式</li><li>其他情况会输出PPM格式</li></ul><p><strong>注意:</strong> 部分bmp图片含有带透明的 delta 部分，此时 <code>bmptopnm</code> 将会报错。</p><p>三种格式其实都大同小异，以可以显示彩色的ppm(Portable Pixel Map)为格式说明：</p><ol><li>开头是ASCII码 <code>P6</code> 以表示文件格式为 ppm，后面一般跟一个换行符</li><li>接着下一行是ASCII码表示的宽度和高度，中间以空白分隔，行尾加换行符</li><li>接着下一行是 <strong>原色的最大值</strong> ，以ASCII表示，最大为65536, 行尾加换行符</li><li>接着便是图像内容，以 <strong>二进制表示</strong> ， 从左到右，从上到下。<ul><li>每一个像素以rgb表示，其中的三原色分别占1或2字节</li></ul></li></ol><p>如下图所示:</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--frameBuffer/pic/pnm_vim.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--frameBuffer/pic/pnm_hex.jpg?raw=true"></p><h2 id="颜色压缩和ASCII输出"><a href="#颜色压缩和ASCII输出" class="headerlink" title="颜色压缩和ASCII输出"></a>颜色压缩和ASCII输出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnmquant 224 logo.pnm &gt; logo224.pnm</span><br></pre></td></tr></table></figure><p>此工具检查原始的pnm文件中颜色的种数，然后将其进行量化为仅有224种颜色的格式。</p><ul><li>为什么会是224种颜色? 猜测这个是linux内部存储配色表的大小限制</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pnmtoplainpnm logo224.pnm &gt; logo_linux_clut224.ppm</span><br></pre></td></tr></table></figure><p>此工具将 224 种色的 pnm 图片转换为简易的 <code>plainppm</code> 。</p><p>plainppm格式比原先的ppm格式更易于阅读，不同之处在于:</p><ul><li>一个文件仅表示一张图片</li><li>图片标识由 <code>P6</code> 变为 <code>P3</code> </li><li>以ASCII的形式显示图片的内容（原来是二进制形式）</li><li>每个像素之间以空格分隔，一行不超过70个ASCII字符</li></ul><p>如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P3</span><br><span class="line"><span class="meta">#</span><span class="bash"> feep.ppm</span></span><br><span class="line">4 4</span><br><span class="line">15</span><br><span class="line"> 0  0  0    0  0  0    0  0  0   15  0 15</span><br><span class="line"> 0  0  0    0 15  7    0  0  0    0  0  0</span><br><span class="line"> 0  0  0    0  0  0    0 15  7    0  0  0</span><br><span class="line">15  0 15    0  0  0    0  0  0    0  0  0</span><br></pre></td></tr></table></figure><h1 id="logo的生成"><a href="#logo的生成" class="headerlink" title="logo的生成"></a>logo的生成</h1><p>前面生成的 ppm 文件将会放在 <code>drivers/video/logo/</code> 文件夹下，此Makefile会在构建过程中调用工具 <code>pnmtologo</code> 进行转换。</p><p>工具源码位于 <code>scripts/pnmtologo.c</code> ，它会将生成对应名称的 c 文件，通过查看 build 目录下的文件可以看到输出文件格式。</p><ul><li>以伪彩色的形式保存图片，包含颜色索引、配色表、图片描述结构体。</li><li>索引中的值减去32就为颜色表中其对应的颜色。<ul><li><strong>对于224色来说，颜色表每3字节代表一个像素。</strong></li></ul></li></ul><p>此源码中有宏:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINUX_LOGO_COLORS 224</span></span><br></pre></td></tr></table></figure><p>这也佐证了为什么 linux 会限制使用 224 色作为 logo。</p><ul><li>如果要增加色彩的分辨率，增加此值即可。</li></ul><h1 id="logo的显示"><a href="#logo的显示" class="headerlink" title="logo的显示"></a>logo的显示</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在进行logo显示前，需要 frambuffer 驱动加载且液晶已完成初始化。</p><p>选中以下选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt; Graphics support -&gt; Bootup logo -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure><h2 id="刷图"><a href="#刷图" class="headerlink" title="刷图"></a>刷图</h2><p>进行刷新logo的核心函数就是 <code>fb_prepare_logo, fb_show_logo_line</code> .</p><p>按照上面编译后的格式，只需要通过索引减去32取颜色显示即可，但linux要兼容众多设备，需要考虑更多情况。<br>如果是为了简便，完全可以在使用 <code>fb_find_logo</code> 之后，便自己实现缓存的填充即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理logo显示的理论。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="driver" scheme="http://kcmetercec.top/categories/linux/driver/"/>
    
    <category term="framebuffer" scheme="http://kcmetercec.top/categories/linux/driver/framebuffer/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ ：属性</title>
    <link href="http://kcmetercec.top/2025/02/15/effective_cpp_attribute/"/>
    <id>http://kcmetercec.top/2025/02/15/effective_cpp_attribute/</id>
    <published>2025-02-14T16:00:00.000Z</published>
    <updated>2025-02-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>从 c++11 开始，就具备了一些属性，其语法是 <code>[[attribute]]</code> 。</p><span id="more"></span><h1 id="fallthrough"><a href="#fallthrough" class="headerlink" title="[[fallthrough]]"></a>[[fallthrough]]</h1><p>如果在 <code>switch</code> 语句中的 <code>case</code> 后没有跟 <code>break</code>，则编译器会给出警告。</p><p>使用 <code>[[fallthrough]]</code> 可以阻止编译器发出这种警告：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 0\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 1\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 2\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[[nodiscard]]"></a>[[nodiscard]]</h1><p>如果一个函数有返回值，而调用者没有使用该返回值，使用 <code>[[nodiscard]]</code>可以让编译器发出警告。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码编译将会给出警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test.cc: In function ‘int main(int, char**)’:</span><br><span class="line">test.cc:15:9: warning: ignoring return value of ‘int func()’, declared with attribute nodiscard [-Wunused-result]</span><br><span class="line">   15 |     func();</span><br><span class="line">      |     ~~~~^~</span><br><span class="line">test.cc:8:19: note: declared here</span><br><span class="line">    8 | [[nodiscard]] int func(void) &#123;</span><br><span class="line">      |  </span><br></pre></td></tr></table></figure><p>此属性可以用于有返回错误状态的函数，以告知用户不要忽略函数的返回。</p><p>c++ 20 及以后，可以在 <code>[[nodiscard]]</code>中加入提示的字符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">nodiscard</span>(<span class="string">&quot;Hello&quot;</span>)]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译将会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main.cpp: In function &#x27;int main(int, char**)&#x27;:</span><br><span class="line">main.cpp:15:10: warning: ignoring return value of &#x27;int func()&#x27;, declared with attribute &#x27;nodiscard&#x27;: &#x27;Hello&#x27; [-Wunused-result]</span><br><span class="line">   15 |      func();</span><br><span class="line">      |      ~~~~^~</span><br><span class="line">main.cpp:8:29: note: declared here</span><br><span class="line">    8 |  [[nodiscard(&quot;Hello&quot;)]] int func(void) &#123;</span><br></pre></td></tr></table></figure><p>这个属性主要是对一些重要的函数、类使用，便于提示调用者不要忽视返回值。</p><blockquote><p>如果对类使用，则调用类中的任何方法都会应用该属性。</p></blockquote><h1 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="[[maybe_unused]]"></a>[[maybe_unused]]</h1><p>当某些变量、参数、函数未被使用时，编译器会给出警告。此属性可以抑制该警告：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var2 加了此属性后便不会给出警告，var1 则会给出警告</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var1, [[maybe_unused]]<span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="noreturn"><a href="#noreturn" class="headerlink" title="[[noreturn]]"></a>[[noreturn]]</h1><p>此属性抑制无返回函数的警告，比如下面的代码进入 func2() 会无返回退出进程。加上该属性，编译器便不会给出警告。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (var1 &gt; <span class="number">10</span>) &#123;</span><br><span class="line">       <span class="built_in">func2</span>();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> result = <span class="built_in">func</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="deprecated"><a href="#deprecated" class="headerlink" title="[[deprecated]]"></a>[[deprecated]]</h1><p>使用此属性用于提醒用户，该 API 已被弃用，可以通过提示信息告知用户使用对应的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;Unsafe method, please use func2&quot;</span>)]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="likely-和-unlikely"><a href="#likely-和-unlikely" class="headerlink" title="[[likely]] 和 [[unlikely]]"></a>[[likely]] 和 [[unlikely]]</h1><p>这两个属性用于更好的帮助编译器做优化，一般是用在具有判断的代码处：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    [[likely]] <span class="keyword">if</span> (v &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v &gt; 8\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v &lt;= 8\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="assume"><a href="#assume" class="headerlink" title="[[assume]]"></a>[[assume]]</h1><p><code>[[assume]]</code>是 c++ 23 增加的属性，告知编译器假定当前表达式条件在编译时判断，而不是在运行时再来判断，以优化代码性能。</p><p>比如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideBy32</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下编译器会产生可以处理正负两种情况的除法，如果确认<code>x</code>的值不会为负数，那么就可以加上<code>[[assume]]</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideBy32</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [[<span class="built_in">assume</span>(x&gt;=<span class="number">0</span>)]];</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子编译器就可以针对非负数除法做优化，比如上面的代码可以优化为<code>x&gt;&gt;5</code>，以单条指令就可以完成达到优化性能的目的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;从 c++11 开始，就具备了一些属性，其语法是 &lt;code&gt;[[attribute]]&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="http://kcmetercec.top/categories/cpp/"/>
    
    <category term="professional" scheme="http://kcmetercec.top/categories/cpp/professional/"/>
    
    
    <category term="cpp" scheme="http://kcmetercec.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>ZynqMP 的启动和配置</title>
    <link href="http://kcmetercec.top/2024/12/31/zynqmp_boot/"/>
    <id>http://kcmetercec.top/2024/12/31/zynqmp_boot/</id>
    <published>2024-12-30T16:00:00.000Z</published>
    <updated>2024-12-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录 ZynqMP 的启动和配置过程。</p><span id="more"></span><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>zynqmp 的启动及配置过程由 PMU（Platform management unit）和 CSU（configuration security unit）来管理，其大体上包含以下 3 个过程：</p><ol><li><p>Pre-confituration stage：系统上电启动时会复位 CSU 和 PMU，PMU 会执行 PMU ROM Code 来设置系统。主要是用于基本的初始化和唤醒处理器。</p></li><li><p>Configuration stage：CSU ROM 会分析<code>boot.bin</code>的文件头，配置系统。然后将 FSBL 加载到内部的 on-chip RAM 执行安全或非安全启动。CSU 还会加载 PMU 用户固件（PMU FW）到 PMU RAM，用于对系统硬件进行管理配置。</p></li><li><p>Post-configuration stage：当 FSBL 开始执行后，CSU ROM 就会进入 post-configuration 阶段。这个阶段是 CSU 硬件提供对文件的校验、配置 PL 、解密等功能。</p></li></ol><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>PMU 启动时会执行一些必须和可选的流程：</p><ul><li><p>清零低功耗域（LPD）寄存器（可选）：当 LPD_SC eFUSEs 被编程，则会执行该步骤</p></li><li><p>清零全功耗域（FPD）寄存器（可选）：当 FPD_SC eFUSEs 被编程，则会执行该步骤</p></li><li><p>清零 PMU RAM：先将 RAM 写 0 然后回读验证，以确保写入成功</p></li><li><p>清零 PMU 处理器的 TLB 内存</p></li><li><p>电压检测：PMU 会检查 LPD、AUX、专用 I/O 的电压，以确保可以正常工作</p></li><li><p>清零内存：PMU 会清零 CSU、LPD、FPD 的内存</p></li></ul><p>PMU 的职责之一就是在硬件上电复位后，对系统各部分进行正确的上电，然后进入后台模式（管理其他部分的上电、睡眠、唤醒等），其上电复位后 PMU ROM code 执行流程为：</p><ol><li><p>初始化 PS SYSMON 单元以及 PLL</p></li><li><p>清空 PMU RAM 和 CSU RAM</p></li><li><p>检查 PLL 是否锁定</p></li><li><p>通过 PS SYSMON 单元检查 LPD，AUX 以及 I/O 电压是否在正常范围内</p></li><li><p>清空低功耗域以及全功耗域</p></li><li><p>当以上步骤无误后，进入到 CSU 阶段，并且自己进入服务模式（如果 PMUFW 没有被使用，则 PMU 模块进入睡眠模式）</p></li></ol><p>CSU 启动后，其执行流程为：</p><ol><li><p>初始化片内 RAM</p></li><li><p>PMU 在复位阶段获取到了启动引脚的配置，CSU 根据该配置来确定应该从哪里读取启动代码</p></li><li><p>CSU 将 FSBL 加载到片内 RAM 执行。</p></li><li><p>CSU 将 PMU FW 加载到 PMU RAM 进行执行</p></li></ol><p>PMU FW 主要用于对硬件进行管理，它与 FSBL 进行结合使用。</p><p>CSU 主要用于加密和非加密的系统配置、密钥管理、PS/PL 编程接口等，它主要由以下两个部分组成：</p><ol><li><p>三重冗余的安全处理器</p></li><li><p>加密接口，包括 AES、RSA、SHA3 等</p></li></ol><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/bootmode.jpg?raw=true"><br>zynqmp 支持 multi-boot 搜寻，其搜寻范围如下：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_search_limit.jpg?raw=true"><br>那么很明显，在 QSPI 中，应该使用 32bit 模式以支持更大的范围。</p><h2 id="启动代码的搜寻"><a href="#启动代码的搜寻" class="headerlink" title="启动代码的搜寻"></a>启动代码的搜寻</h2><p>CSU 运行 BootROM 来搜寻合法的 boot header 并运行启动代码，是根据搜寻头中是否有字符串<code>XLNX</code>来判断头的合法性。一旦找到该字符串，就会对头进行校验和。如果校验和成功则会从启动代码中载入 FSBL 到 OCM 执行。</p><p>启动代码存放的位置需要以 32KB 对齐，因为 BootROM 会以 32KB 的步进来搜寻合法的启动头。</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_search.jpg?raw=true"><br>在 FSBL 中，可以将备份的启动代码位置除以 32KB 写入<code>CSU.csu_multi_boot</code>寄存器，在热复位以后就可以从该寄存器获取地址然后乘以 32KB得到启动代码的位置。</p><p>如果该备份启动代码头不合法，则会通过常规的方式来查找合法的启动代码头。</p><h1 id="启动镜像的结构"><a href="#启动镜像的结构" class="headerlink" title="启动镜像的结构"></a>启动镜像的结构</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/normal_boot_image_format.jpg?raw=true"><br>上图是普通启动镜像的结构，无论镜像是否加密，它们的<code>boot header</code>和<code>partition header</code>都是一样的。</p><h2 id="Boot-Header-Format"><a href="#Boot-Header-Format" class="headerlink" title="Boot Header Format"></a>Boot Header Format</h2><table><thead><tr><th>偏移</th><th>说明</th></tr></thead><tbody><tr><td>0x00~0x1C</td><td>为支持 XIP 方式的 Flash 而保留的中断向量表</td></tr><tr><td>0x20</td><td>指定 QSPI 的位宽</td></tr><tr><td>0x24</td><td>启动镜像的头<code>XNLX</code></td></tr><tr><td>0x28</td><td>加密状态</td></tr><tr><td>0x2C</td><td>FSBL 的执行地址</td></tr><tr><td>0x30</td><td>PMU FW 和 FSBL 的存放起始地址</td></tr><tr><td>0x34</td><td>PMU FW 的原始镜像大小</td></tr><tr><td>0x38</td><td>总共 PMU FW 镜像的大小</td></tr><tr><td>0x3c</td><td>FSBL 原始镜像大小</td></tr><tr><td>0x40</td><td>总共 FSBL 镜像大小</td></tr><tr><td>0x44</td><td>镜像的属性</td></tr><tr><td>0x48</td><td>头的检验和从 0x20~0x44</td></tr><tr><td>0x4c-0x68</td><td>混淆密钥，只在加密状态为A35C_7CA5h 才有效</td></tr><tr><td>0x6c</td><td>保留</td></tr><tr><td>0x70~0x9c</td><td>FSBL/User 定义</td></tr><tr><td>0xa0~0xa8</td><td>加密镜像的初始向量</td></tr><tr><td>0xac~0xb4</td><td></td></tr><tr><td>0xb8~0x8b4</td><td>系统寄存器的初始化值</td></tr><tr><td>0x8b8~0xec0</td><td>PUF 帮助数据</td></tr></tbody></table><h2 id="QSPI-的位宽判定"><a href="#QSPI-的位宽判定" class="headerlink" title="QSPI 的位宽判定"></a>QSPI 的位宽判定</h2><p>如果启动设备是 QSPI 的话，BootROM 会先以 X1 的方式读取启动镜像的头，如果地址<code>0x20</code>处的位宽值为<code>0xAA995566</code>，则表示 flash 位宽为 4 位位宽。然后 BootROM 会切换为 X4 模式读取镜像文件内容（如果 X4 失败了，则会依次尝试 X2、X1 模式）。</p><h2 id="镜像文件的属性"><a href="#镜像文件的属性" class="headerlink" title="镜像文件的属性"></a>镜像文件的属性</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_image_format.jpg?raw=true"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里记录 ZynqMP 的启动和配置过程。&lt;/p&gt;</summary>
    
    
    
    <category term="processor" scheme="http://kcmetercec.top/categories/processor/"/>
    
    <category term="zynq" scheme="http://kcmetercec.top/categories/processor/zynq/"/>
    
    
    <category term="zynq" scheme="http://kcmetercec.top/tags/zynq/"/>
    
  </entry>
  
  <entry>
    <title>Swupdate 的简易使用</title>
    <link href="http://kcmetercec.top/2024/12/19/linux_make_swupdate/"/>
    <id>http://kcmetercec.top/2024/12/19/linux_make_swupdate/</id>
    <published>2024-12-18T16:00:00.000Z</published>
    <updated>2024-12-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录 Swupdate 的简易使用说明。</p><span id="more"></span><h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>SWUpdate 是位于用户空间的应用程序，用于升级嵌入式系统（不包含 bootloader）。</p><p>它以事务的方式标识整个升级过程，事务的标识会写入到 bootloader 中，bootloader 会根据事务标记的值来确认当前升级是否成功。</p><p>比如 SWUpdate 通过设置环境变量<code>recovery_status</code>，来表示升级过程：</p><ol><li><p>开始升级时，其值为<code>progress</code></p></li><li><p>升级成功后，其值会被擦除</p></li><li><p>升级失败，其值为<code>failed</code></p></li></ol><p>bootloader 通过查看其值为<code>progress</code>或<code>failed</code>则代表其升级未完成：</p><ul><li><p>如果当前为<code>single-copy</code>模式，则会再次启动升级流程</p></li><li><p>如果当前为<code>double-copy</code>模式，则会启动上一个版本的程序</p></li></ul><h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_file_struct.jpg?raw=true"><br>上图为其打包后的文件版本，主要是<code>sw-description</code>来实现多个镜像文件的描述。</p><p>可以看到它是将多个文件打包为一个<code>cpio</code>文件，那么这里再来复习一下<code>cpio</code>工具的操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 打包</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建打包：通过 find 遍历当前文件及文件夹输出给 cpio</span></span><br><span class="line">find . -depth -print | cpio -o &gt; /path/archive.cpio</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 解包</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以解包所有文件</span></span><br><span class="line">cpio -i -vd &lt; archive.cpio</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以只提取指定文件</span></span><br><span class="line">cpio -i -d /etc/fstab &lt; archive.cpio</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅查看内容不解包</span></span><br><span class="line">cpio -t &lt; archive.cpio</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong> cpio 打包后的文件大小不能超过 4GB.</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在 <code>buildroot</code>中只需要搜<code>swupdate</code>就可以找到该包并使能，如果想要更细致的配置，可以通过以下命令配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make swupdate-menuconfig</span><br></pre></td></tr></table></figure><p>在输出路径<code>output/build/swupdate/tools</code>中有文件<code>swupdate-progress.c</code>可以作为很好的参考，用于与<code>swupdate</code>交互获取当前的状态。</p><p>为了与 U-Boot 交互，则需要进行以下配置：</p><ul><li><p>在<code>Bootloader Interfaces</code>中使能 U-Boot，并设定文件<code>/etc/fw_env.config</code>以及<code>/etc/u-boot-initial-en</code></p></li><li><p>设定<code>U-Boot</code>中变量为<code>ustate</code></p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>swupdate</code>的一般流程如下：</p><ol><li><p>提取<code>sw-description</code>并校验，如果还使能了签名验证，还会提取<code>sw-description.sig</code> 文件进行签名验证。</p></li><li><p>根据<code>sw-description</code>中提供的信息，读取当前设备的硬件版本，来验证是否有兼容该硬件版本的软件包。</p></li><li><p>根据<code>sw-description</code>中的信息识别哪些软件包需要被安装，如果具有<code>embedded-script</code>则会在解析这些软件包前执行这些脚本，如果具有<code>hooks</code>则会在解析软件包时执行（即使这些软件包会被跳过）。最终生成一张执行列表和对应的哪些<code>handler</code>需要被调用。</p></li><li><p>如果有<code>pre update command</code>，则先执行这些命令</p></li><li><p>如果有分区的必要，则执行<code>partition handlers</code></p></li><li><p>依次从<code>cpio</code>文件中提取需要安装的软件包，在读取软件包时还会进行内容校验，如果检验失败则报错。</p></li><li><p>在安装软件包之前，如果具有<code>pre-install</code>脚本，则会先执行这些脚本</p></li><li><p>执行对应软件包的<code>handler</code>来安装软件包</p></li><li><p>安装完成后，如果具有<code>post-install</code>脚本，则会执行这些脚本</p></li><li><p>更新 bootloader 的环境变量</p></li><li><p>向外部接口输出升级状态</p></li><li><p>如果具有<code>post update command</code>则执行这些命令</p></li></ol><p>使用<code>swupdate</code>执行升级命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swupdate -i &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>也可以启动一个网络服务，通过网页来升级：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动后就可以通过 http://&lt;target_ip&gt;:8080 来访问</span></span><br><span class="line">swupdate -w &quot;--document-root ./www --port 8080&quot;</span><br></pre></td></tr></table></figure><h2 id="改变-U-BOOT"><a href="#改变-U-BOOT" class="headerlink" title="改变 U-BOOT"></a>改变 U-BOOT</h2><p><code>U-BOOT</code>可以保存两份环境变量，便于保证在更新环境变量时的安全性，要使能这个特性，需要配置<code>CONFIG_ENV_OFFSET_REDUND</code>或<code>CONFIG_ENV_ADDR_REDUND</code>。</p><p>除此之外，还可以在<code>U-BOOT</code>中增加一个启动计数器，如果计数器没有正确的被应用程序清零则意味着这个版本升级的应用没有正常运行，然后可以切换到之前备份的应用。</p><h2 id="构建升级包"><a href="#构建升级包" class="headerlink" title="构建升级包"></a>构建升级包</h2><p>升级包需要<code>sw-updescription</code>是第一个文件，其余的镜像可以依次往后放即可。使用类似下面的脚本就可以打包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER_VER=&quot;1.0&quot;</span><br><span class="line">PRODUCT_NAME=&quot;my-software&quot;</span><br><span class="line">FILES=&quot;sw-description image1.ubifs  \</span><br><span class="line">       image2.gz.u-boot uImage.bin myfile sdcard.img&quot;</span><br><span class="line">for i in $FILES;do</span><br><span class="line">        echo $i;done | cpio -ov -H crc &gt;  $&#123;PRODUCT_NAME&#125;_$&#123;CONTAINER_VER&#125;.swu</span><br></pre></td></tr></table></figure><p>也可以通过<a href="https://github.com/sbabic/swugenerator/">GitHub - sbabic/swugenerator: A host tool to generate SWU update package for SWUpdate</a>来打包生成升级包。</p><p>升级包的查看可以通过下面的命令完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swupdate -c -i my-software_1.0.swu</span><br></pre></td></tr></table></figure><h1 id="升级策略"><a href="#升级策略" class="headerlink" title="升级策略"></a>升级策略</h1><h2 id="single-copy"><a href="#single-copy" class="headerlink" title="single copy"></a>single copy</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_single_copy.jpg?raw=true"><br>正常情况下，bootloader 直接启动用户的内核，进入文件系统运行应用程序。</p><p>当需要升级时：</p><ol><li><p>通知 bootloader 需要启动<code>swupdate</code>，然后重启系统</p><ul><li>通知的方式多种多样，比如通过环境变量、GPIO等</li></ul></li><li><p>bootloader 启动带 swupdate 的内核和 RAMFS</p></li><li><p>在 RAMFS 中启动<code>swupdate</code>分析升级包并升级</p></li></ol><p>如果升级过程失败，应用程序无法正确清空 bootloader 的启动计数器，则 bootloader 会主动进入升级系统。</p><h2 id="double-copy"><a href="#double-copy" class="headerlink" title="double copy"></a>double copy</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_double_copy.jpg?raw=true"><br>bootloader 交替的启动切换最新的软件，<code>swupdate</code>则升级那个未被启动的软件分区。</p><p>当当前应用程序没有正确清空 bootloader 的启动计数器时，bootloader 会主动切换回上一个版本的应用程序。</p><p>bootloader 根据变量<code>ustate</code>的值为1，来确认目前有新的软件被安装，那么就需要通过计数器来测试该软件是否安装正确。当测试失败，bootloader 也可以修改<code>ustate</code>的值为 3，来通知应用程序升级是否成功。</p><ul><li><p>当<code>ustate=0</code>，则表示当前无新升级，bootloader 正常引导</p></li><li><p>当<code>ustate=1</code>，表示有新软件被安装，需要测试</p><ul><li><p>测试失败，由 bootloader 将值设置为 3</p></li><li><p>测试成功，由应用程序将值设置为 0</p></li></ul></li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_statemachine.jpg?raw=true"><br>在 bootloader 中，需要准备的变量有：</p><ol><li><h2 id="double-copy-with-rescue-system"><a href="#double-copy-with-rescue-system" class="headerlink" title="double-copy with rescue system"></a>double-copy with rescue system</h2></li></ol><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_double_copy_rescue.jpg?raw=true"><br>在<code>double-copy</code>的基础上，还可以增加一个救援系统，这样当两个版本都无法正确运行（或那个硬盘损坏）的情况下，仍然可以启动救援系统来重新格式化、更新系统。</p><blockquote><p>这个救援系统也是可以被更新的</p></blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一个典型的<code>sw-description</code>文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        description = &quot;Firmware update for XXXXX Project&quot;;</span><br><span class="line"></span><br><span class="line">        hardware-compatibility: [ &quot;1.0&quot;, &quot;1.2&quot;, &quot;1.3&quot;];</span><br><span class="line"></span><br><span class="line">        /* partitions tag is used to resize UBI partitions */</span><br><span class="line">        partitions: ( /* UBI Volumes */</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;rootfs&quot;;</span><br><span class="line">                        device = &quot;mtd4&quot;;</span><br><span class="line">                        size = 104896512; /* in bytes */</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;data&quot;;</span><br><span class="line">                        device = &quot;mtd5&quot;;</span><br><span class="line">                        size = 50448384; /* in bytes */</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        images: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;rootfs.ubifs&quot;;</span><br><span class="line">                        volume = &quot;rootfs&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;swupdate.ext3.gz.u-boot&quot;;</span><br><span class="line">                        volume = &quot;fs_recovery&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;sdcard.ext3.gz&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">                        compressed = &quot;zlib&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;bootlogo.bmp&quot;;</span><br><span class="line">                        volume = &quot;splash&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;uImage.bin&quot;;</span><br><span class="line">                        volume = &quot;kernel&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;fpga.txt&quot;;</span><br><span class="line">                        type = &quot;fpga&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;bootloader-env&quot;;</span><br><span class="line">                        type = &quot;bootloader&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        files: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;README&quot;;</span><br><span class="line">                        path = &quot;/README&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">                        filesystem = &quot;vfat&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        scripts: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;erase_at_end&quot;;</span><br><span class="line">                        type = &quot;lua&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;display_info&quot;;</span><br><span class="line">                        type = &quot;lua&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        bootenv: (</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;vram&quot;;</span><br><span class="line">                        value = &quot;4M&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;addfb&quot;;</span><br><span class="line">                        value = &quot;setenv bootargs $&#123;bootargs&#125; omapfb.vram=1:2M,2:2M,3:2M omapdss.def_disp=lcd&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>software</code>tag为顶层描述，下面的就是为各个镜像的单独说明。</p><p>上面中的<code>hardware-compatib</code>是为了软件与硬件的兼容，而硬件的信息则存储于<code>/etc/hwrevision</code>中，其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> boardname：设备名称，为了便于一个升级包还可以升级多种不同设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> revision：设备的硬件版本</span></span><br><span class="line">&lt;boardname&gt; &lt;revision&gt;</span><br></pre></td></tr></table></figure><p>对于 double copy 的升级策略，一个升级包可能会对应两个分区，那么配置文件应该这样描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        stable = &#123;</span><br><span class="line">                copy-1: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                        &#123;</span><br><span class="line">                                device = &quot;/dev/mtd4&quot;</span><br><span class="line">                                ...</span><br><span class="line">                        &#125;</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                copy-2: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                        &#123;</span><br><span class="line">                                device = &quot;/dev/mtd5&quot;</span><br><span class="line">                                ...</span><br><span class="line">                        &#125;</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际升级时，到底应该是选择哪个分区，则是由应用程序来区分（比如查看当前程序是挂载在哪个分区），然后给<code>swupdate</code>发送消息。</p><blockquote><p>这个消息是要在 <code>swupdate</code>启动前就确认要升级哪个分区，然后通过<code>-e &lt;selection,mode&gt;</code>来告知<code>swupdate</code>。</p><p>也可以在启动前创建一个连接文件<code>/dev/standby</code>指向需要被升级的分区。</p><p>如果要在运行时来区分，就要在<code>sw-description</code>中编写嵌入式脚本来区分，Lua 脚本使用<code>getroot()</code>函数获取当前文件系统挂载的分区。</p></blockquote><h2 id="硬件兼容性"><a href="#硬件兼容性" class="headerlink" title="硬件兼容性"></a>硬件兼容性</h2><p>一个软件包可以兼容多个版本的硬件，则可以像前面一样，在文件内容开始一次性给出。但也有可能在不同的硬件版本下的文件会略有不同，那么还可以再进一步说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        myboard = &#123;</span><br><span class="line">            stable = &#123;</span><br><span class="line"></span><br><span class="line">                hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.3&quot;, &quot;3.0&quot;, &quot;3.1&quot;];</span><br><span class="line">                rev-1.0: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-1.2: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;1.2&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-2.0: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;2.0&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                           ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-1.3: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;1.3&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                            ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                            ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rev-3.0:</span><br><span class="line">                &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;3.0&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-3.1:</span><br><span class="line">                &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;3.1&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其中有部分版本完全一致，那么还可以使用引用的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line"> &#123;</span><br><span class="line">         version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">         myboard = &#123;</span><br><span class="line">             stable = &#123;</span><br><span class="line"></span><br><span class="line">                 hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.3&quot;, &quot;3.0&quot;, &quot;3.1&quot;];</span><br><span class="line">                 rev-1x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                            ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                             ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.2 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.3 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev-2x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev2.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-2x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 rev-3x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                               ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev3.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-3x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev3.1 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-3x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ref</code>是表示引用的关键字，后面的<code>#</code>是必须的。可以用<code>./</code>表示当前层级，用<code>../</code>表示上一个层级。</p><p><code>swupdate</code>获取版本号是在<code>/etc/hwrevision</code>文件中，但是这个文件的内容则可以在应用程序启动时通过各种方式进行更新，比如读取当前硬件上的 EEPROM 获取版本号等。</p><h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><p><code>images</code>标识表示要更新到系统中的镜像文件，其语法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename[mandatory] = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                volume[optional] = &lt;destination volume&gt;;</span><br><span class="line">                device[optional] = &lt;destination volume&gt;;</span><br><span class="line">                mtdname[optional] = &lt;destination mtd name&gt;;</span><br><span class="line">                type[optional] = &lt;handler&gt;;</span><br><span class="line">                /* optionally, the image can be copied at a specific offset */</span><br><span class="line">                offset[optional] = &lt;offset&gt;;</span><br><span class="line">                /* optionally, the image can be compressed if it is in raw mode */</span><br><span class="line">                compressed;</span><br><span class="line">        &#125;,</span><br><span class="line">        /* Next Image */</span><br><span class="line">        .....</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于 emmc 而言，其内容大体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        filename = &quot;core-image-base.ext3&quot;;</span><br><span class="line">        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 flash 而言，其内容大体如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        filename = &quot;u-boot.bin&quot;;</span><br><span class="line">        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">        offset = &quot;16K&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p><code>files</code>标识用于拷贝文件到系统，其语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">files: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                path = &lt;path in filesystem&gt;;</span><br><span class="line">                device[optional] = &lt;device node &gt;;</span><br><span class="line">                filesystem[optional] = &lt;filesystem for mount&gt;;</span><br><span class="line">                properties[optional] = &#123;create-destination = &quot;true&quot;;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>主要就是将文件拷贝到对应路径。</p><h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p><code>scripts</code>标记用于执行一系列的脚本，默认情况下如果没有标注脚本的类型，<code>swupdate</code>会认为是<code>lua</code>脚本。</p><h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lua 脚本必须至少包含 3 个函数：</p><ul><li><p><code>function preinst()</code>：安装镜像前会被执行</p></li><li><p><code>function postinst()</code>：安装镜像后会被执行</p></li><li><p><code>function postfailure()</code>：升级失败后会被执行</p></li></ul><h3 id="shellscript"><a href="#shellscript" class="headerlink" title="shellscript"></a>shellscript</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;shellscript&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>swupdate</code>会在镜像安装前后执行脚本，在执行时会传入参数”preinst”、”postinst”或”postfailure”，脚本可以依据这些参数进行不同的操作。</p><p>除此之外，也可以单独编写<code>preinstall</code>和<code>postinstall</code>脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;preinstall&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;postinstall&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="升级过程中的标记状态"><a href="#升级过程中的标记状态" class="headerlink" title="升级过程中的标记状态"></a>升级过程中的标记状态</h2><p>默认情况下<code>swupdate</code>通过设置 bootloader 的环境变量<code>recovery_status</code>来表示升级的过程，其值有以下几种情况：</p><ul><li><p><code>in_progress</code>：正在升级过程中</p></li><li><p>值被清空：升级成功</p></li><li><p><code>failed</code>：升级失败</p></li></ul><p>如果想关闭这些状态记录，可以在配置文件中设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        bootloader_transaction_marker = false;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>除了这种字符串标记外，还有将 bootloader 的环境变量<code>ustate</code>来设数值方式：</p><ul><li><p><code>1</code>：安装成功</p></li><li><p><code>3</code>：安装失败</p></li></ul><p>关闭<code>ustate</code>也是在配置文件中设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        bootloader_state_markerer = false;</span><br></pre></td></tr></table></figure><h2 id="更新-bootloader-的环境变量"><a href="#更新-bootloader-的环境变量" class="headerlink" title="更新 bootloader 的环境变量"></a>更新 bootloader 的环境变量</h2><p>有两种方式可以更新 bootloader 的环境变量，一种方式是将变量写在文件中，然后将此文件在配置文件中标注一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">images: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &quot;bootloader-env&quot;;</span><br><span class="line">                type = &quot;bootloader&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>文件中变量赋值的格式为：<code>&lt;name of variable&gt;=&lt;value&gt;</code>，如果值不设置，则该变量会被清除掉。</p><p>就像下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Default variables</span></span><br><span class="line">bootslot=0</span><br><span class="line">board_name=myboard</span><br><span class="line">baudrate=115200</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Board Revision dependent</span></span></span><br><span class="line">board_revision=1.0</span><br></pre></td></tr></table></figure><p>另一种方式是直接在配置文件中就写变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootenv: (</span><br><span class="line">        &#123;</span><br><span class="line">                name = &lt;Variable name&gt;;</span><br><span class="line">                value = &lt;Variable value&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p><code>swupdate</code>可以进行版本号比较，默认格式为：<code>&lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;</code></p><p>每个小段都是由数值组成的，其值为 0~65535，4 个 16 位组合成 64 位进行大小比较。</p><p>在启动<code>swupdate</code>之前，应用软件需要更新<code>/etc/sw-versions</code>来保存各个软件包的版本，然后再来启动<code>swupdate</code>进行版本管理，文件内容格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name of component&gt;     &lt;version&gt;</span><br></pre></td></tr></table></figure><h2 id="嵌入式脚本-Embedded-Script"><a href="#嵌入式脚本-Embedded-Script" class="headerlink" title="嵌入式脚本(Embedded Script)"></a>嵌入式脚本(Embedded Script)</h2><p>嵌入式脚本指的是在<code>sw-description</code>中嵌入脚本，该脚本是对配置文件全局可见的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">embedded-script = &quot;&lt;Lua code&gt;&quot;</span><br></pre></td></tr></table></figure><p>在编写脚本时需要注意：双引号应该使用转义字符进行转义，以避免影响脚本的解析。</p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print (\&quot;Test\&quot;)</span><br></pre></td></tr></table></figure><p>在配置文件中的镜像文件或普通文件类型都可以调用一个嵌入式脚本的函数，通过<code>hook</code>标记函数名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">files: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &quot;examples.tar&quot;;</span><br><span class="line">                type = &quot;archive&quot;;</span><br><span class="line">                path = &quot;/tmp/test&quot;;</span><br><span class="line">                hook = &quot;set_version&quot;;</span><br><span class="line">                preserve-attributes = true;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>一个脚本的示例如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_version</span><span class="params">(image)</span></span></span><br><span class="line">        <span class="built_in">print</span> (\<span class="string">&quot;RECOVERY_STATUS.RUN: \&quot;.. swupdate.RECOVERY_STATUS.RUN)</span></span><br><span class="line"><span class="string">        for k,l in pairs(image) do</span></span><br><span class="line"><span class="string">                swupdate.trace(\&quot;image[\&quot; .. tostring(k) .. \&quot;] = \&quot; .. tostring(l))</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        image.version = \&quot;1.0\&quot;</span></span><br><span class="line"><span class="string">        image.install_if_different = true</span></span><br><span class="line"><span class="string">        return true, image</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure><p>上述的<code>image</code>则为传入的参数列表，该脚本设置了版本和安装属性然后返回。</p><p><code>swupdate</code>提供了一些函数便于调用，在脚本前需要写入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> (<span class="string">&#x27;swupdate&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="验证与签名"><a href="#验证与签名" class="headerlink" title="验证与签名"></a>验证与签名</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p><code>swupdate</code>的逻辑为：</p><ol><li><p>对<code>sw-description</code>进行签名验证，确保该文件未被篡改</p></li><li><p>在<code>sw-description</code>中包含各个独立镜像文件的哈希校验，确认这些镜像文件的正确性</p></li></ol><p><code>swupdate</code>可以通过<code>menuconfig</code>来配置签名验证使用的算法</p><ul><li><p>RSA 公钥/私钥验证：私钥存放在构建主机中，公钥存放在目标设备上</p></li><li><p>CMS 用于证书</p></li><li><p>GPG 用于签名</p></li></ul><h2 id="生成密钥和证书"><a href="#生成密钥和证书" class="headerlink" title="生成密钥和证书"></a>生成密钥和证书</h2><p>对于<code>RSA</code>和<code>CMS</code>算法，OpenSSL 用来生成密钥，对于<code>GPG</code>，gpg 用于生成密钥和对镜像文件签名。</p><h3 id="使用-RSA"><a href="#使用-RSA" class="headerlink" title="使用 RSA"></a>使用 RSA</h3><p>生成公钥和私钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先生成私钥</span></span><br><span class="line">openssl genrsa -aes256 -out priv.pem</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再生成公钥</span></span><br><span class="line">openssl rsa -in priv.pem -out public.pem -outform PEM -pubout</span><br></pre></td></tr></table></figure><p>使用 RSA 生成签名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对 sw-description 生成 rsa-pkcs<span class="comment">#1.5 签名</span></span></span><br><span class="line">openssl dgst -sha256 -sign priv.pem sw-description &gt; sw-description.sig</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以生成 rsa-pss 签名</span></span><br><span class="line">openssl dgst -sha256 -sign priv.pem -sigopt rsa_padding_mode:pss \</span><br><span class="line">    -sigopt rsa_pss_saltlen:-2 sw-description &gt; sw-description.sig</span><br></pre></td></tr></table></figure><h3 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \</span><br><span class="line">    -out mycert.cert.pem -subj &quot;/O=SWUpdate /CN=target&quot;</span><br></pre></td></tr></table></figure><ul><li><p><code>mycert.key.pem</code>用于保存在构建主机上</p></li><li><p><code>mycert.cert.pe</code>用于保存在目标设备机上</p></li></ul><h3 id="使用-CMS-进行签名"><a href="#使用-CMS-进行签名" class="headerlink" title="使用 CMS 进行签名"></a>使用 CMS 进行签名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \</span><br><span class="line">        -inkey mycert.key.pem -outform DER -nosmimecap -binary</span><br></pre></td></tr></table></figure><h2 id="使用签名和验证"><a href="#使用签名和验证" class="headerlink" title="使用签名和验证"></a>使用签名和验证</h2><p>对于签名而言，配置文件<code>sw-description</code>和<code>sw-description.sig</code>结合使用，签名文件跟在配置文件之后。</p><p>在配置文件中的镜像都需要包含属性<code>sha256</code>，代表该镜像文件的校验和。</p><p>下面的脚本演示了如何打包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">MODE=&quot;RSA-PKCS-1.5&quot;</span><br><span class="line">PRODUCT_NAME=&quot;myproduct&quot;</span><br><span class="line">CONTAINER_VER=&quot;1.0&quot;</span><br><span class="line">IMAGES=&quot;rootfs kernel&quot;</span><br><span class="line">FILES=&quot;sw-description sw-description.sig $IMAGES&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> you use RSA</span></span><br><span class="line">if [ x&quot;$MODE&quot; == &quot;xRSA-PKCS-1.5&quot; ]; then</span><br><span class="line">    openssl dgst -sha256 -sign priv.pem sw-description &gt; sw-description.sig</span><br><span class="line">elif if [ x&quot;$MODE&quot; == &quot;xRSA-PSS&quot; ]; then</span><br><span class="line">    openssl dgst -sha256 -sign priv.pem -sigopt rsa_padding_mode:pss \</span><br><span class="line">        -sigopt rsa_pss_saltlen:-2 sw-description &gt; sw-description.sig</span><br><span class="line">elif if [ x&quot;$MODE&quot; == &quot;xGPG&quot; ]; then</span><br><span class="line">    gpg --batch --homedir &quot;$&#123;GPG_HOME_DIR&#125;&quot; --default-key &quot;$&#123;GPG_KEY&#125;&quot; \</span><br><span class="line">        --output sw-description.sig --detach-sig sw-description</span><br><span class="line">else</span><br><span class="line">    openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \</span><br><span class="line">        -inkey mycert.key.pem -outform DER -nosmimecap -binary</span><br><span class="line">fi</span><br><span class="line">for i in $FILES;do</span><br><span class="line">        echo $i;done | cpio -ov -H crc &gt;  $&#123;PRODUCT_NAME&#125;_$&#123;CONTAINER_VER&#125;.swu</span><br></pre></td></tr></table></figure><p>下面的配置文件演示了带有 sha256 校验的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        hardware-compatibility: [ &quot;revC&quot;];</span><br><span class="line"></span><br><span class="line">        images: (</span><br><span class="line">                &#123;</span><br><span class="line">                    filename = &quot;core-image-full-cmdline-beaglebone.ext3&quot;;</span><br><span class="line">                    device = &quot;/dev/mmcblk0p2&quot;;</span><br><span class="line">                    type = &quot;raw&quot;;</span><br><span class="line">                    sha256 = &quot;43cdedde429d1ee379a7d91e3e7c4b0b9ff952543a91a55bb2221e5c72cb342b&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        scripts: (</span><br><span class="line">                &#123;</span><br><span class="line">                    filename = &quot;test.lua&quot;;</span><br><span class="line">                    type = &quot;lua&quot;;</span><br><span class="line">                    sha256 = &quot;f53e0b271af4c2896f56a6adffa79a1ffa3e373c9ac96e00c4cfc577b9bea5f1&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p><code>swupdate</code>支持使用 AES 对镜像文件进行对称加密，在配置<code>swupdate</code>时需要使能<code>ENCRYPTED_IMAGES</code>.其使用步骤如下：</p><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>对于<code>aes-256-cbc</code>，需要生成 32 字节密钥和 16 字节初始化向量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -hex 32</span><br><span class="line"><span class="meta">#</span><span class="bash"> key, <span class="keyword">for</span> example 390ad54490a4a5f53722291023c19e08ffb5c4677a59e958c96ffa6e641df040</span></span><br><span class="line">openssl rand -hex 16</span><br><span class="line"><span class="meta">#</span><span class="bash"> IV, <span class="keyword">for</span> example d5d601bacfe13100b149177318ebc7a4</span></span><br></pre></td></tr></table></figure><h2 id="加密镜像"><a href="#加密镜像" class="headerlink" title="加密镜像"></a>加密镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -aes-256-cbc -in &lt;INFILE&gt; -out &lt;OUTFILE&gt; -K &lt;KEY&gt; -iv &lt;IV&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;INFILE&gt;</code>：输入的原始镜像文件</p></li><li><p><code>&lt;OUTFILE&gt;</code>：加密后的镜像文件</p></li><li><p><code>&lt;KEY&gt;</code>：上面生成的 32 字节的密钥</p></li><li><p><code>&lt;IV&gt;</code>：上面生成的 16 字节初始化向量</p></li></ul><h2 id="创建密钥文件"><a href="#创建密钥文件" class="headerlink" title="创建密钥文件"></a>创建密钥文件</h2><p>创建密钥文件，将密钥和初始化向量以空格分隔，写入文件。并在启动 <code>swupdate</code>时，以<code>-K</code>选项传入该文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">390ad54490a4a5f53722291023c19e08ffb5c4677a59e958c96ffa6e641df040 d5d601bacfe13100b149177318ebc7a4</span><br></pre></td></tr></table></figure><h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>最后是在配置文件中加入描述：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.0.1&quot;;</span><br><span class="line">        images: ( &#123;</span><br><span class="line">                        filename = &quot;core-image-full-cmdline-beaglebone.ext3.enc&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p3&quot;;</span><br><span class="line">                        encrypted = true;</span><br><span class="line">                        ivt = &quot;65D793B87B6724BB27954C7664F15FF3&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h1><p><code>handler</code>指的就是对各种镜像文件的安装处理程序，根据镜像文件的类型来匹配不同的<code>handler</code>。</p><p><code>swupdate</code>开放了接口，可以扩展增加各种<code>handler</code>，以适配用户定义的类型。</p><h2 id="创建新的-handler"><a href="#创建新的-handler" class="headerlink" title="创建新的 handler"></a>创建新的 <code>handler</code></h2><p>只需要按照<code>swupdate</code>的接口注册执行函数就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_handler</span><span class="params">(struct img_type *img,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">void</span> __attribute__ ((__unused__)) *data)</span></span></span><br></pre></td></tr></table></figure><p><code>img_type</code>指向要安装的镜像文件的起始，处理函数通过此结构体获取文件的信息，然后读取文件内容并执行安装。</p><p><code>data</code>是用于描述安装过程的数据指针，对于脚本的 handler，其为<code>struct script_handler_data</code></p><p><code>swupdate</code>还提供了通用函数，将流数据拷贝到目的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyfile</span><span class="params">(<span class="keyword">int</span> fdin, <span class="keyword">int</span> fdout, <span class="keyword">int</span> nbytes, <span class="keyword">unsigned</span> <span class="keyword">long</span> *offs,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> skip_file, <span class="keyword">int</span> compressed, <span class="keyword">uint32_t</span> *checksum, <span class="keyword">unsigned</span> <span class="keyword">char</span> *hash)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>fdin</code>：输入流，在处理函数中通过<code>img-&gt;fdin</code>获得</p></li><li><p><code>hash</code>：镜像文件的签名</p></li></ul><p>用户通过下面的函数注册新的<code>handler</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_handler_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">register_handler</span>(<span class="string">&quot;mytype&quot;</span>, my_handler, my_mask, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其函数原型为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">register_handler</span>(my_image_type, my_handler, my_mask, data);</span><br></pre></td></tr></table></figure><ul><li><p><code>my_image_type</code>：以字符串表示的匹配镜像文件类型</p></li><li><p><code>my_handler</code>：处理函数的指针</p></li><li><p><code>my_mask</code>：<code>HANDLER_MASK</code>枚举值，表示可以处理的类型</p></li><li><p><code>data</code>：用于传递给处理函数的数据</p></li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p><code>swupdate</code>具有可被外部程序调用的 API，用于启动<code>swupdate</code>，发送镜像文件，获取状态等。</p><p><code>swupdate</code>使用的是 Unix Domain Socket，socket 路径按照以下顺序来决定：</p><ol><li><p>编译时配置的<code>CONFIG_SOCKET_CTRL_PATH</code></p></li><li><p>当环境变量<code>RUNTIME_DIRECTORY</code>设置了，则其位于<code>$RUNTIME_DIRECTORY/sockinstctrl</code></p></li><li><p>当环境变量<code>TMPDIR</code>设置了，则其位于<code>$TMPDIR/sockinstctrl</code></p></li><li><p><code>/tmp/sockinstctrl</code></p></li></ol><blockquote><p>swupdate 也编译了一个 <code>swupdate-client</code>工具，用于演示客户端如何与服务端进行通信。</p></blockquote><p>这也就意味着<code>swupdate</code>在系统启动后就已经启动服务了，其脚本<code>swupdate.sh</code>，用于启动该服务。该脚本还会遍历位于<code>/etc/swupdate/conf.d/</code>处的配置文件。</p><h2 id="客户端与服务端的通信逻辑"><a href="#客户端与服务端的通信逻辑" class="headerlink" title="客户端与服务端的通信逻辑"></a>客户端与服务端的通信逻辑</h2><p>同时，<code>swupdate</code>提供了客户端库，便于以直接调用函数的方式来完成通信。</p><p>在文件<code>network_ipc.h</code>中定义了通信的帧结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> magic;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        msgdata data;</span><br><span class="line">&#125; ipc_message;</span><br></pre></td></tr></table></figure><ul><li><p><code>magic</code>：通信包的魔数</p></li><li><p><code>type</code>：包类型，包含：<code>REQ_INSTALL, ACK, NACK, GET_STATUS, POST_UPDATE, SWUPDATE_SUBPROCESS, SET_AES_KEY</code></p></li><li><p><code>msgdata</code>：通信的数据数据</p></li></ul><p>客户端和<code>swupdate</code>通信的流程如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_progress.jpg?raw=true"></p><ol><li><p>客户端先发<code>REQ_INSTALL</code>，等待获取到<code>ACK</code>，然后就可以发送镜像文件了</p></li><li><p>客户端持续发送镜像文件直到发送完成，发送标记给<code>swupdate</code></p></li><li><p>客户端从<code>swupdate</code>获取多次获取状态，来记录升级的进度</p></li></ol><h2 id="客户端的-API-库说明"><a href="#客户端的-API-库说明" class="headerlink" title="客户端的 API 库说明"></a>客户端的 API 库说明</h2><h3 id="启动升级"><a href="#启动升级" class="headerlink" title="启动升级"></a>启动升级</h3><p>与升级相关的 API 有以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swupdate_async_start</span><span class="params">(writedata wr_func, getstatus status_func,</span></span></span><br><span class="line"><span class="params"><span class="function">        terminated end_func, <span class="keyword">void</span> *req, <span class="keyword">ssize_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*writedata)</span><span class="params">(<span class="keyword">char</span> **buf, <span class="keyword">int</span> *size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*getstatus)</span><span class="params">(ipc_message *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*terminated)</span><span class="params">(RECOVERY_STATUS status)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>swupdate_async_start</code>：创建了一个线程与<code>swupdate</code>进行通信<ul><li><p><code>wr_func</code>：当需要获取升级包时，此函数会被调用</p></li><li><p><code>status_func</code>：当完成数据流传输时，有状态改变时该函数会被调用</p></li><li><p><code>end_func</code>：当 <code>swupdate</code>停止后，该函数会被调用</p></li><li><p><code>req</code>：是<code>swupdate_request</code>结构体，用于控制升级过程</p></li><li><p><code>size</code>：即为结构体的大小</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swupdate_request</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> apiversion;</span><br><span class="line">        sourcetype source;</span><br><span class="line">        <span class="keyword">int</span> dry_run;</span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> info[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">char</span> software_set[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">char</span> running_mode[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>source</code>：指定数据源的类型，包含<code>SOURCE_UNKNOWN, SOURCE_WEBSERVER, SOURCE_SURICATTA, SOURCE_DOWNLOADER, SOURCE_LOCAL</code></p></li><li><p><code>dry_run</code>：运行状态，包含<code>RUN_DEFAULT (set from command line), RUN_DRYRUN, RUN_INSTALL</code></p></li><li><p><code>info,len</code>：用于转发处理进程的接口</p></li><li><p><code>software_set,running_mode</code>：选择设置状态</p></li></ul><p><code>swupdate_request</code>结构体需要首先通过<code>swupdate_prepare_req()</code>来设置为默认值后再来进一步设置。</p><p>具体的使用流程，可以参考<code>examples/client</code>文件夹。</p><h3 id="设置-AES-密钥"><a href="#设置-AES-密钥" class="headerlink" title="设置 AES 密钥"></a>设置 AES 密钥</h3><p>AES 解密的密钥可以在命令行通过<code>-K</code>选项输入，也可以通过下面的函数输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swupdate_set_aes</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">char</span> *ivt)</span></span>;</span><br></pre></td></tr></table></figure><p>这里固定了是 AES-256 算法，所以<code>key</code>的长度是 64 字节的字符串，<code>ivt</code>是 32 字节的字符串。</p><h3 id="控制swupdate"><a href="#控制swupdate" class="headerlink" title="控制swupdate"></a>控制<code>swupdate</code></h3><p>函数<code>ipc_send_cmd</code>用于给<code>swupdate</code>发送命令，这个函数是同步发送的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_message</span> &#123;</span></span><br><span class="line">   sourcetype source; <span class="comment">/* Who triggered the update */</span></span><br><span class="line">   <span class="keyword">int</span>     cmd;       <span class="comment">/* Optional encoded command */</span></span><br><span class="line">   <span class="keyword">int</span>     timeout;     <span class="comment">/* timeout in seconds if an aswer is expected */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> len;    <span class="comment">/* Len of data valid in buf */</span></span><br><span class="line">   <span class="keyword">char</span>    buf[<span class="number">2048</span>];   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Buffer that each source can fill</span></span><br><span class="line"><span class="comment">                         * with additional information</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">ipc_send_cmd</span><span class="params">(ipc_message *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>source</code>的值为<code>SWUPDATE_SUBPROCESS</code></p></li><li><p><code>cmd</code>的类型可以参考<code>network_ipc.h</code></p></li></ul><h3 id="在升级过程中获取信息"><a href="#在升级过程中获取信息" class="headerlink" title="在升级过程中获取信息"></a>在升级过程中获取信息</h3><p>除了可以获取升级的成功与失败外，还可以获取升级过程中的进度。客户端可以注册一个函数，来获取升级过程中的状态。</p><blockquote><p>swupdate-progress 是一个工具用于获取升级过程中的状态</p></blockquote><p>客户端注册的方式是通过<code>connect</code>来连接<code>/tmp/swupdateprog</code>，然后使用<code>recv</code>来获取消息即可，消息的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">progress_msg</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    magic;          <span class="comment">/* Magic Number */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    status;         <span class="comment">/* Update Status (Running, Failure) */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    dwl_percent;    <span class="comment">/* % downloaded data */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> dwl_bytes;   <span class="comment">/* total of bytes to be downloaded */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    nsteps;         <span class="comment">/* No. total of steps */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    cur_step;       <span class="comment">/* Current step index */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    cur_percent;    <span class="comment">/* % in current step */</span></span><br><span class="line">        <span class="keyword">char</span>            cur_image[<span class="number">256</span>]; <span class="comment">/* Name of image to be installed */</span></span><br><span class="line">        <span class="keyword">char</span>            hnd_name[<span class="number">64</span>];   <span class="comment">/* Name of running handler */</span></span><br><span class="line">        sourcetype      source;         <span class="comment">/* Interface that triggered the update */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    infolen;        <span class="comment">/* Len of data valid in info */</span></span><br><span class="line">        <span class="keyword">char</span>            info[<span class="number">2048</span>];     <span class="comment">/* additional information about install */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>status</code>：大的状态，包含<code>START, RUN, SUCCESS, FAILURE, DOWNLOAD, DONE</code></p></li><li><p><code>dwl_percent</code>：当状态为<code>DOWNLOAD</code>时，表示下载的状态</p></li><li><p><code>dwl_bytes</code>：已经下载的总字节数</p></li><li><p><code>nsteps</code>：总共运行的 handler 的数量</p></li><li><p><code>cur_step</code>：当前运行的 handler 的序号</p></li><li><p><code>cur_percent</code>：当前运行的 <code>handler</code>的进度</p></li><li><p><code>cur_images</code>：当前正在安装的镜像名</p></li><li><p><code>hnd_name</code>：当前正在运行的 handler 名</p></li><li><p><code>infolen</code>：info 数组中包含的数据长度</p></li><li><p><code>info</code>：安装过程的附加信息</p></li></ul><p>整个过程的示例代码位于：<code>tools/swupdate-progress.c</code></p><h3 id="bootloader-接口"><a href="#bootloader-接口" class="headerlink" title="bootloader 接口"></a>bootloader 接口</h3><p>bootloader 接口主要是对其环境变量进行设定的接口，其位于<code>include/bootloader.h</code>文件中，包含的有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">env_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 删除环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_unset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 从文件中读取并批量写入文件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure><p>这些函数需要一开始被注册：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> bootloader trunk = &#123;</span><br><span class="line">    .env_get = &amp;do_env_get,</span><br><span class="line">    .env_set = &amp;do_env_set,</span><br><span class="line">    .env_unset = &amp;do_env_unset,</span><br><span class="line">    .apply_list = &amp;do_apply_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trunk_probe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">register_bootloader</span>(BOOTLOADER_TRUNK, &amp;trunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>bootloader/uboot.c</code>中有使用示例。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里记录 Swupdate 的简易使用说明。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="make" scheme="http://kcmetercec.top/categories/linux/make/"/>
    
    <category term="swupdate" scheme="http://kcmetercec.top/categories/linux/make/swupdate/"/>
    
    
    <category term="swupdate" scheme="http://kcmetercec.top/tags/swupdate/"/>
    
  </entry>
  
  <entry>
    <title>认识 fmt</title>
    <link href="http://kcmetercec.top/2024/10/21/professional_cpp_fmt/"/>
    <id>http://kcmetercec.top/2024/10/21/professional_cpp_fmt/</id>
    <published>2024-10-20T16:00:00.000Z</published>
    <updated>2024-10-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 C++20 已经提供了 <code>std::format</code> 这种格式化库，但直到 C++23 才支持 <code>std::print</code> 这种便利库。</p><p>又由于目前 gcc 对 C++23 支持还不完整，尤其是在嵌入式上。所以仍然是需要以 <a href="https://github.com/fmtlib/fmt">fmt 库</a> 为基本使用工具。</p><span id="more"></span><h1 id="包含-fmt-库"><a href="#包含-fmt-库" class="headerlink" title="包含 fmt 库"></a>包含 fmt 库</h1><p><a href="https://fmt.dev/11.0/get-started/">Get Started</a>中已经详细的描述了如何包含 fmt 到项目中去，为了增加项目的独立性，个人更倾向于使用<code>FetchContent</code>或<code>Embedded</code>的方式包含该库。</p><p>除了上面说的方法，还有一个简单粗暴的办法：</p><ol><li><p>下载源码，将文件夹<code>inculde/fmt</code>和<code>src</code>拷贝至项目中</p></li><li><p>将<code>fmt/core.h</code>，<code>fmt/format.h</code>，<code>fmt/forat-inl.h</code>，<code>src/format.cc</code>添加至编译文件中</p></li><li><p>将<code>fmt</code>路径添加到项目包含路径中</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于 Visual Studio，为了能够顺利编译 fmt 库。</span><br><span class="line"></span><br><span class="line">需要在&quot;属性&quot;-&gt; &quot;C/C++&quot; -&gt; &quot;命令行&quot; -&gt; &quot;附加选项&quot; 中添加 `/utf-8` 指定编码方式</span><br></pre></td></tr></table></figure><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><code>fmt::format</code>和<code>fmt::print</code>语法一致，在字符串中使用花括号<code>&#123;&#125;</code>表示格式化输出部分，如果想输出花括号，则使用两个花括号<code>&#123;&#123;&#125;&#125;</code>。</p><p>替换字段<code>&#123;&#125;</code>的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">replacement_field ::= &quot;&#123;&quot; [arg_id] [&quot;:&quot; (format_spec | chrono_format_spec)] &quot;&#125;&quot;</span><br><span class="line">arg_id            ::= integer | identifier</span><br><span class="line">integer           ::= digit+</span><br><span class="line">digit             ::= &quot;0&quot;...&quot;9&quot;</span><br><span class="line">identifier        ::= id_start id_continue*</span><br><span class="line">id_start          ::= &quot;a&quot;...&quot;z&quot; | &quot;A&quot;...&quot;Z&quot; | &quot;_&quot;</span><br><span class="line">id_continue       ::= id_start | digit</span><br></pre></td></tr></table></figure><h2 id="arg-id"><a href="#arg-id" class="headerlink" title="arg_id"></a>arg_id</h2><p><code>arg_id</code>指的是要输出部分对应后面输入参数的顺序，默认为<code>0~9</code>这样的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fmt::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;\n&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">fmt::<span class="built_in">println</span>(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;\n&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;a, b, c&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;a, b, c&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;2&#125;, &#123;1&#125;, &#123;0&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;c, b, a&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&#123;0&#125;&quot;</span>, <span class="string">&quot;abra&quot;</span>, <span class="string">&quot;cad&quot;</span>);  <span class="comment">// arguments&#x27; indices can be repeated</span></span><br><span class="line"><span class="comment">// Result: &quot;abracadabra&quot;</span></span><br></pre></td></tr></table></figure><p>如果在<code>arg_id</code>后需要增加其他描述，那需要以冒号<code>:</code>分隔<code>arg_id</code>和<code>format_spec</code>。</p><h2 id="format-spec"><a href="#format-spec" class="headerlink" title="format_spec"></a>format_spec</h2><p><code>format_spec</code>描述参数的表示方式，包含长度、对其、空白填充、精度、进制等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec ::= [[fill]align][sign][&quot;#&quot;][&quot;0&quot;][width][&quot;.&quot; precision][&quot;L&quot;][type]</span><br><span class="line">fill        ::= &lt;a character other than &#x27;&#123;&#x27; or &#x27;&#125;&#x27;&gt;</span><br><span class="line">align       ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;^&quot;</span><br><span class="line">sign        ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width       ::= integer | &quot;&#123;&quot; [arg_id] &quot;&#125;&quot;</span><br><span class="line">precision   ::= integer | &quot;&#123;&quot; [arg_id] &quot;&#125;&quot;</span><br><span class="line">type        ::= &quot;a&quot; | &quot;A&quot; | &quot;b&quot; | &quot;B&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; |</span><br><span class="line">                &quot;g&quot; | &quot;G&quot; | &quot;o&quot; | &quot;p&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;?&quot;</span><br></pre></td></tr></table></figure><ul><li><p><code>fill</code>表示填充的字符，除了花括号以外，其他字符都可以使用（需要指定宽度才有意义）</p></li><li><p><code>align</code>指定对齐方式（需要指定宽度才有意义）：</p><ul><li><p><code>&lt;</code>：左对齐，默认值</p></li><li><p><code>&gt;</code>：右对齐，对于数值而言，它是默认值</p></li><li><p><code>^</code>：居中对齐</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fmt::format(<span class="string">&quot;&#123;:&lt;30&#125;&quot;</span>, <span class="string">&quot;left aligned&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;left aligned                  &quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:&gt;30&#125;&quot;</span>, <span class="string">&quot;right aligned&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;                 right aligned&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:^30&#125;&quot;</span>, <span class="string">&quot;centered&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;           centered           &quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:*^30&#125;&quot;</span>, <span class="string">&quot;centered&quot;</span>);  <span class="comment">// use &#x27;*&#x27; as a fill char</span></span><br><span class="line"><span class="comment">// Result: &quot;***********centered***********&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽度也可以设置为参数</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:&lt;&#123;&#125;&#125;&quot;</span>, <span class="string">&quot;left aligned&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// Result: &quot;left aligned </span></span><br></pre></td></tr></table></figure><ul><li><p><code>sign</code>仅在浮点数或有符号整数有效：</p><ul><li><p><code>+</code>：在数值为非负时加上<code>+</code>号，在数值为负数时加上<code>-</code>号</p></li><li><p><code>-</code>：只有在数字为负数时，才加上<code>-</code>号，它是默认值</p></li><li><p><code> </code>：在数值为非负数时，加上空格，在数值为负数时加上<code>-</code>号</p></li></ul></li><li><p><code>#</code>用于对显示格式的切换，仅对整数和浮点数合法：</p><ul><li>对于<code>#b or #B</code>二进制、<code>#o</code>8进制、<code>#x or #X</code>16进制，会输出对应的前缀</li></ul></li><li><p><code>width</code>指定显示的最小位数，如果在<code>width</code>前面加<code>0</code>，则会在符号和数值之间填充0.</p><ul><li>当使用对齐方式时，前面加<code>0</code>的方式就会被忽略</li></ul></li><li><p><code>precision</code>指定小数精度：</p><ul><li><p>对于<code>f or F</code>显示格式，指定小数点后面的位数</p></li><li><p>对于<code>g or G</code>显示格式，指定除小数点外的位数之和</p></li></ul></li><li><p><code>type</code>用于指定具体显示格式：</p><ul><li><p>对于字符串有：</p><ul><li><p><code>s</code>：字符串显示，默认值</p></li><li><p><code>?</code>：调试显示，字符串被引号包含，且里面的特殊字符将不会被转义</p></li></ul></li><li><p>对于字符有：</p><ul><li><p><code>c</code>：字符显示，默认值</p></li><li><p><code>?</code>：调试显示，字符被引号包含，且特殊字符不会被转义</p></li></ul></li><li><p>对于整数有：</p><ul><li><p><code>b</code>或<code>B</code>：以二进制显示，如果加上<code>#</code>则会分别加上<code>0b</code>和<code>0B</code>前缀</p></li><li><p><code>c</code>：以字符显示</p></li><li><p><code>d</code>：以十进制显示</p></li><li><p><code>o</code>：以八进制显示</p></li><li><p><code>x</code>或<code>X</code>：以 16 进制显示，如果加上<code>#</code>则会分别加上<code>0x</code>和<code>0X</code>前缀</p></li></ul></li><li><p>对于浮点数有：</p><ul><li><p><code>a</code>或<code>A</code>：以 16 进制显示浮点数</p></li><li><p><code>e</code>或<code>E</code>：以科学计数法表示浮点数</p></li><li><p><code>f</code>或<code>F</code>：以固定精度显示浮点数</p></li><li><p><code>g</code>或<code>G</code>：对浮点数进行四舍五入</p></li></ul></li><li><p>对于指针有：<code>fmt::print(&quot;&#123;:p&#125;&quot;, fmt::ptr(p));</code></p><ul><li><code>p</code>：以 16 进制的方式显示指针，默认值。</li></ul></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fmt::format(<span class="string">&quot;&#123;:.&#123;&#125;f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Result: &quot;3.1&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:+f&#125;; &#123;:+f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show it always</span></span><br><span class="line"><span class="comment">// Result: &quot;+3.140000; -3.140000&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;: f&#125;; &#123;: f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show a space for positive numbers</span></span><br><span class="line"><span class="comment">// Result: &quot; 3.140000; -3.140000&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:-f&#125;; &#123;:-f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show only the minus -- same as &#x27;&#123;:f&#125;; &#123;:f&#125;&#x27;</span></span><br><span class="line"><span class="comment">// Result: &quot;3.140000; -3.140000&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;int: &#123;0:d&#125;;  hex: &#123;0:x&#125;;  oct: &#123;0:o&#125;; bin: &#123;0:b&#125;&quot;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// Result: &quot;int: 42;  hex: 2a;  oct: 52; bin: 101010&quot;</span></span><br><span class="line"><span class="comment">// with 0x or 0 or 0b as prefix:</span></span><br><span class="line">fmt::format(<span class="string">&quot;int: &#123;0:d&#125;;  hex: &#123;0:#x&#125;;  oct: &#123;0:#o&#125;;  bin: &#123;0:#b&#125;&quot;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// Result: &quot;int: 42;  hex: 0x2a;  oct: 052;  bin: 0b101010&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:#04x&#125;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Result: &quot;0x00&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然 C++20 已经提供了 &lt;code&gt;std::format&lt;/code&gt; 这种格式化库，但直到 C++23 才支持 &lt;code&gt;std::print&lt;/code&gt; 这种便利库。&lt;/p&gt;
&lt;p&gt;又由于目前 gcc 对 C++23 支持还不完整，尤其是在嵌入式上。所以仍然是需要以 &lt;a href=&quot;https://github.com/fmtlib/fmt&quot;&gt;fmt 库&lt;/a&gt; 为基本使用工具。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="http://kcmetercec.top/categories/cpp/"/>
    
    <category term="professional" scheme="http://kcmetercec.top/categories/cpp/professional/"/>
    
    
    <category term="cpp" scheme="http://kcmetercec.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统基本脉络</title>
    <link href="http://kcmetercec.top/2024/09/17/linux_fs_training/"/>
    <id>http://kcmetercec.top/2024/09/17/linux_fs_training/</id>
    <published>2024-09-16T16:00:00.000Z</published>
    <updated>2024-09-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录从上层用户操作到底层文件系统之间的调用流程以及数据流。<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true"></p><span id="more"></span><h1 id="simplefs-实战"><a href="#simplefs-实战" class="headerlink" title="simplefs 实战"></a>simplefs 实战</h1><p>[simplefs][<a href="https://github.com/psankar/simplefs]">https://github.com/psankar/simplefs]</a> 用最少的代码实现了文件系统的基本操作。</p><h2 id="基本体验"><a href="#基本体验" class="headerlink" title="基本体验"></a>基本体验</h2><h3 id="创建一个硬盘"><a href="#创建一个硬盘" class="headerlink" title="创建一个硬盘"></a>创建一个硬盘</h3><p>目前使用 <code>dd</code> 命令创建一个块大小为 4096字节，共100个块的硬盘文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">bs 指定一个块的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">count 指定块数目</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> 输入文件内容， /dev/zero 会不断输出0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">of 输出文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此命令可以用来测试内存的操作速度</span></span><br><span class="line">dd bs=4096 count=100 if=/dev/zero of=image</span><br></pre></td></tr></table></figure><h3 id="格式化并挂载"><a href="#格式化并挂载" class="headerlink" title="格式化并挂载"></a>格式化并挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">./mkfs-simplefs image</span><br><span class="line">mkdir mount</span><br><span class="line">sudo insmod simplefs.ko </span><br><span class="line">mount -o loop -t simplefs image ./mount</span><br></pre></td></tr></table></figure><h3 id="查看内容"><a href="#查看内容" class="headerlink" title="查看内容"></a>查看内容</h3><p>接下来就是以root的身份进入到 <code>mount</code> 文件夹，便可以查看其文件及文件内容。</p><h2 id="格式化代码分析-mkfs-simplefs-c"><a href="#格式化代码分析-mkfs-simplefs-c" class="headerlink" title="格式化代码分析(mkfs-simplefs.c)"></a>格式化代码分析(mkfs-simplefs.c)</h2><p>其格式化的步骤为：</p><ol><li>写入superblock 的内容</li><li>写根目录inode</li><li>写文件inode</li><li>写根目录block</li><li>写文件block</li></ol><h3 id="写-superblock"><a href="#写-superblock" class="headerlink" title="写 superblock"></a>写 superblock</h3><p>此函数将一个block来保存superblock的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_MAGIC 0x10032013</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> version; <span class="comment">//版本号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> magic; <span class="comment">//魔数</span></span><br><span class="line">        <span class="keyword">uint64_t</span> block_size;<span class="comment">//super block 信息所占用的块大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This should be moved to the inode store and not part of the sb */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inodes_count;<span class="comment">//目前已经使用了多少个inode</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> free_blocks;<span class="comment">//目前还剩下多少个block</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此部分是为了填充结构体，使整个结构体大小为4096字节</span></span><br><span class="line">        <span class="keyword">char</span> padding[SIMPLEFS_DEFAULT_BLOCK_SIZE - (<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>))];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_superblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> <span class="title">sb</span> =</span> &#123;</span><br><span class="line">                .version = <span class="number">1</span>,</span><br><span class="line">                .magic = SIMPLEFS_MAGIC,</span><br><span class="line">                .block_size = SIMPLEFS_DEFAULT_BLOCK_SIZE,</span><br><span class="line">                <span class="comment">/* One inode for rootdirectory and another for a welcome file that we are going to create */</span></span><br><span class="line">                .inodes_count = <span class="number">2</span>,<span class="comment">//使用一个inode对应根目录，一个inode对应一个文件</span></span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> Free blocks management is not implemented yet */</span></span><br><span class="line">                .free_blocks = (~<span class="number">0</span>) &amp; ~(<span class="number">1</span> &lt;&lt; WELCOMEFILE_DATABLOCK_NUMBER),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;sb, <span class="keyword">sizeof</span>(sb));</span><br><span class="line">        <span class="keyword">if</span> (ret != SIMPLEFS_DEFAULT_BLOCK_SIZE) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;bytes written [%d] are not equal to the default block size\n&quot;</span>,</span><br><span class="line">                         (<span class="keyword">int</span>)ret);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Super block written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写根文件inode"><a href="#写根文件inode" class="headerlink" title="写根文件inode"></a>写根文件inode</h3><p>根文件的inode紧接着superblock 往后填充，也就是在第2个block中存储inode.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode; <span class="comment">//此inode表示的档案类型</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//inode的索引号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> data_block_number;<span class="comment">//与inode对应的block的索引号</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//文件大小或是目录对应的内容对</span></span><br><span class="line">                <span class="keyword">uint64_t</span> file_size;</span><br><span class="line">                <span class="keyword">uint64_t</span> dir_children_count;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_INODE_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_INODESTORE_BLOCK_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode_store</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">root_inode</span>;</span></span><br><span class="line"></span><br><span class="line">        root_inode.mode = S_IFDIR;</span><br><span class="line">        root_inode.inode_no = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        root_inode.data_block_number = SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER;</span><br><span class="line">        root_inode.dir_children_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;root_inode, <span class="keyword">sizeof</span>(root_inode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(root_inode)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The inode store was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;root directory inode written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写文件inode"><a href="#写文件inode" class="headerlink" title="写文件inode"></a>写文件inode</h3><p>通过此函数可以看出：所有的inode都存储在一个block中，而一个inode大小为 <code>28</code> 字节。<br>也就是说，此文件系统最多支持文件和文件夹的总数为 <code>4096 / 28 = 146 </code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_INODE_NUMBER = <span class="number">2</span>;<span class="comment">//文件inode为2号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_DATABLOCK_NUMBER = <span class="number">3</span>;<span class="comment">//文件内容block</span></span><br><span class="line"><span class="keyword">char</span> welcomefile_body[] = <span class="string">&quot;Love is God. God is Love. Anbe Murugan.\n&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">welcome</span> =</span> &#123;</span><br><span class="line">        .mode = S_IFREG,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">        .data_block_number = WELCOMEFILE_DATABLOCK_NUMBER,</span><br><span class="line">        .file_size = <span class="keyword">sizeof</span>(welcomefile_body),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_inode *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">off_t</span> nbytes;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, i, <span class="keyword">sizeof</span>(*i));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(*i)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The welcomefile inode was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;welcomefile inode written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算出需要移动到block尾需要多少字节(依次减去root inode 和 welcome inode)</span></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*i) - <span class="keyword">sizeof</span>(*i);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);</span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The padding bytes are not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;inode store padding bytes (after the two inodes) written sucessfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写根目录block"><a href="#写根目录block" class="headerlink" title="写根目录block"></a>写根目录block</h3><p>写根目录block就是写文件名以及其inode的索引,一个名称对的大小为 <code>264</code> 字节，<br>也就是说一个目录最多可以存储的名称对为 <code>4096 / 264 = 15</code> 个，也就是说一个目录<br>最多存储15个文件或目录名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_FILENAME_MAXLEN 255 <span class="comment">//文件名的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> filename[SIMPLEFS_FILENAME_MAXLEN];</span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//文件名以及其对应的block索引</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> <span class="title">record</span> =</span> &#123;</span><br><span class="line">        .filename = <span class="string">&quot;vanakkam&quot;</span>,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_dirent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_dir_record *record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> nbytes = <span class="keyword">sizeof</span>(*record), ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, record, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (ret != nbytes) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the rootdirectory datablock (name+inode_no pair for welcomefile) has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;root directory datablocks (name+inode_no pair for welcomefile) written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*record);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);<span class="comment">//移动到下一个block</span></span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the padding for rootdirectory children datablock has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;padding after the rootdirectory children written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写文件block"><a href="#写文件block" class="headerlink" title="写文件block"></a>写文件block</h3><p>写文件block就是把文件内容写进去即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_block</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *block, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, block, len);</span><br><span class="line">        <span class="keyword">if</span> (ret != len) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Writing file body has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block has been written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>根据上面的格式化代码，可以知道其结构如下图：</p><p>！<a href="./simplefs_struct.jpg"></a></p><p>可以看出此文件系统的确是足够的简单：</p><ol><li>superblock描述极为简单</li><li>并不具备block bitmap 和 inode bitmap</li><li>最多支持的文件和文件夹总数为146个(因为仅用了一个block来存储inode)</li><li>一个文件夹中可以存储的文件和文件夹总数为15个</li><li>一个文件的内容不能超过一个block</li></ol><h3 id="文件系统操作逻辑"><a href="#文件系统操作逻辑" class="headerlink" title="文件系统操作逻辑"></a>文件系统操作逻辑</h3><p>根据以上简单结构的分析，可以猜测出其基本的文件操作逻辑：</p><ol><li>新建文件夹</li></ol><ul><li>从inode table 中填充一个文件夹类型的inode并获取其索引</li><li>为此索引的inode分配一个block并写入对应的inode</li><li>将新建文件夹的名称和inode索引对应存储在当前文件夹的block中</li><li>更新 superblock 中的inode计数</li></ul><ol start="2"><li>新建文件</li></ol><ul><li>从inode table 中填充一个文件类型的inode并获取其索引</li><li>为此索引的inode分配一个block并写入对应的inode</li><li>将文件内容写入其block中</li><li>将新建文件的名称和inode索引对应存储在当前文件夹的block中</li><li>更新 superblock 中的inode计数</li></ul><ol start="3"><li>删除文件或文件夹</li></ol><ul><li>去除当前文件夹中对应此文件或文件夹的描述字符串</li><li>更新 superblock 中的inode计数</li></ul><ol start="4"><li>建立硬链接</li></ol><ul><li>在当前文件夹下拷贝一份目标文件所在的文件夹中对于此文件的描述字符串</li></ul><ol start="5"><li>建立符号链接</li></ol><ul><li>首先新建一个文件</li><li>然后新建文件的内容指向目标文件所在的文件夹的inode</li></ul><p>基于这些猜测，接下来分析其文件系统操作代码。</p><h2 id="操作代码分析-simple-c"><a href="#操作代码分析-simple-c" class="headerlink" title="操作代码分析(simple.c)"></a>操作代码分析(simple.c)</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>在载入模块时，会首先使用函数 ·kmem_cache_create· ，用于为文件系统的inode申请缓存以便达到快速访问的目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sfs_inode_cachep = kmem_cache_create(<span class="string">&quot;sfs_inode_cache&quot;</span>,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct simplefs_inode),</span><br><span class="line">                                     <span class="number">0</span>,</span><br><span class="line">                                     (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD),</span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>在挂载文件时，会调用函数 <code>simplefs_fill_super</code> 函数，此函数的主要目的就是填充 <code>super_block</code> 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function, as the name implies, Makes the super_block valid and</span></span><br><span class="line"><span class="comment"> ,* fills filesystem specific information in the super block */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb_disk</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret = -EPERM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从存储super block 描述的block(0)中读取数据</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到 simplefs_super_block 具体内容</span></span><br><span class="line">        sb_disk = (struct simplefs_super_block *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;The magic number obtained in disk is: [%llu]\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;magic);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;magic != SIMPLEFS_MAGIC)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;simplefs seem to be formatted using a non-standard block size.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO</span><br><span class="line">               <span class="string">&quot;simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;version, sb_disk-&gt;block_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A magic number that uniquely identifies our filesystem type */</span></span><br><span class="line">        sb-&gt;s_magic = SIMPLEFS_MAGIC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For all practical purposes, we will be using this s_fs_info as the super block */</span></span><br><span class="line">        <span class="comment">//设为私有地址，以便后面使用</span></span><br><span class="line">        sb-&gt;s_fs_info = sb_disk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大的文件大小就是为一个block</span></span><br><span class="line">        sb-&gt;s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;</span><br><span class="line">        <span class="comment">//super block 操作</span></span><br><span class="line">        sb-&gt;s_op = &amp;simplefs_sops;</span><br><span class="line"></span><br><span class="line">        root_inode = new_inode(sb);</span><br><span class="line">        <span class="comment">//跟目录的inode位置</span></span><br><span class="line">        root_inode-&gt;i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        inode_init_owner(root_inode, <span class="literal">NULL</span>, S_IFDIR);</span><br><span class="line">        root_inode-&gt;i_sb = sb;</span><br><span class="line">        <span class="comment">//根目录inode操作</span></span><br><span class="line">        root_inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        <span class="comment">//根目录操作</span></span><br><span class="line">        root_inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        root_inode-&gt;i_atime = root_inode-&gt;i_mtime = root_inode-&gt;i_ctime =</span><br><span class="line">                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到根目录的inode内容(并且会将此inode放入inode cache 中)</span></span><br><span class="line">        root_inode-&gt;i_private =</span><br><span class="line">                simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> move such stuff into separate header. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 3, 0)</span></span><br><span class="line">        sb-&gt;s_root = d_make_root(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        sb-&gt;s_root = d_alloc_root(root_inode);</span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">                iput(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">release:</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据填充结果如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/struct_super_block.jpg?raw=true"><br>在 <code>super.h</code> 中有以下两个操作,对照上图就可以看出其意义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 simplefs_super_block 结构体地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_super_block *<span class="title">SIMPLEFS_SB</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb-&gt;s_fs_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件或目录 inode的地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_inode *<span class="title">SIMPLEFS_INODE</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inode-&gt;i_private;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取文件夹内容"><a href="#读取文件夹内容" class="headerlink" title="读取文件夹内容"></a>读取文件夹内容</h3><p>为了获取文件夹的内容得先从目录inode找到其对应的block。</p><p>当在 <code>mount</code> 文件夹下使用命令 <code>ls</code> 时，其执行路径依次为：</p><ul><li>simplefs_iterate : 用于扫描目录中的文件或文件夹名称以及其对应的inode</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_iterate</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_readdir</span><span class="params">(struct file *filp, <span class="keyword">void</span> *dirent, <span class="keyword">filldir_t</span> filldir)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">loff_t</span> pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">        pos = ctx-&gt;pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pos = filp-&gt;f_pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        inode = filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> We use a hack of reading pos to figure if we have filled in all data.</span></span><br><span class="line"><span class="comment">                 ,* We should probably fix this to work in a cursor based model and</span></span><br><span class="line"><span class="comment">                 ,* use the tokens correctly to not fill too many data in each cursor based call */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的inode</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!S_ISDIR(sfs_inode-&gt;mode))) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;inode [%llu][%lu] for fs object [%s] not a directory\n&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;inode_no, inode-&gt;i_ino,</span><br><span class="line">                       filp-&gt;f_dentry-&gt;d_name.name);</span><br><span class="line">                <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的block</span></span><br><span class="line">        bh = sb_bread(sb, sfs_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取目录blockc内容</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="comment">//根据目录中含有的条目进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_inode-&gt;dir_children_count; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">                <span class="comment">//返回文件名以及其对应的inode</span></span><br><span class="line">                dir_emit(ctx, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN,</span><br><span class="line">                         record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                ctx-&gt;pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                filldir(dirent, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN, pos,</span><br><span class="line">                        record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                filp-&gt;f_pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_lookup : 得到文件或文件夹的inode内容并初始化系统的 inode结构体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct dentry *<span class="title">simplefs_lookup</span><span class="params">(struct inode *parent_inode,</span></span></span><br><span class="line"><span class="params"><span class="function">                               struct dentry *child_dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取目录inode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent</span> =</span> SIMPLEFS_INODE(parent_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> parent_inode-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的block</span></span><br><span class="line">        bh = sb_bread(sb, parent-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的blockå����</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parent-&gt;dir_children_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(record-&gt;filename, child_dentry-&gt;d_name.name)) &#123;</span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> There is a corner case where if an allocated inode,</span></span><br><span class="line"><span class="comment">                         ,* is not written to the inode store, but the inodes_count is</span></span><br><span class="line"><span class="comment">                         ,* incremented. Then if the random string on the disk matches</span></span><br><span class="line"><span class="comment">                         ,* with the filename that we are comparing above, then we</span></span><br><span class="line"><span class="comment">                         ,* will use an invalid uninitialized inode */</span></span><br><span class="line"></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//根据文件inode号获取其内容</span></span><br><span class="line">                        sfs_inode = simplefs_get_inode(sb, record-&gt;inode_no);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//初始化inode结构体以及其对应的文件或文件夹操作</span></span><br><span class="line">                        inode = new_inode(sb);</span><br><span class="line">                        inode-&gt;i_ino = record-&gt;inode_no;</span><br><span class="line">                        inode_init_owner(inode, parent_inode, sfs_inode-&gt;mode);</span><br><span class="line">                        inode-&gt;i_sb = sb;</span><br><span class="line">                        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                printk(KERN_ERR</span><br><span class="line">                                       <span class="string">&quot;Unknown inode type. Neither a directory nor a file&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> We should store these times to disk and retrieve them */</span></span><br><span class="line">                        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =</span><br><span class="line">                                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">                        inode-&gt;i_private = sfs_inode;</span><br><span class="line"></span><br><span class="line">                        d_add(child_dentry, inode);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_ERR</span><br><span class="line">               <span class="string">&quot;No inode found for the filename [%s]\n&quot;</span>,</span><br><span class="line">               child_dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_get_inode : 得到请求的inode号码的内容</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This functions returns a simplefs_inode with the given inode_no</span></span><br><span class="line"><span class="comment"> ,* from the inode store, if it exists. */</span></span><br><span class="line"><span class="function">struct simplefs_inode *<span class="title">simplefs_get_inode</span><span class="params">(struct super_block *sb,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">uint64_t</span> inode_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sfs_sb</span> =</span> SIMPLEFS_SB(sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_buffer</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The inode store can be read once and kept in memory permanently while mounting.</span></span><br><span class="line"><span class="comment">         ,* But such a model will not be scalable in a filesystem with</span></span><br><span class="line"><span class="comment">         ,* millions or billions of files (inodes) */</span></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        sfs_inode = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Failed to acquire mutex lock %s +%d\n&quot;</span>,</span><br><span class="line">                       __FILE__, __LINE__);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//扫描inode table 是否有与要求的序号匹配的Inode</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_sb-&gt;inodes_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sfs_inode-&gt;inode_no == inode_no) &#123;</span><br><span class="line">                        <span class="comment">//申请cache</span></span><br><span class="line">                        inode_buffer = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">                        <span class="built_in">memcpy</span>(inode_buffer, sfs_inode, <span class="keyword">sizeof</span>(*inode_buffer));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sfs_inode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span></span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line">        <span class="keyword">return</span> inode_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_iterate</li></ul><p>可以看出其基本思路是：</p><ol><li>通过文件夹的inode获取其block</li><li>扫描block有哪些文件或文件夹</li><li>获取这些扫描到的文件或文件夹的inode内容，为其操作做好准备</li></ol><h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>可以猜测为了读取文件内容，首先要获取其inode才能找到其block.</p><p>当执行 <code>cat vanakkam</code> 时，执行的函数依次是：</p><ul><li>simplefs_iterate : 重复执行了8次</li><li>simplefs_read</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_read</span><span class="params">(struct file * filp, <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode</span> =</span></span><br><span class="line">                SIMPLEFS_INODE(filp-&gt;f_path.dentry-&gt;d_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line">        <span class="keyword">int</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*ppos &gt;= inode-&gt;file_size) &#123;</span><br><span class="line">                <span class="comment">/* Read request with offset beyond the filesize */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取block</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line">        nbytes = min((<span class="keyword">size_t</span>) inode-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, buffer, nbytes)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents to the userspace buffer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        ,*ppos += nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_read</li></ul><p>可以看出其思路为：</p><ol><li>从目录inode获取目录block，进而获取到文件的inode</li></ol><ul><li>所以当你对一个目录都没有读权限时，是无法通过其inode来获取文件内容的</li></ul><ol start="2"><li>从文件inode找到其对应block再读取其内容</li></ol><h3 id="写文件内容"><a href="#写文件内容" class="headerlink" title="写文件内容"></a>写文件内容</h3><p>可以猜测其与读文件内容的思路是一样的：</p><ol><li>从目录inode获取目录block，进而获取到文件的inode</li><li>从文件inode找到其对应block再写入对应的内容</li><li>更新inode描述(因为inode中具有文件信息)</li></ol><p>执行 echo “Hello world!” &gt; vanakkam 其执行路径为：</p><ul><li>simplefs_iterate : 重复执行了12次，没看懂为什么</li><li>simplefs_write : 写入数据并同步</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_write</span><span class="params">(struct file * filp, <span class="keyword">const</span> <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        retval = generic_write_checks(filp, ppos, &amp;len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line">        <span class="comment">//获取block地址</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      sfs_inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move the pointer until the required byte offset */</span></span><br><span class="line">        buffer += *ppos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(buffer, buf, len)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents from the userspace buffer to the kernel space\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        ,*ppos += len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步数据到硬盘</span></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set new size</span></span><br><span class="line"><span class="comment">         ,* sfs_inode-&gt;file_size = max(sfs_inode-&gt;file_size, *ppos);</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* <span class="doctag">FIXME:</span> What to do if someone writes only some parts in between ?</span></span><br><span class="line"><span class="comment">         ,* The above code will also fail in case a file is overwritten with</span></span><br><span class="line"><span class="comment">         ,* a shorter buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sfs_inode-&gt;file_size = *ppos;</span><br><span class="line">        retval = simplefs_inode_save(sb, sfs_inode);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                len = retval;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_inode_save : 更新inode</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_inode_save</span><span class="params">(struct super_block *sb, struct simplefs_inode *sfs_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从inode table 起始遍历出对应inode的内容</span></span><br><span class="line">        inode_iterator = simplefs_inode_search(sb,</span><br><span class="line">                                               (struct simplefs_inode *)bh-&gt;b_data,</span><br><span class="line">                                               sfs_inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(inode_iterator)) &#123;</span><br><span class="line">                <span class="comment">//更新 inode</span></span><br><span class="line">                <span class="built_in">memcpy</span>(inode_iterator, sfs_inode, <span class="keyword">sizeof</span>(*inode_iterator));</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;The inode updated\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//与硬盘同步</span></span><br><span class="line">                mark_buffer_dirty(bh);</span><br><span class="line">                sync_dirty_buffer(bh);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The new filesize could not be stored to the inode.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_inode_search : 从inode table 中找到对应序列的inode</li></ul><h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>先来猜测新建文件夹的步骤：</p><ol><li>根据文件夹inode找到其block</li><li>为新建的文件夹在inode table 中获取一个inode</li><li>为新建的文件夹分配一个block</li><li>将新申请到的文件夹名称以及其inode号写入父文件夹的block中</li><li>更新父文件夹inode</li><li>与硬盘同步</li></ol><p>执行命令 <code>mkdir hello</code> 其调用函数依次为：</p><ul><li>simplefs_iterate : 浏览目录获取其档案及对应inode</li><li>simplefs_lookup : 查看当前目录是否已有此档案名</li><li>simplefs_mkdir : 新建文件夹</li><li>simplefs_create_fs_object : 新建档案</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_create_fs_object</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent_dir_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">dir_contents_datablock</span>;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> count;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_directory_children_update_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sb = dir-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 super block 中记录的 inode 数目</span></span><br><span class="line">        ret = simplefs_sb_get_objects_count(sb, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(count &gt;= SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                <span class="comment">/* The above condition can be just == insted of the &gt;= */</span></span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Maximum number of objects supported by simplefs is already reached&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!S_ISDIR(mode) &amp;&amp; !S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Creation request but for neither a file nor a directory&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_sb = sb;</span><br><span class="line">        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_ino = (count + SIMPLEFS_START_INO - SIMPLEFS_RESERVED_INODES + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sfs_inode = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">        sfs_inode-&gt;inode_no = inode-&gt;i_ino;</span><br><span class="line">        inode-&gt;i_private = sfs_inode;</span><br><span class="line">        sfs_inode-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New directory creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;dir_children_count = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New file creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First get a free block and update the free map,</span></span><br><span class="line"><span class="comment">         ,* Then add inode to the inode store and update the sb inodes_count,</span></span><br><span class="line"><span class="comment">         ,* Then update the parent directory&#x27;s inode with the new child.</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* The above ordering helps us to maintain fs consistency</span></span><br><span class="line"><span class="comment">         ,* even in most crashes</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="comment">//申请一个空闲的block</span></span><br><span class="line">        ret = simplefs_sb_get_a_freeblock(sb, &amp;sfs_inode-&gt;data_block_number);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;simplefs could not get a freeblock&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//申请一个空闲的inode</span></span><br><span class="line">        simplefs_inode_add(sb, sfs_inode);</span><br><span class="line"></span><br><span class="line">        parent_dir_inode = SIMPLEFS_INODE(dir);</span><br><span class="line">        bh = sb_bread(sb, parent_dir_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到父目录的block</span></span><br><span class="line">        dir_contents_datablock = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Navigate to the last record in the directory contents */</span></span><br><span class="line">        dir_contents_datablock += parent_dir_inode-&gt;dir_children_count;</span><br><span class="line">        <span class="comment">//在父目录的blockä������������������inode对</span></span><br><span class="line">        dir_contents_datablock-&gt;inode_no = sfs_inode-&gt;inode_no;</span><br><span class="line">        <span class="built_in">strcpy</span>(dir_contents_datablock-&gt;filename, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存父目录inode</span></span><br><span class="line">        parent_dir_inode-&gt;dir_children_count++;</span><br><span class="line">        ret = simplefs_inode_save(sb, parent_dir_inode);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* <span class="doctag">TODO:</span> Remove the newly created inode from the disk and in-memory inode store</span></span><br><span class="line"><span class="comment">                 ,* and also update the superblock, freemaps etc. to reflect the same.</span></span><br><span class="line"><span class="comment">                 ,* Basically, Undo all actions done during this create call */</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">        inode_init_owner(inode, dir, mode);</span><br><span class="line">        d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li><li>simplefs_sb_get_a_freeblock : 获取空闲block</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_sb_get_a_freeblock</span><span class="params">(struct super_block *vsb, <span class="keyword">uint64_t</span> * out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                ret = -EINTR;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Loop until we find a free block. We start the loop from 3,</span></span><br><span class="line"><span class="comment">         ,* as all prior blocks will always be in use */</span></span><br><span class="line">        <span class="comment">//从第三个block 开始寻找，前两个分别是(super block 和 inode table)</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED; i++) &#123;</span><br><span class="line">                <span class="comment">//通过位与的方式来获取空位，这也就是为什么最多支持64个block(free_blocks 是64位)</span></span><br><span class="line">                <span class="keyword">if</span> (sb-&gt;free_blocks &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(i == SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;No more free blocks available&quot;</span>);</span><br><span class="line">                ret = -ENOSPC;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ,*out = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新super block 中记录的空闲blockå��</span></span><br><span class="line">        <span class="comment">/* Remove the identified block from the free list */</span></span><br><span class="line">        sb-&gt;free_blocks &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步super block 与硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_sb_sync : 同步super block 与硬盘</li><li>simplefs_inode_add : 获取一个inode</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simplefs_inode_add</span><span class="params">(struct super_block *vsb, struct simplefs_inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bh = sb_bread(vsb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取inode table 内容</span></span><br><span class="line">        inode_iterator = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the new inode in the end in the inode store */</span></span><br><span class="line">        <span class="comment">//移动到inode table 的第一个空闲处</span></span><br><span class="line">        inode_iterator += sb-&gt;inodes_count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(inode_iterator, inode, <span class="keyword">sizeof</span>(struct simplefs_inode));</span><br><span class="line">        <span class="comment">//更新super block 计数</span></span><br><span class="line">        sb-&gt;inodes_count++;</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        <span class="comment">//同步super block 到硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>simplefs_sb_sync </li><li>simplefs_inode_save </li><li>simplefs_inode_search </li></ul><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>还是先来猜测一下新建文件的步骤：</p><ol><li>根据文件夹inode找到对应的block</li><li>从inode table 中为新建文件获取一个inode</li><li>从block 中为新建文件获取一个block，并填充其内容</li><li>更新文件的inode</li><li>更新文件夹的inode,以及block</li><li>更新super block 的 inode</li></ol><p>下面执行 <code>echo &quot;hello world!&quot; &gt; hello/hello.txt</code> 其条用函数依次为：</p><ul><li>simplefs_iterate : 首先通过根目录扫描其所包含的条目</li><li>simplefs_iterate : 然后通过扫描 =hello= 目录扫描其所包含的条目</li><li>simplefs_lookup : 查找是否存在 =hello.txt= 的inode</li><li>simplefs_create_fs_object: 新建文件</li><li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li><li>simplefs_sb_get_a_freeblock : 获取空闲block</li><li>simplefs_sb_sync : 同步super block 与硬盘</li><li>simplefs_inode_add : 获取一个inode</li><li>simplefs_sb_sync </li><li>simplefs_inode_save </li><li>simplefs_inode_search </li><li>simplefs_write : 写入文件内容</li><li>simplefs_inode_save : 更新inode</li><li>simplefs_inode_search </li></ul><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>通过查看其代码可以发现，此文件系统还有以下功能未能实现：</p><ul><li>删除文件</li><li>删除文件夹</li><li>建立符号链接</li><li>建立硬链接</li></ul><p>下面来尝试一一实现：</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>前面已经新建了文件 <code>/hello/hello.txt</code> ，下面尝试将它删除。</p><p>根据已有的知识先来猜测一下如何以最简单的方式删除一个文件，<br>为了能够使得操作步骤尽量的少，其实没有必要去擦除文件block的内容，而只需要对其inode操作即可。</p><p>也就是说涉及以下几个部分：</p><ol><li>文件夹block的字符串和inode对擦除</li><li>文件夹inode中的描述修改</li><li>inode table 修改</li><li>super block 修改</li></ol><p>通过 <code>strace rm -f hello.txt</code> 观察到有这么一行输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlinkat(AT_FDCWD, &quot;hello.txt&quot;, 0)      = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure><p>对应驱动的调用接口应该是 <code>struct inode_operations</code> 下的 <code>unlink</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br></pre></td></tr></table></figure><ul><li>在实现的过程中发现，其在增加inode 和 dir content 时是直接简单粗暴的在尾部增加，很明显在删除文件时会产生漏洞，所以此bug也需要修复。</li></ul><h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/fuse.jpg?raw=true"><br>如上图所示，FUSE仅仅在内核中实现了一个简单的模块，用于接口VFS和用户空间，文件系统的操作细节则存在于用户空间中。</p><ul><li>这种方式导致操作效率低但便于调试</li></ul><h1 id="比较重要的数据结构"><a href="#比较重要的数据结构" class="headerlink" title="比较重要的数据结构"></a>比较重要的数据结构</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 文件系统总览</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT8<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_DEV_MOUNT16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_VISIBLE32<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE32768<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">        <span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief super block 信息及操作结构体</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_list</span>;</span><span class="comment">/* Keep this first */</span></span><br><span class="line">        dev_ts_dev;<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">        <span class="keyword">unsigned</span> chars_blocksize_bits;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_blocksize;</span><br><span class="line">        loff_ts_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_flags;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_iflags;<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_magic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphores_umount</span>;</span></span><br><span class="line">        ints_count;</span><br><span class="line">        atomic_ts_active;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                    *s_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_heads_anon</span>;</span><span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_mounts</span>;</span><span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nodes_instances</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_quota_types;<span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">quota_infos_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sb_writerss_writers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line">        u8 s_uuid[<span class="number">16</span>];<span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_max_links;</span><br><span class="line">        fmode_ts_mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">           Cannot be worse than a second */</span></span><br><span class="line">        u32   s_time_gran;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">         ,* even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">         ,* in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved mount options for lazy filesystems using</span></span><br><span class="line"><span class="comment">         ,* generic_show_options()</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> __rcu *s_options;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved pool identifier for cleancache (-1 means none)</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> cleancache_poolid;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span><span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">        <span class="keyword">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Being remounted read-only */</span></span><br><span class="line">        <span class="keyword">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">s_dio_done_wq</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">s_pins</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Keep the lru lists last in the structure so they always sit on their</span></span><br><span class="line"><span class="comment">         ,* own individual cachelines.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_dentry_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_inode_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_headrcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_structdestroy_work</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutexs_sync_lock</span>;</span><span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">        spinlock_ts_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> ,* the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> ,* of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">umode_t</span>                i_mode;</span><br><span class="line">        <span class="keyword">unsigned</span>               shorti_opflags;</span><br><span class="line">        <span class="keyword">kuid_t</span>                 i_uid;</span><br><span class="line">        <span class="keyword">kgid_t</span>                 i_gid;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_flags;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_acl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_default_acl</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>  *<span class="title">i_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>             *<span class="title">i_sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                           *i_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>                  i_ino;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">         ,* following functions for modification:</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,*    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">         ,*    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">dev_t</span>                  i_rdev;</span><br><span class="line">        <span class="keyword">loff_t</span>                 i_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span></span><br><span class="line">        spinlock_ti_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>         i_bytes;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_blkbits;</span><br><span class="line">        <span class="keyword">blkcnt_t</span>               i_blocks;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">        <span class="keyword">seqcount_t</span>             i_size_seqcount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Misc */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          i_state;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>           <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_time_when;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>      <span class="title">i_hash</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>       <span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>   *<span class="title">i_wb</span>;</span><span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">        <span class="keyword">int</span>                     i_wb_frn_winner;</span><br><span class="line">        u16                     i_wb_frn_avg_time;</span><br><span class="line">        u16                     i_wb_frn_history;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_sb_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>  <span class="title">i_dentry</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">i_rcu</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        u64                        i_version;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_dio_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_writecount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>   *<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>       *<span class="title">i_flctx</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           <span class="title">i_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>               <span class="title">i_devices</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">i_pipe</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">i_bdev</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>            *<span class="title">i_cdev</span>;</span></span><br><span class="line">                <span class="keyword">char</span>                   *i_link;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __u32                          i_generation;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">        __u32                          i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>              <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>                           *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * (*follow_link) (struct dentry *, <span class="keyword">void</span> **);</span><br><span class="line">        <span class="keyword">int</span> (*permission) (struct inode *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*readlink) (struct dentry *, <span class="keyword">char</span> __user *,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">void</span> (*put_link) (struct inode *, <span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*create) (struct inode *,struct dentry *, <span class="keyword">umode_t</span>, <span class="keyword">bool</span>);</span><br><span class="line">        <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*mkdir) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rmdir) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*mknod) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>,<span class="keyword">dev_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rename) (struct inode *, struct dentry *,</span><br><span class="line">                       struct inode *, struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*rename2) (struct inode *, struct dentry *,</span><br><span class="line">                        struct inode *, struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*setattr) (struct dentry *, struct iattr *);</span><br><span class="line">        <span class="keyword">int</span> (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</span><br><span class="line">        <span class="keyword">int</span> (*setxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">size_t</span>,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*getxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*listxattr) (struct dentry *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*removexattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,</span><br><span class="line">                      u64 len);</span><br><span class="line">        <span class="keyword">int</span> (*update_time)(struct inode *, struct timespec *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*atomic_open)(struct inode *, struct dentry *,</span><br><span class="line">                           struct file *, <span class="keyword">unsigned</span> open_flag,</span><br><span class="line">                           <span class="keyword">umode_t</span> create_mode, <span class="keyword">int</span> *opened);</span><br><span class="line">        <span class="keyword">int</span> (*tmpfile) (struct inode *, struct dentry *, <span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*set_acl)(struct inode *, struct posix_acl *, <span class="keyword">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表的是一个路径</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">        <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line">        <span class="keyword">seqcount_t</span> d_seq;<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">                               ,* negative */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span><span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">        <span class="keyword">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">        &#125; d_u;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表一个文件的引用（一个文件可以被打开多次就有多个引用，但inode却是仅有一个）</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>     <span class="title">fu_llist</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>       <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">        &#125; f_u;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                   <span class="title">f_path</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                  *<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>  *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">         ,* Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>                    f_lock;</span><br><span class="line">        <span class="keyword">atomic_long_t</span>                 f_count;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>                  f_flags;</span><br><span class="line">        <span class="keyword">fmode_t</span>                       f_mode;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>                  <span class="title">f_pos_lock</span>;</span></span><br><span class="line">        <span class="keyword">loff_t</span>                        f_pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>            <span class="title">f_owner</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>             *<span class="title">f_cred</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>          <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">        u64                           f_version;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                          *f_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">        <span class="keyword">void</span>                          *private_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">        <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_ep_links</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>          *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure><p>inode Tab 存在于硬盘中，如果每次CPU从硬盘中读取那么效率会比较低下，<br>所以内核会为inode Table 申请一段内存以作为缓存，称为 <strong>对应文件系统的 inode cache</strong>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_inodecache</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ext4_inode_cachep = kmem_cache_create(<span class="string">&quot;ext4_inode_cache&quot;</span>,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(struct ext4_inode_info),</span><br><span class="line">                                              <span class="number">0</span>, (SLAB_RECLAIM_ACCOUNT|</span><br><span class="line">                                                  SLAB_MEM_SPREAD),</span><br><span class="line">                                              init_once);</span><br><span class="line">        <span class="keyword">if</span> (ext4_inode_cachep == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样在VFS层面上，也会对抽象出来的 inode 和 路径进行缓存(dentry), 分别称为 icache 和 dcache.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">dcache_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* A constructor could be added for stable state like the lists,</span></span><br><span class="line"><span class="comment">         ,* but it is probably not worth it because of the cache nature</span></span><br><span class="line"><span class="comment">         ,* of the dcache.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        dentry_cache = KMEM_CACHE(dentry,</span><br><span class="line">                                  SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in dcache_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dentry_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Dentry cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_bl_head),</span><br><span class="line">                                        dhash_entries,</span><br><span class="line">                                        <span class="number">13</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;d_hash_shift,</span><br><span class="line">                                        &amp;d_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; d_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_BL_HEAD(dentry_hashtable + loop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">inode_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* inode slab cache */</span></span><br><span class="line">        inode_cachep = kmem_cache_create(<span class="string">&quot;inode_cache&quot;</span>,</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct inode),</span><br><span class="line">                                         <span class="number">0</span>,</span><br><span class="line">                                         (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|</span><br><span class="line">                                          SLAB_MEM_SPREAD),</span><br><span class="line">                                         init_once);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in inode_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inode_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Inode-cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_head),</span><br><span class="line">                                        ihash_entries,</span><br><span class="line">                                        <span class="number">14</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;i_hash_shift,</span><br><span class="line">                                        &amp;i_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; i_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_HEAD(&amp;inode_hashtable[loop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终这些申请的缓存都是内核通过LRU算法进行回收的(内核通过 shrink方法来回收slab内存)</p><ul><li>shrink 方法需要驱动编写者来主动实现</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录从上层用户操作到底层文件系统之间的调用流程以及数据流。&lt;br&gt;&lt;img src=&quot;https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="fs" scheme="http://kcmetercec.top/categories/linux/fs/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/fs/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统基本实现</title>
    <link href="http://kcmetercec.top/2024/09/13/linux_fs_detail/"/>
    <id>http://kcmetercec.top/2024/09/13/linux_fs_detail/</id>
    <published>2024-09-12T16:00:00.000Z</published>
    <updated>2024-09-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><p>继续深入理解文件系统的实现。</p><span id="more"></span><h1 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h1><p>根据前面的了解，可以知道当新建一个文件时，需要修改以下部分：</p><ul><li>从inode bitmap 中找到空闲位</li><li>从block bitmap 中找到空闲位</li><li>填充此新文件的数据内容到block中</li><li>填充此新文件的inode内容到inode table中</li><li>在包含此文件的目录的block中增加新文件的条目<ul><li>如果已经超过了一个block，则还需要申请新block并填充</li></ul></li><li>更新目录的inode内容</li><li>更新superblock的inode和block记录信息</li></ul><p>以上这么多步操作显然就不是原子性的，如果在操作过程中系统崩溃或者硬件掉电，都会造成元数据和数据不一致的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里其实还有会安全性的问题，因为文件系统在删除一个文件时，</span><br><span class="line">为了提高处理速度一般是不会去真的删除block中的内容的，一般是直接删除其元数据即可。</span><br><span class="line"></span><br><span class="line">那么当为一个文件增加一个block时，如果在写完元数据后真正的block还没有被写入时发生了掉电，</span><br><span class="line">那么下次启动时，这个文件下一个block的内容其实是上次被删除文件的内容!</span><br></pre></td></tr></table></figure><h2 id="实例模拟掉电过程"><a href="#实例模拟掉电过程" class="headerlink" title="实例模拟掉电过程"></a>实例模拟掉电过程</h2><h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个虚拟硬盘</span></span><br><span class="line">dd if=/dev/zero of=image bs=4096 count=1024</span><br><span class="line"><span class="meta">#</span><span class="bash">格式化</span></span><br><span class="line">mkfs.ext4 -b 4096 image</span><br></pre></td></tr></table></figure><h3 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看super block 的具体描述</span></span><br><span class="line">dumpe2fs image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">First inode:              11</span></span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Block bitmap at 2 (+2), Inode bitmap at 18 (+18)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Inode table at 34-65 (+34)</span></span><br></pre></td></tr></table></figure><p>由上面输出可以看到其 inode bitmap 起始块为18，block bitmap 起始块为2，inode table 起始块为34</p><ul><li>查看bitmap内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-C 以16进制显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-n 32 只显示前32个数</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure><p>可以看到其输出的 bitmap，前面的 <code>ff 07</code> 正好是11位，和前面的 <code>First inode: 11</code> 遥相呼应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  ff 07 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure><h3 id="增加文件再次查看元数据"><a href="#增加文件再次查看元数据" class="headerlink" title="增加文件再次查看元数据"></a>增加文件再次查看元数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir hello</span><br><span class="line"><span class="meta">#</span><span class="bash">文件模拟的硬盘需要 <span class="string">&quot;-o loop&quot;</span> 命令</span></span><br><span class="line">mount -o loop image hello</span><br><span class="line"><span class="meta">#</span><span class="bash">新建文件</span></span><br><span class="line">cd hello</span><br><span class="line">echo &quot;hello&quot; &gt; world</span><br><span class="line"><span class="meta">#</span><span class="bash">再次查看inode bitmap</span></span><br><span class="line">cd ../</span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure><p>查看其输出，发现第12位被置位了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  ff 0f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure><h3 id="破坏inode-bitmap"><a href="#破坏inode-bitmap" class="headerlink" title="破坏inode bitmap"></a>破坏inode bitmap</h3><p>下面再来将其12位清零，以造成数据不一致的错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先卸载挂载</span></span><br><span class="line">umount hello</span><br><span class="line">vim image</span><br><span class="line"><span class="meta">#</span><span class="bash">转为16进制显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash">:%!xxd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">计算其inode bitmap起始地址为 0x12000</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改对应 0f 为 07</span></span><br><span class="line"><span class="meta">#</span><span class="bash">保存后还原为二进制</span></span><br><span class="line"><span class="meta">#</span><span class="bash">:%!xxd -r</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure><p>通过以上操作可以发现其12位已经被清零了，并且此时使用 <code>fsck.ext4 image</code> 并无法检查出此错误。</p><p>重新 <code>mount</code> 依然可以看到文件的inode还是12（因为此记录依然保存在文件夹的block中）。</p><p>但如果此时再新建一个文件，便会报错 <code>Input/output erro</code> ,此时通过 <code>dmesg</code> 可以看到错误提示。</p><p>再次使用 <code>fsck.ext4 image</code> 即可检查出问题并修复</p><h3 id="破坏block-bitmap"><a href="#破坏block-bitmap" class="headerlink" title="破坏block bitmap"></a>破坏block bitmap</h3><p>再次使用 <code>dumpe2fs image</code> 查看其super block:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Group 0: (Blocks 0-1023) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0xf4d9, unused inodes 1012</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-1</span><br><span class="line">  Block bitmap at 2 (+2), Inode bitmap at 18 (+18)</span><br><span class="line">  Inode table at 34-65 (+34)</span><br><span class="line">  981 free blocks, 1012 free inodes, 2 directories, 1012 unused inodes</span><br><span class="line">  Free blocks: 8-17, 20-33, 67-1023</span><br><span class="line">  Free inodes: 13-1024</span><br></pre></td></tr></table></figure><p>通过其free blocks 输出，猜测其block bitmap 的前9字节应该是(小端模式16进制): ff 00 0c 00 fc ff ff ff 07</p><p>然后通过 <code>dd if=image bs=4096 skip=2 | hexdump -C -n 32</code> 来查看输出，果然如此。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000  ff 00 0c 00 fc ff ff ff  07 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure><p>新建文件然后查看其block bitmap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop image hello/</span><br><span class="line">echo &quot;haha&quot; &gt; hello/123</span><br><span class="line">dd if=image bs=4096 skip=2 | hexdump -C -n 32</span><br><span class="line"><span class="meta">#</span><span class="bash">00000000  ff 00 0c 00 <span class="built_in">fc</span> ff ff ff  0f 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000020</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br><span class="line"><span class="meta">#</span><span class="bash">00000000  ff 1f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000020</span></span><br></pre></td></tr></table></figure><p>然后按照之前类似步骤将 block bitmap的 <code>0f</code> 修改为 <code>07</code> , 如果此时再来新建文件却并不会报错。<br>然后通过 <code>fsck.ext4 image</code> 可以检测block bitmap错误，但同时新建文件的内容则为空。</p><h3 id="fsck-缺点"><a href="#fsck-缺点" class="headerlink" title="fsck 缺点"></a>fsck 缺点</h3><p>fsck 由于是进行全部元数据的对比扫描所以及执行速度比较慢，转而的替代方案则是日志文件系统。</p><h2 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由上面的掉电过程可以知道：在操作文件系统的任何时刻掉电都会造成数据不一致的问题，<br>而如果在检查文件系统时通过遍历的方法显然是低效的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了提高操作效率，我们完全可以将文件系统的操作过程来做一次记录，那么下次就可以直接检查最后一次记录的完整性：</p><ul><li>如果记录完整则代表上层操作已操作完毕</li><li>如果不完整则根据最后一次记录的进度，要么将此次操作撤销，要么主动完成此次操作。</li></ul><p>transaction(事务): 保证数据操作一致性</p><p>日志文件系统就以 transaction 为基础，来记录对文件系统的操作，其日志分4个阶段：</p><ol><li>journal write: 将要对文件系统的操作步骤写入 transaction </li><li>journal commit: 将此 transaction 写入存储日志内容的block中</li><li>checkpoint: 此步才是真正来执行文件系统的操作</li><li>Free： 此步若完成，则更新日志的 superblock以表示完成，并释放 transaction 在block中的空间</li></ol><p>分析以上步骤：</p><ul><li>假设在 jounral write 或 jounral commit 步骤掉电了，那么对日志来说用户什么都没有做</li><li>假设在 checkpoint 步骤中掉电了，那么日志已经记录了此操作，但用户真正操作还没有完成，那将由日志来主动完成。</li></ul><p>所以对文件系统的一致性就简化为两种状态：</p><ul><li>要么什么都没有做</li><li>要么没有做完，那么从新做一次</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的日志系统的transaction是要保存文件系统操作的每个步骤，那在对block的操作中所消耗的空间和时间都比较大，<br>为了能够提高效率，可以仅需要对其元数据做 transaction 即可。</p><p>进而演化出了 Metadata 日志阶段：</p><ol><li>Data write : 写文件数据到block<ul><li>此部分有几个选项 data=writeback,data=ordered<ul><li>writeback: 不用等待此步骤完成，而是并行的开始后面的步骤</li><li>ordered: 需要等待此步骤完成才能进行后面的步骤</li></ul></li></ul></li><li>Journal metadata write: 将要操作的文件的元数据过程写入到transaction</li><li>Journal commit: 将此transaction 写入存储日志内容的block中</li><li>checkpoint metadata: 真正执行文件的元数据操作</li><li>Free: 更新日志superblock 并释放transaction 在block中的空间</li></ol><p>分析以上步骤：</p><ul><li>当以 ordered 形式操作，如果在commit以以前的步骤掉电了则就等于什么都没有做</li><li>当以writeback形式操作，则可能出现 metadata已经checkpoint，但block还未写完的现象</li></ul><p>在实际格式化磁盘时，就可以给文件系统选项以让日志工作在什么模式：</p><ul><li><code>data=journal</code> : 传统日志方式，所有操作都做日志</li><li><code>data=ordered</code> : 等待block写完</li><li><code>data=writeback</code> : 并行写block和日志</li></ul><h2 id="COW-读拷贝更新-文件系统"><a href="#COW-读拷贝更新-文件系统" class="headerlink" title="COW(读拷贝更新)文件系统"></a>COW(读拷贝更新)文件系统</h2><p>COW的基本思路是：在更改磁盘时，先对要更改的对象创造一个副本，然后去修改这个副本。<br>当副本操作完成后，将副本与之前的节点链接起来为一个新树，最后再将superblock 指向新树的树顶。</p><p>由于 <strong>最后的superblock指针的操作</strong> 是原子性的，所以这种文件系统也只有两种状态：</p><ol><li>在指针操作之前断电，那相当于什么都没有发生，依然使用之前的树</li><li>在指针操作后断电，所有操作也都完成了，使用新树</li></ol><p>这种操作系统就不需要日志系统了。</p><p>Btrfs就是使用这种技术的文件系统：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_detail/Btrfs.jpg?raw=true"></p><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><ul><li>格式化并挂载</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//申请的磁盘空间不能太小，否则会出现警告 &quot;no space to alloc data/metadata chunk&quot;</span><br><span class="line">dd if=/dev/zero of=image bs=4096 count=102400</span><br><span class="line">mkfs.btrfs image</span><br><span class="line">mkdir hello</span><br><span class="line">mount -o loop image hello</span><br></pre></td></tr></table></figure><ul><li>创建当前文件系统的快照和子卷<ul><li>快照相当于对当前文件系统做了一个备份。</li><li>子卷相当于做了一个小分区</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd hello</span><br><span class="line">echo &quot;Hello world&quot; &gt; hello</span><br><span class="line"><span class="meta">#</span><span class="bash">为当前文件创建一个名为 snapshot1 的快照</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此时snapshot1 中的内容和当前目录一样，但其实是指针指向了同一个树，并没有复制内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当文件系统根目录修改时，它会为止使用COW技术来生成一个新的树。</span></span><br><span class="line">btrfs subvolume snapshot . snapshot1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个名为 sub1 的子卷</span></span><br><span class="line">btrfs subvolume create sub1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看文件系统子卷信息</span></span><br><span class="line">btrfs subvolume list .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ID 256 gen 9 top level 5 path snapshot1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ID 257 gen 13 top level 5 path sub1</span></span><br></pre></td></tr></table></figure><ul><li>直接挂载子卷的内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ../</span><br><span class="line">umount hello</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">根据前面的ID号来mount子卷</span></span><br><span class="line">mount image -o subvolid=257 hello</span><br></pre></td></tr></table></figure><h1 id="文件系统inode和block互查"><a href="#文件系统inode和block互查" class="headerlink" title="文件系统inode和block互查"></a>文件系统inode和block互查</h1><h2 id="通过文件查看其inode内容"><a href="#通过文件查看其inode内容" class="headerlink" title="通过文件查看其inode内容"></a>通过文件查看其inode内容</h2><ul><li>使用命令 <code>stat &lt;file_name&gt;</code> 来查看简易版的inode</li><li>使用命令 <code>debugfs</code> 来查看文件详细的inode内容：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file_path 绝对文件路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device_partition 设备分区路径</span></span><br><span class="line">debugfs -R &#x27;stat &lt;file_path&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure><p>比如在之前的 <code>simplefs</code> 中查看 <code>simple.c</code> 的 inode : </p><ul><li>debugfs -R ‘stat /home/baohua/github/simplefs-master/simple.c’ /dev/sda1</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">inode号        档案类型         权限</span></span><br><span class="line">Inode: 441161   Type: regular    Mode:  0664   Flags: 0x80000</span><br><span class="line">Generation: 2565248354    Version: 0x00000000:00000001</span><br><span class="line"><span class="meta">#</span><span class="bash">user id      group id        文件内容大小</span></span><br><span class="line">User:  1000   Group:  1000   Size: 27049</span><br><span class="line">File ACL: 0    Directory ACL: 0</span><br><span class="line"><span class="meta">#</span><span class="bash">链接数</span></span><br><span class="line">Links: 1   Blockcount: 56</span><br><span class="line">Fragment:  Address: 0    Number: 0    Size: 0</span><br><span class="line"><span class="meta">#</span><span class="bash">使用 <span class="built_in">stat</span> &lt;file_name&gt; 来显示文件所有相关时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash">最后改变文件属性的时间</span></span><br><span class="line"> ctime: 0x5afce24b:a4380e4c -- Thu May 17 10:00:43 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">最后访问时间</span></span><br><span class="line"> atime: 0x5afce251:0dda0cac -- Thu May 17 10:00:49 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">最后修改文件内容的时间，命令 ls -al 默认显示此时间</span></span><br><span class="line"> mtime: 0x5afce24b:a3be0bec -- Thu May 17 10:00:43 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">创建时间</span></span><br><span class="line">crtime: 0x5afce24b:a3be0bec -- Thu May 17 10:00:43 2018</span><br><span class="line">Size of extra inode fields: 28</span><br><span class="line">EXTENTS:#block 位置</span><br><span class="line">(0-6):1537640-1537646</span><br></pre></td></tr></table></figure><h2 id="根据-block-查看其inode"><a href="#根据-block-查看其inode" class="headerlink" title="根据 block 查看其inode"></a>根据 block 查看其inode</h2><p>同样通过 <code>debugfs</code> 可以反算出inode号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs -R &#x27;icheck &lt;block_num&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure><p>继续上面的例子(block号取其中任意一个都可以算出其inode)：</p><ul><li>debugfs -R ‘icheck 1537640’ /dev/sda1<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debugfs 1.42.9 (4-Feb-2014)</span><br><span class="line">Block    Inode number</span><br><span class="line">1537640    441161</span><br></pre></td></tr></table></figure></li></ul><p>继续通过 inode 得出其文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugfs -R &#x27;ncheck &lt;inode_num&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">debugfs 1.42.9 (4-Feb-2014)</span><br><span class="line">Inode    Pathname</span><br><span class="line">441161    /home/baohua/github/simplefs-master/simple.c</span><br></pre></td></tr></table></figure><h2 id="低级方式查看block中的内容"><a href="#低级方式查看block中的内容" class="headerlink" title="低级方式查看block中的内容"></a>低级方式查看block中的内容</h2><p>使用 <code>blkcat</code> 来直接读取block中的内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkcat &lt;device_partition&gt; &lt;block_num&gt;</span><br></pre></td></tr></table></figure><p>依然以 <code>simple.c</code> 的block <code>1537640</code> 来读取其一部分代码:</p><ul><li>blkcat /dev/sda1 1537640</li></ul><p>还可以使用 <code>dd</code> 命令来以扇区为偏移读取block的内容：</p><ul><li>首先使用 <code>fdisk -l /dev/sda1</code> 来查看磁盘的扇区<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda1: 16.6 GB, 16641949696 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2023 cylinders, total 32503808 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x00000000</span><br></pre></td></tr></table></figure>可以看出其扇区为512字节，当前文件系统的block为4096字节，那么一个block由8个扇区组成。</li></ul><p>然后可以使用 dd 来查看block的一个扇区:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sda1 of=sector skip=$((1537640*8)) bs=512c count=1</span><br></pre></td></tr></table></figure><p>然后就可以在文件 <code>sector</code> 中查看其一个扇区的内容了。</p><p>当要从磁盘最开始查找的话，还需要计算 <code>/dev/sda1</code> 分区的起始扇区，这可以通过 <code>fdisk /dev/sda</code> 使用 <code>p</code> 查看</p><p>比如查看当前偏移是2048个扇区，那么命令就可以修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sda1 of=sector skip=$((1537640*8 + 2048)) bs=512c count=1</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;继续深入理解文件系统的实现。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="fs" scheme="http://kcmetercec.top/categories/linux/fs/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/fs/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统基本操作</title>
    <link href="http://kcmetercec.top/2024/09/10/linux_fs_hello/"/>
    <id>http://kcmetercec.top/2024/09/10/linux_fs_hello/</id>
    <published>2024-09-09T16:00:00.000Z</published>
    <updated>2024-09-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h1><p>此节只列出 Linux 和 c 库操作接口，具体的详细信息还是要找 <code>man</code> 。</p><ul><li>其实在实际应用中，还是尽量使用标准的 c/c++ 库便于以后移植。</li></ul><p>需要注意的是：标准的ISOC库的I/O操作默认是带有缓存的，也就是填充一定的缓存后才会去调用系统接口。<br>而如果直接使用POSIX标准的系统接口，相当于上层没有做缓存，但实际上 <strong>内核为了尽量批量化的操作I/O，其内部也会做缓存。</strong></p><h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 设置文件在创建时需要去掉的权限</span></span><br><span class="line"><span class="comment">  * @note : 此设置仅影响此进程的umask，不会影响 shell 默认的 umask</span></span><br><span class="line"><span class="comment">  * 使用shell命令 umask </span></span><br><span class="line"><span class="comment">  * 可以查看 shell 设置输出依次为: &lt;special bits&gt;&lt;user&gt;&lt;group&gt;&lt;other&gt; </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umask</span><span class="params">(<span class="keyword">int</span> newmask)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 创建文件并设置权限</span></span><br><span class="line"><span class="comment">  * @note 权限与 umask 相与决定最终的权限</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 此函数使用较少，一般使用 open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>mode value</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>用户可读</td></tr><tr><td>S_IWUSR</td><td>用户可写</td></tr><tr><td>S_IXUSR</td><td>用户可执行</td></tr><tr><td>S_IRWXU</td><td>用户可读、写、执行</td></tr><tr><td>S_IRGRP</td><td>组可读</td></tr><tr><td>S_IWGRP</td><td>组可写</td></tr><tr><td>S_IXGRP</td><td>组可执行</td></tr><tr><td>S_IRWXG</td><td>组可读、写、执行</td></tr><tr><td>S_IROTH</td><td>其他人可读</td></tr><tr><td>S_IWOTH</td><td>其他人可写</td></tr><tr><td>S_IXOTH</td><td>其他人可执行</td></tr><tr><td>S_IRWXO</td><td>其他人可读、写、执行</td></tr><tr><td>S_ISUID</td><td>设置用户执行ID</td></tr><tr><td>S_ISGID</td><td>设置组执行ID</td></tr></tbody></table><h3 id="创建及打开"><a href="#创建及打开" class="headerlink" title="创建及打开"></a>创建及打开</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以flags指定的方式打开 pathname 指定的文件</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> * 1. 当 flags 为 O_CREAT 时，需要指定其 mode</span></span><br><span class="line"><span class="comment"> * 2. 当pathname为相对路径时，可以使用 openat 为其指定一个 dirfd，以此dir为相对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>flags value</th><th>含义</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读方式打开</td></tr><tr><td>O_WRONLY</td><td>只写方式打开</td></tr><tr><td>O_RDWR</td><td>读写方式打开</td></tr><tr><td>O_APPEND</td><td>追加方式打开</td></tr><tr><td>O_CREAT</td><td>创建</td></tr><tr><td>O_EXCL</td><td>如果使用了O_CREATE且文件存在，就会发生错误</td></tr><tr><td>O_NOBLOCK</td><td>以非阻塞的方式打开</td></tr><tr><td>O_TRUNC</td><td>如果文件存在则删除其内容</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><ul><li>在POSIX标准中的标准输入、输出、错误对应的宏依次为 <code>STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO</code> 位于头文件 <code>&lt;unistd.h&gt;</code> 中</li></ul><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>进行 read 和 write 大量数据读写时，需要考虑单次读写的字节数，取文件系统的block大小(比如4096字节)，能在尽量减小系统调用的同时保证较高的写入效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">( <span class="keyword">void</span>          *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">              FILE          *stream )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">               FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以 whence 为起始移动 offset 字节</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> * 1. 获取当前文件位置使用 currpos = lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"> * 当返回负数代表此文件对象不能做移动操作，比如FIFO，SOCKET</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>whence value</th><th>含义</th></tr></thead><tbody><tr><td>SEEK_SET</td><td>文件开头</td></tr><tr><td>SEEK_CUR</td><td>当前位置</td></tr><tr><td>SEEK_END</td><td>文件尾</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">( FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief : 从文件末尾到文件头的顺序截断length字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><ul><li>新建</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>移除</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * ### 文件操作</span></span><br><span class="line"><span class="comment"> * 1. 创建</span></span><br><span class="line"><span class="comment"> * &gt; int create(const char *filename, mode_t mode);</span></span><br><span class="line"><span class="comment"> * &gt; mode 与 umask (mode &amp; umask)共同决定文件的最终权限</span></span><br><span class="line"><span class="comment"> * &gt; int umask(int newmask);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; FILE *fopen(const char *path, const char *mode);</span></span><br><span class="line"><span class="comment"> * &gt; mode --&gt; &quot;r&quot;/&quot;rb&quot;/&quot;w&quot;/&quot;wb&quot;/&quot;a&quot;/&quot;ab&quot;/&quot;r+&quot;/&quot;r+b&quot;/&quot;rb+&quot;/&quot;w+&quot;/&quot;w+b&quot;/&quot;wb+&quot;/&quot;a+&quot;/&quot;a+b&quot;/&quot;ab+&quot;</span></span><br><span class="line"><span class="comment"> * 2. 打开</span></span><br><span class="line"><span class="comment"> * &gt; int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment"> * &gt; int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment"> * &gt; flag --&gt; O_RDONLY / O_WRONLY / O_RDWR / O_APPEND / O_CREAT / O_EXEC / O_NOBLOCK / O_TRUNC;</span></span><br><span class="line"><span class="comment"> * &gt; mode --&gt; S_IRUSR / S_IWUSR/ S_IXUSR / S_IRWXU / S_IRGRP / S_IWGRP / S_IXGRP / S_IRWXGRP / S_IROTH / S_IWOTH / S_IXOTH / S_IRWXO / S_ISUID / S_ISGID;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 读写</span></span><br><span class="line"><span class="comment"> * &gt; int read(int fd, const void *buf, size_t length);</span></span><br><span class="line"><span class="comment"> * &gt; int write(int fd, const void *buf, size_t length);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fgetc(FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fputc(int c, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; char *fgets(char *s, int n, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fputs(const char *s, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fprintf(FILE *stream, const char *format, ...);</span></span><br><span class="line"><span class="comment"> * &gt; int fscanf(FILE *stream, const char *format, ...);</span></span><br><span class="line"><span class="comment"> * &gt; size_t fread(void *ptr, size_t size, size_t n, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 定位</span></span><br><span class="line"><span class="comment"> * &gt; int lseek(int fd, offset_t offset, int whence);</span></span><br><span class="line"><span class="comment"> * &gt; whence --&gt; SEEK_SET / SEEK_CUR / SEEK_END;</span></span><br><span class="line"><span class="comment"> * &gt; 得到文件长度 lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fgetpos(FILE *stream, fpos_t *pos);</span></span><br><span class="line"><span class="comment"> * &gt; int fsetpos(FILE *stream, const fpos_t *pos);</span></span><br><span class="line"><span class="comment"> * &gt; int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 关闭</span></span><br><span class="line"><span class="comment"> * &gt; int close(int fd);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fclose(FILE *stream);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH      (100)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> fd, len;</span><br><span class="line">      <span class="keyword">char</span> str[LENGTH];</span><br><span class="line">      FILE *p_fd;</span><br><span class="line"></span><br><span class="line">      fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);</span><br><span class="line">      <span class="keyword">if</span>(fd)</span><br><span class="line">      &#123;</span><br><span class="line">            write(fd, <span class="string">&quot;Hello world&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line">            close(fd);</span><br><span class="line">      &#125;</span><br><span class="line">      p_fd = fopen(<span class="string">&quot;hello_lib.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(p_fd)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;Hello world! ^_^ \n&quot;</span>, p_fd);</span><br><span class="line">            fclose(p_fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">      len = read(fd, str, LENGTH);</span><br><span class="line">      str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">      close(fd);</span><br><span class="line"></span><br><span class="line">      p_fd = fopen(<span class="string">&quot;hello_lib.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      fgets(str, LENGTH, p_fd);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">      fclose(p_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多个进程打开同一个文件"><a href="#多个进程打开同一个文件" class="headerlink" title="多个进程打开同一个文件"></a>多个进程打开同一个文件</h2><p>多个进程打开同一个文件时，每个进程的 <code>task_struct</code> 都会包含此文件的资源描述，但是最终它们都是指向同一个 <code>inode</code> 。</p><ul><li>每个文件资源描述都包含对该文件的操作状态，位置偏移等信息</li><li>当进行 <code>lseek</code> 这种操作时，如果没有造成文件的扩大，其实是直接操作的资源描述结构体，而没有去操作inode。</li></ul><h3 id="互斥操作"><a href="#互斥操作" class="headerlink" title="互斥操作"></a>互斥操作</h3><p>如果有多个进程在操作同一个文件，则很有可能会造成竞态，有以下方式来避免此问题的发生：</p><ul><li>pread , pwrite</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief : 在文件为起始的 offset 字节处开始读或者写</span></span><br><span class="line"><span class="comment"> * @note :</span></span><br><span class="line"><span class="comment"> * 1. 这两个函数的操作是原子性的</span></span><br><span class="line"><span class="comment"> * 2. 此函数并不会改变对应进程本身所保存的 offset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="文件索引的复制"><a href="#文件索引的复制" class="headerlink" title="文件索引的复制"></a>文件索引的复制</h2><p>使用以下函数可以完成文件索引的复制(也就是两个不同的索引指向同一个文件描述资源，它们具有联动的偏移位置)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="主动写回数据到硬盘"><a href="#主动写回数据到硬盘" class="headerlink" title="主动写回数据到硬盘"></a>主动写回数据到硬盘</h2><p>一般的文件读写数据都会被存在 page cache 中，待内核在合适的时间写入硬盘，为了强制同步，可以使用下面函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以阻塞的方式等待某个文件同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以阻塞的方式同步文件数据，文件的元数据不一定会同步</span></span><br><span class="line"><span class="comment"> * @note : 只有一些重要的修改才会同步元数据，比如文件大小改变了</span></span><br><span class="line"><span class="comment"> * 但文件的方式文件改变了，是不会同步元数据的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给内核发送同步消息，并不会等待内核操作完成</span></span><br><span class="line"><span class="comment"> * @note shell 中的 sync 命令 也是调用的此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="文件运行时控制"><a href="#文件运行时控制" class="headerlink" title="文件运行时控制"></a>文件运行时控制</h2><p>当一个文件已经打开，要修改它的一些属性时，可以使用函数 <code>fcntl</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>此函数具有以下用途：</p><ol><li>生成一个文件描述符的副本</li><li>获取或设置文件描述符标记</li><li>获取或设置文件状态</li><li>获取或设置文件拥有者关系</li><li>获取或设置文件锁</li></ol><p><strong>需要注意的是：</strong> 当要修改某个文件状态时，应该像操作寄存器位那样通过 <code>读-修改-写</code> 的方式操作（也就是先读取当前设置值，然后写入新设置的那一位，再回写回去）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./test&quot;</span>, O_CREAT | O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((status = fcntl(fd, F_GETFL, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not get file status:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> close_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(status &amp; O_ACCMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read only\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write only\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_RDWR:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read write\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can not get file mode!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_APPEND)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_NONBLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nonblocking\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_SYNC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;synchronous writes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close_out:</span><br><span class="line">    close(fd);</span><br><span class="line">    remove(<span class="string">&quot;./test&quot;</span>);</span><br><span class="line">quick_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的一个控制函数便是 <code>ioctl</code> ，这个在驱动的操作中经常使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="文件的权限与属性"><a href="#文件的权限与属性" class="headerlink" title="文件的权限与属性"></a>文件的权限与属性</h2><h3 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h3><p>平时使用最多的 shell 命令 <code>ls -al</code> 就是提取的文件属性来显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* file type */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">      precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">      For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取文件的属性并存储于结构 stat 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果文件是符号链接，那么获取被链接文件的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//获取已打开文件的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//如果文件是符号链接，那么获取该符号链接的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据用户指定的 dirfd 和提供的路径 pathname 来获取文件属性，</span></span><br><span class="line"><span class="comment">//flags 用于控制是否读取符号链接本身</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 也可以使用下面的函数修改时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimes</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lutimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>如下代码所示，使用 lstat 来判断文件类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ./a.out &lt;file_path&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lstat(argv[<span class="number">1</span>], &amp;file_stat) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not get file status:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The file type is : &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;regular file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;directory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISCHR(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;character device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;symbolic link&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">quick_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作文件的权限"><a href="#操作文件的权限" class="headerlink" title="操作文件的权限"></a>操作文件的权限</h3><p>与操作文件相关的 ID 具有下面几类：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>真实用户ID和真实组ID</td><td>表示当前是哪个用户位于哪个组正在访问此文件</td></tr><tr><td>有效用户ID，有效组ID和补充组ID</td><td>表示该文件允许的用户和组(在没有suid,sgid的情况下，此值与真实用户和真实组ID是一个值)</td></tr><tr><td>suid</td><td>当文件user的可执行权限打开并设置了suid后，其他用户可以以该文件所有者的权限来运行此文件</td></tr><tr><td>sgid</td><td>当文件group的可执行权限打开并设置了sgid后，其他用户可以以该文件组成员的权限来运行此文件</td></tr></tbody></table><ul><li>对于权限方面还有一个(sticky bit):当文件other的可执行权限打开并设置了sticky后，用户都可以在此文件夹下新建文件和文件夹(类似于共享文件夹)<ul><li>但用户不能删除其他用户所新建的文件或文件夹</li></ul></li><li>对于普通权限 <code>rwx</code> 不得不提的是：<ul><li>要进入基本的目录，至少要具有 <code>x</code> 权限，要读取目录内容列表信息，至少要具有 <code>rx</code> 权限。</li><li>对一个文件是否具有新建或删除的权限，要看用户对此目录是否具有 <code>rw</code> 权限。<ul><li>这与文件自身的权限无关， <strong>自身权限只关联其内容的操作权限</strong></li></ul></li></ul></li></ul><p>可以使用下面的函数来判断当前进程是否有权限访问某个文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改文件权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//改变用户id和组id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>  每增加一个硬链接，文件的链接数量加1，以表示有多少个文件引用到同一个inode.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>  每取消一个硬链接，文件的链接数量减1，当一个文件的链接数量减至0 <strong>并且没有进程打开此文件时</strong> ，文件既被删除。</p><ul><li>当有进程打开了文件，那么当进程退出或关闭文件时，内核检查引用计数为0，才删除文件。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//移除文件时，与 unlink 一致，移除文件夹时，与 rmdir 一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><ul><li>创建</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>读取符号链接本身内容(可以看到其block内容为其引用文件路径)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat2</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="文件系统与设备驱动-include-linux-fs-h"><a href="#文件系统与设备驱动-include-linux-fs-h" class="headerlink" title="文件系统与设备驱动(include/linux/fs.h)"></a>文件系统与设备驱动(include/linux/fs.h)</h1><p>在设备驱动中，会关心 file 和 inode 这两个结构体。</p><ul><li>每打开一个文件，在内核空间中就有与之关联的 file 结构体<ul><li>设备驱动通过此结构体判断用户操作模式(比如是阻塞还是非阻塞等)<ul><li>判断阻塞还是非阻塞使用 <code>f_flags</code> </li></ul></li><li><code>private_data</code> 保存该设备驱动申请的数据地址</li></ul></li><li>inode 则包含了一个文件的详细信息，比如权限、生成时间、访问时间、最后修改时间等</li></ul><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>    <span class="title">f_llist</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">f_rcuhead</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_iocb_flags;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>        <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>    <span class="comment">/* cached value */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span> <span class="comment">// 和文件关联的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">     * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        f_lock;</span><br><span class="line">    <span class="keyword">atomic_long_t</span>        f_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_flags; <span class="comment">// 文件标志，如 O_RDONLY、O_NONBLOCK </span></span><br><span class="line">    <span class="keyword">fmode_t</span>            f_mode;<span class="comment">// 文件读/写模式，FMODE_READ 和 FMODE_WRITE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">f_pos_lock</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span>            f_pos; <span class="comment">// 当前读写的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>    <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64            f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="keyword">void</span>            *private_data; <span class="comment">// 文件私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    *<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="keyword">errseq_t</span>        f_wb_err;</span><br><span class="line">    <span class="keyword">errseq_t</span>        f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));    <span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure><h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> * of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">umode_t</span>            i_mode; <span class="comment">// inode 权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        i_opflags;</span><br><span class="line">    <span class="keyword">kuid_t</span>            i_uid; <span class="comment">// inode 拥有者 id</span></span><br><span class="line">    <span class="keyword">kgid_t</span>            i_gid; <span class="comment">// inode 所属群组 id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>            *i_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_ino;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">dev_t</span>            i_rdev; <span class="comment">// 若是设备文件，此字段记录设备的设备号</span></span><br><span class="line">    <span class="keyword">loff_t</span>            i_size; <span class="comment">// inode 所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_atime</span>;</span> <span class="comment">// 最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_mtime</span>;</span> <span class="comment">// 最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_ctime</span>;</span> <span class="comment">// inode 的产生时间</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        i_lock;    <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">    u8            i_blkbits;</span><br><span class="line">    u8            i_write_hint;</span><br><span class="line">    <span class="keyword">blkcnt_t</span>        i_blocks; <span class="comment">// inode 所使用的 block 数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="keyword">seqcount_t</span>        i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>    <span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        dirtied_when;    <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        dirtied_time_when;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_io_list</span>;</span>    <span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>    *<span class="title">i_wb</span>;</span>        <span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">    <span class="keyword">int</span>            i_wb_frn_winner;</span><br><span class="line">    u16            i_wb_frn_avg_time;</span><br><span class="line">    u16            i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>        <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>    <span class="comment">/* backing dev writeback list */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">i_dentry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>        <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">atomic64_t</span>        i_version;</span><br><span class="line">    <span class="keyword">atomic64_t</span>        i_sequence; <span class="comment">/* see futex */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_count;</span><br><span class="line">    <span class="keyword">atomic_t</span>        i_dio_count;</span><br><span class="line">    <span class="keyword">atomic_t</span>        i_writecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>    <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="keyword">void</span> (*free_inode)(struct inode *);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>    *<span class="title">i_flctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>    *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>        *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的 cdev 结构体指针</span></span><br><span class="line">        <span class="keyword">char</span>            *i_link;</span><br><span class="line">        <span class="keyword">unsigned</span>        i_dir_seq;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32            i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32            i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>    *<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>    *<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span>    *<span class="title">i_verity_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><ul><li><code>i_rdev</code> 表示设备编号，由高12位主设备号和低20位次设备号组成，使用下面的函数获取主次设备号<ul><li>主设备号代表同一类设备，次设备号表示使用该设备的实例对象</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS    20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK    ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">iminor</span><span class="params">(<span class="keyword">const</span> struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MINOR(inode-&gt;i_rdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">imajor</span><span class="params">(<span class="keyword">const</span> struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAJOR(inode-&gt;i_rdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以在 <code>/proc/devices</code> 中得到注册设备的主设备号和设备名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/devices</span><br></pre></td></tr></table></figure><ul><li>可以在 <code>/dev/</code> 下得到注册设备的主次设备号</li></ul><h1 id="udev-用户空间设备管理"><a href="#udev-用户空间设备管理" class="headerlink" title="udev 用户空间设备管理"></a>udev 用户空间设备管理</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux设计中强调的一个基本观点是机制和策略分离。</span><br><span class="line">机制是做某样事情的固定步骤、方法，而策略是每一个步骤所采取的不同方式。</span><br><span class="line">机制是固定的，而每个步骤采用的策略是不固定的。机制是稳定的，而策略是灵活的。</span><br><span class="line">因此，在Linux内核中，不应该实现策略。</span><br></pre></td></tr></table></figure><p>udev完全在用户态工作，利用设备加入或移出时内核所发送的热拔插事件(Hotplug Event)来工作。<br>在热拔插时，设备的详细信息会由内核通过netlink套接字发送出来，发出的事件叫uevent。<br>udev的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用从内核收到的信息来进行创建设备文件节点等工作。</p><p>udev的工作过程：</p><ol><li>当内核检测到系统中出现了新设备后，内核会通过netlink套接字发送uevent</li><li>udev获取内核发送的信息，进行规则的匹配。匹配的事物包括SUBSYSTEM、ACTION、attribute，内核提供的名称(通过KERNEL=)以及其他的环境变量</li></ol><p>使用下面的代码就可以接收 netlink 消息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nls</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;nls, <span class="number">0</span>, <span class="keyword">sizeof</span>(nls));</span><br><span class="line"></span><br><span class="line">    nls.nl_family = AF_NETLINK;</span><br><span class="line">    nls.nl_pid = getpid();</span><br><span class="line">    nls.nl_groups = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pfd.events = POLLIN;</span><br><span class="line">    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);</span><br><span class="line">    assert(pfd.fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(pfd.fd, (<span class="keyword">void</span> *)&amp;nls, <span class="keyword">sizeof</span>(nls));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (poll(&amp;pfd, <span class="number">1</span>, <span class="number">-1</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(pfd.fd, buf, <span class="keyword">sizeof</span>(buf), MSG_DONTWAIT);</span><br><span class="line">        assert(len != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf + i);</span><br><span class="line">            i += <span class="built_in">strlen</span>(buf + i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想要让内核主动发出一次 uevent，则可以对 <code>/sys/module</code> 中的模块主动写 <code>add</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo add &gt; /sys/module/psmouse/uevent</span><br></pre></td></tr></table></figure><p>会输出类似以下的消息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add@/module/psmouse</span><br><span class="line">ACTION=add</span><br><span class="line">DEVPATH=/module/psmouse</span><br><span class="line">SUBSYSTEM=module</span><br><span class="line">SYNTH_UUID=0</span><br><span class="line">SEQNUM=739</span><br></pre></td></tr></table></figure><h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs是内核设备模型的一个全局概览，此目录下的多个顶层文件是站在不同的角度来查看设备模型的：</p><ul><li><code>bus</code> 是以总线的视角来看待。<ul><li>首先，总线有很多种类型，所以在bus目录下会有多个代表不同总线类型的文件</li><li>其次，每种总线相对应的就包含设备和驱动，所以就会有 <code>devices,drivers</code> 文件夹<ul><li>设备下的文件是 <code>/sys/devices</code> 中文件的符号链接</li></ul></li></ul></li><li><code>devices</code> 是以设备的视角看待<ul><li>首先，设备是以层级的方式拓扑的，所以目录也是以此层级进行排列的</li><li>其次，当设备与驱动匹配以后，对应设备目录就会有 <code>driver</code> 目录</li></ul></li><li><code>class</code> 是以设备种类的视角看待设备<ul><li>此目录下都是以种类区分各种设备</li><li>设备下的文件是 <code>/sys/devices</code> 中文件的符号链接</li></ul></li><li><code>block</code> 是单独列出块设备文件</li><li><code>dev</code> 是块设备和字符设备文件</li></ul><p>在代码实现中，分别使用 <code>bus_type,device_driver,device</code> 来描述总线、驱动和设备:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>        *<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*dma_cleanup)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>        *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>        *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *mod_name;    <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;    <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>    *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>    *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>        *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>    *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>    *<span class="title">bus</span>;</span>        <span class="comment">/* type of bus device is on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>    <span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">                       device */</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;    <span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">                       core doesn&#x27;t touch it */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;    <span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">                       dev_set_drvdata/dev_get_drvdata */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>device_driver 和 device 都依附于总线，所以都包含了 <code>bus_type</code> 指针。而 device 又由 driver 驱动，所以它还包含了 <code>device_driver</code> 指针。</p><p>设备和驱动都是分开被注册的，总线的<code>match</code>函数来进行对应的匹配，匹配成功后驱动的<code>probe()</code>函数就会被调用。</p><p>总线、设备和驱动都会映射在 <code>sysfs</code> 中，其中的目录来源于 <code>bus_type,device_driver,device</code> ，而目录中的文件来源于 <code>attribute</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="keyword">umode_t</span>            mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>            ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>    *<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>    <span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct bus_type *bus, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct bus_type *bus, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于以上结构，内核提供了快捷的操作宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_PREALLOC(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        __ATTR_PREALLOC(_name, _mode, _show, _store)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_ADMIN_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RW_MODE(_name, 0600)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_ADMIN_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RO_MODE(_name, 0400)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_WO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_WO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ULONG_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_INT_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_BOOL_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_bool, device_store_bool), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name =        \</span></span><br><span class="line"><span class="meta">        __ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_WO(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_WO(_name)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="userspace" scheme="http://kcmetercec.top/categories/linux/userspace/"/>
    
    <category term="fs" scheme="http://kcmetercec.top/categories/linux/userspace/fs/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件系统结构概览</title>
    <link href="http://kcmetercec.top/2024/09/08/linux_fs_overview/"/>
    <id>http://kcmetercec.top/2024/09/08/linux_fs_overview/</id>
    <published>2024-09-07T16:00:00.000Z</published>
    <updated>2024-09-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><p>复习网站： <a href="http://linux.vbird.org/linux_basic/0230filesystem.php#">鸟哥私房菜</a></p><p>重温文件系统(ext)的相关操作并做整理，不然我这尿记性要不了多久又会忘。。。</p><span id="more"></span><h1 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在Linux中，一个磁盘可以分为多个区，每个区可以格式化为不同的文件系统，<br>最终通过虚拟文件系统VFS将这些抽象给上层统一的函数接口操作。</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/vfs_overview.jpg?raw=true"></p><ul><li>在驱动中，无论是字符设备、块设备、还是其他文件系统，与VFS所接口的都是填充 <code>struct file_operations</code> 结构体</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/vfs_fileoperations.jpg?raw=true"><br>一个ext文件系统的组成部分如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/fs_struct_overview.jpg?raw=true"></p><h3 id="Boot-Sector"><a href="#Boot-Sector" class="headerlink" title="Boot Sector"></a>Boot Sector</h3><p>此部分通过MBR跳转过来，用于显示关于此部分系统的启动界面以及引导系统启动，以达到多重启动的目的。 <a href="https://en.wikipedia.org/wiki/Boot_sector">wiki上有很详细的解释</a></p><h3 id="Block-Group"><a href="#Block-Group" class="headerlink" title="Block Group"></a>Block Group</h3><p>Block Group 用于将文件系统分为几个块，便于管理。</p><h3 id="Superblock"><a href="#Superblock" class="headerlink" title="Superblock"></a>Superblock</h3><p>此部分描述整个文件系统信息，是此分区文件系统的全部概览。 </p><p><strong>一个文件系统只能有一个Superblock,其他BlockGroup中可能会具有Superblock的备份，用于备用恢复。</strong></p><h3 id="文件系统描述"><a href="#文件系统描述" class="headerlink" title="文件系统描述"></a>文件系统描述</h3><p>此部分是描述当前block group的相关信息。</p><h3 id="区块对照表-block-bitmap"><a href="#区块对照表-block-bitmap" class="headerlink" title="区块对照表(block bitmap)"></a>区块对照表(block bitmap)</h3><p>此表用于查询文件系统中的block的使用情况，以反应出block的全局概览。</p><h3 id="inode对照表-inode-bitmap"><a href="#inode对照表-inode-bitmap" class="headerlink" title="inode对照表(inode bitmap)"></a>inode对照表(inode bitmap)</h3><p>此表用于查询文件系统中的inode的使用情况，以反应出inode的全局概览。</p><h3 id="inode-table"><a href="#inode-table" class="headerlink" title="inode table"></a>inode table</h3><p>用于存储该部分的inode的具体内容，一个文件对应一个inode。</p><p>inode用于描述文件权限、群组关系、容量、时间、链接的block等等相关信息，它不包含文件的实际内容。</p><p>inode中存储了包含文件内容的block索引，系统可以根据此索引预读文件内容，如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/inode_block_overview.jpg?raw=true"><br>一个inode的大小是有限制的，如果一个文件很大，就会需要很多的block。<br>那么一个inode就无法存储这么多地址，所以文件系统使用一部分block来存储inode，如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/inode_save_block.jpg?raw=true"><br>ext2/3 的inode可以直接寻址的block为12个，间接寻址、双间接寻址、三间接寻址各一个。</p><ul><li>一个block的地址为4字节，当block为4k时那么它就可以存储1024个block地址</li><li>所以一个直接寻址的总共block大小为 <code>12 * 4k = 48k (block_size * num)</code></li><li>间接寻址 :<code>1024 * 4k = 4M  [(block_size / 4) ^ 1] * block_size</code></li><li>双间接寻址: <code>1024 * 1024 * 4k = 4GB  [(block_size / 4) ^ 2] * block_size</code></li><li>三间接寻址为: <code>1024 * 1024 * 1024 * 4k = 4TB [(block_size / 4) ^ 3] * block_size</code></li></ul><p>ext4在此基础上做了优化:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">本来的ext2/3中inode以1个4字节对应一个block，如果一个文件占用了1000个block，</span><br><span class="line">那对应的inode中需要分配block来对应存储这1000个block的索引。</span><br><span class="line"></span><br><span class="line">但如果这1000个block地址是连续的，那就没有必要一一存储，可以在inode中存储一个结构体</span><br><span class="line">以表示block索引的起始地址和结束地址。这样就大大减少了inode的存储空间。</span><br><span class="line"></span><br><span class="line">也就是说同样大小的文件，ext4中对应inode此文件的inode占用空间更小，</span><br><span class="line">那么ext4中的inode能表示的文件大小范围也更大。</span><br></pre></td></tr></table></figure><h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>data block 用于存储文件的实际内容，在格式化的时候一个block的大小就规定好了，此为最小的存储单位。<br>也就是说当一个文件内容不足一个block也会占用一个block。</p><h2 id="superblock-查看与理解"><a href="#superblock-查看与理解" class="headerlink" title="superblock 查看与理解"></a>superblock 查看与理解</h2><ul><li>首先使用命令 <code>sudo blkid</code> 查看当前已经被格式化过的且已挂载的分区以及对应的文件系统</li><li>然后使用命令 <code>sudo dumpe2fs -h &lt;partition&gt;</code> 用于查看文件系统的全局概览。<ul><li>当不加 h 选项时还会输出 block group 的信息。<br>通过下面这个输出就可以看出一个 superblock 中可以看到的文件系统信息：</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">文件系统名称</span></span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">上一次的挂载点</span></span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          db4b4bdb-ebff-4928-b154-786622f8438f</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line"><span class="meta">#</span><span class="bash">文件系统特征</span></span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line"><span class="meta">#</span><span class="bash">默认挂载选项</span></span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line"><span class="meta">#</span><span class="bash">文件系统状态</span></span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line"><span class="meta">#</span><span class="bash">总共的inode数量</span></span><br><span class="line">Inode count:              8126464</span><br><span class="line"><span class="meta">#</span><span class="bash">总共的block数量</span></span><br><span class="line">Block count:              32505600</span><br><span class="line"><span class="meta">#</span><span class="bash">保留的block数量</span></span><br><span class="line">Reserved block count:     1625280</span><br><span class="line"><span class="meta">#</span><span class="bash">还剩余多少blocks和inodes可用</span></span><br><span class="line">Free blocks:              28442724</span><br><span class="line">Free inodes:              7560146</span><br><span class="line"><span class="meta">#</span><span class="bash">第一个block的起始索引</span></span><br><span class="line">First block:              0</span><br><span class="line"><span class="meta">#</span><span class="bash">block 大小</span></span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Reserved GDT blocks:      1016</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group的block数量</span></span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group的inode数量</span></span><br><span class="line">Inodes per group:         8192</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group可用多少个block来表示inode</span></span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line"><span class="meta">#</span><span class="bash">时间信息</span></span><br><span class="line">Filesystem created:       Tue Apr 18 22:27:06 2017</span><br><span class="line">Last mount time:          Thu Apr 26 09:20:42 2018</span><br><span class="line">Last write time:          Thu Apr 26 09:20:38 2018</span><br><span class="line">Mount count:              280</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Tue Apr 18 22:27:06 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          137 GB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line"><span class="meta">#</span><span class="bash">inode大小</span></span><br><span class="line">Inode size:               256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line"><span class="meta">#</span><span class="bash">日志系统的inode号码</span></span><br><span class="line">Journal inode:            8</span><br><span class="line">First orphan inode:       3538974</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      7deaec65-123c-4de8-aab7-9ca8dd458823</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke</span><br><span class="line"><span class="meta">#</span><span class="bash">文件日志可用大小</span></span><br><span class="line">Journal size:             128M</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x00042c45</span><br><span class="line">Journal start:            16552</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">第一个group的block索引范围</span></span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x5c5a, unused inodes 8175</span><br><span class="line"><span class="meta">  #</span><span class="bash">主superblock在0号block里面，group描述符在1-8号block里面</span></span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-8</span><br><span class="line">  Reserved GDT blocks at 9-1024</span><br><span class="line"><span class="meta">  #</span><span class="bash">block位图地址与inode位图地址</span></span><br><span class="line">  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)</span><br><span class="line"><span class="meta">  #</span><span class="bash">Inode Table地址</span></span><br><span class="line">  Inode table at 1057-1568 (+1057)</span><br><span class="line"><span class="meta">  #</span><span class="bash">剩余可用inode和block</span></span><br><span class="line">  22550 free blocks, 8176 free inodes, 2 directories, 8175 unused inodes</span><br><span class="line"><span class="meta">  #</span><span class="bash">具体剩余索引</span></span><br><span class="line">  Free blocks: 9255-9309, 9366-9402, 10310-32767</span><br><span class="line">  Free inodes: 16, 18-8192</span><br></pre></td></tr></table></figure><p>上面信息中说每个group有8192个inode可用，其 计算公式为：</p><ul><li>Inode Table 占用的block数量为 <code>1568 - 1057 + 1 = 512</code></li><li>由于一个block大小为4096字节，所以inode table 总共占用 <code>512 * 4096 = 2097152</code> 字节</li><li>由于一个inode的大小为256字节，所以一个inode table可用容纳 <code>2097152 / 256 = 8192</code> 个inode</li></ul><p>根据文件系统的结构来看，可以知道新增一个档案的流程为：</p><ol><li>确定使用者是否有 wx 权限，有权限才能新增</li><li>从inode bitmap 中取出一个空闲的inode号码 ,并将权限写入此inode</li><li>从block bitmap 中根据文件大小取出对应个数的block并将文件内容写入block</li><li>将文件对应的block号码写入其对应的inode,如果block太多还需要申请更多的block来存储inode</li><li>将新写入的inode和block同步到inode bitmap,block bitmap, superblock 中</li></ol><p>对应的删除一个档案的流程为：</p><ol><li>确定使用者具有wx权限</li><li>将对应的block 和 inode 置为空闲并同步到 inode bitmap , block bitmap ,superblock 中<ul><li>这里仅仅是猜测文件系统为了效率是不会实际删除内容的，而是清除其标志即可。待后面分析其代码再回头来梳理</li></ul></li></ol><h2 id="目录与文件的关系"><a href="#目录与文件的关系" class="headerlink" title="目录与文件的关系"></a>目录与文件的关系</h2><p>通过inode与block的关系可以知道目录肯定有其自己的inode与block，其block链接至其他的文件，如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/dir2file.jpg?raw=true"></p><ul><li>使用命令 <code>ls -li</code> 可以列出当前目录下存储文档的inode </li></ul><p>需要注意的是：inode并不保存文件名，文件名是保存在目录的block中的， <strong>所以文件的读取都是要先经过目录的</strong></p><p>其流程为：</p><ol><li>根据文件系统挂载点得知起始目录的inode</li><li>读取目录inode权限确认可以访问对应block中的内容</li><li>读取目录block中的内容，并根据文件名匹配到对应的inode</li><li>根据文件的inode进行权限确认是否可以访问文件block</li><li>读取block中的内容…</li></ol><h2 id="日志档案系统的作用"><a href="#日志档案系统的作用" class="headerlink" title="日志档案系统的作用"></a>日志档案系统的作用</h2><p>当在文件的增删过程中如果出现意外(比如文件内容已经写入但是inode bitmap, block bitmap, superblock没有得到同步)，<br>这就会出现内容与描述不一致的情况，系统为了还原此描述就需要扫描整个文件系统内容来同步修复，这个效率显然是很低下的。</p><p>日志文件系统就是记录文件的修改过程，当出现不一致时系统直接来比对日志即可，这样效率就提高了不少。</p><h2 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h2><ul><li>通过命令 <code>ls -al /lib/modules/$(uname -r)/kernel/fs</code> 可以看到系统所支持的文件系统种类</li><li>通过命令 <code>cat /proc/filesystems</code> 可以查看已经载入到RAM中的文件系统</li></ul><h1 id="文件系统的操作"><a href="#文件系统的操作" class="headerlink" title="文件系统的操作"></a>文件系统的操作</h1><h2 id="查看目录与硬盘容量"><a href="#查看目录与硬盘容量" class="headerlink" title="查看目录与硬盘容量"></a>查看目录与硬盘容量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出当前系统已经挂载的文件系统，显示其使用率，挂载点等信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当只是简单查看时，可以不用加 <span class="string">&#x27;a&#x27;</span> 选项</span></span><br><span class="line">df -aTh</span><br><span class="line"><span class="meta">#</span><span class="bash">显示当前系统中已挂载文件系统inode的使用率</span></span><br><span class="line">df -ih</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出当前目录及其子目录占用总容量</span></span><br><span class="line">du -sh</span><br></pre></td></tr></table></figure><h2 id="软链接与硬链接"><a href="#软链接与硬链接" class="headerlink" title="软链接与硬链接"></a>软链接与硬链接</h2><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接：新建一个文件，此文件的内容(block)指向的是被链接的文件名(由被链接文件的目录inode间接找到此文件名)</p><ul><li>使用 <code>ln -s &lt;src&gt; &lt;dst&gt;</code> 建立软链接</li><li>通过 <code>df -i</code> 可以看到 inode数量变化，以及通过 <code>ll -i</code> 可以看到新建文件指向的inode不一致</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/soft_link_overview.jpg?raw=true"><br>软链接优点：</p><ol><li>可以跨文件系统</li><li>可以链接目录<ul><li>对链接目录的软链接文件使用 <code>rm -rf soft_link_file</code> <strong>并不会删除对应目录，而仅仅是删除此软链接文件</strong></li></ul></li></ol><p>软链接缺点：</p><ol><li>会新建一个文件从而占用一个 inode和block</li><li>被链接的文件在其目录被删除后，无法通过链接文件访问文件内容</li></ol><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接：在目录的内容(block)中新建立一个指向被链接文件名的inode的映射关系</p><ul><li>使用 <code>ln &lt;src&gt; &lt;dst&gt;</code> 建立硬链接</li><li>通过 <code>df -i</code> 可以看到 inode数量不变，以及通过 <code>ll -i</code> 可以看到新建文件指向的inode一致,此时inode被链接数也会增加</li><li>新建的目录默认链接数是2(包括 “dir” 和 “dir/.”)而上层目录的链接数会加1(因为 “dir/..”) 会指向此目录</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/hard_link_overview.jpg?raw=true"><br>硬链接的优点：</p><ol><li>仅仅是在目录block中建立映射关系，所以不会消耗更多的inode和block<ul><li>除非目录block已经满了，则还需要新增加一个block来存储</li></ul></li><li>当被链接文件在其目录中的对应关系被删除后，在当前文件依然可以访问文件内容</li></ol><p>硬链接的缺点：</p><ol><li>不能跨文件系统</li><li>不能链接目录</li></ol><h2 id="分区、格式化、挂载"><a href="#分区、格式化、挂载" class="headerlink" title="分区、格式化、挂载"></a>分区、格式化、挂载</h2><h3 id="查看磁盘分区状态"><a href="#查看磁盘分区状态" class="headerlink" title="查看磁盘分区状态"></a>查看磁盘分区状态</h3><ul><li>使用命令 <code>lsblk</code> 可以查看当前系统磁盘以及其分区状态<ul><li>使用 <code>-f</code> 选项可以查看对应的UUID</li></ul></li><li>使用命令 <code>parted /dev/xxx print</code> 查看某个磁盘具体分区情况<ul><li>其中 <code>Partiton Table</code> 指出了磁盘使用的分割表</li></ul></li></ul><h3 id="磁盘分割"><a href="#磁盘分割" class="headerlink" title="磁盘分割"></a>磁盘分割</h3><ul><li>使用 <code>fdisk /dev/xxx</code> 对使用MBR分割表的磁盘进行分割</li><li>使用 <code>gdisk /dev/xxx</code> 对使用GPT分割表的磁盘进行分割</li><li>分割完成后，使用 <code>partprobe -s</code> 来更新分区表</li></ul><p>嵌入式批量出厂时， 可以在 <code>sed</code> 的帮助下完成自动化的分割，来源于 <a href="https://superuser.com/questions/332252/how-to-create-and-format-a-partition-using-a-bash-script">[wiki上有很详细的解释]</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> to create the partitions programatically (rather than manually)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> we<span class="string">&#x27;re going to simulate the manual input to fdisk</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> The sed script strips off all the comments so that we can</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> document what we&#x27;</span>re doing in-line with the actual commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that a blank line (commented as <span class="string">&quot;default&quot;</span> will send a empty</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> line terminated with a newline to take the fdisk default.</span></span><br><span class="line">sed -e &#x27;s/\s*\([\+0-9a-zA-Z]*\).*/\1/&#x27; &lt;&lt; EOF | fdisk $&#123;TGTDEV&#125;</span><br><span class="line">  o # clear the in memory partition table</span><br><span class="line">  n # new partition</span><br><span class="line">  p # primary partition</span><br><span class="line">  1 # partition number 1</span><br><span class="line"><span class="meta">  #</span><span class="bash"> default - start at beginning of disk</span></span><br><span class="line">  +100M # 100 MB boot parttion</span><br><span class="line">  n # new partition</span><br><span class="line">  p # primary partition</span><br><span class="line">  2 # partion number 2</span><br><span class="line"><span class="meta">  #</span><span class="bash"> default, start immediately after preceding partition</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> default, extend partition to end of disk</span></span><br><span class="line">  a # make a partition bootable</span><br><span class="line">  1 # bootable partition is partition 1 -- /dev/sda1</span><br><span class="line">  p # print the in-memory partition table</span><br><span class="line">  w # write the partition table</span><br><span class="line">  q # and we&#x27;re done</span><br><span class="line">  EOF</span><br></pre></td></tr></table></figure><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul><li>使用命令 <code>mkfs.ext4 /dev/xxxn</code> 来格式化对应分区</li></ul><h3 id="文件系统的检验"><a href="#文件系统的检验" class="headerlink" title="文件系统的检验"></a>文件系统的检验</h3><ul><li>使用命令 <code>fsck.ext4</code> 可以完成ext4 文件系统的检查</li></ul><h3 id="挂载与卸载"><a href="#挂载与卸载" class="headerlink" title="挂载与卸载"></a>挂载与卸载</h3><p>在挂载前需要注意的是：</p><ol><li><p>单一目录不应该重复挂载多个文件系统</p></li><li><p>要作为挂载点的目录需要是空目录</p></li></ol><ul><li><p>首先使用 <code>mkdir &lt;new dir&gt;</code> 新建空目录</p></li><li><p>然后使用 <code>mount /dev/xxxn &lt;new dir&gt;</code> 将分区挂载到空目录上</p></li><li><p>使用 <code>unmount &lt;dir&gt;</code> 来卸载分区</p></li></ul><h3 id="开机挂载"><a href="#开机挂载" class="headerlink" title="开机挂载"></a>开机挂载</h3><p>开机挂载规则存储于文件 <code>/etc/fstab</code> 中，如果需要增加挂载规则，那么在后面继续加入即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/fstab: static file system information.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that works even <span class="keyword">if</span> disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> / was on /dev/sda1 during installation</span></span><br><span class="line">UUID=db4b4bdb-ebff-4928-b154-786622f8438f /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="meta">#</span><span class="bash"> swap was on /dev/sda5 during installation</span></span><br><span class="line">UUID=25fea792-68fb-4dcc-a793-c96933dd39a1 none            swap    sw              0       0</span><br></pre></td></tr></table></figure><p>其规则从左到右依次为：</p><ul><li>UUID : 分区的唯一ID</li><li>mount point: 挂载的目录路径</li><li>type : 文件系统类型</li><li>options : 文件系统参数</li></ul><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>async/sync</td><td>是否以同步方式操作，一般为async</td></tr><tr><td>auto/noauto</td><td>当使用 mount -a 时，此文件系统是否会被主动测试挂载，默认为auto</td></tr><tr><td>rw/ro</td><td>整个文件系统的读写权限</td></tr><tr><td>exec/noexec</td><td>此文件系统中的档案是否可执行</td></tr><tr><td>user/nouser</td><td>是否允许普通用户可以挂载该文件系统，默认为nouser(不允许)</td></tr><tr><td>suid/nosuid</td><td>文件系统中的文件是否允许SUID的存在</td></tr><tr><td>default</td><td>默认:rw,suid,dev,exec,auto,nouser,async, 所以一般使用此参数即可</td></tr></tbody></table><ul><li>dump : 是否能被 dump 备份指定使用，一般设为 0</li><li>pass : 是否在开机是进行文件系统检查，为1代表需要检查 </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当 fstab 文件写入有误导致开机失败，那么可以进入维护模式然后使用命令  &quot;mount -n -o remount,rw /&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;复习网站： &lt;a href=&quot;http://linux.vbird.org/linux_basic/0230filesystem.php#&quot;&gt;鸟哥私房菜&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重温文件系统(ext)的相关操作并做整理，不然我这尿记性要不了多久又会忘。。。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="fs" scheme="http://kcmetercec.top/categories/linux/fs/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/fs/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下进程的创建</title>
    <link href="http://kcmetercec.top/2024/09/02/linux_process_create/"/>
    <id>http://kcmetercec.top/2024/09/02/linux_process_create/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2024-09-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><p>Linux 创建进程是基于 COW 实现的，现在再来深入一下。</p><span id="more"></span><h1 id="为什么需要-COW-技术"><a href="#为什么需要-COW-技术" class="headerlink" title="为什么需要 COW 技术"></a>为什么需要 COW 技术</h1><p>由于基于 COW 技术，fork() 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。</p><p>假设子进程运行和父进程一样的代码，那么只有在子进程写内存时才会真正的进行对应部分页表映射，这样：</p><ol><li>将传统 fork() 整个拷贝的开销均摊到了平时的操作中，降低了时间复杂度</li><li>极有可能子进程仅仅写一小部分内存，这样降低了物理内存的占用</li></ol><p>假设子进程启动后会运行 <code>exec()</code> 执行其他的可执行代码，那么就避免传统 fork() 大量拷贝所做的无用功。</p><h1 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h1><p>fork(),vfork(),__clone() 库函数调用实际上都是根据需要传入一些列的参数给 <code>clone()</code> ，在内核中由 <code>clone()</code> 去调用 <code>_do_fork()</code> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">,*  Ok, this is the main fork-routine.</span></span><br><span class="line"><span class="comment">,*</span></span><br><span class="line"><span class="comment">,* It copies the process, and if successful kick-starts</span></span><br><span class="line"><span class="comment">,* it and waits for it to finish using the VM if required.</span></span><br><span class="line"><span class="comment">,*</span></span><br><span class="line"><span class="comment">,* args-&gt;exit_signal is expected to be checked for sanity by the caller.</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="keyword">long</span> _do_fork(struct kernel_clone_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    u64 clone_flags = args-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine whether and which event to report to ptracer.  When</span></span><br><span class="line"><span class="comment">     * called from kernel_thread or CLONE_UNTRACED is explicitly</span></span><br><span class="line"><span class="comment">     * requested, no event is reported; otherwise, report if the event</span></span><br><span class="line"><span class="comment">     * for the type of forking is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">        trace = PTRACE_EVENT_VFORK;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args-&gt;exit_signal != SIGCHLD)</span><br><span class="line">        trace = PTRACE_EVENT_CLONE;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">        trace = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制父进程的资源</span></span><br><span class="line">    p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line">    add_latent_entropy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">      <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do this prior waking up the new thread - the thread pointer</span></span><br><span class="line"><span class="comment">     * might get invalid after that point, if the thread exits quickly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">    pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">    nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">      put_user(nr, args-&gt;parent_tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">      p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">      init_completion(&amp;vfork);</span><br><span class="line">      get_task_struct(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* forking complete and child started to run, tell ptracer */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">      ptrace_event_pid(trace, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">        ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>copy_process</code> 在复制父进程资源时，执行了如下流程：</p><ul><li><code>dup_task_struct()</code> : 为新进程创建内核栈、thread_info、task_struct。<ul><li>它们的值与父进程相同，那么它们的描述符也是一样的</li></ul></li><li><code>task_rlimit()</code> : 检测新创建子进程后，当前用户所拥有的进程数目没有超出限制</li><li>子进程初始化自己的 task_struct，使得与父进程区别开来</li><li>拷贝父进程指向的文件、地址空间、信号处理等</li><li><code>alloc_pid()</code> : 为新进程分配有效的 PID</li><li>返回新申请的 task_struct</li></ul><h1 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h1><p>vfork() 相比 fork() 而言就是不拷贝父进程的页表，这样 vfork() 与父进程共享内存空间，就相当于一个线程了。</p><p>一般使用 vfork() 后会立即调用 exec() 来读取新的代码。这在性能上的节约相比 fork() 后再使用 exec() 也高不了多少。</p><p>但有一个特性：vfork() 之后父进程被阻塞，直到子进程调用 exit() 或执行 exec()。</p><p>也就是说，vfork() 在执行 exec() 之后父进程才执行，这可以保证父子进程之间的同步关系。</p><p>vfork() 调用相比 fork() 调用在参数中多了一些标记：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(vfork)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> =</span> &#123;</span><br><span class="line">                                     .flags        = CLONE_VFORK | CLONE_VM,</span><br><span class="line">                                     .exit_signal    = SIGCHLD,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _do_fork(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是 <code>CLONE_VFORK</code> 这个标记使得父进程会等待子进程退出或完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">    init_completion(&amp;vfork);</span><br><span class="line">    get_task_struct(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">      ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>线程对内核来讲也是会分配一个 task_struct，只不过这个结构会与其进程共享内存等资源，但在调度算法上并没有区别对待。</p><p>在用户空间使用 <code>pthread_create()</code>= 创建线程时，实际上是调用了 clone() 函数并传入一些参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">,* cloning flags:</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL        0x000000ff    <span class="comment">/* signal mask to be sent at exit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM    0x00000100    <span class="comment">/* set if VM shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS    0x00000200    <span class="comment">/* set if fs info shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES    0x00000400    <span class="comment">/* set if open files shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND    0x00000800    <span class="comment">/* set if signal handlers and blocked signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PIDFD    0x00001000    <span class="comment">/* set if a pidfd should be placed in parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE    0x00002000    <span class="comment">/* set if we want to let tracing continue on the child too */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK    0x00004000    <span class="comment">/* set if the parent wants the child to wake it up on mm_release */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT    0x00008000    <span class="comment">/* set if we want to have the same parent as the cloner */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD    0x00010000    <span class="comment">/* Same thread group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS    0x00020000    <span class="comment">/* New mount namespace group */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM    0x00040000    <span class="comment">/* share system V SEM_UNDO semantics */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLS    0x00080000    <span class="comment">/* create a new TLS for the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID    0x00100000    <span class="comment">/* set the TID in the parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID    0x00200000    <span class="comment">/* clear the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED        0x00400000    <span class="comment">/* Unused, ignored */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED        0x00800000    <span class="comment">/* set if the tracing process can&#x27;t force CLONE_PTRACE on this clone */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID    0x01000000    <span class="comment">/* set the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWCGROUP        0x02000000    <span class="comment">/* New cgroup namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS        0x04000000    <span class="comment">/* New utsname namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC        0x08000000    <span class="comment">/* New ipc namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUSER        0x10000000    <span class="comment">/* New user namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWPID        0x20000000    <span class="comment">/* New pid namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNET        0x40000000    <span class="comment">/* New network namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_IO        0x80000000    <span class="comment">/* Clone io context */</span></span></span><br><span class="line"></span><br><span class="line">clone(..., CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, ...);</span><br></pre></td></tr></table></figure><p>同理，内核线程的创建也会分配一个 task_struct，只是与用户空间请求创建的线程有 1 点不同：内核线程所谓的地址空间就是内核空间，它们只在内核空间运行。</p><ul><li>在调度方面来讲，内核线程并不天生比用户请求的线程高贵，大家都是同等的被调度，都可以设置各自的调度策略和优先级。</li></ul><p>与用户空间相对应最为相似的内核线程创建便是 <code>kthread_run</code> 宏，可以看到也是返回了一个 task_struct。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* kthread_run - create and wake a thread.</span></span><br><span class="line"><span class="comment">* @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment">* @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment">* @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Description: Convenient wrapper for kthread_create() followed by</span></span><br><span class="line"><span class="comment">* wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kthread_run(threadfn, data, namefmt, ...)                 \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">    struct task_struct *__k                                       \</span></span><br><span class="line"><span class="meta">    = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (!IS_ERR(__k))                                             \</span></span><br><span class="line"><span class="meta">    wake_up_process(__k);                                       \</span></span><br><span class="line"><span class="meta">    __k;                                                          \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>终止内核线程便可以通过其返回的 task_struct 指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="进程的终结"><a href="#进程的终结" class="headerlink" title="进程的终结"></a>进程的终结</h1><p>进程的终结是通过内核 <code>do_exit()</code> 函数来完成的，其步骤如下：</p><ol><li><code>exit_signals()</code> 将 task_struct 中的标志成员设置为 <code>PF_EXITING</code></li><li>删除任意内核定时器，确保没有定时器在排队，也没有定时器处理程序在运行</li><li>如果进程记账功能是开启的，调用 <code>acct_update_integrals()</code> 输出记账信息</li><li><code>exit_mm()</code> 释放进程占用的 mm_struct，如果没有别的进程使用它，就彻底释放它们</li><li><code>exit_sem()</code> 释放信号量</li><li><code>exit_shm()</code> 释放共享内存</li><li><code>exit_files()，exit_fs()</code> 递减文件描述符和文件系统引用计数，如果计数值降为 0，那么就释放资源。</li><li>将退出码存入 task_struct 的 exit_code 成员，用于父进程检索退出原因</li><li><code>exit_notify()</code> 通知父进程，并将当前进程设置为 <code>EXIT_ZOMBIE</code> 僵死状态。</li><li><code>do_task_dead()</code> 切换到新的进程。</li></ol><p>在调用 <code>exit_notify()</code> 通知父进程外，还需要为此进程的子进程找到新的父进程，其会执行 <code>forget_original_parent()</code> ,<br>然后会调用 <code>find_new_reaper</code> 为子进程找到新的父进程，其搜寻的先后顺序是：</p><ol><li>在当前线程组内找个一个线程作为父进程</li><li>如果不行，就看哪个进程将其设置为了 subreaper 属性，如果有就将其作为父进程</li><li>如果还是不行，就将 init 进程设置为父进程</li></ol><p>经过上面步骤以后，该进程还保有内核栈、thread_info 和 task_struct 结构，用于向父进程提供信息。</p><p>在父进程通过 wait 类系统调用获取到该进程的退出状态后，进程剩余的内存也就被释放，归还给系统了。</p>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Linux 创建进程是基于 COW 实现的，现在再来深入一下。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="process" scheme="http://kcmetercec.top/categories/linux/process/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/process/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下进程和线程的调度</title>
    <link href="http://kcmetercec.top/2024/09/02/linux_process_schedule/"/>
    <id>http://kcmetercec.top/2024/09/02/linux_process_schedule/</id>
    <published>2024-09-01T16:00:00.000Z</published>
    <updated>2024-09-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h1><h2 id="吞吐和响应"><a href="#吞吐和响应" class="headerlink" title="吞吐和响应"></a>吞吐和响应</h2><p>操作系统的主要目标是要在保持高的吞吐量的同时还要有高的响应速度。</p><ul><li>吞吐量：整个系统在单位时间内做的有用功越多，吞吐量就越大<ul><li>进程的切换，代码的局部搬移都属于无用功</li></ul></li><li>响应速度：当发生切换请求时，要以尽量快的完成切换，哪怕牺牲其他的任务为代价<ul><li>这其中就包含了进程环境切换，以及代码局部性处理的搬移（cache miss 而导致的需要读内存）</li></ul></li></ul><p>毫无疑问，这两个指标是互相矛盾的，只有选择一个侧重点。</p><p>在内核配置的 <code>Kernel Features -&gt; Preemption Model</code> 中可以选择调度策略：</p><ul><li>No Forced Preemption(Server): 不能被抢占</li><li>Voluntary Kernel Preemption(Desktop): kernel自愿让出</li><li>Preemptible Kernle(Low-Latency Desktop):kernel可以被抢占(嵌入式系统一般都选择此项)</li></ul><h2 id="CPU与I-O平衡"><a href="#CPU与I-O平衡" class="headerlink" title="CPU与I/O平衡"></a>CPU与I/O平衡</h2><p>进程分为两种类型：</p><ul><li>I/O消耗型：更多的是I/O操作，对CPU的占用率低<ul><li>在I/O操作时，一般进程会阻塞的等待，CPU会被让出去</li></ul></li><li>CPU消耗型：更多的操作是在CPU的运算上</li></ul><p>当以红蓝图来显示CPU的消耗如下图：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--schedule/cpu_io.jpg?raw=true"><br>由此可以看出，在调度时，我们应该 <strong>优先调度I/O消耗型</strong> ，以让其尽快响应。</p><ul><li>I/O型的进程消耗时间绝大部分是在I/O设备上，所以其对CPU的性能要求并不高<ul><li>ARM通过big.LITTLE架构来组成4小核和4大核，让小核来做I/O任务，大核做运算任务<ul><li>虽然小核处理能力弱，但其功耗低。而且从宏观上看其性能依然是8核的性能</li></ul></li></ul></li></ul><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>Linux的优先级从0~139，数值越低优先级越高。</p><ul><li>在内核中，设置的值便与优先级一一对应</li><li>在用户空间中，设置的RT值通过公式 <code>99 - priority</code> 来计算真实的优先级(所以在用户空间中，设置的RT值越小优先级反而越低)，而设置的 NICE 值则又是<code>100+20+priority</code>而得到的（这种情况也是 NICE 值越低，优先级越高）。</li></ul><h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>其中0<del>99使用RT策略，100</del>139使用NICE策略。</p><ul><li>关于内核、用户空间、top命令中的优先级显示，参看<a href="https://mp.weixin.qq.com/s/44Gamu17Vkl77OGV2KkRmQ">此文章</a></li></ul><table><thead><tr><th>用户</th><th>内核</th><th>Top</th></tr></thead><tbody><tr><td>RT 50</td><td>49(99-RT)</td><td>-51(-1-RT)</td></tr><tr><td>RT99</td><td>0</td><td>rt</td></tr><tr><td>NICE 5</td><td>125</td><td>25(20+NICE)</td></tr></tbody></table><p>通过上表也可以看出：</p><ol><li><p>使用 Top 看到的优先级，数值越小优先级越高</p></li><li><p>使用 Top 看到的优先级如果小于0 或 rt 则是 RT 策略，否则就是 NICE 策略</p></li></ol><h3 id="RT策略"><a href="#RT策略" class="headerlink" title="RT策略"></a>RT策略</h3><p>RT策略分为 SCHED_FIFO 和 SCHED_RR:</p><ul><li>SCHED_FIFO:霸占CPU，除非自己主动让出<ul><li>在不同优先级的情况下，高优先级的对象先运行， <strong>并且要等待此对象主动释放CPU，其他对象才能依次运行</strong><ul><li>在同优先级下，也是要等待主动释放，所以才称为FIFO(first in first out)策略</li></ul></li></ul></li><li>SCHED_RR:高优先级的对象先运行，同等优先级轮转<ul><li>在不同优先级的情况下，高优先级的对象先运行， <strong>并且要等待此对象主动释放CPU，其他对象才能依次运行</strong><ul><li>在同优先级下，对象轮转运行，所以才称为RR(round-robin)策略</li></ul></li></ul></li></ul><p>可以看出，SCHED_FIFO和SCHED_RR在不同优先级的情况下策略是一样的，区别是在同等优先级的情况下。</p><h3 id="NICE策略"><a href="#NICE策略" class="headerlink" title="NICE策略"></a>NICE策略</h3><ul><li>不同优先级下，高优先级 <strong>可以抢占低优先级运行</strong> ，但 <strong>高优先级不会霸占CPU，而是会被调度器主动剥夺CPU使用权用于低优先级运行</strong><ul><li>虽然是轮转运行，但高优先级可以获得的时间片比低优先级要多</li></ul></li><li>nice值在 -20 ~ +19 对应优先级的 100 ~ 139<ul><li>nice值越高其优先级越低，运行的时间片越少</li><li>默认新建进程的Nice值为0</li></ul></li></ul><h2 id="策略补丁"><a href="#策略补丁" class="headerlink" title="策略补丁"></a>策略补丁</h2><h3 id="RT门限"><a href="#RT门限" class="headerlink" title="RT门限"></a>RT门限</h3><p>根据RT策略来讲如果 RT 里面的线程没有主动让出CPU，那 NICE 策略的进程就无法运行。<br>为此，linux 在 2.6 以后设置了 RT 门限，以设置 RT 策略的进程只能在一个周期里运行确定的时间。</p><p>在 <code>/proc/sys/kernel/</code> 下的 <code>sched_rt_period_us,sched_rt_runtime_us</code> 来设置 period和runtime。</p><ul><li>也就是是在period的时间里，RT进程只能最多运行runtime时间。</li><li>可以通过命令 <code>chrt -f -a -p &lt;prio&gt; &lt;pid&gt;</code> 来改变进程的优先级</li></ul><h3 id="CFS-完全公平调度-NICE策略优化"><a href="#CFS-完全公平调度-NICE策略优化" class="headerlink" title="CFS :完全公平调度(NICE策略优化)"></a>CFS :完全公平调度(NICE策略优化)</h3><ul><li><p>NICE策略下的进程都具有一个权重</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class="line"><span class="comment"> ,* nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class="line"><span class="comment"> ,* nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class="line"><span class="comment"> ,* that remained on nice 0.</span></span><br><span class="line"><span class="comment"> ,*</span></span><br><span class="line"><span class="comment"> ,* The &quot;10% effect&quot; is relative and cumulative: from _any_ nice level,</span></span><br><span class="line"><span class="comment"> ,* if you go up 1 level, it&#x27;s -10% CPU usage, if you go down 1 level</span></span><br><span class="line"><span class="comment"> ,* it&#x27;s +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class="line"><span class="comment"> ,* If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class="line"><span class="comment"> ,* the relative distance between them is ~25%.)</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>虚拟运行时间通过公式计算： <code>vtime = ptime * 1024 / weight</code> (NICE值越大，权重越小，虚拟运行时间越高)</p><ul><li>ptime : 实际运行时间</li><li>weight : 权重</li><li>1024: 对应NICE为0的权重</li></ul></li><li><p>将此虚拟运行时间挂在一颗红黑树上</p></li><li><p>linux首先运行红黑树上值最小的节点，当节点运行其ptime会继续增加</p><ul><li>所有随着时间推移，该节点将不会是最小的节点</li></ul></li></ul><p>基于以上这个逻辑， <strong>I/O型的ptime就比较小，所有它就会被优先调度</strong> ，这就满足了优先运行I/O型进程的初衷。</p><ul><li>可以通过 <code>renice -n &lt;nice_value&gt; -g &lt;pid&gt;</code> 来修改进程的nice值</li><li>可以通过 <code>nice &lt;nice_value&gt; &lt;process&gt;</code> 来启动一个进程并设置nice</li></ul><h2 id="设置API"><a href="#设置API" class="headerlink" title="设置API"></a>设置API</h2><table><thead><tr><th>System Call</th><th>Description</th></tr></thead><tbody><tr><td>nice()</td><td>设置进程的nice值</td></tr><tr><td>sched_setscheduler()</td><td>设置调度策略</td></tr><tr><td>sched_getscheduler()</td><td>获取调度策略</td></tr><tr><td>sched_setparam()</td><td>设置RT策略优先级</td></tr><tr><td>sched_getparam()</td><td>获取RT策略优先级</td></tr><tr><td>sched_get_priority_max()</td><td>得到RT策略最高优先级</td></tr><tr><td>sched_get_priority_min()</td><td>得到RT策略最低优先级</td></tr><tr><td>sched_rr_get_interval()</td><td>得到RR策略时间片参数</td></tr><tr><td>sched_setaffinity()</td><td>设置进程关系</td></tr><tr><td>sched_getaffinity()</td><td>获取进程关系</td></tr><tr><td>sched_yield()</td><td>主动让出CPU</td></tr></tbody></table><p>在pthread库支持下，又封装了一次系统调用，通过 <code>pthread_attr_xxxx</code> 来实现设置。</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>负载均衡是指：尽量让CPU各个核心都均摊处理任务，不能出现1核有难7核围观的情况。</p><ul><li>每个核的处理调度都是以 <code>task_struct</code> 为基本单位的</li><li>核与核之间是通过 push 和 pull 操作来实现任务分配的，在实际运行时一个 <code>task_struct</code> 会在多个核间动态转移<ul><li>通过命令 <code>cat /proc/cpuinfo</code> 获取cpu相关具体信息</li><li>也可以在 <code>top</code> 命令中按下 <code>1</code> 来获取cpu负载</li></ul></li></ul><h2 id="关于运行时间"><a href="#关于运行时间" class="headerlink" title="关于运行时间"></a>关于运行时间</h2><p>一个代码运行时间包括：</p><ul><li>real time: 用户所感受的运行时间</li><li>user time: 代码在user space 运行时间</li><li>kernel time: 代码陷入内核的运行时间，也就是计算通过系统调用所花费的时间</li></ul><p>可以使用命令 <code>time &lt;exec&gt;</code> 来统计一个程序的时间，这个时间的计算依据是根据 <strong>资源为单位</strong> 计算的：</p><ul><li>当一个程序 fork() 出一个进程，那么一共就有两个进程，对应两个 <code>task_struct</code> 的同时也对应两份资源，所以通过 time 来计算的real time 和 user time 是一致的</li><li>当一个程序 create() 出一个线程，那么一共对应两个 <code>task_struct</code> 但只有一份资源，那么在多核上跑时，通过 time 计算的 user time 是 real time 的两倍</li><li>在路径 <code>/proc/&lt;pid&gt;/task/</code> 下可以查看具体的 <code>task_struct</code> 信息</li></ul><p>通过以下实例可以验证:</p><ul><li>共享一份资源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> syscall(__NR_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, thread pid = %d, thread_self = %d\n&quot;</span>,</span><br><span class="line">         getpid(), gettid(), pthread_self());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">  <span class="comment">//pthread_self() 是用户空间库所创建的ID，内核不可见</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, man thread pid = %d,man thread_self = %d\n&quot;</span>,</span><br><span class="line">         getpid(), gettid(), pthread_self());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每个 <code>task_struct</code> 对应一份资源</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get sig_handler = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;wait signal failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">        <span class="keyword">if</span>(WCOREDUMP(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not to be a subreaper!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;childl-&gt; %d parent pid is %d\n&quot;,getpid(), getppid());</span></span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//if(signal(SIGCHLD,sig_handler) == SIG_ERR)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//perror(&quot;wait signal error:&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同策略下的负载均衡"><a href="#不同策略下的负载均衡" class="headerlink" title="不同策略下的负载均衡"></a>不同策略下的负载均衡</h2><ul><li>RT策略下的负载均衡就按照其优先级依次分配到几个核心</li><li>NICE策略下的负载均衡是在系统tick时动态分配到核心上</li><li>当一个核心空闲时，也会主动pull任务</li><li>当有上层调用，最终新建了 <code>task_struct</code> 后，内核也会根据CPU的负载情况主动分配到空闲核心上</li></ul><h2 id="主动修改负载"><a href="#主动修改负载" class="headerlink" title="主动修改负载"></a>主动修改负载</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setaffinity_np</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getaffinity_np</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> cpusetsize, <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> cpusetsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> cpusetsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">cpu_set_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mask 即为CPU掩码，比如03(16进制)，代表运行于核心0和核心1</span></span><br><span class="line">taskset -a -p &lt;mask&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="中断负载均衡"><a href="#中断负载均衡" class="headerlink" title="中断负载均衡"></a>中断负载均衡</h2><p>除了 <code>task_struct</code> 任务会消耗CPU外，中断和软中断的执行也会消耗CPU，为了能够让多个核能够处理中断所以有时需要做负载均衡(比如将网卡多个fifo均衡到多个核上以提高吞吐量)。</p><ul><li>其优先级为 中断 &gt; 软中断 &gt; 调度</li><li>通过命令 <code>cat /proc/interrupts</code> 可以查看硬中断全局概览</li><li>通过命令 <code>cat /proc/softirqs</code> 查看软中断概览</li><li>通过命令 <code>cat /proc/irq/&lt;num&gt;/smp_affinity</code> 查看对应 <num> 中断目前的均衡设置，然后以 <code>echo &lt;mask&gt; /proc/irq/&lt;num&gt;/smp_affinity</code> 来设置新的值</li></ul><h3 id="软中断负载均衡"><a href="#软中断负载均衡" class="headerlink" title="软中断负载均衡"></a>软中断负载均衡</h3><p>当一个核中断发生后，其对应的软中断也必须由此核调用，但如果处理量太大则可以将此核的处理任务再次均分到其他核以快速处理提高吞吐量。</p><ul><li>在网络上通过 <code>echo &lt;mask&gt; &gt; /sys/class/net/eth1/queues/rx-0/rps_cpus</code> 来打开此功能</li></ul><h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>将 <code>task_struct</code> 进行分组为多个 group，Linux 再以 group 为单位对其进行均衡。</p><h3 id="创建group操作流程"><a href="#创建group操作流程" class="headerlink" title="创建group操作流程"></a>创建group操作流程</h3><ul><li>进入路径 <code>/sys/fs/cgroup/</code></li><li>新建组名文件 <code>mkdir &lt;group name&gt;</code><ul><li>进入文件后发现有 <code>cgroup.procs</code> 用于存储组类成员的pid， <code>cpu.max</code> 存储此组的权重<ul><li>修改权重可以修改此组的CPU占用率,越大占用率越高</li></ul></li></ul></li><li>使用 <code>echo &lt;pid&gt; &gt; cgroup.procs</code> 加入成员到组</li></ul><h3 id="限制cpu使用率-配额-操作流程"><a href="#限制cpu使用率-配额-操作流程" class="headerlink" title="限制cpu使用率(配额)操作流程"></a>限制cpu使用率(配额)操作流程</h3><ul><li>基于上面的基础上，进入此组，先 <code>cat cpu.cfs_periods_us</code> 查看设置的 period 时间</li><li>然后 <code>echo &lt;value&gt; cpu.cfs_quota_us</code> 来设置其在period中的占空比<ul><li>当 <code>cfs_quota_us</code> 的值大于 <code>cfs_periods_us</code> 时，内核会分配多于的CPU来处理此任务</li></ul></li></ul><h1 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h1><p>硬实时操作系统需要：无论当前系统在做什么事，调度器 <strong>都可以在要求的时间内完成任务切换，这一切都是可以预期的。</strong></p><p>而Linux内核在中断，软中断，spinlock等情况下都无法完成调度切换，这个时间是无法预期的，所以其是一个软实时系统。<br>也就是说，系统只保证尽快的完成切换而已。</p><h2 id="实时补丁"><a href="#实时补丁" class="headerlink" title="实时补丁"></a>实时补丁</h2><p>在 <a href="https://wiki.linuxfoundation.org/realtime/start"></a> 给出了实时补丁（需要手动merge到代码中,然后在menuconfig 中配置）。</p><p>此补丁做了如下改动：</p><ul><li>将中断和软中断都修改为线程</li><li>将不可调度锁修改为可调度锁</li></ul><p>这样系统在任何时候都是可以调度的，以此来提高切换速度。</p><blockquote><p>但由于 Linux 存在内存申请的 Lazy 机制等等，所以仍然无法做到硬实时。</p></blockquote><p>替代方案： rt thread + linux</p>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="process" scheme="http://kcmetercec.top/categories/linux/process/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/process/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下进程和线程的基本概念及操作</title>
    <link href="http://kcmetercec.top/2024/08/31/linux_process_hello/"/>
    <id>http://kcmetercec.top/2024/08/31/linux_process_hello/</id>
    <published>2024-08-30T16:00:00.000Z</published>
    <updated>2024-08-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>首先需要明确的是：进程是资源分配的基本单位，线程是调度的基本单位。同一进程里的线程之间共享进程的资源。</p><h2 id="进程的表示"><a href="#进程的表示" class="headerlink" title="进程的表示"></a>进程的表示</h2><p>在Linux内核中，使用结构体(PCB) <code>task_struct</code> （位于 include/linux/sched.h）来表明一个进程，其中不仅包括了此进程的资源，还有其状态、优先级等参数。</p><p>此结构体中就包含了内存资源、文件系统路径、打开的文件资源等：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> users;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//指定了根路径以及当前路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open file table structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">bool</span> resize_in_progress;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> resize_wait;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> next_fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储打开的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="进程的限制"><a href="#进程的限制" class="headerlink" title="进程的限制"></a>进程的限制</h2><p>系统中可以创建的进程总数是有限的，同理单个用户可以创建的进程数也是有限的。</p><ul><li>用户可以使用 <code>ulimit -u</code> 查看限制的进程数，也可以使用 <code>getrlimit(),setrlimit()</code> 来得到或设置资源</li><li>在<code>/proc/sys/kernel/pid_max</code>中表示了整个系统的进程限制</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getrlimit(RLIMIT_NPROC, &amp;rl) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not get the limit of process!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rl.rlim_cur == RLIM_INFINITY) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the maximum number of process is unlimit!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The limit number of process is %lu, and the hardware maxinum number of process is %lu\n&quot;</span>,</span><br><span class="line">           rl.rlim_cur, rl.rlim_max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork-bomb"><a href="#fork-bomb" class="headerlink" title="fork bomb"></a>fork bomb</h3><p>由于系统的进程是有限的，如果无限制的创建进程，那最终将导致进程被耗光，也就相当于系统资源被消耗完而出现系统死掉的现象。</p><blockquote><p> <a href="https://en.wikipedia.org/wiki/Fork_bomb">fork bomb</a> 就是基于这个原理做出来的。</p></blockquote><h3 id="android-提权漏洞"><a href="#android-提权漏洞" class="headerlink" title="android 提权漏洞"></a>android 提权漏洞</h3><p><a href="https://blog.csdn.net/feglass/article/details/46403501">提权漏洞</a> 就是因为pid会被恶意消耗完，而代码没有检查自己降权成功而导致的root权限问题。</p><h2 id="进程的链接"><a href="#进程的链接" class="headerlink" title="进程的链接"></a>进程的链接</h2><p>Linux内核以三种数据结构来链接进程PCB：</p><ul><li>链表 ： 用于遍历所有进程</li><li>树 ： 用于查看进程的继承关系<ul><li>使用命令 <code>pstree</code> 可以查看进程的树形结构</li></ul></li><li>哈希表 ： 用于快速查找出进程</li></ul><h2 id="进程的树形结构"><a href="#进程的树形结构" class="headerlink" title="进程的树形结构"></a>进程的树形结构</h2><p>进程是以树的形式创建的，也是基于这个关系使得父进程可以监控子进程。</p><ul><li>当子进程意外退出后，父进程可以获取其退出的原因并且重新启动它。</li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--basic/linux_process_life_cycle.jpg?raw=true"><br><strong>注意：</strong></p><ol><li>Linux的调度算法仅针对就绪态和运行态的调度!</li><li>内核以 <code>task_struct</code> 为单位进行调度!</li></ol><h3 id="理解僵死态"><a href="#理解僵死态" class="headerlink" title="理解僵死态"></a>理解僵死态</h3><p>僵死态就是进程已经退出， <strong>其占有的资源已经被释放，但父进程还没有清理其PCB时的一个状态</strong>。</p><p>当父进程清理子进程PCB后(通过 <code>waitpid</code> 实现)，那么对于该进程的所有痕迹都被清除了。</p><ul><li>只要进程一退出，其所占有的所有资源都被释放了，所以不用担心代码里面动态申请的内存还未来得及释放</li><li>如果父进程没有清理子进程，那么其最后的PCB就代表它的尸体存在。<ul><li>可以通过 <code>ps -aux</code> 命令来查看其状态。</li></ul></li></ul><p>可以通过以下代码来理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_CHILD_PID 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CLEAR_CHILD_PID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, i get child pid is %d\n&quot;</span>, child_pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">            <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                    WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到:</p><ul><li>当父进程使用 <code>waitpid()</code> 时，外部使用 <code>kill</code> 命令后，使用 <code>ps -aux</code> 看不到子进程的任何痕迹</li><li>当父进程没有使用 <code>waitpid()</code> 来清除子进程的僵死态时，使用 <code>ps -aux</code> 看到其状态是 <code>Z+</code> 。<ul><li>当父进程被终止后，其僵死态也消失了。</li></ul></li></ul><h3 id="理解内存泄露"><a href="#理解内存泄露" class="headerlink" title="理解内存泄露"></a>理解内存泄露</h3><p>根据上面对僵死态的理解，可以知道 <strong>只要进程退出，就会释放其所占的资源，也就没有所谓的内存泄露</strong></p><p>内存泄露指的是： <strong>在进程运行时</strong>其所占用的内存随着时间的推移在震荡的上升。</p><ul><li>正常的进程所占用的内存应该是在一个平均值周围震荡。</li></ul><h3 id="理解停止态"><a href="#理解停止态" class="headerlink" title="理解停止态"></a>理解停止态</h3><p>停止态用于 <strong>主动暂停进程</strong>，有点类似于给这个进程打了一个断点（此进程已经不占用CPU资源）。在需要其运行的时候，又可以让其继续运行。</p><ul><li><p>睡眠是进程没有获取到资源而 <strong>主动让出CPU</strong></p></li><li><p>在shell中可以使用 <code>Ctrl + Z</code> 来让一个进程进入停止状态，使用 <code>fg</code> 来让其再次前台运行， <code>bg</code> 进入后台运行</p><ul><li>也可以使用 <code>cpulimit</code> 命令来限制某个进程的利用率，其内部就是在让进程间歇性的进入停止态以控制其CPU利用率</li></ul></li></ul><h3 id="理解睡眠"><a href="#理解睡眠" class="headerlink" title="理解睡眠"></a>理解睡眠</h3><p>当一个进程在等待资源时便会进入睡眠态，一般情况下都会设置为浅度睡眠，只有在读写块设备这种情况才会深度睡眠。</p><p>睡眠的底层实现，是将 <code>task_struct</code> 放入等待队列中，然后在接收到信号或资源可用来唤醒此队列中的一个进程。</p><p>如下面的示例代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalfifo_dev</span> *<span class="title">dev</span> =</span> container_of(filp-&gt;private_data,</span><br><span class="line">    struct globalfifo_dev, miscdev);</span><br><span class="line"></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (dev-&gt;current_len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()的作用是在一个进程的基础上为其分裂出一个子进程，其内部是为子进程单独分配了一个 <code>task_struct</code> 的PCB。</p><p>此时两个进程分别通过fork()来返回，父进程中fork()返回子进程的pid，子进程中的fork()返回0。</p><h3 id="父进程与子进程资源-gt-fork"><a href="#父进程与子进程资源-gt-fork" class="headerlink" title="父进程与子进程资源-&gt;fork()"></a>父进程与子进程资源-&gt;fork()</h3><p>当父进程通过 fork() 创建子进程时，子进程除了拥有一个PCB外，也具有与父进程 <strong>一样的资源</strong> （内存、文件系统、文件、信号等）。</p><p>在接下来的过程中，父子进程可以分别单独的修改自己的资源，二者并不会冲突。 </p><p>在实现逻辑的过程中，<strong>内存资源</strong>的分离是基于 <strong>具有MMU支持的COW技术</strong> 来实现的。</p><ul><li>在 fork() 前，内存资源是可读可写的</li><li>在 fork() 后二者的内存资源都 <strong>变为只读</strong> 的，此时父子进程对应内存的虚拟地址和物理地址都是一致的</li><li>父或子进程的其中一个修改内存时，便会触发MMU的 pagefault</li><li>然后内核会为此进程访问的内存重新申请页表，让其对应到另一个物理地址</li><li>最后父子进程虽然虚拟地址一样，但它们对应的物理地址就不一样了，并且它们的内存资源权限又恢复为可读可写了</li><li>最终此进程的内存修改才正式生效（Linux 会修改 PC 指针重新到写的那部分代码，这次写才会有效）</li></ul><p>所有在内存分离时，最开始的操作是比较耗时的！</p><p>验证内存分离的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;fork() failed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: val = %d\n&quot;</span>, val);</span><br><span class="line">        val *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: val = %d\n&quot;</span>, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, val  = %d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父进程与子进程资源-gt-vfork"><a href="#父进程与子进程资源-gt-vfork" class="headerlink" title="父进程与子进程资源 -&gt; vfork()"></a>父进程与子进程资源 -&gt; vfork()</h3><p>当硬件中没有MMU支持时，父进程通过vfork()来创建子进程，子进程拥有一个新的PCB，此时二者是具有 <strong>完全一样的内存资源（但文件系统、文件、信号等资源是分离的）</strong> ，且 <strong>无法完成内存分离</strong> 。</p><ul><li>所以，无论是父还是子修改了内存，这些修改对于另一方是可见的</li><li>如果子进程没有退出，父进程是无法运行的。</li></ul><h3 id="父进程与子进程资源-gt-clone"><a href="#父进程与子进程资源-gt-clone" class="headerlink" title="父进程与子进程资源 -&gt; clone()"></a>父进程与子进程资源 -&gt; clone()</h3><p>父进程通过clone()来创建子进程，子进程拥有一个新PCB，此时二者是具有 <strong>完全一样的所有资源，也就是共享所有资源</strong> ， 那就是一个线程了!</p><ul><li>子进程的资源指针直接指向父进程的资源</li><li>pthread_create()的底层就是由clone()所支持的</li></ul><h2 id="孤儿"><a href="#孤儿" class="headerlink" title="孤儿"></a>孤儿</h2><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_CHILD_PID 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;check parent pid...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;My parent pid is %d\n&quot;</span>, getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CLEAR_CHILD_PID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, i get child pid is %d\n&quot;</span>, child_pid);</span><br><span class="line">        <span class="keyword">if</span>(waitpid(child_pid, &amp;status, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">            <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                    WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码查看，当kill掉父进程以后，子进程的 parent pid 会变为另外一个进程的pid。</p><ul><li>此父进程有可能是init进程，也可能是具有subreaper属性的进程。<ul><li>这要根据子进程是否挂接在各自的链表中<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--basic/orphan.jpg?raw=true"><h3 id="subreaper"><a href="#subreaper" class="headerlink" title="subreaper"></a>subreaper</h3></li></ul></li></ul><p>subrepaer 是在3.4后引入的，当将进程设置为 repaer 时需要注意wait子进程，以回收它的PCB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get sig_handler = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;wait signal failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">        <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not to be a subreaper!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;childl-&gt; %d parent pid is %d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(signal(SIGCHLD,sig_handler) == SIG_ERR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;wait signal error:&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根进程"><a href="#根进程" class="headerlink" title="根进程"></a>根进程</h2><p>Linux在启动的过程会创建进程0，此进程0会创建init进程1，此后所有的进程都是挂接在init进程下的。</p><p>进程0在完成创建init进程后，会设置自己的优先级为最低，也就是将自己退化成了idle进程。<br>当其他进程都不占有CPU时，idle进程会运行，并将CPU置为低功耗模式。<br>当接收到中断后，如果有其他进程调度便又会将CPU让给其他进程。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>由上面的 <code>clone()</code> 可以看出：在Linux中创建线程实际上在内核也会位置分配一个 <code>task_struct</code> ，但它们的资源都指向同一个地址。<br>而 <code>task_struct</code> 中具有pid，这样在创建线程的同时也创建了多个pid。</p><h2 id="tgid"><a href="#tgid" class="headerlink" title="tgid"></a>tgid</h2><p>为了符合操作系统中关于线程的要求：一个进程中的多个线程所访问的pid都是一致的。</p><p>Linux内核使用 TGID(thread group ID)，来使得上层调用 <code>getpid()</code> 时获取的pid，都是最初此进程的pid，而其他的pid被掩盖了。</p><ul><li>可以在shell中访问 <code>/proc/[pid]/task/</code> 中看到几个被掩盖的pid<ul><li>也可以使用 <code>top -H</code> 来查看各个线程对应的Pid</li></ul></li><li>在编程时，使用系统调用 <code>syscall(__NR_gettid)</code> 来获取自己真实的pid</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> syscall(__NR_gettid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, thread pid = %d, thread_self = %d\n&quot;</span>,</span><br><span class="line">       getpid(), gettid(), pthread_self());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="comment">//pthread_self() 是用户空间库所创建的ID，内核不可见</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, man thread pid = %d,man thread_self = %d\n&quot;</span>,</span><br><span class="line">       getpid(), gettid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内存应用</title>
    <link href="http://kcmetercec.top/2024/08/18/linux_memory_usage/"/>
    <id>http://kcmetercec.top/2024/08/18/linux_memory_usage/</id>
    <published>2024-08-17T16:00:00.000Z</published>
    <updated>2024-08-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>课程: 宋宝华老师的内存管理</p><p>理解了内存概念后再来看应用方面的知识就会比以前深入得多。</p><table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="memory-cgroup"><a href="#memory-cgroup" class="headerlink" title="memory cgroup"></a>memory cgroup</h1><p>linux通过 cgroup 对系统中的3大资源： 内存资源，I/O资源,进程占用CPU资源。都可以为它们加入各自的组，进行对应的资源限制。</p><p>对内存的限制就称为memroy cgroup。</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>编写测试代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 2000</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span>*SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc buffer : %p\n&quot;</span>, p);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>*<span class="number">1024</span>*(SIZE/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">      p[i] = <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">if</span>((i&amp;<span class="number">0xfffff</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%dMB written\n&quot;</span>, i &gt;&gt; <span class="number">18</span>);</span><br><span class="line">          usleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  pause();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭swap分区</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="meta">#</span><span class="bash">允许应用程序申请内存</span></span><br><span class="line">echo 1 &gt; /proc/sys/vm/overcommit_memory</span><br><span class="line"><span class="meta">#</span><span class="bash">进入memory cgroup 并创建 group</span></span><br><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">mkdir A</span><br><span class="line">cd A</span><br><span class="line"><span class="meta">#</span><span class="bash">限制此group可以使用的最大内存为200M</span></span><br><span class="line">echo $((200*1024*1024)) &gt; memory.limit_in_bytes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加进程到memory group A,并运行</span></span><br><span class="line">sudo cgexec -g memory:A ./a.out</span><br><span class="line"><span class="meta">#</span><span class="bash">可以发现其申请到200M内存时就被系统<span class="built_in">kill</span>掉了</span></span><br></pre></td></tr></table></figure><h1 id="脏页的写回"><a href="#脏页的写回" class="headerlink" title="脏页的写回"></a>脏页的写回</h1><p>内存中脏页写回到硬盘，是由内核来完成的，它需要考虑时间和空间的维度。</p><ul><li>时间：脏页在内存中待的时间需要合适<ul><li>如果太长则提高了掉电丢数据的概率</li><li>如果太短则会由于写硬盘操作过于频繁而降低系统的处理能力</li></ul></li><li>空间维度：脏页在内存中所占的比例不能太高<ul><li>如果太高则一次写硬盘的时间太长，当其他进程需要内存时则需要等待这个操作完成</li></ul></li></ul><h2 id="时间配置"><a href="#时间配置" class="headerlink" title="时间配置"></a>时间配置</h2><ul><li><code>/proc/sys/vm/dirty_expire_centisecs</code> : 此文件配置当脏页存在的时间超过此值时，则会触发写回操作<ul><li>最终的时间计算是: <code>值 * 10ms</code></li></ul></li></ul><h2 id="空间配置"><a href="#空间配置" class="headerlink" title="空间配置"></a>空间配置</h2><ul><li><code>/proc/sys/vm/dirty_background_ratio</code> : 当进程写的脏页比例超过此值时，内核将触发写回操作<ul><li>此时有可能进程还依然在产生脏页</li></ul></li><li><code>/proc/sys/vm/dirty_ratio</code> : 当进程写的脏页比例超过此值时，内核将禁止进程产生脏页<ul><li>此时进程这部分操作就被停止了，所以 <code>dirty_ratio</code> 的值大于 <code>dirty_background_ratio</code> 的值</li></ul></li></ul><h1 id="内存回收原则"><a href="#内存回收原则" class="headerlink" title="内存回收原则"></a>内存回收原则</h1><p>正常情况下，当内存不够用时，内核会将内存中的 <code>file-backed pages</code> 和 <code>anonymous pages</code> 进行swap。</p><ul><li><code>/proc/sys/vm/min_free_kbytes</code> : 决定了内存中无论如何都要保持的最小空闲内存。<ul><li>这段内存是为了用于运行系统紧急处理时所需要的进程。<ul><li>申请紧急内存使用标志位 <code>PF_MEMALLOC</code></li></ul></li><li><code>min_free_kbytes = 4 * sqrt(lowmem_kbytes); //lowmem_kbytes指的是低端内存所占用的kb</code></li></ul></li></ul><p>当 <code>min_free_kbytes</code> 被确定后， <code>dma_zone</code>, <code>normal_zone</code>, 会根据此值计算它们的水位。</p><ul><li>dma_min = dma_zone_size / (dma_zone_size + normal_zone_size) * min_free_kbytes<ul><li>低水位: low = dma_min * 125%</li><li>高水位: high = dma_min * 150%</li></ul></li><li>normal_min = normal_zone_size / (dma_zone_size + normal_zone_size) * min_free_kbytes<ul><li>低水位: low = normal_min * 125%</li><li>高水位: high = normal_min * 150%</li></ul></li></ul><p>基于上面的公式，这样 <code>dma_zone</code> 和 <code>normal_zone</code> 都会具有 min,low,high 3个值，作用分别如下：</p><ul><li>min : 当内存到此值，内核在应用程序的进程上下文进行回收内存(direct reclaim)，会阻塞应用</li><li>low : 当内存到此值，内核的 <code>kswapd</code> 服务启动内存回收(reclaim),不会阻塞应用</li><li>high : 当内存到此值，内核停止内存回收</li></ul><p>可以看出这个工作机制和脏页写回机制类似。</p><p><strong>但是脏页写回的触发条件是以脏页的时间或空间为基准的，而内存回收则是以内存不够用为基准触发条件的。</strong></p><h1 id="swap空间触发时机"><a href="#swap空间触发时机" class="headerlink" title="swap空间触发时机"></a>swap空间触发时机</h1><p>swappiness 反映是否积极的使用swap空间(也就是swap anonymous pages)，其设定值位于 <code>/proc/sys/vm/swappiness</code> 文件中。</p><p>根据其取值来决定:</p><ul><li>0 : 仅在内存不足的情况下使用swap空间<ul><li>也就是空闲的内存和file-backed页空间之和小于zone的 high 水位之时</li></ul></li><li>60 : 默认值</li><li>100 : 积极的使用swap空间</li></ul><p>某个进程也可以通过系统调用 <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> 来禁止内核对此进程的所占用的一切内存空间进行swap，可以提高该进程在内存应用上的是实时性。</p><h1 id="获取进程延迟"><a href="#获取进程延迟" class="headerlink" title="获取进程延迟"></a>获取进程延迟</h1><p><code>Documentation/accounting/getdelays.c</code> 工具用于测量调度、I/O、swap、Reclaim延迟。</p><p>此代码是一个独立代码不是内核模块，所以可以将其直接通过gcc编译。</p><p>使用格式为: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&lt;<span class="built_in">exec</span>&gt;即为可执行文件名</span></span><br><span class="line">./getdelays -d -c &lt;exec&gt;</span><br></pre></td></tr></table></figure><h1 id="获取系统的动态情况"><a href="#获取系统的动态情况" class="headerlink" title="获取系统的动态情况"></a>获取系统的动态情况</h1><p>vmstat 可以展现给Linux的CPU使用率、内存使用、虚拟内存交换情况、I/O读写情况等。</p><ul><li>vmstat <period> : <period> 代表每隔几秒刷新一次监控情况</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;课程: 宋宝华老师的内存管理&lt;/p&gt;
&lt;p&gt;理解了内存概念后再来看应用方面的知识就会比以前深入得多。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内存与I/O交换</title>
    <link href="http://kcmetercec.top/2024/08/17/linux_memory_overview_memio/"/>
    <id>http://kcmetercec.top/2024/08/17/linux_memory_overview_memio/</id>
    <published>2024-08-16T16:00:00.000Z</published>
    <updated>2024-08-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h1><p>计算机硬件系统中具有 cache 来缓存内存中的一部分内容以达到CPU的快速访问。</p><p>而在软件逻辑上，操作系统可以为硬盘中的文件做一个cache到内存，而避免频繁的IO操作以提高访问效率。</p><ul><li>之所以称为 page cache，是因为内存申请都是以页为基本单位的</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/why_pagecache.jpg?raw=true"><br>那么在Linux上读写文件的逻辑就是：</p><ol><li>当读取文件内容时，首先检查此内容是否在内存命中，如果命中则直接从内存读取，如果不命中就从硬盘读取并更新 pagecache.</li><li>当写文件内容时，首先将内容写入内存中，内核在合适的时候将内存的内容更新到硬盘。</li><li>使用 mmap 将内核中的page cache地址映射到用户空间，用户空间可以直接通过指针来访问。<ul><li>mmap 由于是直接的内存映射操作，所以其操作效率很高。(不需要再通过copy与内核交互)</li><li>代码段就是通过 mmap 的方式将其映射，并以指针的方式执行，其本质也是 page cache。</li></ul></li></ol><p>通过以下方式来观察page cache:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清空cache</span></span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line">\time -v python ./hello.py #注意：运行的代码需要文件关联够多，才比较容易看出效果,推荐python</span><br><span class="line"><span class="meta">#</span><span class="bash">第一次运行此命令，可以发现其产生了major page faults，代表有硬盘的文件交互</span></span><br><span class="line"></span><br><span class="line">\time -v python ./hello.py</span><br><span class="line"><span class="meta">#</span><span class="bash">第二次运行此命令，可以发现其major page faults 计数为0，代表是直接从内存读，且运行时间远短于第一次</span></span><br></pre></td></tr></table></figure><h2 id="page-cache-的表现形式"><a href="#page-cache-的表现形式" class="headerlink" title="page cache 的表现形式"></a>page cache 的表现形式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/pagecache_mode.jpg?raw=true"><br>由上图可以看出，page cache有两种不同的表现形式:</p><ul><li>cached : 当用户以文件的方式来进行 I/O 操作，这时对文件的 page cache 就称为cached<ul><li><strong>在文件系统底层会将 inode 这些元数据放入 buffers，而将文件block放入 cached</strong></li></ul></li><li>buffers: 当用户以设备的方式来访问分区进行I/O操作时，这时对分区的 page cache 就称为buffers</li></ul><p>在 <code>cat /proc/meminfo</code> 和 <code>free</code> 中都可以看到这两项数据报告。</p><h2 id="free-显示说明"><a href="#free-显示说明" class="headerlink" title="free 显示说明"></a>free 显示说明</h2><p>free 命令的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       2063720     483316    1580404       7292       6564     170096</span><br><span class="line">-/+ buffers/cache:     306656    1757064</span><br><span class="line">Swap:       522236          0     522236</span><br></pre></td></tr></table></figure><ul><li>第一行说明:<ul><li>total = <code>used + free (以buddy的角度来计算整体)</code></li><li>buffers = <code>以裸分区方式访问 + 文件系统的元数据所缓存的page cache</code></li><li>cached = <code>以文件方式访问所缓存的page cache</code></li></ul></li><li>第二行说明:(比较新的free命令已经取消了此行，改用 available 参数来预估系统可用的内存)<ul><li>used = <code>第一行used - buffers - cached</code><ul><li>buffers 和 cached 所使用掉的page cache是可以释放掉的</li></ul></li><li>free = <code>第一行free + buffers + cached</code><ul><li>同理，实际上还可以通过释放 buffers 和 cached 获取空间内存</li></ul></li></ul></li></ul><h1 id="file-backed-和-anonymous-page"><a href="#file-backed-和-anonymous-page" class="headerlink" title="file-backed 和 anonymous page"></a>file-backed 和 anonymous page</h1><ul><li>file-backed pages : 称为有文件背景的page cache，指的是在硬盘中有对应的文件，为了提高执行效率，内存读取了一段作为副本<ul><li>当内核需要更多的内存时，这些 file-backed pages 可以被取消映射而不会影响进程的正常执行(<strong>这个动作称为swap</strong>)<ul><li>当然，文件内容如果被修改了肯定是会写回到文件的</li></ul></li></ul></li><li>anonymous pages : 称为匿名页,指的是在运行过程中所产生的栈、堆等所占用的页面，虚拟地址空间与硬盘的文件没有映射关系<ul><li>这些匿名页是无法回收到硬盘对应文件中的,为了让出更多的内存就只有将硬盘一部分分区作为单独存放anonymous pages的位置， <strong>这个就是swap分区(也就是将匿名页swap到swap分区)</strong> 。<ul><li>windows中与之相对的概念就是 <strong>虚拟内存</strong></li></ul></li></ul></li></ul><h2 id="linux内核中的swap动作"><a href="#linux内核中的swap动作" class="headerlink" title="linux内核中的swap动作"></a>linux内核中的swap动作</h2><p>linux内核使用LRU(Least Recently Used)算法来实现将 <code>file-backed</code> 和 <code>annoymous pages</code> swap到对应分区中,将最近最少使用的内存页swap出去.</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/LRU.jpg?raw=true"><br>上图来自链接:<a href="https://xuri.me/2016/08/13/lru-and-lfu-cache-algorithms.html"></a></p><p><strong>linux内核通过软件实现LRU算法置换内存页到硬盘，而CPU内部的硬件cache与内存之间也是通过LRU算法实现的置换，只不过这是硬件实现的。</strong></p><h2 id="zRAM-Swap"><a href="#zRAM-Swap" class="headerlink" title="zRAM Swap"></a>zRAM Swap</h2><p>虽然将硬盘的一个分区作为swap分区可以变相增大内存，但当进程切换的时候会导致硬盘被频繁的读写。</p><ul><li>在嵌入式系统上频繁擦写flash会导致其寿命大大降低</li></ul><p>为了改善这种情况，linux提供了zRAM 算法:</p><ul><li>将物理内存中分一小块分区作为swap分区</li><li>CPU将要被置换的页面 <strong>压缩</strong> 以后放入这个swap分区<ul><li>这样也相当于增加了一部分内存</li></ul></li><li>当进程要切换回来时，CPU再解压缩swap分区</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/ZRAM.jpg?raw=true"></p>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程(用户空间)内存的消耗与泄露</title>
    <link href="http://kcmetercec.top/2024/08/16/linux_memory_consume/"/>
    <id>http://kcmetercec.top/2024/08/16/linux_memory_consume/</id>
    <published>2024-08-15T16:00:00.000Z</published>
    <updated>2024-08-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><p>理解进程(用户空间)对内存的消耗和泄露，可以更好的监控用户空间内存。</p><p>通过前面的说明，可以知道用户空间获得的内存都是lazy机制，但在用户空间中的虚拟地址却是认为已经被全部分配了，那么这些地址空间是如何表示的呢？</p><p>同时用户空间中有很多的共享内存(比如代码段)，这些又是如何表示的呢？</p><ul><li>VSS(virtual set size)</li><li>RSS(resident set size)</li><li>PSS(proporitional set size)</li><li>USS(unique set size)</li></ul><h1 id="一个进程的内存表示"><a href="#一个进程的内存表示" class="headerlink" title="一个进程的内存表示"></a>一个进程的内存表示</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/vma_struct.jpg?raw=true"><br>上面这幅图就表明了一个进程所占用的虚拟内存资源的表示形式，下面进行一一说明。</p><p>在进程表示的结构体 <code>task_struct</code> 中包含了结构 <code>mm_struct</code> 的指针，以总体表示该进程占用的虚拟内存资源。</p><ul><li><code>pgd</code> 代表该进程的页表</li><li><code>struct vm_area_struct *mmap</code> 将进程整个VMA给链接起来了</li></ul><p>mmap是一个指向 <code>vm_area_struct</code> 结构的链表，每一个节点(称为VMA)都表示了该进程的<strong>合法虚拟地址空间</strong>,进程每申请一段虚拟内存都会有一个节点与之对应。</p><ul><li>虽然实际分配内存是lazy机制，但进程的VMA中已经包含了该进程所有的代码段、数据段等全部地址范围<ul><li>所以站在程序员(虚拟空间的角度)，一个程序在最开始运行时它就被全部加载到了内存</li></ul></li><li><code>vm_start,vm_end</code> 表示一段虚拟地址的起始和结束</li><li><code>vm_page_prot</code> 表示了这段地址的访问权限</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/vma_code.jpg?raw=true"><br>正是因为有了这些合法虚拟地址节点，内核才可以判断出：在后期的操作中，当进程写该段空间时，对产生的pagefault进行对应的处理。</p><ul><li>比如是用户<strong>首次对申请的堆进行写(其VMA权限是可读可写,但其页表是只读的)</strong> ，处理pagefault应该是申请物理地址并修改其页表<ul><li>minor page fault:只发生内存申请操作</li></ul></li><li>如果是对其只读空间(比如代码段)进行写(<strong>其VMA权限和页表都是只读的</strong>)，处理pagefault应该是杀死进程并抛出segmentatoin fault信号。</li><li>如果是要执行代码，刚开始代码还没有存在内存中，这时产生pagefault，内核检查这部分是<strong>可执行的权限</strong>，然后将一部分代码段从硬盘读取到内存并修改页表。<ul><li>major page fault：不仅要申请内存还要发生IO操作，从硬盘读</li></ul></li><li>如果访问的虚拟地址并没有落在任何一个VMA中，那就是一段非法地址了，内核也会kill进程并抛出segmentation fault信号</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/pagefault.jpg?raw=true"></p><h2 id="vma的查看"><a href="#vma的查看" class="headerlink" title="vma的查看"></a>vma的查看</h2><p>在查看进程的vma前，首先就是要知道其pid，可以通过 <code>ps -aux</code> 或 <code>pidof</code> 来找出 pid.</p><p>有以下3种方式查看vma：</p><ol><li>使用 <code>pmap &lt;pid&gt;</code> </li><li>使用 <code>cat /proc/&lt;pid&gt;/maps</code> </li><li>使用 <code>cat /proc/&lt;pid&gt;/smaps | more</code><ul><li>此种方式最为详细</li></ul></li></ol><h1 id="多个进程在内存条中的分配"><a href="#多个进程在内存条中的分配" class="headerlink" title="多个进程在内存条中的分配"></a>多个进程在内存条中的分配</h1><p>从上面的理解可以知道，每个进程的vma都表示了自己所独自占用的虚拟地址空间， <strong>但实际上只有部分被加载到了物理内存</strong> 。</p><p>当有多个进程时，一个物理内存上有具有多个进程加载的一部分，这些多个进程是如何瓜分内存条的呢？</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/multiprocess_mem.jpg?raw=true"><br>由上图可以看出：</p><ol><li>每个进程的虚拟地址空间都认为自己独占整个系统内存资源</li><li>每个进程都具有一个页表，在进程切换的时候也会发生页表切换，页表的基地址会给MMU</li><li>页表将每个进程对应的物理地址进行映射，其中具有相同代码段的进程其物理地址是一样的，虽然虚拟地址可能不一样<ul><li>在多核架构上，每个核都有一个MMU可以实现一一映射，之间并不冲突</li></ul></li></ol><p>基于上图，就可以再次来看内存消耗表示的几个概念了:</p><ul><li>VSS(Virtual set size) : 指的是一个进程所消耗的虚拟地址空间。<ul><li>对应进程1044，其 VSS = 1 + 2 + 3 </li></ul></li><li>RSS(resident set size) : 指的是一个进程所真实消耗的物理内存空间<ul><li>对应进程1044, 其 RSS = 4 + 5 + 6</li></ul></li><li>PSS(proporitional set size) : 指一个进程所消耗的经过比例运算后的物理内存空间<ul><li>对应进程1044，其所占用的libc空间也同时被其他两个进程所使用，所以1044仅占用1/3。bash空间被另外一个进程所占用，所以1044仅占用1/2<ul><li>那么其所占用的 PSS = 4 / 3 + 5 / 2 + 6</li></ul></li><li>如果站在内存条的视角，看当前所有进程所占用的空间，那么就应该看PSS之和</li></ul></li><li>USS(unique set size) : 指一个进程所独占的物理内存空间<ul><li>对应进程1044，其 USS = 6</li><li>一个进程所独占的空间其中必然包含堆区，所以：<strong>我们可以通过多点采样进程的USS来观察其是否有内存泄露</strong></li></ul></li></ul><p>有以下几种方式来观察进程内存消耗：</p><ul><li>使用 <code>smem -P &lt;pid&gt;</code> 来观察其总体的消耗<ul><li>在实际检测一个进程是否有内存泄露时，可以通过脚本使用此命令来长时间抓取其USS并保存到文件中，最后通过matlab之类的软件拟合出一条曲线<ul><li>嵌入式中使用的是 <code>smemcap</code> 来获取数据然后再交由PC上分析</li></ul></li><li><code>smem --pie/--bar</code> 还可以以图形的方式来显示</li></ul></li><li>使用 <code>cat /proc/&lt;pid&gt;/smaps | more</code> 的方式来详细的观察进程的VSS,RSS,PSS.</li><li>使用 <code>valgrind</code> 来监控一个进程是否有内存泄露， <strong>这种方式会严重降低进程的运行速度.</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c</span><br><span class="line">valgrind --tool=memcheck --leak-check=yes ./a.out</span><br></pre></td></tr></table></figure><ul><li>在使用 gcc 编译代码时，使能其 <code>addresssanitizer</code> 选项。这种方式会在源代码中插入内存监控代码，进程运行速度影响不大。<br>如下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sanitizer/lsan_interface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *p1, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">      <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//check memory leak by asan</span></span><br><span class="line">      <span class="keyword">if</span>(++i &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          __lsan_do_leak_check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>还需要加上编译选项:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -fsanitize=address ./leak.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure><h1 id="观察内核的内存泄露"><a href="#观察内核的内存泄露" class="headerlink" title="观察内核的内存泄露"></a>观察内核的内存泄露</h1><p>多个进程是共享同一份内核空间的，当进程发出系统调用陷入内核后，如果内核有内存泄露那么其 slab 和 vmalloc 的占用就会随着时间推移宏观上呈上升趋势。</p><p>有以下几个办法来观察内核是否有泄露：</p><ol><li>通过脚本长时间抓取 <code>cat /proc/meminfo</code> 输出中的 slab 和 vmalloc 记录并保存在文件中，最后经过 matlab之类工具进行绘图。</li></ol>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 内存的申请与释放</title>
    <link href="http://kcmetercec.top/2024/08/13/linux_memory_overview_allocAndFree/"/>
    <id>http://kcmetercec.top/2024/08/13/linux_memory_overview_allocAndFree/</id>
    <published>2024-08-12T16:00:00.000Z</published>
    <updated>2024-08-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="buddy-算法缺陷"><a href="#buddy-算法缺陷" class="headerlink" title="buddy 算法缺陷"></a>buddy 算法缺陷</h1><h2 id="算法页面连续性缺陷"><a href="#算法页面连续性缺陷" class="headerlink" title="算法页面连续性缺陷"></a>算法页面连续性缺陷</h2><p>buddy算法虽然是动态的分离和合并，但合并的前置条件是这段物理页内存空间需要是连续的。但在申请内存的时候，确是分散的。<br>随着时间的推移，最终必然会造成很多空闲内存页分散的情况。</p><p>这就会造成一个问题： <strong>当DMA需要申请一个连续的物理内存空间时，虽然空闲页面远远大于此内存，但由于它们都是分散的，导致申请失败!</strong></p><ul><li>对于用户而言，虚拟地址空间连续即可，物理空间是否分散都不影响其使用，而DMA是直接对应物理内存操作的，需要其物理内存真的连续。</li></ul><h2 id="页面连续性问题解决方案"><a href="#页面连续性问题解决方案" class="headerlink" title="页面连续性问题解决方案"></a>页面连续性问题解决方案</h2><h3 id="reserved-内存"><a href="#reserved-内存" class="headerlink" title="reserved 内存"></a>reserved 内存</h3><p>为了保证 DMA 在任何时候都可以申请到连续的物理内存，所以在一开始就指定一片内存区域为保留区，仅仅用于DMA申请连续物理内存。</p><p>但这会导致当平时DMA不使用时，这片内存也无法用作其他用途，造成空间浪费。</p><h3 id="CMA-Contiguous-Memory-Allocator-连续内存分配器"><a href="#CMA-Contiguous-Memory-Allocator-连续内存分配器" class="headerlink" title="CMA(Contiguous Memory Allocator, 连续内存分配器)"></a>CMA(Contiguous Memory Allocator, 连续内存分配器)</h3><p>为了弥补 reserved 方式的不足，三星提出了CMA方式，其基本思想为：</p><ol><li><p>在物理内存分配了一片CMA区域(设备树中指定)，这片区域是物理内存连续的。</p></li><li><p>当DMA没有使用时，这片CMA区域交付给用户空间使用</p></li><li><p>当DMA要使用时，将用户空间的虚拟与物理内存对应表进行修改，也就是将这片物理内存区域移动到其他物理内存区域，空闲出 CMA 区。</p><ul><li>在这个过程中，由于应用程序的虚拟地址没有改变，所以其感知不到这个变化</li><li>在移动应用程序对应的物理内存时，新申请的内存是否连续对应用程序并不影响</li><li>由于在移动过程中需要重新修改页表，这段时间应用程序无法操作物理内存，会有短暂的卡顿。</li></ul></li><li><p>将CMA区交付给DMA使用。</p></li></ol><ul><li>有关reserved内存在设备树中的配置文档位于 <code>Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</code> </li></ul><p>可以在 menuconfig 中配置 cma：</p><ul><li><code>Memory Management options -&gt; Contiguous Memory Allocator</code> : 使能cma</li><li><code>Library routines -&gt; DMA Contiguous Mmeory Allocator</code> : 使能dma_cma</li></ul><h2 id="算法粒度问题"><a href="#算法粒度问题" class="headerlink" title="算法粒度问题"></a>算法粒度问题</h2><p>由于buddy算法的基本单位是页，而目前大部分页都是4K字节，这就导致当一个用户仅申请几个字节时，剩余的3K多字节就白白浪费了！</p><p>为了解决这个问题，Linux内核在buddy的基础之上进行了二次管理。</p><h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>在内核空间申请的内存都是不可移动的，这也会导致最终的内存碎片。虽然内存中有足够多的空间，但这些空间由于其不连续而导致申请大内存失败。</p><p>为此linux将内存空间又分为了可移动的、不可移动的、可回收类型，内核空间就在不可移动内存中申请空间，用户空间就在可移动内存中申请空间。这样内核就可以整理可移动的内存空间以腾出大片的连续内存。</p><p>但这些类型的分配都是一个动态的过程，最开始都是可移动的页面，只有在内核申请时才会从可移动页面申请一部分为不可移动内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* This array describes the order lists are fallen back to when</span></span><br><span class="line"><span class="comment"> ,* the free lists for the desirable migrate type are depleted</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fallbacks[MIGRATE_TYPES][<span class="number">4</span>] = &#123;</span><br><span class="line">                                          [MIGRATE_UNMOVABLE]   = &#123; MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">                                          [MIGRATE_RECLAIMABLE] = &#123; MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">                                          [MIGRATE_MOVABLE]     = &#123; MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">                                          [MIGRATE_CMA]         = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">                                          [MIGRATE_ISOLATE]     = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码展示了不同类型的内存在其空间不够用时寻找内存的顺序。</p><ul><li>比如内核要申请 UNMOVABLE(不可移动) 内存时如果当前类型空间不够了，依次在RECLAIMABLE(可回收)、MOVABLE(可移动)类型中寻找。</li></ul><p>主动触发可移动页面整理:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/compact_memory</span><br></pre></td></tr></table></figure><h1 id="buddy-算法与slab-malloc之间的关系"><a href="#buddy-算法与slab-malloc之间的关系" class="headerlink" title="buddy 算法与slab,malloc之间的关系"></a>buddy 算法与slab,malloc之间的关系</h1><p>buddy算法与slab,malloc之间的关系可以简单的以下图表示:</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/buddy_struct.jpg?raw=true"><br>从上图可以看出：</p><ol><li>buddy算法是针对整个内存条的，它将内存条进行统一的管理。 <strong>而内核态或是用户态对它来说都是客户而已！</strong><ul><li>也就是说：内核和用户对buddy来说都是平级的，无论是哪一方申请走了内存，另外一方都无法再申请同一处内存。</li></ul></li><li>在 <strong>内核空间</strong> 中 slab策略 将 buddy 的内存进行了二次管理，将从 buddy 申请的一大块内存分成很多小块给内核 kmalloc,kfree 使用<ul><li>slab并非是每次都要与buddy交互，这要根据内核中申请的内存大小而定。</li><li>并且可以看出 kmalloc 和 kfree 与 buddy 没有直接的关系，其申请与释放都是与slab交互的</li><li>buddy将内存条视为内存池，而slab将buddy视为内存池，所以它们在算法上是对等的</li></ul></li><li>在 <strong>内核空间</strong> 中，vmalloc直接与buddy进行交互，并没有二级管理<ul><li>所以申请的数量都是2的n次方页， <strong>所以使用vmalloc不适合申请小内存!</strong></li></ul></li><li>在 <strong>用户空间</strong> 中 glibc 库通过 <code>brk,mmap</code> 将buddy的内存进行了二次管理，提供给用户函数 <code>malloc,free</code> 使用<ul><li>glibc 也并非是每次都要与 buddy 交互，依然根据用户空间申请的内存大小而定</li><li>malloc,free 属于是库函数接口，不是系统调用</li></ul></li></ol><h2 id="slab机制-内核空间"><a href="#slab机制-内核空间" class="headerlink" title="slab机制(内核空间)"></a>slab机制(内核空间)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>slab先从buddy中申请一块内存，当内核空间要申请一小块内存时，slab将申请好的内存分成多个 <strong>相同的小块</strong> ，并将其中一块给予内核空间。<br>当预先申请的内存使用完后，slab再从buddy中申请一块内存来使用。</p><p>这一个小块，在slab中就称为一个object.</p><ul><li>使用命令 <code>sudo cat /proc/slabinfo</code> 就可以看到内核中slab的分配情况<ul><li>输出的前半部分，表示slab为内核中一些常用的数据分配的空间</li><li>输出的后半部分，表示slab为内核通用的用户提供的可以申请的内存块</li></ul></li></ul><h3 id="slab算法分类"><a href="#slab算法分类" class="headerlink" title="slab算法分类"></a>slab算法分类</h3><p>slab机制分为slab,slub,slob三种算法来实现slab机制。</p><h2 id="glibc-用户空间"><a href="#glibc-用户空间" class="headerlink" title="glibc(用户空间)"></a>glibc(用户空间)</h2><p>gblic从buddy先申请内存，而后提供接口给用户使用，这样可以避免频繁的系统调用，减少CPU在IO切换上的消耗，提高系统吞吐量。</p><h3 id="通过设置收缩阀值，提高申请内存速度"><a href="#通过设置收缩阀值，提高申请内存速度" class="headerlink" title="通过设置收缩阀值，提高申请内存速度"></a>通过设置收缩阀值，提高申请内存速度</h3><p>glibc会在释放的内存到达一定的阀值后，才将其释放给buddy内存池，下次申请大内存的时候glibc又要从buddy申请，这无疑会影响申请速度。</p><p>为了提高内存申请速度，可以设置glibc不释放内存给buddy，这样下次再来申请时，其速度就会快很多!</p><p>试验代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_SIZE (200 * 1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">end</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> timer;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;free bytes through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//在真实写入操作时，glibc才会将此虚拟内存映射到物理内存</span></span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes again through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n***************\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!mlockall(MCL_CURRENT | MCL_FUTURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置收缩阀值为无穷大</span></span><br><span class="line">    mallopt(M_TRIM_THRESHOLD, <span class="number">-1UL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mallopt(M_MMAP_MAX, <span class="number">0</span>);</span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//此时的free只还给了glibc但没有还给buddy内存池</span></span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;free bytes through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes again through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存申请的流程"><a href="#内存申请的流程" class="headerlink" title="内存申请的流程"></a>内存申请的流程</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/malloc.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/malloc_ex.jpg?raw=true"><br>由上两幅图可以看出：</p><ul><li>vmalloc 可以用于申请内存的任何位置以及映射寄存器<ul><li>使用 <code>sudo cat /proc/vmallocinfo | grep ioremap</code> 可以查看当前寄存器被映射的情况</li><li><strong>通过vmalloc申请的地址其虚拟地址连续但物理地址不一定连续</strong></li></ul></li><li>kmalloc 申请低端内存时，由于不需要修改页表，所以其操作简便<ul><li>正因为kmalloc与物理内存的简单映射关系，所以 <strong>其物理地址连续并且对应的虚拟地址也是连续的</strong></li></ul></li><li>高端内存映射区通过kmap对应申请高端物理内存</li><li>用户空间malloc则可以 <strong>申请内存条的任意位置</strong><ul><li><strong>通过malloc申请的地址其虚拟地址连续但物理地址不一定连续</strong></li></ul></li></ul><h2 id="malloc-申请机制"><a href="#malloc-申请机制" class="headerlink" title="malloc 申请机制"></a>malloc 申请机制</h2><p>malloc在用户使用时，其内部使用的是 lazy机制：</p><ol><li>当用户调用 <code>malloc</code> 时，malloc将其申请的虚拟地址都指向0页，并且 <strong>此页是一个只读页</strong><ul><li>此时用户还没有真正拥有内存，并且使用代码读取时读到的都是0</li></ul></li><li>当用户 <strong>真正是写时由于0页是只读页，此时发生pagefault，内核才会去分配真正的内存</strong><ul><li>也就是说在用户第一次写对应虚拟空间页时，内核才依次的为其分配内存。</li><li><strong>pagefault几乎是所有应用程序获取物理内存的途径</strong><ul><li>代码段、数据段、栈、堆都是一样的lazy机制</li></ul></li></ul></li></ol><p>由此就引出两个概念：</p><ul><li>VSS(Virtual Set size)：用户调用 malloc 返回的虚拟地址空间大小</li><li>RSS(resident set size)：用户真正获取到的对应的物理内存空间(驻留内存)大小</li></ul><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/vss_rss.jpg?raw=true"></p><h3 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h3><p>既然内核给用户空间的内存都是lazy机制的，那么就完全有可能出现VSS大于真正的RSS的情况，导致用户真正写内存时内存不够用的情况。</p><p>此时Linux就会启动OOM(out of memory)机制， <strong>将内存打分因子最高</strong> 的应用给Kill掉以释放足够的内存。</p><p>在内存为1G的32位虚拟机上，按照如下流程体验：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用root身份，关闭交换空间</span></span><br><span class="line">swapoff -a</span><br><span class="line">echo 1 &gt; /proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 2000</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * SIZE);</span><br><span class="line">  assert(p != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc buffer addr = %p\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * (SIZE/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//此时才会真正分配到物理内存</span></span><br><span class="line">      p[i] = <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">if</span>((i &amp; <span class="number">0xfffff</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d MB written\n&quot;</span>, i &gt;&gt; <span class="number">18</span>);</span><br><span class="line">          usleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  pause();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现应用会被内核强制杀死,并在dmesg中也会看到相应的提示。</p><h3 id="打分因子"><a href="#打分因子" class="headerlink" title="打分因子"></a>打分因子</h3><p>Linux会为每个进程进行打分，每个进程的 oom score 取决于:</p><ul><li>驻留内存、pagetable和swap的使用量<ul><li>采用百分比乘以10(percent-times-tem):一个使用全部内存的进程得分1000，使用0字节的进程得分0</li></ul></li><li>root用户进程减去30分</li><li>oom_score_adj: oom_score 会加上 oom_score_adj 这个值</li><li>oom_adj: -15 ~ 15 的系数范围调整</li></ul><p>这部分规则的代码位于函数 <code>/mm/oom_kill.c/oom_badness()</code> 中:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* oom_badness - heuristic function to determine which candidate task to kill</span></span><br><span class="line"><span class="comment"> ,* @p: task struct of which task we should calculate</span></span><br><span class="line"><span class="comment"> ,* @totalpages: total present RAM allowed for page allocation</span></span><br><span class="line"><span class="comment"> ,*</span></span><br><span class="line"><span class="comment"> ,* The heuristic for determining which task to kill is made to be as simple and</span></span><br><span class="line"><span class="comment"> ,* predictable as possible.  The goal is to return the highest value for the</span></span><br><span class="line"><span class="comment"> ,* task consuming the most memory to avoid subsequent oom failures.</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">oom_badness</span><span class="params">(struct task_struct *p, struct mem_cgroup *memcg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">nodemask_t</span> *nodemask, <span class="keyword">unsigned</span> <span class="keyword">long</span> totalpages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> points;</span><br><span class="line">  <span class="keyword">long</span> adj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oom_unkillable_task(p, memcg, nodemask))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = find_lock_task_mm(p);</span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  adj = (<span class="keyword">long</span>)p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line">  <span class="keyword">if</span> (adj == OOM_SCORE_ADJ_MIN) &#123;</span><br><span class="line">    task_unlock(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* The baseline for the badness score is the proportion of RAM that each</span></span><br><span class="line"><span class="comment">   ,* task&#x27;s rss, pagetable and swap space use.</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  points = get_mm_rss(p-&gt;mm) + get_mm_counter(p-&gt;mm, MM_SWAPENTS) +</span><br><span class="line">    atomic_long_read(&amp;p-&gt;mm-&gt;nr_ptes) + mm_nr_pmds(p-&gt;mm);</span><br><span class="line">  task_unlock(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* Root processes get 3% bonus, just like the __vm_enough_memory()</span></span><br><span class="line"><span class="comment">   ,* implementation used by LSMs.</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  <span class="keyword">if</span> (has_capability_noaudit(p, CAP_SYS_ADMIN))</span><br><span class="line">    points -= (points * <span class="number">3</span>) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normalize to oom_score_adj units */</span></span><br><span class="line">  adj *= totalpages / <span class="number">1000</span>;</span><br><span class="line">  points += adj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* Never return 0 for an eligible task regardless of the root bonus and</span></span><br><span class="line"><span class="comment">   ,* oom_score_adj (oom_score_adj can&#x27;t be OOM_SCORE_ADJ_MIN here).</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  <span class="keyword">return</span> points &gt; <span class="number">0</span> ? points : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以手动来调整每个进程的oom_score_adj或oom_adj来改变进程打分，这样可以偏向让系统首先杀死谁。</p><ul><li>在 <code>/proc/&lt;pid&gt;/</code> 下就具有这些文件</li></ul><p>安卓主动将前台进程的oom调低，将后台的进程oom调高，这样以保证可以杀死后台来给予前台更多的运行内存。</p><h3 id="oom调试"><a href="#oom调试" class="headerlink" title="oom调试"></a>oom调试</h3><p>将 <code>/proc/sys/vm/panic_on_oom</code> 写1，这样当出现oom时，内核会奔溃，这在调试嵌入式程序是比较有帮助的。</p>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>初步认识 Linux 内存管理</title>
    <link href="http://kcmetercec.top/2024/08/05/linux_memory_hello/"/>
    <id>http://kcmetercec.top/2024/08/05/linux_memory_hello/</id>
    <published>2024-08-04T16:00:00.000Z</published>
    <updated>2024-08-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>kernel version</th><th>arch</th></tr></thead><tbody><tr><td>v5.4.0</td><td>arm32</td></tr></tbody></table><span id="more"></span><h1 id="CPU-与内存-I-O"><a href="#CPU-与内存-I-O" class="headerlink" title="CPU 与内存,I/O"></a>CPU 与内存,I/O</h1><h2 id="内存空间与I-O空间的区别"><a href="#内存空间与I-O空间的区别" class="headerlink" title="内存空间与I/O空间的区别"></a>内存空间与I/O空间的区别</h2><p>I/O 空间的概念是存在于 X86 架构中的，与内存空间做区分，它通过特定的指令<code>in</code>,<code>out</code>来访问外设寄存器的地址。</p><p>但是在实际使用时，我们也可以将外设设计在 X86 架构的内存空间中，直接访问寄存器地址，所以 <strong>I/O空间是可选的</strong> 。</p><p>在大多数嵌入式微控制器中没有I/O空间，仅有内存空间。内存空间可以直接通过地址，指针来访问，程序以及其他数据都是存在于内存空间中的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">再次强调：无论是在内核态还是在用户态，CPU 看到的都是虚拟地址！</span><br><span class="line"></span><br><span class="line">无论是内存条还是寄存器的访问，内核都是通过虚拟地址去访问的，内核中所有的指针操作</span><br><span class="line">都是虚拟地址。</span><br><span class="line"></span><br><span class="line">在内核中，物理地址对于 Linux 来说就是一个整数，如下物理地址在内核中的定义：</span><br><span class="line">//file: include/linux/types.h</span><br><span class="line"><span class="meta">#</span><span class="bash">ifdef CONFIG_PHYS_ADDR_T_64BIT</span></span><br><span class="line">typedef u64 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line">typedef u32 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br></pre></td></tr></table></figure><h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>MMU提供虚拟地址和物理地址的映射，内存访问权限保护和 Cache 缓存控制等硬件支持，<br>用户在编写实际程序时不用考虑实际物理地址有多大，以及是否会与其他程序地址冲突等等。</p><ul><li>具体MMU工作参考 <a href="https://kcmetercec.top/2023/04/06/linux_mm_hardware_mmu/">MMU基本原理</a></li></ul><h3 id="MMU操作原理"><a href="#MMU操作原理" class="headerlink" title="MMU操作原理"></a>MMU操作原理</h3><p>MMU中比较重要的两个概念：</p><ul><li>TLB(Translation Lookaside Buffer)<ul><li>转换旁路缓存，TLB 是 MMU 的核心部件，它缓存少量的虚拟地址与物理地址的转换关系，是转换表的Cache，因此也经常被称为”快表”。</li></ul></li><li>TTW(Translation Table wale)<ul><li>转换表漫游，当TLB中没有缓冲对应的地址转换对应关系时，需要通过对内存中转换表的访问来获得虚拟地址和物理地址的对应关系。TTW成功后，结果应写入TLB中。</li></ul></li></ul><p>MMU操作的原则都是以最快的速度来读写 CPU 所需要的数据或指令:</p><ol><li>所以它会首先访问 TLB 以保证最快的速度找到映射关系然后进行存取，如果此时打开了Cache并且Cache命中，那也会直接取Cache的数据否则取内存的数据并且更新Cache</li><li>如果TLB没有命中那么就会访问 TTW 找到映射关系并反过来更新 TLB。</li></ol><h3 id="MMU的权限管理"><a href="#MMU的权限管理" class="headerlink" title="MMU的权限管理"></a>MMU的权限管理</h3><p>MMU的权限管理主要包含以下两个方面：</p><ol><li>这段内存是否具有RWX权限(比如代码段只有RX权限，避免被改写)</li><li>这段内存是仅有内核才可访问，还是内核和用户都可访问<ul><li>仅有内核可访问的内存，避免用户获取到内核的数据</li></ul></li></ol><p>权限管理使用下面程序进行体验：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    access();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">,* @note : 此处新建一个文件，就是让编译器在预编译、编译、汇编的过程中，无法察觉变量 a的类型，</span></span><br><span class="line"><span class="comment">,* 以保证编译通过。</span></span><br><span class="line"><span class="comment">,* 但实际上 a 的内存权限为可读，所以当执行写时，就会触发page fault</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="meltdown漏洞"><a href="#meltdown漏洞" class="headerlink" title="meltdown漏洞"></a>meltdown漏洞</h3><p>meltdown漏洞使得用户空间可以访问内核空间中的内容，详细解释参考 <a href="https://mp.weixin.qq.com/s/YjKoay39rtKQXGbWN6qfug">格友</a> 。</p><p>简单解释就是：</p><ol><li>用户空间先申请一个大数组，这个大数组的每个元素的大小即为内存页表的大小，这是为了每个页可以覆盖整个 cache，便于后期测试不被干扰</li><li>用户空间发送读取内核空间中 <strong>一个字节的请求</strong> ，一个字节的值为 0~255，假设该值为 N</li><li>由于CPU的分支预测执行功能，将用户空间大数组的第 N 个块进行读取操作（此时 N 的值依然存在于寄存器中）</li><li>虽然MMU进行了权限检查，但此时用户空间中数组的第 N 个块的部分数据已经存在于 cache 中了，此时 cache hit</li><li>由于读取Cache的速度要远远快于读取内存的速度，用户通过依次扫描 0~255 块的读取速度，识别出读取最快的那个块，便知道这第 N 个块代表内核地址的值为 N</li></ol><p>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">由于这个漏洞是由硬件造成的，而执行的入口是用户空间和内核空间共用了一个页表（这样用户空间才可以通过虚拟地址去访问内核）。</span><br><span class="line">所以如果将用户空间和内核空间的页表进行分离，大家各用各的页表那么用户空间就无法通过虚拟地址访问到内核了。(无论用户空间如何访问，它都是访问自己的页表，对应自己代码的物理地址或者就干脆是没有命中的地址)</span><br><span class="line"></span><br><span class="line">但这样相当于MMU将内核空间和用户空间隔离为了两个进程一样，当用户空间调用内核空间接口函数时，在切换为特权模式的同时还要切换一次页表。同理，内核处理完成后回到用户空间还要切换一次页表。这样就会消耗很多时间，性能损耗比较大。</span><br><span class="line"></span><br><span class="line">需要注意的是：</span><br><span class="line">并不是说进程页表一丁点都不覆盖内核空间了，当进程进行正常合法的系统调用时，这部分逻辑是应该正常运行的。</span><br><span class="line">也就是说进程的页表要进程内核空间的系统调用接口部分以实现正常的访问。</span><br><span class="line">- 而进入到内核这部分代码之后，它会切换到内核页表，内核的页表便是覆盖所有空间的。当调用完成后，又切换回用户态的页表。</span><br></pre></td></tr></table></figure><p>实例体验:实际代码及操作位于 <a href="https://github.com/21cnbao/meltdown-example">宋宝华老师github</a></p><h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><ul><li>在Linux系统中,进程的 <strong>虚拟4GB内存空间</strong> 被分为两个部分—用户空间和内核空间.</li><li>用户空间的地址一般分布为0<del>3GB(即PAGE_OFFSET),剩下的3</del>4GB为内核空间.  <ul><li><strong>用户进程只有通过系统调用(代表用户进程在内核态执行)等方式才可以访问到内核空间</strong>.</li><li>每个进程的用户空间都是完全独立，互不相干的。**<strong>用户进程各自有不同的页表</strong>。而内核空间是由内核负责映射，它并不会跟着进程改变,是固定的。</li><li>*<em>内核空间的虚拟地址到物理地址的映射是被所有进程共享的，内核虚拟空间独立于其他程序</em>***。</li></ul></li></ul><p>在menuconfig中 <code>Kernel Features -&gt; Memory split(..)</code> 可以选择设置 <code>CONFIG_PAGE_OFFSET</code> ，默认内核空间就是位于3G~4G空间的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:arch/arm/include/asm/memory.h</span></span><br><span class="line"><span class="comment">/* PAGE_OFFSET - the virtual address of the start of the kernel image */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET        UL(CONFIG_PAGE_OFFSET)</span></span><br></pre></td></tr></table></figure><ul><li>由上面代码也可以知道内核中可以使用 <code>PAGE_OFFSET</code> 宏来判断内核虚拟空间的起始地址</li></ul><h2 id="对物理内存条的分配"><a href="#对物理内存条的分配" class="headerlink" title="对物理内存条的分配"></a>对物理内存条的分配</h2><ul><li>请注意： <strong>这里说的是物理内存条，不是内存空间</strong></li></ul><p>Linux一般将内存条分为DMA_ZONE, NORMAL_ZONE, HIGH_ZONE3个区,<br><a href="https://mp.weixin.qq.com/s/5K7rlPXo2yIcoIXXgqqLfQ">阅码场</a> 上有清晰的说明,<br><a href="https://www.quora.com/In-reference-to-Linux-Kernel-what-is-the-difference-between-high-memory-and-normal-memory">quora</a> 上对此也有解释。</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/%5BWhat%5DLinux--mem_IO/mem_area.jpg?raw=true"></p><h3 id="DMA-ZONE"><a href="#DMA-ZONE" class="headerlink" title="DMA_ZONE"></a>DMA_ZONE</h3><p>DMA_ZONE 是为特定 DMA 划分的区域，某些芯片的 DMA 控制器无法访问全部内存条(有些仅能访问有限的十几兆空间)，所以 Linux 为此类 DMA 规划一片内存.</p><p>当实际编写内核代码时，申请 DMA 缓存时使用 <code>GFP_DMA</code> 标记，以告知 Linux 在那片固定区域申请。</p><p>在内核代码中也有关于此标记的注释(提到了还可以作为紧急后备内存来使用):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GFP_DMA exists for historical reasons and should be avoided where possible.</span><br><span class="line">The flags indicates that the caller requires that the lowest zone be</span><br><span class="line">used (ZONE_DMA or 16M on x86-64). Ideally, this would be removed but</span><br><span class="line">it would require careful auditing as some users really require it and</span><br><span class="line">others use the flag to avoid lowmem reserves in ZONE_DMA and treat the</span><br><span class="line">lowest zone as a type of emergency reserve.</span><br></pre></td></tr></table></figure><p>DMA_ZONE 的设置一般在构架目录下的Kconfig中设置，比如 <code>arch/arm/Kconfig</code> 具有其使能标记，但在设置前一定要搞清楚具体硬件！</p><h3 id="NORMAL-ZONE"><a href="#NORMAL-ZONE" class="headerlink" title="NORMAL_ZONE"></a>NORMAL_ZONE</h3><p>前面说过，在虚拟地址中3<del>4G为内核空间。 **Linux将物理内存的0</del>1G线性映射到3G~4G虚拟地址空间** ，而这1G的空间减去 DMA_ZONE 剩下的部分就是 NORMAL_ZONE。 </p><p>所谓的线性映射指的就是页表的简单映射关系，一般这种情况下仅仅是一个简单的偏移即可转换，内核提供了函数以相互转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note ： 在内核中物理地址都是一个数值，它能以指针操作的只有虚拟地址，</span></span><br><span class="line"><span class="comment"> ,* 所以此处物理地址都是 unsigned long 型</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">virt_to_phys</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> *address)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">phys_to_virt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure><p>注意： <strong>线性映射并不是内核已经占用了内存，而是提前映射好以便后面操作,而无需使用时再来映射。</strong></p><h3 id="HIGH-ZONE"><a href="#HIGH-ZONE" class="headerlink" title="HIGH_ZONE"></a>HIGH_ZONE</h3><p>当实际的物理内存大于1G时，多于的部分就是HIGH_ZONE.</p><p>当内核空间要使用此段内存时，由于没有提前映射，则需要经过以下步骤使用：</p><ol><li>映射HIGH_ZONE到 高端页面映射区</li><li>使用</li><li>释放映射</li></ol><p>注意： 内核对HIGH_ZONE 不能使用 <code>virt_to_phys,phys_to_virt</code> 来转换，因为它们不是简单的线性映射!</p><p>对于用户空间而言，用户申请内存时，Linux搜寻内存的路径为： HIGH_ZONE -&gt; NORMAL_ZONE -&gt; DMA_ZONE.</p><h2 id="对内核虚拟空间的分配"><a href="#对内核虚拟空间的分配" class="headerlink" title="对内核虚拟空间的分配"></a>对内核虚拟空间的分配</h2><h3 id="x86-32-架构下的分配"><a href="#x86-32-架构下的分配" class="headerlink" title="x86-32 架构下的分配"></a>x86-32 架构下的分配</h3><p>Linux中1GB的虚拟内核地址空间又被划分为:</p><table><thead><tr><th>区域名称</th><th>虚拟地址位置</th><th>相关代码</th></tr></thead><tbody><tr><td>保留区</td><td>FIXADDR_TOP ~ 4GB</td><td>搜索宏 FIXADDR_TOP</td></tr><tr><td>专用页面映射区</td><td>FIXADDR_START ~ FIXADDR_TOP</td><td>搜索宏 FIXADDR_START</td></tr><tr><td>高端内存映射区</td><td>PKMAP_BASE ~ FIXADDR_START</td><td>搜索宏 PKMAP_BASE</td></tr><tr><td>隔离区</td><td></td><td></td></tr><tr><td>vmalloc虚拟内存分配区</td><td>VMALLOC_START ~ VMALLOC_END</td><td>搜索宏 VMALLOC_START</td></tr><tr><td>隔离区</td><td></td><td></td></tr><tr><td>物理内存映射区</td><td>3GB起始最大长度896M(对应物理内存的896M)</td><td></td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接映射的最大896M物理内存分为两个区域：</span><br><span class="line">- 0 ~ 16M : ISA设备用作DMA申请</span><br><span class="line">- 16M ~ 896M : 常规区域</span><br></pre></td></tr></table></figure><ul><li>当系统物理内存超过4GB时，必须使用CPU的扩展分页(PAE)模式所提供的64位页目录才能取到4GB以上的物理内存。</li></ul><p>由上表可以看出：此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<br><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></p><h3 id="arm32-linux-下的分配"><a href="#arm32-linux-下的分配" class="headerlink" title="arm32 linux 下的分配"></a>arm32 linux 下的分配</h3><table><thead><tr><th>区域名称</th><th>虚拟地址位置</th><th>相关代码</th></tr></thead><tbody><tr><td>向量表</td><td>0xfff0000~0xfff0fff</td><td>文档 Documentation/arm/memory.txt</td></tr><tr><td>隔离区</td><td></td><td></td></tr><tr><td>vmalloc和ioremap区域</td><td>VMALLOC_START ~ VMALLOC_END -1</td><td>宏 VMALLOC_START</td></tr><tr><td>隔离区</td><td></td><td></td></tr><tr><td>DMA和常规区域映射区</td><td>PAGE_OFFSET ~ high_memory -1</td><td>宏 PAGE_OFFSET 以及变量 high_memory</td></tr><tr><td>高端内存映射区</td><td>PKMAP_BASE ~ PAGE_OFFSET -1</td><td>宏 PKMAP_BASE</td></tr><tr><td>内核模块</td><td>MODULES_VADDR ~ MODULES_END -1</td><td>宏 MODULES_VADDR</td></tr></tbody></table><p>由上表可以看出: </p><ul><li>对于arm32 来说， <strong>从内核模块开始的地方就已经是内核空间了！</strong></li><li>此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<ul><li><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在编译内核的时候可以选择：</span><br><span class="line">- VMSPLIT_3G : 用户空间3G，内核空间1G。内核模块范围为 3GB-16MB ~ 3GB-2MB,高端内存映射 3GB-2MB ~ 3GB</span><br><span class="line">- VMSPLIT_2G : 用户空间2G，内核空间2G。内核模块范围为 2GB-16MB ~ 2GB-2MB,高端内存映射 2GB-2MB ~ 2GB</span><br><span class="line"></span><br><span class="line">ARM系统的Linux之所以把内核模块放在16MB范围内，是因为ARM指令在32M以内是短跳转。</span><br><span class="line"></span><br><span class="line">而内核代码位于 3G~3G+6M 的位置，所以将内核模块放在3G-2M ~ 3G-16M之间的内存差异在32M以内，</span><br><span class="line">这样就实现了内核模块和内核本身的代码段之间的短跳转，以最小的开销实现函数的调用.</span><br></pre></td></tr></table></figure><h2 id="DMA、常规、高端内存分布"><a href="#DMA、常规、高端内存分布" class="headerlink" title="DMA、常规、高端内存分布"></a>DMA、常规、高端内存分布</h2><p>有以下4种可能的情况分布(地址由低到高)：</p><ul><li>DMA区域 | 常规区域 | 高端内存区域 <ul><li>内存较大，硬件DMA只能访问一部分地址，并且内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li></ul></li><li>DMA区域(常规区域) | 高端内存区域<ul><li>内存较大，硬件DMA可以访问全部地址，但内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li></ul></li><li>DMA区域 | 常规区域<ul><li>内存较小，硬件DMA只能访问一部分地址，且内核可以完全映射物理内存</li></ul></li><li>DMA区域(常规区域)<ul><li>内存较小，硬件DMA可以访问全部地址，且内核可以完全映射物理内存</li></ul></li></ul><h3 id="buddy-算法"><a href="#buddy-算法" class="headerlink" title="buddy 算法"></a>buddy 算法</h3><p>DMA、常规、高端内存分布区 <strong>最底层</strong> 使用的是 <code>buddy</code> 算法进行管理，它将空闲 <strong>页</strong> 面以 2 的 n次方进行分配，而内存申请也是也 2 的 n 次方申请。</p><ul><li>buddy 在不断的拆分和合并，其空闲页面以 1,2,4,8,16… 这种形式组织起来<ul><li>从16个页面中取出一页后，buddy会拆分为 1,2,4,8 空闲页</li><li>如果原来是1,2,8的空闲，现在又释放了2页, <strong>如果这2页和原来空闲的2页内存连续</strong> ，buddy会合并为1,4,8空闲页</li></ul></li><li>与此同时， <strong>用户每次申请也只能是2的n次方！</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在 /proc/buddyinfo 会显示这些区域的空闲页面分布情况,依次从左到右显示 1,2,4,8,16 空闲页数量</span><br></pre></td></tr></table></figure><p>在内核编程时，可以使用以下函数来申请buddy页(一般不会直接使用)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief file: /include/linux/gfp.h</span></span><br><span class="line"><span class="comment"> ,* @note 此处的order就代表2的次方</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct page * <span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="内存申请实际操作"><a href="#内存申请实际操作" class="headerlink" title="内存申请实际操作"></a>内存申请实际操作</h1><h2 id="用户空间内存动态申请"><a href="#用户空间内存动态申请" class="headerlink" title="用户空间内存动态申请"></a>用户空间内存动态申请</h2><p>用户空间的内存申请和释放使用标准的c库即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>Linux内核总是采用按需调页(Demand Paging)，因此当malloc()返回的时候，虽然是成功返回，但是内核并没有真正给这个进程内存。这个时候如果去读申请的内存，内容全部是0，这个页面的映射是只读的。只有当写到某个页面的时候，内核才在页错误后，真正把这个页面给这个进程。</strong></p><h2 id="内核空间内存动态申请"><a href="#内核空间内存动态申请" class="headerlink" title="内核空间内存动态申请"></a>内核空间内存动态申请</h2><h3 id="物理内存连续申请"><a href="#物理内存连续申请" class="headerlink" title="物理内存连续申请"></a>物理内存连续申请</h3><p>函数 <code>kmalloc() 和 __get_free_pages()以及类似函数</code> 申请的区域位于 <code>DMA和常规区域的映射区</code> ，在物理上是连续的，与真实物理地址只有一个固定的偏移。</p><ul><li>kmalloc() 底层依赖于 <code>__get_free_pages()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 申请内存地址</span></span><br><span class="line"><span class="comment"> ,* @param size: 要申请的字节数</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请的内存类型</span></span><br><span class="line"><span class="comment"> ,* @note flags 一般有以下取值：</span></span><br><span class="line"><span class="comment"> ,* GFP_USER -&gt; 为用户空间页分配内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_KERNEL -&gt; 为内核空间申请内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_ATOMIC -&gt; 原子方式申请内存，若不存在则直接返回而不阻塞(用于中断、tasklet、内核定时器等非进程上下文环境中)</span></span><br><span class="line"><span class="comment"> ,* GFP_HIGHUSER -&gt; 从高端区域中为用户空间分配</span></span><br><span class="line"><span class="comment"> ,* GFP_NOIO -&gt; 申请期间，不允许任何 I/O 初始化</span></span><br><span class="line"><span class="comment"> ,* GFP_NOFS -&gt; 申请期间，不允许任何文件系统调用</span></span><br><span class="line"><span class="comment"> ,* GFP_NOWAIT -&gt; 若不存在空闲页则不等待</span></span><br><span class="line"><span class="comment"> ,* GFP_DMA -&gt; 从DMA区域分配内存</span></span><br><span class="line"><span class="comment"> ,* 还有其他取值请参考文件 include/linux/slab.h</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kzalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放kmalloc对应申请的内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 内存的申请管理设备，当设备被释放时内存也跟着自动释放</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kmalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在 devm_kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kzalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="物理内存不一定连续申请"><a href="#物理内存不一定连续申请" class="headerlink" title="物理内存不一定连续申请"></a>物理内存不一定连续申请</h3><p>函数 <code>vmalloc()</code> 申请区域位于 <code>vmalloc区域</code> ，在物理上不一定是连续的，与真实物理地址转换关系也不简单。</p><ul><li>vmalloc() 一般只为存在于软件中的(没有对应硬件访问)较大的内存分配</li><li>vmalloc() 效率没有 kmalloc() 高，不适合用来分配小内存<ul><li>在申请时会内存映射并修改页表</li></ul></li><li>vmalloc() <strong>不能用在原子上下文中</strong> ，因为它内存实现使用了标志为 <code>GFP_KERNEL</code> 的 kmalloc，可能会导致睡眠</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="slab机制提高少量字节申请效率"><a href="#slab机制提高少量字节申请效率" class="headerlink" title="slab机制提高少量字节申请效率"></a>slab机制提高少量字节申请效率</h3><p>slab机制使得内核中的小对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，大大提高分配效率。</p><ul><li>kmalloc() 就是使用 slab 机制实现的</li><li>使用 slab机制申请的内存与物理内存之间也是简单的线性偏移关系</li><li>查看 <code>/proc/slabinfo</code> 可以得到当前 slab 分配和使用情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 创建一个slab缓存，保留任意数据且全部大小相同的后备缓存</span></span><br><span class="line"><span class="comment"> ,* @param name: 缓存名称，最终会映射在 /proc/slabinfo 中</span></span><br><span class="line"><span class="comment"> ,* @param size: 每个数据结构的大小</span></span><br><span class="line"><span class="comment"> ,* @param aligh: 数据的对齐方式</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请标记：</span></span><br><span class="line"><span class="comment"> ,* - SLAB_POISON</span></span><br><span class="line"><span class="comment"> ,* - SLAB_RED_ZONE : </span></span><br><span class="line"><span class="comment"> ,* - SLAB_HWCACHE_ALIGH : 每个数据对象被对齐到一个缓存行</span></span><br><span class="line"><span class="comment"> ,* @param ctor: 对象的构造函数</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmem_cache_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cache, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cache,<span class="keyword">void</span> *objp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放 slab 缓存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *s)</span></span>;</span><br></pre></td></tr></table></figure><p>使用例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">kmem_cache_t</span> *xxx_cachep;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 申请slab缓存池</span></span><br><span class="line">xxx_cachep = kmem_cache_create(<span class="string">&quot;xxx&quot;</span>, <span class="keyword">sizeof</span>(struct xxx), <span class="number">0</span>, SLAB_HWCACHE_ALIGH | SLAB_PANIC,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//! 分配对象内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">ctx = kmem_cache_alloc(xxx_cachep, GFP_KERNEL);</span><br><span class="line"><span class="comment">//! 使用对象内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放对象内存</span></span><br><span class="line">kmem_cache_free(xxx_cachep, ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放slab缓存池</span></span><br><span class="line">kmem_cache_destroy(xxx_cachep);</span><br></pre></td></tr></table></figure><p>内存池技术也是用于分配大量小对象的后备缓存技术。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mempool_t</span> *<span class="title">mempool_create</span><span class="params">(<span class="keyword">int</span> min_nr, <span class="keyword">mempool_alloc_t</span> *alloc_fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">mempool_free_t</span> *free_fn, <span class="keyword">void</span> *pool_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mempool_alloc</span><span class="params">(<span class="keyword">mempool_t</span> *pool, <span class="keyword">gfp_t</span> gfp_mask)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_free</span><span class="params">(<span class="keyword">void</span> *element, <span class="keyword">mempool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_destroy</span><span class="params">(<span class="keyword">mempool_t</span> *pool)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="设备-I-O-端口和-I-O-内存的访问"><a href="#设备-I-O-端口和-I-O-内存的访问" class="headerlink" title="设备 I/O 端口和 I/O 内存的访问"></a>设备 I/O 端口和 I/O 内存的访问</h1><p>设备通常会提供一组寄存器来控制设备,读写设备和获取设备状态,这些寄存器可能位于 I/O 空间中,也可能位于内存空间中.</p><ul><li>当位于I/O 空间时,通常被称为 <strong>I/O端口</strong>;</li><li>当位于内存空间时,对应的内存空间被称为 <strong>I/O内存</strong>.</li><li>在使用I/O区域时,需要 <strong>申请该区域</strong> ,以表明驱动要访问这片区域.</li></ul><h2 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h2><p>I/O 端口的具体操作流程为：</p><ol><li>申请I/O端口资源</li><li>使用读写函数操作I/O端口</li><li>释放I/O端口资源</li></ol><h3 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 向内核申请 n 个端口,这些端口从 start开始,name 参数为设备的名称</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_region(start,n,name) __request_region(&amp;ioport_resource,(start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_region(start,n) __release_region(&amp;ioport_resource, (start), (n))</span></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_region(dev,start,n,name) __devm_request_region(dev,&amp;ioport_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!读写一字节端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写16位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写32位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(<span class="keyword">unsigned</span> longword, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串32位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="I-O-内存"><a href="#I-O-内存" class="headerlink" title="I/O 内存"></a>I/O 内存</h2><p>I/O内存的操作流程为：</p><ol><li>申请I/O内存资源</li><li>将资源地址映射到内核虚拟空间</li><li>使用读写函数操作</li><li>释放I/O内存资源</li></ol><h3 id="申请与释放-1"><a href="#申请与释放-1" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 申请以start为开始的,n字节的I/O内存区域，名字为name</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_mem_region(start,n,name) __request_region(&amp;iomem_resource, (start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放申请的内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_mem_region(start,n) __release_region(&amp;iomem_resource, (start),(n))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_mem_region(dev,start,n,name) __devm_request_region(dev,&amp;iomem_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从物理地址 offset处映射size字节内存到内核虚拟内存</span></span><br><span class="line"><span class="comment"> ,* @note ioremap() 与 vmalloc() 类似，也需要新建页表，但不进行内存分配行为。</span></span><br><span class="line"><span class="comment"> ,* 所映射的虚拟地址区为 vmalloc 映射区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">ioremap</span><span class="params">(<span class="keyword">phys_addr_t</span> offset, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//! 取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span><span class="params">(<span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="comment">//! 当设备资源释放后自动取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">devm_ioremap</span><span class="params">(struct device *dev, <span class="keyword">resource_size_t</span> offset, <span class="keyword">resource_size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="读写操作函数"><a href="#读写操作函数" class="headerlink" title="读写操作函数"></a>读写操作函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 分别读写 8,16,32,64 位</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">u8  <span class="title">readb</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u16 <span class="title">readw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u32 <span class="title">readl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u64 <span class="title">readq</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeb</span><span class="params">(u8  value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeq</span><span class="params">(u64 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="将设备地址映射到用户空间"><a href="#将设备地址映射到用户空间" class="headerlink" title="将设备地址映射到用户空间"></a>将设备地址映射到用户空间</h2><p>驱动可以通过mmap()函数来给用户空间提供设备的虚拟地址，以达到间接访问的目的。</p><p>mmap()实现这样一个映射的过程：将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，<br>实际上会转化为对设备的访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般这样做的目的并不是为了用户空间来直接控制寄存器，因为这就破坏了分层的原则。</span><br><span class="line"></span><br><span class="line">一般就用于将内核空间申请的内存映射到用户空间，这样用户可以直接高效的参与内存读写，避免再进行一次数据搬移。</span><br><span class="line">比如：用户空间直接读写DMA收发的数据。</span><br></pre></td></tr></table></figure><h3 id="内存映射与VMA"><a href="#内存映射与VMA" class="headerlink" title="内存映射与VMA"></a>内存映射与VMA</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 内核 file_operatoins 中的 mmap()</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct file *, struct vm_area_struct *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 用户空间的 mmap()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从内核空间映射一段内存到用户空间</span></span><br><span class="line"><span class="comment"> ,* @param addr : 映射到用户空间以 addr 为起始，为NULL则自动分配</span></span><br><span class="line"><span class="comment"> ,* @param length: 映射的字节数</span></span><br><span class="line"><span class="comment"> ,* @param prot: 内存访问权限</span></span><br><span class="line"><span class="comment"> ,* - PROT_NONE : 不可访问</span></span><br><span class="line"><span class="comment"> ,* - PROT_EXEC : 可以执行</span></span><br><span class="line"><span class="comment"> ,* - PROT_READ : 可读</span></span><br><span class="line"><span class="comment"> ,* - PROT_WRITE: 可写</span></span><br><span class="line"><span class="comment"> ,* @param flags : 内存状态</span></span><br><span class="line"><span class="comment"> ,* - MAP_SHARED : 可被进程共享</span></span><br><span class="line"><span class="comment"> ,* - MAP_PRIVATE: 非共享</span></span><br><span class="line"><span class="comment"> ,* @param fd: 打开的文件索引</span></span><br><span class="line"><span class="comment"> ,* @param offset: 从内核的 offset 偏移处开始映射</span></span><br><span class="line"><span class="comment"> ,* @return 申请的地址</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 取消映射</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>当用户调用 mmap()的时候,内核会进行如下处理.</p><ol><li>在进程的虚拟空间查找一块 VMA</li><li>将这块VMA进行映射</li><li>如果设备驱动程序或者文件系统的file_operations定义了mmap()操作,则调用它</li><li>将这个VMA插入进程的VMA链表中</li></ol><p>驱动中的mmap()的实现机制是建立页表,并填充VMA结构体中 <code>vm_operations_struct</code> 指针.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! 用于描述一个虚拟内存区域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*The first cache line has the info for VMA tree walking.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;<span class="comment">/*Our start address within vm_mm.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;<span class="comment">/*The first byte after our end address within vm_mm*/</span></span><br><span class="line">        <span class="comment">/* lnked list of VM areas per task, sorted by address*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>,*<span class="title">vm_prev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>VMA结构体描述的虚拟地址介于 vm_start 和 vm_end之间,其 vm_ops 成员指向这个VMA的操作集, 针对VMA的操作都被包含在 vm_operations_struct 结构体中.</p><p>操作范例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_mmap</span><span class="params">(stuct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建页表项</span></span><br><span class="line">        <span class="keyword">if</span>(remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff, vma-&gt;vm_end -</span><br><span class="line">                           vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        vma-&gt;vm_ops = &amp;xxx_remap_vm_ops;</span><br><span class="line">        xxx_vma_open(vma);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户空间使用 mmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_open</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA open, virt %lx, phys %lx\n&quot;</span>, vma-&gt;vm_start, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在用户空间使用 munmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_close</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA close.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">xxx_remap_vm_ops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">        .open = xxx_vma_open,</span><br><span class="line">        .close = xxx_vma_close,</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="fault-函数"><a href="#fault-函数" class="headerlink" title="fault() 函数"></a>fault() 函数</h3><p>fault() 函数可以为设备提供更加灵活的内存映射途径。<br>当访问的页不在内存时，fault()会被内核自动调用。</p><p>当发生缺页时，流程为：</p><ol><li>找到缺页的虚拟地址所在的VMA</li><li>如果必要分配中间页目录表和页表</li><li>如果页表项对应的物理页面不存在，则调用 fault() 函数，它返回物理页面的页描述符</li><li>将物理页面地址填充到页表中</li></ol><h1 id="I-O内存静态映射"><a href="#I-O内存静态映射" class="headerlink" title="I/O内存静态映射"></a>I/O内存静态映射</h1><p>在将linux移植到目标电路板的过程中,有的会建立外设I/O内存物理地址到虚拟地址的静态映射,这个映射通过在与电路板对应的 map_desc 结构体数组中添加新的成员完成.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">virtual</span>;  <span class="comment">//虚拟地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn;     <span class="comment">//__phys_to_pfn(phy_addr)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">//内存大小</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> type;     <span class="comment">//内存类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="DMA内存"><a href="#DMA内存" class="headerlink" title="DMA内存"></a>DMA内存</h1><h2 id="DMA与硬件Cache一致性"><a href="#DMA与硬件Cache一致性" class="headerlink" title="DMA与硬件Cache一致性"></a>DMA与硬件Cache一致性</h2><ol><li>在DMA不工作的情况下或者DMA与Cache相对应的主存没有重叠区, 那么Cache 与主存中的数据具有一致性特点.二者并不会起冲突.</li><li>*<strong>当DMA与Cache相对应的主存有重叠区时,当DMA更新了重叠区的内容,而Cache并没有对应的更新.此时CPU仍然使用的是陈旧的cache的数据,就会发生Cache与内存之间数据”不一致性”的错误!</strong><ul><li>当CPU向内存写数据时，此时也是先写到了cache，DMA传输数据到外设依然是原来陈旧的数据</li><li>在发生Cache与内存不一致性错误后,驱动将无法正常运行.</li></ul></li><li>Cache的不一致问题并不是只发生在DMA的情况下,实际上,它还存在于Cache使能和关闭的时刻.例如,对于带MMU功能的ARM处理器,在开启 <em>MMU之前需要先置Cache无效,否则在开启MMU之后,Cache里面有可能保存的还是之前的物理地址,这也会造成不一致性的错误!</em>.</li></ol><h2 id="Linux-下的DMA编程-DMA只是一种外设与内存的交互方式"><a href="#Linux-下的DMA编程-DMA只是一种外设与内存的交互方式" class="headerlink" title="Linux 下的DMA编程(DMA只是一种外设与内存的交互方式)"></a>Linux 下的DMA编程(<em>DMA只是一种外设与内存的交互方式</em>)</h2><p>内存中用于外设交互数据的一块区域称为 DMA 缓冲区, <em><strong>在设备不支持scatter/gather操作的情况下,DMA缓冲区在物理上必须上连续的.</strong></em></p><ul><li>当硬件支持 <code>IOMMU</code> 时，缓冲区也可以不连续</li></ul><h3 id="DMA区域"><a href="#DMA区域" class="headerlink" title="DMA区域"></a>DMA区域</h3><p>对于大多数现代嵌入式处理器而言,DMA操作可以在整个常规内存区域进行,因此DMA区域就直接覆盖了常规内存.</p><h3 id="虚拟地址-物理地址-总线地址"><a href="#虚拟地址-物理地址-总线地址" class="headerlink" title="虚拟地址,物理地址,总线地址"></a>虚拟地址,物理地址,总线地址</h3><ul><li>总线地址： 基于DMA硬件使用的是总线地址而不是物理地址，是从设备角度上看到的内存地址</li><li>物理地址：是从CPU MMU 控制器外围角度上看到的内存地址</li><li>虚拟地址：CPU看到的是MMU反映给它的地址</li></ul><h3 id="DMA地址掩码"><a href="#DMA地址掩码" class="headerlink" title="DMA地址掩码"></a>DMA地址掩码</h3><p>设备不一定能在所有的内存地址上执行DMA操作,在这种情况下需要设置DMA能够操作的地址总线宽度.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask</span><span class="params">(struct device *dev, u64 mask)</span></span></span><br></pre></td></tr></table></figure><p>如果DMA只能操作24位地址,那么就应该调用 <code>dma_set_mask(dev,0xffffff)</code></p><ul><li><p>此时内核会为申请增加 <code>GFP_DMA</code> 标记，以从 DMA_ZONE 中申请内存</p><h3 id="一致性DMA缓冲区"><a href="#一致性DMA缓冲区" class="headerlink" title="一致性DMA缓冲区"></a>一致性DMA缓冲区</h3><p>为了能够避免 <em>DMA与Cache一致性问题</em>,使用如下函数分配一个DMA一致性的内存区域:</p></li><li><p>操作此函数的过程是不用关心CMA区域设置，这个是内核底层完成的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  申请一致性DMA缓冲区(一般不带cache, 但如果有 cache coherent interconnect 硬件支持，则就可以带cache)</span></span><br><span class="line"><span class="comment">  note: 这段缓存区一般是连续的，但如果硬件带IOMMU,则也可以是不连续的</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="comment">//返回申请到的DMA缓冲区的虚拟地址</span></span><br><span class="line"><span class="comment">//handle 代表总线地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_coherent</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放申请的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_coherent</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  分配一个写合并(writecombining)的DMA缓冲区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_writecombine</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_writecombine</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  PCI设备申请缓冲区</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pci_alloc_consistent</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *dma_addrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_free_consisten</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> dma_addr)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>:</p><p><code>dma_alloc_xxx()</code> 函数虽然是以 dma_alloc_开头, <strong>但是其申请的区域不一定在DMA区域里面</strong>.以32位ARM处理器为例,当conherent_dma_mask小于0xffffffff时,才会设置GFP_DMA标记,并从DMA区域去申请内存.</p><h3 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h3><p>在许多情况下缓冲区来自内核的较上层，上层很可能以普通的 kmalloc() 等方式申请内存，<br>也就是说这段内存是具有硬件cache的，这时就需要使用流式DMA。</p><p>流式DMA操作在本质上大多就是进行flush或invalidate Cache操作，以解决一致性问题。</p><ul><li>flush 是指将cache内容写入内存，invalidate是指让CPU再次从内存读取数据来刷新一次cache</li><li>如果有 <code>cache coherent interconnect</code> 硬件，则不需要关闭cache，从应用编程的角度来讲，只要按照规矩来操作即可。</li></ul><p>操作步骤为：</p><ol><li>进行流式DMA映射</li><li>执行DMA操作</li><li>取消映射</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一片内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多片非连续内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;kernel version&lt;/th&gt;
&lt;th&gt;arch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;v5.4.0&lt;/td&gt;
&lt;td&gt;arm32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="memory" scheme="http://kcmetercec.top/categories/linux/memory/"/>
    
    <category term="overview" scheme="http://kcmetercec.top/categories/linux/memory/overview/"/>
    
    
    <category term="linux" scheme="http://kcmetercec.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Buildroot 的定制化使用</title>
    <link href="http://kcmetercec.top/2024/04/09/linux_make_yocto_buildroot/"/>
    <id>http://kcmetercec.top/2024/04/09/linux_make_yocto_buildroot/</id>
    <published>2024-04-08T16:00:00.000Z</published>
    <updated>2024-04-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里记录 Buildroot 的进一步使用说明。</p><span id="more"></span><h1 id="构建过程时修改源码"><a href="#构建过程时修改源码" class="headerlink" title="构建过程时修改源码"></a>构建过程时修改源码</h1><p>Buildroot 构建的过程是下载压缩包、解压、配置、编译、安装，就算包的源是 git 这种版本管理工具，它也会克隆并压缩，然后按照之前的流程进行。</p><p>默认情况下，解压缩后的源码会位于 <code>output/build/&lt;package&gt;-&lt;version&gt;</code>，当使用 <code>make clean</code> 之后，该目录的内容会被清空！</p><p>所以，如果想修改源码再进行打包验证的话，直接在这个目录下操作是不合理的。</p><p>Buildroot 提供了 <code>&lt;pkg&gt;_OVERRIDE_SRCDIR</code> 机制，让 Buildroot 选择指定的源码路径。</p><p>默认在通过 <code>BR2_PACKAGE_OVERRIDE_FILE</code> 配置的覆盖文件是 <code>$(CONFIG_DIR)/local.mk</code>，而 <code>$(CONFIG_DIR)</code> 指的就是 <code>.config</code> 文件所在的路径。</p><p>所以 <code>local.mk</code> 也就是默认和 <code>.config</code> 在一个文件夹下。<code>local.mk</code> 的文件格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pkg1&gt;_OVERRIDE_SRCDIR = /path/to/pkg1/sources</span><br><span class="line">&lt;pkg2&gt;_OVERRIDE_SRCDIR = /path/to/pkg2/sources</span><br></pre></td></tr></table></figure><p>比如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINUX_OVERRIDE_SRCDIR = /home/bob/linux/</span><br><span class="line">BUSYBOX_OVERRIDE_SRCDIR = /home/bob/busybox/</span><br></pre></td></tr></table></figure><p>当指定了特定包的路径后，Buildroot 就不会走下载、解压的步骤，而是直接使用指定路径的源码。在执行编译时，buildroot 会将源码拷贝到指定目录下的 <code>&lt;package&gt;-custom</code>。</p><p>然后就可以使用：</p><ul><li><code>make &lt;pkg&gt;-rebuild</code> ： 重新编译</li><li><code>make &lt;pkg&gt;-reconfig</code> ： 重新配置</li><li><code>make &lt;pkg&gt;-rebuild all</code> : 重新配置并编译</li></ul><p>除此之外，对于像 UBOOT、Kernel 这种包，需要指定其配置文件，配置文件不能带有<code>_defconfig</code>。</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_uboot_src.jpg?raw=true"><br>对于 Linux 而言，还需要注意配置其设备树：</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_linux_src.jpg?raw=true"></p><h1 id="常用的配置步骤"><a href="#常用的配置步骤" class="headerlink" title="常用的配置步骤"></a>常用的配置步骤</h1><p>使用 Buildroot 的一般配置步骤如下：</p><ul><li><p>配置 Buildroot 基本配置，比如工具链、bootloader、内核、文件系统等</p></li><li><p>配置其他组件，比如 BusyBox、Qt 等</p></li><li><p>进行文件系统定制化配置</p><ul><li><p>根据配置<code>BR2_ROOTFS_OVERLAY</code>,将需要覆盖的配置文件、应用程序按照文件系统结构放置</p></li><li><p>根据配置<code>BR2_ROOTFS_POST_BUILD_SCRIPT</code>指定的脚本，修改或删除文件</p></li><li><p>根据配置<code>BR2_ROOTFS_DEVICE_TABLE</code>来修改特定文件的权限</p></li><li><p>根据配置<code>BR2_ROOTFS_STATIC_DEVICE_TABLE</code>来增加特定的设备节点</p></li><li><p>根据配置<code>BR2_ROOTFS_USERS_TABLES</code>来添加用户</p></li><li><p>根据配置<code>BR2_ROOTFS_POST_IMAGE_SCRIPT</code>指定的脚本来生成镜像文件</p></li><li><p>根据配置<code>BR2_GLOBAL_PATCH_DIR</code>来添加对应包的补丁</p></li></ul></li></ul><h1 id="推荐的定制化目录"><a href="#推荐的定制化目录" class="headerlink" title="推荐的定制化目录"></a>推荐的定制化目录</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+-- board/</span><br><span class="line">| +-- &lt;company&gt;/</span><br><span class="line">|     +-- &lt;boardname&gt;/</span><br><span class="line">|         +-- linux.config</span><br><span class="line">|         +-- busybox.config</span><br><span class="line">|         +-- &lt;other configuration files&gt;</span><br><span class="line">|         +-- post_build.sh</span><br><span class="line">|         +-- post_image.sh</span><br><span class="line">|         +-- rootfs_overlay/</span><br><span class="line">|         |     +-- etc/</span><br><span class="line">|         |     +-- &lt;some files&gt;</span><br><span class="line">|         +-- patches/</span><br><span class="line">|             +-- foo/</span><br><span class="line">|             |     +-- &lt;some patches&gt;</span><br><span class="line">|             +-- libbar/</span><br><span class="line">|                 +-- &lt;some other patches&gt;</span><br><span class="line">|</span><br><span class="line">+-- configs/</span><br><span class="line">|     +-- &lt;boardname&gt;_defconfig</span><br><span class="line">|</span><br><span class="line">+-- package/</span><br><span class="line">| +-- &lt;company&gt;/</span><br><span class="line">|         +-- Config.in (if not using a br2-external tree)</span><br><span class="line">|         +-- &lt;company&gt;.mk (if not using a br2-external tree)</span><br><span class="line">|         +-- package1/</span><br><span class="line">|         |     +-- Config.in</span><br><span class="line">|         |     +-- package1.mk</span><br><span class="line">|         +-- package2/</span><br><span class="line">|             +-- Config.in</span><br><span class="line">|             +-- package2.mk</span><br><span class="line">|</span><br><span class="line">+-- Config.in (if using a br2-external tree)</span><br><span class="line">+-- external.mk (if using a br2-external tree)</span><br><span class="line">+-- external.desc (if using a br2-external tree)</span><br></pre></td></tr></table></figure><p>以上的目录结构既可以在 Buildroot 上建立一个分支，也可以在 Buildroot 目录之外建立。</p><p>如果在目录之外建立，那么在首次构建时，需要设置变量<code>BR2_EXTERNAL</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BR2_EXTERNAL=/path/to/foo menuconfig</span></span><br></pre></td></tr></table></figure><p>该设置会被保存在 output 目录的 <code>.br2-external.mk</code> 文件中，下次再构建就可以不用再次设置了。</p><p>如果要切换到新目录，就再设置一次该变量即可。也可以关闭使用外部目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BR2_EXTERNAL= menuconfig</span></span><br></pre></td></tr></table></figure><h1 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h1><h2 id="Buildroot-的整体配置"><a href="#Buildroot-的整体配置" class="headerlink" title="Buildroot 的整体配置"></a>Buildroot 的整体配置</h2><p>简单的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make savedefconfig</span><br></pre></td></tr></table></figure><p>将当前配置保存为文件<code>defconfig</code>，也可以存放在其他位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make savedefconfig BR2_DEFCONFIG=&lt;path-to-defconfig&gt;</span><br></pre></td></tr></table></figure><p>最简单的方式还是存在<code>configs/&lt;boardname&gt;_defconfig</code></p><h2 id="其他软件包的配置"><a href="#其他软件包的配置" class="headerlink" title="其他软件包的配置"></a>其他软件包的配置</h2><p>对于像 U-Boot，Linux 的配置，也应该需要保存。保存的位置根据前面所述，位于<code>board/&lt;company&gt;/&lt;boardname&gt;/</code>中最好。</p><p>可以使用<code>make linux-menuconfig</code>来创建 linux 的配置文件。</p><ul><li><p><code>make linux-update-defconfig</code>将配置存储于<code>BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE</code>指定的路径中</p></li><li><p><code>make busybox-update-config</code>将配置存储于<code>BR2_PACKAGE_BUSYBOX_CONFIG</code>指定的路径中</p></li><li><p><code>make uboot-update-defconfig</code>将配置存储于 <code>BR2_TARGET_UBOOT_CUSTOM_CONFIG_FILE</code>指定的路径中</p></li></ul><h1 id="定制文件系统"><a href="#定制文件系统" class="headerlink" title="定制文件系统"></a>定制文件系统</h1><p>定制文件系统有两种方式，一种是覆盖文件系统，一种是通过预构建脚本。</p><h2 id="覆盖-BR2-ROOTFS-OVERLAY"><a href="#覆盖-BR2-ROOTFS-OVERLAY" class="headerlink" title="覆盖 (BR2_ROOTFS_OVERLAY)"></a>覆盖 (<code>BR2_ROOTFS_OVERLAY</code>)</h2><p>配置<code>BR2_ROOTFS_OVERLAY</code>指定了覆盖目录的路径，Buildroot 会按照该目录的路径对文件系统进行覆盖。</p><p>比较推荐的路径是<code>board/&lt;company&gt;/&lt;boardname&gt;/rootfs-overlay</code></p><h1 id="构建脚本-BR2-ROOTFS-POST-BUILD-SCRIPT"><a href="#构建脚本-BR2-ROOTFS-POST-BUILD-SCRIPT" class="headerlink" title="构建脚本(BR2_ROOTFS_POST_BUILD_SCRIPT)"></a>构建脚本(<code>BR2_ROOTFS_POST_BUILD_SCRIPT</code>)</h1><p>在 Buildroot 构建了软件但还没有打包镜像文件时，会运行该配置指定的脚本。</p><p>这种方式更为灵活，可以删除、编辑目标板上的文件。</p><p>比较推荐的路径是``board/<company>/<boardname>/post_build.sh<code>.</code></p><p>该脚本被调用时，传入的第一个参数，就是目标文件系统的路径。</p><p>除此之外，还有其他变量可以使用：</p><ul><li><p><code>BR2_CONFIG</code>：Buildroot .config 文件路径</p></li><li><p><code>CONFIG_DIR</code>：包含 .config 的目录路径</p></li><li><p><code>HOST_DIR`, `STAGING_DIR`, `TARGET_DIR</code></p></li><li><p><code>BUILD_DIR</code>：构建路径</p></li><li><p><code>BINARIES_DIR</code>：镜像文件的存放路径</p></li><li><p><code>BASE_DIR</code>：输出路径</p></li></ul><h1 id="设置文件权限和所有人"><a href="#设置文件权限和所有人" class="headerlink" title="设置文件权限和所有人"></a>设置文件权限和所有人</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;这里记录 Buildroot 的进一步使用说明。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="make" scheme="http://kcmetercec.top/categories/linux/make/"/>
    
    <category term="yocto" scheme="http://kcmetercec.top/categories/linux/make/yocto/"/>
    
    
    <category term="yocto" scheme="http://kcmetercec.top/tags/yocto/"/>
    
  </entry>
  
  <entry>
    <title>linux 构建系统</title>
    <link href="http://kcmetercec.top/2024/03/09/linux_make_yocto_build_system/"/>
    <id>http://kcmetercec.top/2024/03/09/linux_make_yocto_build_system/</id>
    <published>2024-03-08T16:00:00.000Z</published>
    <updated>2024-03-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面已经手撸了整个嵌入式系统的构建过程，但是在实际工作中，尤其是根文件系统的建立是很费时间的。这个时候一个自动化的构建工具就非常重要了。</p><p>自动化构建工具，需要能完成：</p><ol><li>自动化的获取源码（不管是网络还是本地）</li><li>为源码打补丁，并进行一些配置</li><li>完成构建</li><li>将构建的文件组织成根文件系统</li><li>最终可以将多个镜像文件打包并装载到目标机。</li></ol><p>以上的过程都是可以用户灵活配置的，并可以输出 SDK 便于多个开发人员的环境统一。</p><p>目前有以下自动化构建工具：</p><ol><li><a href="https://buildroot.org/">Buildroot</a>：使用 Make 和 Kconfig 的构建工具，非常易于使用。</li><li><a href="https://www.embtoolkit.org/">EmbToolkit</a>：用于构建跟文件系统和工具链的简单构建工具</li><li><a href="https://openembedded.org/">OpenEmbedded</a>：功能强大的构建系统，是 Yocto 的核心组件</li><li><a href="https://openwrt.org/">OpenWrt</a>：专用于构建无线路由器软件包的工具</li><li><a href="https://www.ptxdist.org/">PTXdist</a>：简单的构建工具</li><li><a href="https://www.yoctoproject.org/">Yocto</a>基于 OpenEmbedded 扩展的元数据、工具、文档集，更为强大的构建工具</li></ol><p>其中 Buildroot 最易用，Yocto 最完善，所以这里只关注 Buildroot 和 Yocto。</p><span id="more"></span><h1 id="使用-Buildroot-构建"><a href="#使用-Buildroot-构建" class="headerlink" title="使用 Buildroot 构建"></a>使用 Buildroot 构建</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>要正常使用 Buildroot 需要至少安装以下依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y sed make binutils build-essential \</span><br><span class="line">diffutils gcc g++ bash patch gzip bzip2 perl tar cpio unzip \</span><br><span class="line">rsync file bc findutils wget python3 libncurses5-dev </span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>buildroot 具有一些默认配置文件，存在于<code>configs</code>文件夹下，也可以使用<code>make list-defconfigs</code> 来列出所有的默认配置。</p><p>对于 bbb 而言就是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make beaglebone_defconfig menuconfig</span><br></pre></td></tr></table></figure><p>接下来需要对配置做一些修改。</p><ol><li><p>选择自己构建的工具链：</p><ul><li><p><strong>Toolchain-&gt;Toolchain type-&gt;External toolchain</strong></p></li><li><p><strong>Toolchain-&gt;Toolchain-&gt;Custom toolchain</strong></p></li><li><p><strong>Toolchain-&gt;Toolchain path</strong>：填入工具链的路径</p></li><li><p><strong>Toolchain-&gt;Toolchain prefix</strong>：修改为正确的工具链前缀</p></li><li><p>选择 c 库为 glibc</p></li></ul></li><li><p>配置工具链的版本：</p><ul><li><strong>Toolchain-&gt;External toolchain gcc version</strong>：可以通过<code>arm-cortex_a8-linux-gnueabihf-gcc -v</code> 查看</li></ul></li></ol><p>工具链对应的头文件版本，有对应的说明：</p><blockquote><p>If unsure what version your toolchain is using, you can look  at the value of LINUX_VERSION_CODE in linux/version.h in your  toolchain. The Linux version is M.m.p, with:<br> M = ( LINUX_VERSION_CODE &gt;&gt; 16 ) &amp; 0xFF<br> m = ( LINUX_VERSION_CODE &gt;&gt; 8  ) &amp; 0xFF<br> p = ( LINUX_VERSION_CODE &gt;&gt; 0  ) &amp; 0xFF </p></blockquote><p>那么查看当前工具链：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ./arm-cortex_a8-linux-gnueabihf/sysroot/usr/include/linux/version.h</span><br></pre></td></tr></table></figure><p>得到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">define LINUX_VERSION_CODE 328466</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; <span class="string">16) + ((b) &lt;&lt; 8) + (c))</span></span></span><br></pre></td></tr></table></figure><p>那么就得到对应的版本是：5.03.18</p><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_compiler.jpg?raw=true"><br>3. 以 initramfs 的方式构建：</p><ul><li><strong>Filesystem images-&gt;cpio the root filesystem (for use as an initial RAM filesystem)</strong></li><li><strong>Compression method-&gt;lz4</strong>：这是为了文件系统尽量的小</li></ul><ol start="4"><li>取消 Kernel 和 Uboot 的构建，因为前面几章已经构建了自己的 bootloader 和 Kernel</li></ol><p>在取消了内核和 Uboot 构建后，需要修改文件 <code>board/beaglebone/genimage.cfg</code>，让它只生成 rootfs.cpio：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">image boot.vfat &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    vfat &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        files = &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;MLO&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;u-boot.img&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;zImage&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;uEnv.txt&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-evm.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-evmsk.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bone.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-boneblack.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bonegreen.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-boneblack-wireless.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bonegreen-wireless.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;extlinux&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#    size = 16M</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line"></span><br><span class="line">image sdcard.img &#123;</span><br><span class="line">    hdimage &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #partition u-boot &#123;</span><br><span class="line">    #    partition-type = 0xC</span><br><span class="line">    #    bootable = &quot;true&quot;</span><br><span class="line">    #    image = &quot;boot.vfat&quot;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    partition rootfs &#123;</span><br><span class="line">        partition-type = 0x83</span><br><span class="line">        image = &quot;rootfs.cpio&quot;</span><br><span class="line">        size = 512M</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 <code>make</code> 构建后，会产生两个新的目录：</p><ul><li><p><code>dl</code>：用于 Buildroot 构建的，从网络下载的软件包</p></li><li><p><code>output</code>：包含编译的中间文件和最终的文件</p></li></ul><p>在 <code>output</code>中有以下目录：</p><ul><li><p><code>build</code>：包含所有组件的编译输出</p></li><li><p><code>host</code>：包含 Buildroot 所需要的主机上的工具</p></li><li><p><code>images</code>：打包好的镜像文件和一些脚本</p></li><li><p><code>staging</code>：指向编译器的<code>sysroot</code>的符号链接</p></li><li><p><code>target</code>：根文件系统，但是其权限不对，所以无法直接使用</p></li></ul><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来，只需要把生成的<code>rootfs.cpio</code>编译进内核，然后在 Uboot 中输入命令就可以进入新做的文件系统了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/sbin/init</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure><h2 id="sdcard-img-内容查看"><a href="#sdcard-img-内容查看" class="headerlink" title="sdcard.img 内容查看"></a>sdcard.img 内容查看</h2><p>查看 sdcard.img 可以通过 fdisk 和 mount 在本机上查看：</p><p>先通过 <code>fdisk -l ./sdcard.img</code> 查看分区情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cec@box:$ fdisk -l ./sdcard.img </span><br><span class="line">Disk ./sdcard.img: 38.58 MiB, 40458240 bytes, 79020 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x00000000</span><br><span class="line"></span><br><span class="line">Device        Boot Start     End Sectors  Size Id Type</span><br><span class="line">./sdcard.img1 *        1   32768   32768   16M  c W95 FAT32 (LBA)</span><br><span class="line">./sdcard.img2      32769 1081344 1048576  512M 83 Linux</span><br></pre></td></tr></table></figure><p>可以看到分区大小和类型，然后可以挂载在当前某个空目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> offset 指定挂载的起始位置</span></span><br><span class="line">sudo mount -o loop,offset=$((1*512)) -t vfat ./sdcard.img ./mnt/</span><br></pre></td></tr></table></figure><h2 id="将应用程序打包进-rootfs"><a href="#将应用程序打包进-rootfs" class="headerlink" title="将应用程序打包进 rootfs"></a>将应用程序打包进 rootfs</h2><h3 id="overlay-的方式"><a href="#overlay-的方式" class="headerlink" title="overlay 的方式"></a>overlay 的方式</h3><p>在编译完应用程序后，将其拷贝到 board 对应的 overlay 目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cec@box:~/github/buildroot-2024.02/board/beaglebone/rootfs_overlay$ mkdir -p usr/bin</span><br><span class="line"></span><br><span class="line">cp ~/lab/cpp/hello/hello /home/cec/github/buildroot-2024.02/board/beaglebone/rootfs_overlay</span><br></pre></td></tr></table></figure><p>然后配置 buildroot 中的 <strong>System configuration | Root filesystem overlay directories</strong> 为此 overlay 路径，再次编译后该应用程序便被打包进去了。</p><h1 id="重新认识构建过程"><a href="#重新认识构建过程" class="headerlink" title="重新认识构建过程"></a>重新认识构建过程</h1><h2 id="初始化构建环境"><a href="#初始化构建环境" class="headerlink" title="初始化构建环境"></a>初始化构建环境</h2><p>NXP 将构建初始化环境又封装了一次脚本，所以其构建命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DISTRO=fsl-imx-xwayland MACHINE=myd-imx8mm source myir-setup-release.sh -b build-xwayland</span><br></pre></td></tr></table></figure><p>可以先不去分析<code>myir-setup-release.sh</code>，而是看其输出的结果。</p><h3 id="bblayers-conf"><a href="#bblayers-conf" class="headerlink" title="bblayers.conf"></a>bblayers.conf</h3><p>首先看<code>bblayers.conf</code>，这包含了 bitbake 将要构建的层：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">LCONF_VERSION = &quot;7&quot;</span><br><span class="line"></span><br><span class="line">BBPATH = &quot;$&#123;TOPDIR&#125;&quot;</span><br><span class="line">BSPDIR := &quot;$&#123;@os.path.abspath(os.path.dirname(d.getVar(&#x27;FILE&#x27;, True)) + &#x27;/../..&#x27;)&#125;&quot;</span><br><span class="line"></span><br><span class="line">BBFILES ?= &quot;&quot;</span><br><span class="line">BBLAYERS = &quot; \</span><br><span class="line"><span class="meta">  $</span><span class="bash">&#123;BSPDIR&#125;/sources/poky/meta \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/poky/meta-poky \</span></span><br><span class="line"><span class="bash">  \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-oe \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-multimedia \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-python \</span></span><br><span class="line"><span class="bash">  \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale-3rdparty \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale-distro \</span></span><br><span class="line"><span class="bash"><span class="string">&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> i.MX Yocto Project Release layers</span></span></span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-bsp &quot;</span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-sdk &quot;</span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-ml &quot;</span><br><span class="line"></span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-browser&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-rust&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-gnome&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-networking&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-filesystems&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-qt5&quot;</span><br></pre></td></tr></table></figure><p>为了能够比较清楚的知道层之间的优先级，需要输出其优先级来看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers show-layers</span></span><br><span class="line">NOTE: Starting bitbake server...</span><br><span class="line">layer                 path                                      priority</span><br><span class="line">==========================================================================</span><br><span class="line">meta                  ~/yocto/sources/poky/meta      5</span><br><span class="line">meta-poky             ~/yocto/sources/poky/meta-poky  5</span><br><span class="line">meta-oe               ~/yocto/sources/meta-openembedded/meta-oe  6</span><br><span class="line">meta-multimedia       ~/yocto/sources/meta-openembedded/meta-multimedia  6</span><br><span class="line">meta-python           ~/yocto/sources/meta-openembedded/meta-python  7</span><br><span class="line">meta-freescale        ~/yocto/sources/meta-freescale  5</span><br><span class="line">meta-freescale-3rdparty  ~/yocto/sources/meta-freescale-3rdparty  4</span><br><span class="line">meta-freescale-distro  ~/yocto/sources/meta-freescale-distro  4</span><br><span class="line">meta-bsp              ~/yocto/sources/meta-myir/meta-bsp  8</span><br><span class="line">meta-sdk              ~/yocto/sources/meta-myir/meta-sdk  8</span><br><span class="line">meta-ml               ~/yocto/sources/meta-myir/meta-ml  8</span><br><span class="line">meta-browser          ~/yocto/sources/meta-browser   7</span><br><span class="line">meta-rust             ~/yocto/sources/meta-rust      7</span><br><span class="line">meta-gnome            ~/yocto/sources/meta-openembedded/meta-gnome  7</span><br><span class="line">meta-networking       ~/yocto/sources/meta-openembedded/meta-networking  5</span><br><span class="line">meta-filesystems      ~/yocto/sources/meta-openembedded/meta-filesystems  6</span><br><span class="line">meta-qt5              ~/yocto/sources/meta-qt5       7</span><br></pre></td></tr></table></figure><p>数值越大优先级越高（可以覆盖低优先级的配置），那么可以看到在<code>meta-myir</code>层中的优先级较高，在后面需要对当前配置进行微调时，可以在这个层中进行修改。</p><h3 id="local-conf"><a href="#local-conf" class="headerlink" title="local.conf"></a>local.conf</h3><p><code>local.conf</code>是对构建环境变量的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat conf/local.conf</span></span><br><span class="line">MACHINE ??= &#x27;myd-imx8mm&#x27;</span><br><span class="line">DISTRO ?= &#x27;fsl-imx-xwayland&#x27;</span><br><span class="line">PACKAGE_CLASSES ?= &#x27;package_rpm&#x27;</span><br><span class="line">EXTRA_IMAGE_FEATURES ?= &quot;debug-tweaks&quot;</span><br><span class="line">USER_CLASSES ?= &quot;buildstats image-mklibs image-prelink&quot;</span><br><span class="line">PATCHRESOLVE = &quot;noop&quot;</span><br><span class="line">BB_DISKMON_DIRS ??= &quot;\</span><br><span class="line">    STOPTASKS,$&#123;TMPDIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,$&#123;DL_DIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,$&#123;SSTATE_DIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,/tmp,100M,100K \</span><br><span class="line">    ABORT,$&#123;TMPDIR&#125;,100M,1K \</span><br><span class="line">    ABORT,$&#123;DL_DIR&#125;,100M,1K \</span><br><span class="line">    ABORT,$&#123;SSTATE_DIR&#125;,100M,1K \</span><br><span class="line">    ABORT,/tmp,10M,1K&quot;</span><br><span class="line">PACKAGECONFIG_append_pn-qemu-system-native = &quot; sdl&quot;</span><br><span class="line">CONF_VERSION = &quot;1&quot;</span><br><span class="line"></span><br><span class="line">DL_DIR ?= &quot;$&#123;BSPDIR&#125;/downloads/&quot;</span><br><span class="line">ACCEPT_FSL_EULA = &quot;1&quot;</span><br></pre></td></tr></table></figure><p>这里最主要的就是<code>MACHINE</code>和<code>DISTRO</code>两个环境变量：</p><ul><li><code>MACHINE</code>：主要表明了对用户空间以下的系统配置，比如 bootloader，kernel</li><li><code>DISTRO</code>：则是对整个发型版的全局配置，比如发行版的名字，使用 x11 还是 wayland 等</li></ul><p>除了以上二者，还有个比较重要的就是<code>image</code>。</p><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>构建完整镜像，使用<code>bitbake myir-image-full</code>即可，这里表示了与之相关的 image 就是 <code>myir-image-full</code>。</p><h2 id="构建的脉络"><a href="#构建的脉络" class="headerlink" title="构建的脉络"></a>构建的脉络</h2><p>基于<code>MACHINE</code>,<code>DISTRO</code>和<code>image</code>这 3 个最为重要的元素，以及所包含的 layer，便可以梳理出构建的主要脉络。</p><h3 id="MACHINE"><a href="#MACHINE" class="headerlink" title="MACHINE"></a>MACHINE</h3><p>通过<code>MACHINE</code>的值，便可以搜寻到其关联的配置文件<code>myd-imx8mm.conf</code>。</p><p>在这个文件中，便可以清楚明了的看到以下主要内容：</p><ul><li><code>bootloader</code>的配置</li><li>会生成的设备树</li><li>kernel 构建时调用的配置文件</li></ul><h3 id="DISTRO"><a href="#DISTRO" class="headerlink" title="DISTRO"></a>DISTRO</h3><p>通过<code>DISTRO</code>的值，可以搜寻到其关联的配置文件<code>fsl-imx-xwayland.conf</code>。</p><p>通过展开其包含的头文件，就可以清楚明了的看到其使用的是<code>wayland</code>，初始化系统使用的是<code>systemd</code>等。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>通过<code>myir-image-full</code>可以查到其对用的 recipe 文件就是<code>myir-image-full.bb</code>。</p><p>可以看到它在<code>imx-image-multimedia.bb</code>的基础之上进行了文件系统的扩展。</p><h3 id="layer-之间的覆盖"><a href="#layer-之间的覆盖" class="headerlink" title="layer 之间的覆盖"></a>layer 之间的覆盖</h3><p>可以使用命令<code>bitbake-layers show-appends</code>来查看对原有<code>recipe</code>的附加修改。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果仅仅是在官方提供的构建工具下做微调，那么只要把握<code>MACHINE</code>,<code>DISTRO</code>,<code>image</code>,<code>layers</code>这 4 个核心元素，就可以顺藤摸瓜了解整个系统的配置。</p><p>其他的诸如变量表达式的意思、生成文件的路径、配置的增加及删除等等都是一些细枝末节的东西。只要把握重点，并通过查询文档便可以掌握这些细枝末节。</p><p>整个嵌入式开发的重点难点依然是在<code>bootloader</code>,<code>kernel</code>，以及用户态的业务逻辑层。</p><h1 id="认识-devtool"><a href="#认识-devtool" class="headerlink" title="认识 devtool"></a>认识 devtool</h1><p>简单的 recipe 可以使用 bitbake-layers 来创建，然后再手动编写。但是如果 recipe 太多时，就会比较繁琐。这个时候使用 devtool 就会更加方便。</p><h2 id="devtool-的工作流"><a href="#devtool-的工作流" class="headerlink" title="devtool 的工作流"></a>devtool 的工作流</h2><p>首先初始化工作环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> oe-init-build-env build/</span></span><br></pre></td></tr></table></figure><p>然后创建新的层：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers create-layer ../meta-mine</span></span><br></pre></td></tr></table></figure><p>接下来将新建的层加入构建任务中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers add-layer ../meta-mine</span></span><br></pre></td></tr></table></figure><p>然后使用<code>devtool</code>来构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool build-image core-image-sato</span></span><br></pre></td></tr></table></figure><p>经过构建后，发现<code>conf</code>目录下新增了一个<code>devtool.conf</code>文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[General]</span><br><span class="line">workspace_path = /home/cec/github/poky/build/workspace</span><br><span class="line"></span><br><span class="line">[SDK]</span><br><span class="line">target_basename = core-image-sato</span><br></pre></td></tr></table></figure><p>其中的<code>workspace_path</code>指定了由<code>devtool</code>所创建的沙盒工作区，可以在这里面做一些试验。</p><blockquote><p>可以看到在 bblayers.conf 中也加入了该 workspace 的路径，在用户测试完成后，可以将该路径移除。</p></blockquote><h2 id="创建新的-recipe"><a href="#创建新的-recipe" class="headerlink" title="创建新的 recipe"></a>创建新的 recipe</h2><p>下面以<code>devtool</code>来构建<a href="https://github.com/containers/bubblewrap">bubblewrap</a>。</p><h3 id="增加-recipe"><a href="#增加-recipe" class="headerlink" title="增加 recipe"></a>增加 recipe</h3><p>首先增加这个 recipe：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool add https://github.com/containers/bubblewrap/releases/download/v0.5.0/bubblewrap-0.5.0.tar.xz</span></span><br></pre></td></tr></table></figure><p>可以发现<code>devtool</code>会自动下载压缩包，然后解压缩文件，接下来会自动创建一些 recipe：</p><ol><li><p>在<code>appends</code>目录下创建<code>bubblewrap_0.5.0.bbappend</code></p><blockquote><p>这里面指定了本地解压缩源码的位置</p></blockquote></li><li><p>在<code>recipes</code>目录下创建<code>bubblewrap/bubblewrap_0.5.0.bb</code></p><blockquote><p>这里面指定了远端 URI 及其校验，还根据源码推测了构建系统是 autotools</p></blockquote></li><li><p>在<code>source</code>目录中即为 bubblewrap 的源码</p></li></ol><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>接下来是编辑文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool edit-recipe bubblewrap</span></span><br></pre></td></tr></table></figure><p>可以指定其说明文件安装目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> PN 代表 packagename，在这里就是 bubblewrap。将其说明安装到 /usr/share 目录中</span></span><br><span class="line"><span class="meta">FILES_$</span><span class="bash">&#123;PN&#125; += <span class="string">&quot;/usr/share/*&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>构建命令也十分简单：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool build bubblewrap</span></span><br></pre></td></tr></table></figure><p>接下来便可以看到其配置、编译、打包的过程。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><code>devtool</code>可以将构建的包直接部署到目标机，以便快速验证结果。</p><p>这里先启动<code>qemu</code>来做演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> runqemu qemux86-64 nographic</span></span><br></pre></td></tr></table></figure><p>可以通过 ifconfig 看到其 ip 是 192.168.7.2，那么就将该包部署过去：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool deploy-target bubblewrap root@192.168.7.2</span></span><br></pre></td></tr></table></figure><p><code>bwrap</code>可执行文件便安装完成了，且可执行了。</p><h3 id="清除部署"><a href="#清除部署" class="headerlink" title="清除部署"></a>清除部署</h3><p>当测试完成后，便可以从目标机系统中清除该包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool undeploy-target bubblewrap root@192.168.7.2</span></span><br></pre></td></tr></table></figure><p>执行该命令后，可以发现<code>bwrap</code>相关文件已经清理完毕了。</p><h3 id="完成-recipe"><a href="#完成-recipe" class="headerlink" title="完成 recipe"></a>完成 recipe</h3><p>到目前为止还只是测试完毕，接下来就是将沙盒中的 recipe 更新到<code>meta-mine</code>中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool finish -f bubblewrap ../meta-mine</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>meta-mine</code>中已经包含了<code>bubblewrap</code>相关 recipe，干净又整洁！</p><p>既然已经部署完成，便可以删除之前的沙盒了，为了以后再次构建，也可以仅仅在<code>bblayers.conf</code>中屏蔽这个沙盒 layer 即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面已经手撸了整个嵌入式系统的构建过程，但是在实际工作中，尤其是根文件系统的建立是很费时间的。这个时候一个自动化的构建工具就非常重要了。&lt;/p&gt;
&lt;p&gt;自动化构建工具，需要能完成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动化的获取源码（不管是网络还是本地）&lt;/li&gt;
&lt;li&gt;为源码打补丁，并进行一些配置&lt;/li&gt;
&lt;li&gt;完成构建&lt;/li&gt;
&lt;li&gt;将构建的文件组织成根文件系统&lt;/li&gt;
&lt;li&gt;最终可以将多个镜像文件打包并装载到目标机。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上的过程都是可以用户灵活配置的，并可以输出 SDK 便于多个开发人员的环境统一。&lt;/p&gt;
&lt;p&gt;目前有以下自动化构建工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://buildroot.org/&quot;&gt;Buildroot&lt;/a&gt;：使用 Make 和 Kconfig 的构建工具，非常易于使用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.embtoolkit.org/&quot;&gt;EmbToolkit&lt;/a&gt;：用于构建跟文件系统和工具链的简单构建工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openembedded.org/&quot;&gt;OpenEmbedded&lt;/a&gt;：功能强大的构建系统，是 Yocto 的核心组件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://openwrt.org/&quot;&gt;OpenWrt&lt;/a&gt;：专用于构建无线路由器软件包的工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ptxdist.org/&quot;&gt;PTXdist&lt;/a&gt;：简单的构建工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yoctoproject.org/&quot;&gt;Yocto&lt;/a&gt;基于 OpenEmbedded 扩展的元数据、工具、文档集，更为强大的构建工具&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中 Buildroot 最易用，Yocto 最完善，所以这里只关注 Buildroot 和 Yocto。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="make" scheme="http://kcmetercec.top/categories/linux/make/"/>
    
    <category term="yocto" scheme="http://kcmetercec.top/categories/linux/make/yocto/"/>
    
    
    <category term="yocto" scheme="http://kcmetercec.top/tags/yocto/"/>
    
  </entry>
  
  <entry>
    <title>构建根文件系统</title>
    <link href="http://kcmetercec.top/2024/02/27/linux_make_yocto_fs/"/>
    <id>http://kcmetercec.top/2024/02/27/linux_make_yocto_fs/</id>
    <published>2024-02-26T16:00:00.000Z</published>
    <updated>2024-02-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新来梳理一下根文件系统编译。</p><span id="more"></span><h1 id="根文件系统里面有什么？"><a href="#根文件系统里面有什么？" class="headerlink" title="根文件系统里面有什么？"></a>根文件系统里面有什么？</h1><p>内核挂载根文件系统，可以以<code>initramfs</code>的方式，或者通过<code>root=</code>参数指定的设备来挂载，然后执行其<code>init</code>程序来进行接下来的初始化。</p><p>最小的根文件系统包含下面这些基本组件：</p><ul><li><code>init</code>：用于初始化系统基本环境的程序，通常会调用一系列的脚本</li><li><code>shell</code>：提供一个用于交互的命令行环境，以执行其他的程序</li><li><code>Daemons</code>：守护进程为其他程序提供基础服务</li><li><code>Shared libraries</code>：很多程序都会使用到共享库，所以这个是必须的</li><li><code>Configuration files</code>：对守护进程对应的配置文件，通常位于<code>/etc</code>目录下</li><li><code>Device nodes</code>：设备节点提供应用程序的访问设备驱动的通道</li><li><code>proc and sys</code>：提供对内核参数的检测和控制文件夹</li><li><code>Kernel modules</code>：内核模块会被安装于<code>/lib/modules/&lt;kernel versoin&gt;/</code>中</li></ul><h2 id="目录的分布"><a href="#目录的分布" class="headerlink" title="目录的分布"></a>目录的分布</h2><p>为满足 FHS（Filesystem Hierarchy Standard）标准，一般目录分布如下：</p><ul><li><code>/bin</code>：对所有用户都适用的基础命令</li><li><code>/dev/</code>：存放设备节点和其他特殊文件</li><li><code>/etc/</code>：系统配置文件</li><li><code>/lib</code>：系统基本的共享库</li><li><code>/proc</code>：对进程等内核参数进行交互的虚拟文件</li><li><code>/sbin</code>：对系统管理员所适用的基础命令</li><li><code>/sys</code>：描述设备何其驱动对应关系的虚拟文件</li><li><code>/tmp</code>：用于存放临时文件的 RAM fs</li><li><code>/usr</code>：更多的命令、库、管理员工具等</li><li><code>/var</code>：存放在运行时会被改变的文件</li></ul><p>对于 <code>proc</code>和<code>sysfs</code>是需要挂载的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount [-t vfstype] [-o options] device directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载存储设备时，大部分情况下不用主动指明文件系统</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而对于 proc,sysfs 这种伪文件系统，则需要指明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t proc proc /proc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t sysfs sysfs /sys</span></span><br></pre></td></tr></table></figure><h2 id="创建staging文件夹"><a href="#创建staging文件夹" class="headerlink" title="创建staging文件夹"></a>创建<code>staging</code>文件夹</h2><p>所谓的<code>staging</code>文件夹，就是一个根文件系统的基础框架，在最开始可以创建它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir bin dev etc home lib proc sbin sys tmp usr var</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir usr/bin usr/lib usr/sbin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p var/<span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于 ARM64 lib 引用的是 lib64，其实只需要为 lib 创建软链接即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s lib lib64</span></span><br></pre></td></tr></table></figure><p>接下来就是要考虑一些文件的权限问题了，对于一些重要文件应该限制为<code>root </code>用户才能操作。而其他程序应该运行在普通用户模式。</p><h2 id="目录中具有的程序"><a href="#目录中具有的程序" class="headerlink" title="目录中具有的程序"></a>目录中具有的程序</h2><h3 id="init程序"><a href="#init程序" class="headerlink" title="init程序"></a><code>init</code>程序</h3><p><code>init</code>程序是进入根文件系统后运行的第一个程序。</p><blockquote><p>对于 busybox 而言，就是<code>/sbin/init</code>，最终还是指向 busybox 这个独立可执行程序。</p></blockquote><p><code>init</code>程序首先会读取<code>/etc/inittab</code>中的配置，然后依次启动对应的程序。</p><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p><code>Shell</code>用户运行脚本，和用户交互等。在嵌入式系统中，有这么几个常用的<code>Shell</code>：</p><ul><li><code>bash</code>：功能强大，但是体积占用也大，一般运行于桌面系统中。</li><li><code>ash</code>：和<code>bash</code>兼容性很好，且体积占用小，适合于嵌入式系统。</li><li><code>hush</code>：用于 bootloader，占用很小的 shell。</li></ul><p>其实只要空间不紧张，嵌入式也使用<code>bash</code>就好，因为和桌面系统完全一致，避免在桌面可以正常运行的脚本在嵌入式端运行就不正常了。</p><h3 id="工具程序"><a href="#工具程序" class="headerlink" title="工具程序"></a>工具程序</h3><p>工具程序用于支撑其他程序的正常运行。</p><h2 id="BusyBox"><a href="#BusyBox" class="headerlink" title="BusyBox"></a>BusyBox</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>这些程序要是手动编译一个个放入文件系统会累死，而<code>BusyBox</code>就将这些工具精简编译到一个可执行程序中，这个程序就包含了常用的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">busybox.nosuid</span><br><span class="line">cat -&gt; /bin/busybox.nosuid</span><br><span class="line">chgrp -&gt; /bin/busybox.nosuid</span><br><span class="line">chmod -&gt; /bin/busybox.nosuid</span><br><span class="line">chown -&gt; /bin/busybox.nosuid</span><br><span class="line">cp -&gt; /bin/busybox.nosuid</span><br><span class="line">cpio -&gt; /bin/busybox.nosuid</span><br><span class="line">date -&gt; /bin/busybox.nosuid</span><br><span class="line">dd -&gt; /bin/busybox.nosuid</span><br><span class="line">df -&gt; /bin/busybox.nosuid</span><br><span class="line">dmesg -&gt; /bin/busybox.nosuid</span><br></pre></td></tr></table></figure><p>当用户输入<code>cat</code>时，实际上是调用了<code>busybox</code>这个可执行文件，该文件按照如下流程处理：</p><ul><li>获取<code>argv[0]</code>得到字符串<code>cat</code></li><li>然后根据该字符串获取到对应入口函数<code>cat_main</code></li><li>执行<code>cat_main</code></li></ul><h3 id="构建-BusyBox"><a href="#构建-BusyBox" class="headerlink" title="构建 BusyBox"></a>构建 BusyBox</h3><p>首选获取源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.busybox.net/busybox</span></span><br></pre></td></tr></table></figure><p>然后切换到最新稳定版：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 1_34_stable</span></span><br></pre></td></tr></table></figure><p>按照惯例，当然是先clean 一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make distclean</span></span><br></pre></td></tr></table></figure><p>使用其默认配置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make defconfig</span></span><br></pre></td></tr></table></figure><p>然后使用<code>make menuconfig</code> 进入<code>Settings -&gt; Cross compiler prefix</code>来设置安装路径到前面的 staging 目录。</p><p>接下来便是编译及安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ARCH=arm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><p>可以看到 staging 目录中已经安装好了，且那些文件都以软连接的形式指向了<code>busybox</code>这个可执行文件。</p><h2 id="根文件系统中的库"><a href="#根文件系统中的库" class="headerlink" title="根文件系统中的库"></a>根文件系统中的库</h2><p>应用程序要运行，就要依赖部分编译工具链中的库，简单粗暴的解决方式就是把这些库都拷贝到 staging 目录中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以 SYSROOT 存储路径，比较方便</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> SYSROOT=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)</span></span><br></pre></td></tr></table></figure><p>其中<code>lib</code>文件夹存储得是共享链接库，将它们复制进去即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 -a ，不破坏其软连接</span></span><br><span class="line">cec@box:~/lab/rootfs$ cp -aR $&#123;SYSROOT&#125;/lib/** ./lib/</span><br></pre></td></tr></table></figure><h2 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h2><p>创建设备节点使用命令<code>mknod</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 依次是设备节点名称，类型，主设备号，次设备号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mknod &lt;name&gt; &lt;<span class="built_in">type</span>&gt; &lt;major&gt; &lt;minor&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>主设备号和次设备号可以在 <code>Documentation/devices.txt</code>文件中找到</p></blockquote><p>对于 BusyBox 而言，所需要的两个节点是<code>console</code>和<code>null</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> null 节点所有用户都可以读写，所以权限是 666</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mknod -m 666 dev/null c 1 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> console 节点只允许 root 操作，所以权限是 600</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mknod -m 600 dev/console c 5 1</span></span><br></pre></td></tr></table></figure><h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>内核模块也需要被安装在根文件系统中，需要被内核设置<code>INSTALL_MOD_PATH</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于前面已经设置了 ARCH 和 CROSS_COMPILE 所以这里就不用设置了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make INSTALL_MOD_PATH=/home/cec/lab/rootfs modules_install</span></span><br></pre></td></tr></table></figure><p>可以看到模块都被安装到了根文件系统的<code>lib/modules/&lt;kernel_version&gt;</code>目录下了。</p><blockquote><p>但是会发现还安装了<code>source</code>和<code>build</code>文件夹，这个是嵌入式中不需要的，可以把它们删除。</p></blockquote><h1 id="创建-initramfs"><a href="#创建-initramfs" class="headerlink" title="创建 initramfs"></a>创建 initramfs</h1><p>在使用<code>initramfs</code>之前需要确保<code>CONFIG_BLK_DEV_INITRD=y</code>，以表示内核支持<code>initramfs</code>。</p><p>创建<code>initramfs</code>有以下 3 种方法：</p><ol><li>独立打包为<code>cpio</code>格式的文件包：这种方式最为灵活</li><li>将<code>initramfs</code>嵌入到内核镜像文件中</li><li>由内核构建系统将其编译进去</li></ol><h2 id="创建一个独立包"><a href="#创建一个独立包" class="headerlink" title="创建一个独立包"></a>创建一个独立包</h2><p>先打包到上级目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定了 GID 和 UID 都是 root</span></span><br><span class="line">cec@box:~/lab/rootfs$ find . | cpio -H newc -ov --owner root:root &gt;  ../initramfs.cpio</span><br></pre></td></tr></table></figure><p>然后再进行一次压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cec@box:~/lab/rootfs$ gzip initramfs.cpio</span><br></pre></td></tr></table></figure><p>最后使用工具<code>mkimage</code>来为文件加入头：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cec@box:~/lab$ mkimage -A arm -O linux -T ramdisk -d initramfs.cpio.gz uRamdisk</span><br><span class="line">Image Name:   </span><br><span class="line">Created:      Fri Mar  1 09:18:49 2024</span><br><span class="line">Image Type:   ARM Linux RAMDisk Image (gzip compressed)</span><br><span class="line">Data Size:    27835346 Bytes = 27182.96 KiB = 26.55 MiB</span><br><span class="line">Load Address: 00000000</span><br><span class="line">Entry Point:  00000000</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>initramfs 包体积不能太大，因为压缩包和解压后的文件都会全部存在于内存中！</strong> </p><blockquote><p><a href="https://www.lightofdawn.org/blog/?viewDetailed=00128">这篇文章</a>有讲到，<code>initramfs</code>包最好小于内存的 25%</p></blockquote><h2 id="启动独立包"><a href="#启动独立包" class="headerlink" title="启动独立包"></a>启动独立包</h2><h3 id="拷贝进-SD-卡"><a href="#拷贝进-SD-卡" class="headerlink" title="拷贝进 SD 卡"></a>拷贝进 SD 卡</h3><p>作为测试目的，我们可以将<code>uRamdisk</code>也拷贝到 SD 卡的第一分区，然后在 U-boot 中载入。</p><h3 id="载入到-DDR"><a href="#载入到-DDR" class="headerlink" title="载入到 DDR"></a>载入到 DDR</h3><p>然后需要将<code>initramfs</code>载入到 DDR 中，前面我们将：</p><ul><li>Image 载入到 <code>0x80200000</code></li><li>FDT 载入到 <code>0x80f00000</code></li></ul><p>而 FDT 目前大小只有 58KB，那么可以将<code>uRamdisk</code>载入到<code>0x81000000</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x80200000 zImage</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x80f00000 am335x-boneblack.dtb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x81000000 uRamdisk</span></span><br></pre></td></tr></table></figure><ol start="3"><li>指定启动的<code>init</code>程序</li></ol><p>需要在<code>bootargs</code>中加入启动程序是 shell：<code>rdinit=/bin/sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> setenv bootargs console=ttyO0,115200 rdinit=/bin/sh</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 bootz 启动</li></ol><p>也就是说在原来的基础上，加上<code>initramfs</code>的地址即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> $ bootz <span class="variable">$&#123;loadaddr&#125;</span> <span class="variable">$&#123;initrd_addr&#125;</span> <span class="variable">$&#123;fdt_addr&#125;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bootz 0x80200000 0x81000000 0x80f00000</span></span><br></pre></td></tr></table></figure><p>这个时候会发现没有工作控制流而给出警告：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: can&#x27;t access tty; job control turned off</span><br></pre></td></tr></table></figure><h2 id="将-initramfs-嵌入内核"><a href="#将-initramfs-嵌入内核" class="headerlink" title="将 initramfs 嵌入内核"></a>将 initramfs 嵌入内核</h2><p>将<code>initramfs</code>嵌入内核非常简单：在<code>General setup -&gt; Initramfs source file(s)</code>中指定<strong>未压缩的 cpio 文件</strong>，然后再次运行 make 即可。</p><p>这样设置以后，便可以在 bootloader 中指定内核和设备树地址就行了。</p><blockquote><p>这里需要注意内核 + initramfs 所占用的空间，设备树需要预留足够多的空间以避免相互覆盖。</p><p>比如当前内核 + initramfs 就有 50MB，那么设备树的载入位置需要再往后放一点。</p><p>当前开发板具有 512MB 内存，那 DDR 寻址范围是 0x80000000 ~ 0xA0000000。</p><p>所以设备树的位置预留足够位置即可，比如放置在 0x8CA00000 处，就预留了 200MB 的空间。</p></blockquote><p>编译进内核以后，启动命令就简单了一点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/bin/sh</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure><h2 id="以设备列表的形式构建-initramfs"><a href="#以设备列表的形式构建-initramfs" class="headerlink" title="以设备列表的形式构建 initramfs"></a>以设备列表的形式构建 initramfs</h2><p>设备列表就是一个配置文件，用以列出文件、文件夹、设备节点、链接等等。</p><p>在构建内核的时候，也就会生成按照设备列表配置的 cpio 文件。</p><p>和上面的方式一样，在内核的<code>Initramfs source file(s)</code>处指向该配置文件。</p><p><code>cpio</code>文件就会在编译时创建。</p><p>下面是一个简单的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> dir &lt;name&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">dir /bin 775 0 0</span><br><span class="line">dir /sys 775 0 0</span><br><span class="line">dir /tmp 775 0 0</span><br><span class="line">dir /dev 775 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> nod &lt;name&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt; &lt;dev_type&gt; &lt;maj&gt; &lt;min&gt;</span></span><br><span class="line">nod /dev/null 666 0 0 c 1 3</span><br><span class="line">nod /dev/console 600 0 0 c 5 1</span><br><span class="line">dir /home 775 0 0</span><br><span class="line">dir /proc 775 0 0</span><br><span class="line">dir /lib 775 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> slink &lt;name&gt; &lt;target&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">slink /lib/libm.so.6 libm-2.22.so 777 0 0</span><br><span class="line">slink /lib/libc.so.6 libc-2.22.so 777 0 0</span><br><span class="line">slink /lib/ld-linux-armhf.so.3 ld-2.22.so 777 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> file &lt;name&gt; &lt;location&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">file /lib/libm-2.22.so /home/chris/rootfs/lib/libm-2.22.so 755 </span><br><span class="line">0 0</span><br><span class="line">file /lib/libc-2.22.so /home/chris/rootfs/lib/libc-2.22.so 755 </span><br><span class="line">0 0</span><br><span class="line">file /lib/ld-2.22.so /home/chris/rootfs/lib/ld-2.22.so 755 0 0</span><br></pre></td></tr></table></figure><p>可以使用内核文件<code>/usr/gen_initramfs_list.sh</code>来根据前面的 rootfs 生成一个配置文文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./usr/gen_initramfs_list.sh -u 1000 -g 1000 ~/lab/rootfs &gt; initramfs-device-table</span></span><br></pre></td></tr></table></figure><h1 id="完整启动-initramfs"><a href="#完整启动-initramfs" class="headerlink" title="完整启动 initramfs"></a>完整启动 initramfs</h1><p>前面的启动过程，会由于 initramfs 缺少文件而退出 shell，而正确的启动流程是：</p><ol><li>内核启动<code>/sbin/init</code>程序</li><li><code>/sbin/init</code>读取<code>/etc/inittab</code>确定启动级别及运行 shell</li><li>根据<code>/etc/inittab</code>中的内容找到<code>/etc/init.d/rcS</code>然后依次运行对应脚本进行环境初始化</li></ol><p>而<code>busybox</code>在其源码<code>examples/bootfloppy/etc/</code>中就提供了通用的示例，将其拷贝到我们创建的<code>rootfs</code>中是比较简单的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cec@box:~/lab/rootfs$ cp -aR ../busybox/examples/bootfloppy/etc/** etc/</span><br></pre></td></tr></table></figure><h2 id="inittab-修改"><a href="#inittab-修改" class="headerlink" title="inittab 修改"></a>inittab 修改</h2><p>作为测试目的，对其进行简单修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动初始化脚本为 /etc/init.d/rcS</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 虚拟终端作为 shell</span></span><br><span class="line">::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure><h2 id="rcS-修改"><a href="#rcS-修改" class="headerlink" title="rcS 修改"></a>rcS 修改</h2><p>在 <code>rcS</code>脚本中，需要至少挂载<code>proc,sys</code>两个虚拟文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc </span><br><span class="line">mount -t sysfs sysfs /sys</span><br></pre></td></tr></table></figure><p>修改以后再次打包为 cpio 文件，对应的 bootargs 就可以修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/sbin/init</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure><h2 id="增加用户配置"><a href="#增加用户配置" class="headerlink" title="增加用户配置"></a>增加用户配置</h2><p><code>busybox</code>默认会支持 shadow 特性，这需要添加用户配置文件。</p><p>用户名及相关信息被配置于<code>/etc/passwd</code>文件中，每个用户一行，中间以冒号分开，依次是：</p><ul><li><p>用户名</p></li><li><p><code>x</code>代表密码存储于<code>/etc/shadow</code></p><blockquote><p><code>/etc/passwd</code>是所有人可读的，而<code>/etc/shadow</code>则只能是 root 用户和组可以读，以此来保证安全性。</p></blockquote></li><li><p>用户 ID</p></li><li><p>组 ID</p></li><li><p>注释</p></li><li><p>用户的<code>home</code>目录</p></li><li><p>用户所使用的 shell</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/false</span><br></pre></td></tr></table></figure><p>组名称则存储于<code>/etc/group</code>中，也是每个组一行，中间以冒号分开：</p><ul><li>组名</li><li>组密码，<code>x</code>代表该组没有密码</li><li>组 ID</li><li>那些用于属于该组</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br><span class="line">daemon:x:1:</span><br></pre></td></tr></table></figure><p><code>/etc/shadow</code> 中的示例内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root::10933:0:99999:7:::</span><br><span class="line">daemon:*:10933:0:99999:7:::</span><br></pre></td></tr></table></figure><p>在 rootfs 中加入这几个文件，其中 <strong>/etc/shadow</strong> 需要修改权限为 600，以便只有 root 可以打开此文件。</p><p>然后再编辑 <code>etc/inittab</code> 让初始启动程序为 getty 获取用户名及密码验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta">#</span><span class="bash"> respawn 代表当一个用户退出后，又重新启动 getty</span></span><br><span class="line">::respawn:/sbin/getty 115200 console</span><br></pre></td></tr></table></figure><h1 id="创建设备节点更好的方法"><a href="#创建设备节点更好的方法" class="headerlink" title="创建设备节点更好的方法"></a>创建设备节点更好的方法</h1><p><code>mknod</code>创建设备节点比较繁琐，还有其他更好的办法：</p><ul><li><code>devtmpfs</code>：这是在启动时被挂载到<code>/dev</code>的伪文件系统。内核通过它来动态的增加和删除设备节点。</li><li><code>mdev</code>：由 busybox 提供的工具，通过读取<code>/etc/mdev.conf</code>来达到自动挂载节点的目的</li><li><code>udev</code>：功能和<code>mdev</code>类似，现在属于<code>systemd</code>的一部分</li></ul><p>在实际使用中，一般是通过<code>devtmpfs</code>来自动创建节点，而<code>mdev/udev</code>来设置节点的属性。</p><h2 id="devtmpfs"><a href="#devtmpfs" class="headerlink" title="devtmpfs"></a><code>devtmpfs</code></h2><p>在使用<code>devtmpfs</code>之前，需要确保内核已经使能了<code>CONFIG_DEVTMPFS</code>。</p><blockquote><p>如果使能了 CONFIG_DEVTMPFS_MOUNT 内核会自动挂载该文件系统，只是不适用于 initramfs</p></blockquote><p>对于<code>initramfs</code>在启动脚本中挂载<code>devtmpfs</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t devtmpfs devtmpfs /dev</span><br></pre></td></tr></table></figure><h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a><code>mdev</code></h2><p>在使用<code>mdev</code>之前，需要在启动脚本中将其设置为接收内核发送的<code>hotplug</code>事件，然后再启动<code>mdev</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><p><code>mdev</code>会根据<code>/etc/mdev.conf</code>文件来配置节点的属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file /etc/mdev.conf</span></span><br><span class="line">null root:root 666</span><br><span class="line">random root:root 444</span><br><span class="line">urandom root:root 444</span><br></pre></td></tr></table></figure><p>关于 <code>mdev</code>更多说明，参考 busybox 源码中的 <code>docs/mdev.txt</code>文件。</p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>与网络配置相关的文件有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">etc/network</span><br><span class="line">etc/network/if-pre-up.d</span><br><span class="line">etc/network/if-up.d</span><br><span class="line">etc/network/interfaces</span><br><span class="line">var/run</span><br></pre></td></tr></table></figure><p>其中<code>interfaces</code>中是对网络的配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 eth0 为静态 IP</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">    address 192.168.1.101</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    network 192.168.1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以这样配置，使用动态 IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> auto eth0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iface eth0 inet dhcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iface eth1 inet dhcp</span>    </span><br></pre></td></tr></table></figure><p>对于动态 IP，busybox 使用 <code>udchpcd</code>运行<code>/usr/share/udhcpc/default.script</code>来完成配置，可以拷贝<code>examples/udhcp/simple.script</code>来完成。</p><h2 id="字符串映射"><a href="#字符串映射" class="headerlink" title="字符串映射"></a>字符串映射</h2><p>glibc 使用 <code>name service switch（NSS）</code>来实现从名称到特定数值的转换。</p><p>比如从用户名转换到 UID，从服务器名称转换到端口号，从主机名称转换到 IP 地址等。</p><p>这些配置被存储于<code>/etc/nssswitch.conf</code>文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">passwd:    files # 查询 UID ，就在 /etc/passwd</span><br><span class="line">group:     files</span><br><span class="line">shadow:    files</span><br><span class="line">hosts:     files dns # 查询主机就在 /etc/hosts，如果查询不到就从 DNS 查询</span><br><span class="line">networks:  files</span><br><span class="line">protocols: files</span><br><span class="line">services:  files # 查询端口号，就在 /etc/services</span><br></pre></td></tr></table></figure><p>这些文件完全可以在当前主机中拷贝，这些文件都是有统一格式的。</p><p>最后还需要安装库以便于正确执行名称查找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -a <span class="variable">$SYSROOT</span>/lib/libnss* lib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -a <span class="variable">$SYSROOT</span>/lib/libresolv* lib</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;重新来梳理一下根文件系统编译。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://kcmetercec.top/categories/linux/"/>
    
    <category term="make" scheme="http://kcmetercec.top/categories/linux/make/"/>
    
    <category term="yocto" scheme="http://kcmetercec.top/categories/linux/make/yocto/"/>
    
    
    <category term="yocto" scheme="http://kcmetercec.top/tags/yocto/"/>
    
  </entry>
  
</feed>
