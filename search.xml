<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何分析一个算法？</title>
    <url>/2022/09/09/analysis_of_algorithms/</url>
    <content><![CDATA[<ul>
<li>学习书籍：<a href="https://algs4.cs.princeton.edu/home/">Algorithms 4th Edition</a></li>
</ul>
<p>我们在编写一段代码时，在需要其频繁运行或处理一大堆数据时，总会有一些疑问：</p>
<ol>
<li>这段代码的单次运行时间有多长，能否再优化？</li>
<li>这段代码会占用多少内存，是否会触发 Stack overflow 或 Out of memory？</li>
</ol>
<p>如果仅仅是凭感觉来估算，真实解决往往是大相径庭，我们需要科学方法来量化代码的时间及空间复杂度。</p>
<blockquote>
<p>实际上，代码的准确执行时间是无法计算的，这根据运行的软硬件环境都有关系。<br>但是不管环境如何，其趋势是可预测的。</p>
</blockquote>
<span id="more"></span>

<h1 id="科学方法"><a href="#科学方法" class="headerlink" title="科学方法"></a>科学方法</h1><h2 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h2><p>分析一段代码的运行时间，那么就需要一定数量的样本输入，多个样本的输入对应多个运行时间，最后就可以画出一条曲线。</p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>按照书籍上的代码来依次分析示例文件中的整数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        count += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;working directory: &quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;analyze file: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] a = in.readAllInts();</span><br><span class="line"></span><br><span class="line">        Stopwatch timer = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        <span class="keyword">int</span> count = count(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;elapsed time = &quot;</span> + timer.elapsedTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试文件与对应的输出时间关系如下表：</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>数量</th>
<th>执行时间(秒)</th>
</tr>
</thead>
<tbody><tr>
<td>1Kints.txt</td>
<td>1000</td>
<td>0.159</td>
</tr>
<tr>
<td>2Kints.txt</td>
<td>2000</td>
<td>1.198</td>
</tr>
<tr>
<td>4Kints.txt</td>
<td>4000</td>
<td>9.157</td>
</tr>
<tr>
<td>8Kints.txt</td>
<td>8000</td>
<td>72.616</td>
</tr>
<tr>
<td>16Kints.txt</td>
<td>16000</td>
<td>562.817</td>
</tr>
<tr>
<td>32Kints.txt</td>
<td>32000</td>
<td>4584.773</td>
</tr>
<tr>
<td>1Mints.txt</td>
<td>1000000</td>
<td></td>
</tr>
</tbody></table>
<p>上面这段代码，执行时间主要在 for 循环上，是一个 <code>n * n * n</code> 的循环。也就是说其代码的时间复杂度是 <code>O(n^3)</code>，可以预测其时间会比较长。</p>
<p>但是，对于 java 的这个测试结果，我试过 maven 和 Intellij 构建，得到的时间都相差不大，这么长的时间实在是让我目瞪口呆……</p>
<p>为了做一下对比，我决定使用 c++ 来跑一下这个测试，看看时间差异有多大。</p>
<p>c++ 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Input file name: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string file_name;</span><br><span class="line">    std::cin &gt;&gt; file_name;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream <span class="title">istrm</span><span class="params">(file_name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!istrm.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Can&#x27;t open file &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; bag;</span><br><span class="line">    std::array&lt;<span class="keyword">char</span>, 15&gt; tmp&#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!istrm.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        istrm.<span class="built_in">getline</span>(&amp;tmp[<span class="number">0</span>], tmp.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">int</span> value = std::<span class="built_in">atoi</span>(tmp.<span class="built_in">data</span>());</span><br><span class="line">        bag.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I have read &quot;</span> &lt;&lt; bag.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; integers\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="built_in">count</span>(bag);</span><br><span class="line">    <span class="keyword">auto</span> stop = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(stop - start).<span class="built_in">count</span>();</span><br><span class="line">    <span class="keyword">double</span> took = elapsed / <span class="number">1000.0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;function `count` took &quot;</span></span><br><span class="line">        &lt;&lt; took</span><br><span class="line">        &lt;&lt; <span class="string">&quot; seconds\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>文件名称</th>
<th>数量</th>
<th>c++ 执行时间（秒）</th>
<th>java 执行时间（秒）</th>
</tr>
</thead>
<tbody><tr>
<td>1Kints.txt</td>
<td>1000</td>
<td>0.033</td>
<td>0.159</td>
</tr>
<tr>
<td>2Kints.txt</td>
<td>2000</td>
<td>0.277</td>
<td>1.198</td>
</tr>
<tr>
<td>4Kints.txt</td>
<td>4000</td>
<td>2.192</td>
<td>9.157</td>
</tr>
<tr>
<td>8Kints.txt</td>
<td>8000</td>
<td>17.608</td>
<td>72.616</td>
</tr>
<tr>
<td>16Kints.txt</td>
<td>16000</td>
<td>140.416</td>
<td>562.817</td>
</tr>
<tr>
<td>32Kints.txt</td>
<td>32000</td>
<td>1128.04</td>
<td>4584.773</td>
</tr>
<tr>
<td>1Mints.txt</td>
<td>1000000</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>可以看出来：c++ 的运行效率（未开优化）大约是 java 的 4 倍，c++ 还是香啊……</p>
<p>接下来，使用 excel 进行绘图，结果如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/three_sum_result.jpg?raw=true"><br>可以看到，虽然执行时间差异大，但是它们的趋势都是一样的。也就是说都可以用同样的公式来进行量化。</p>
<p>由于其代码时间复杂度是<code>O(n^3)</code>，那么可以计算其系数：</p>
<blockquote>
<p>n^3 x a = time</p>
</blockquote>
<p>那么以 c++ 为例，可以算出 a 大约为 (0.033 / 1000^3) ≈ 3.3 x 10^(-11)</p>
<p>那么就可以推算出来，一百万个输入大约需要 382 天！如果是 java 来算就需要大约 1528 天！</p>
<p>这样一比较，就可以感性的认识到，代码时间复杂度<code>O(n^3)</code>是多么的丧心病狂！</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>前面是几个文件的测试结果，那我们参考书籍提供的<code>DoublingTest</code>类，完成可以生成多个结果的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.StdRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        count += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">timeTrial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            a[i] = StdRandom.uniformInt(-<span class="number">1000000</span>, <span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stopwatch timer = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        count(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timer.elapsedTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">250</span>; <span class="keyword">true</span>; n += n) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%7d %7.5f\n&quot;</span> , n , timeTrial(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> 250 0.01000</span><br><span class="line"> 500 0.02500</span><br><span class="line">1000 0.21100</span><br><span class="line">2000 1.41800</span><br><span class="line">4000 9.48900</span><br><span class="line">8000 74.05500</span><br></pre></td></tr></table></figure>

<p>将这个结果绘制为图标也是和之前一致的：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/three_sum_linear_log.jpg?raw=true"><br>从右边的对数曲线，可以得出其公式为：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/three_sum_equation.jpg?raw=true"><br>上面是对数，转化为线性后，加减就变成了乘除，就是和之前的公式一致了。</p>
<h2 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h2><p>代码的运行时间由两个主要因素决定：</p>
<ol>
<li><p>每个语句的执行时间</p>
</li>
<li><p>每个语句的执行频率</p>
</li>
</ol>
<h3 id="计算执行次数"><a href="#计算执行次数" class="headerlink" title="计算执行次数"></a>计算执行次数</h3><p>上面的测试代码主要是<code>count()</code>函数的耗时，那么就来尝试以数学的方法来计算其执行频率，以 cpp 代码为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最开始的创建两个局部变量，它们的频率都是 1，这个是没有疑问的，重点是在于下面的 <code>for</code>循环语句（或者说是里面的<code>if</code>语句）的执行次数。</p>
<p>由于上面是 3 层循环，对于我这种数学渣理解起来有点困难，那么我们先将 3 层循环简化为 2 层循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> run_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            run_cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; run_cnt &lt;&lt; <span class="string">&quot; times\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面先列举出规律：</p>
<table>
<thead>
<tr>
<th>i 的值</th>
<th>内层执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>n - 1</td>
</tr>
<tr>
<td>1</td>
<td>n - 2</td>
</tr>
<tr>
<td>2</td>
<td>n - 3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n - 2</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>那么总的执行次数就是内层执行次数之和（外层相对于内层每次执行次数就是 1）：</p>
<blockquote>
<p>1 + 2 + .…+(n-2) + (n-1)</p>
</blockquote>
<p>那么就可以简化公式：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/2level_for.jpg?raw=true">那么假设 n 为 10，最终两层<code>for</code>循环执行次数就是 45 次，实测结果也是一致的。</p>
<p>下面再来看有三层<code>for</code>循环的情况，为了便于分析，同样也是以第二层和第三层<code>for</code>循环作为分析对象：</p>
<table>
<thead>
<tr>
<th>i 的值</th>
<th>j 的值</th>
<th>第三层执行次数</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>n - 2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>n - 3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>n-4</td>
<td>n-3</td>
<td>2</td>
</tr>
<tr>
<td>n-3</td>
<td>n-2</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>当<code>i</code>的值为 0 时，<code>j</code>的值将从 1~(n-1)，其执行次数是：</p>
<blockquote>
<p>1 + 2 + … + (n-3) + (n-2)</p>
</blockquote>
<p>其公式为：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for.jpg?raw=true">那么依次计算当<code>i</code>的值增加时，第三层的执行次数为：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for_list.jpg?raw=true">那么将这些执行次数求和：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for_sum.jpg?raw=true"><br>最终推导：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for_result.jpg?raw=true">至此，结果就推导出来了。</p>
<p>我顺便还查看了<a href="https://github.com/reneargento/algorithms-sedgewick-wayne/">github</a>上对此公式的解释：</p>
<blockquote>
<p>Counting argument:<br>When choosing the first element there are N possibilities.<br>When choosing the second element there are N - 1 possibilities.<br>When choosing the third element there are N - 2 possibilities.</p>
</blockquote>
<blockquote>
<p>This is a total of N(N - 1)(N - 2). If the order of items mattered, this would be the result.<br>However, the order of items does not matter. For 3 items there is a total of 3! possible orderings.<br>3! = 6</p>
</blockquote>
<blockquote>
<p>So, the number of triples that can be chosen from N items is equal to:<br>N(N - 1)(N - 2) / 6</p>
</blockquote>
<p>他的这个算法则是简单易懂：如果 3 层<code>for</code>循环的<code>i,j,k</code>可以随意组合，那么其执行次数就应该是<code>N(N-1)(N-2)</code>，<br>但是由于其顺序是必然的<code>i&gt;j&gt;k</code>，那么这 3 个组合只会有 6 种中的一种，所以需要总次数除以 6.</p>
<h3 id="与-O-n-3"><a href="#与-O-n-3" class="headerlink" title="与 O(n^3)"></a>与 O(n^3)</h3><p>前面推导的公式进行展开就是：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for_formula_expand.jpg?raw=true">这个结果虽然很精准，但是在表示代码执行复杂度的时候会有点麻烦。如果遇到了更为复杂的代码，那其精确的公式会更加复杂。</p>
<blockquote>
<p>目前只是计算了最内层<code>for</code>的执行复杂度，而内部的<code>cnt+1</code>则更是一个不确定的执行时间，这完全根据输入的值而定。<br>所以，在工程应用中来评估代码执行复杂度，往往都是看执行时间最长的、完全可预测的那段。也就是抓住主要矛盾，忽略次要矛盾。</p>
</blockquote>
<p>这种复杂的表达方式会干扰我们对代码执行效率的分析，所以我们要抓住主要矛盾，忽略次要矛盾。</p>
<p>从公式的展开结果可以推测，3 阶的<code>n</code>应该是最为主要的，其次的 2 阶、1 阶、系数都是次要的。</p>
<p>为了能够验证这个推测，可以通过<code>octave</code>来绘制：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">set(<span class="number">0</span>, <span class="string">&quot;defaulttextfontsize&quot;</span>, <span class="number">36</span>);  <span class="comment">% title</span></span><br><span class="line">set(<span class="number">0</span>, <span class="string">&quot;defaultaxesfontsize&quot;</span>, <span class="number">24</span>);  <span class="comment">% axes labels</span></span><br><span class="line"></span><br><span class="line">point = [<span class="number">1</span>: <span class="number">2000</span>];</span><br><span class="line">formula_1 = (point.^<span class="number">3</span> / <span class="number">6</span>)</span><br><span class="line">formula_2 = (point.^<span class="number">3</span> / <span class="number">6</span> - point.^<span class="number">2</span> / <span class="number">2</span>)</span><br><span class="line">formula_3 = (point.^<span class="number">3</span> / <span class="number">6</span> - point.^<span class="number">2</span> / <span class="number">2</span> + point./<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">title(<span class="string">&quot;compare formulas&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;points&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(point, formula_1);</span><br><span class="line"><span class="built_in">plot</span>(point, formula_2);</span><br><span class="line"><span class="built_in">plot</span>(point, formula_3);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;n^3/6&quot;</span>, <span class="string">&quot;n^3/6 - n^2/2&quot;</span>, <span class="string">&quot;n^3/6 - n^2/2 + n/3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/3level_for_formula_tilde.jpg?raw=true"><br>从绘制结果可以看出来，果然是高阶的影响最大，次阶几乎没有影响。</p>
<p>虽然说高阶下还有个除以 6 的运算，但是其增长趋势和<code>n^3</code>是一模一样的，所以除以 6 也是可以省略的，最终计算其代码运行复杂度就是以 O(n^3) 来表示了。</p>
<p>所以，对于精确公式的估计方式如下表：</p>
<table>
<thead>
<tr>
<th>精确的公式</th>
<th>近似的公式</th>
<th>增长趋势</th>
</tr>
</thead>
<tbody><tr>
<td>N^3/6 - N^2/2 + N/3</td>
<td>N^3/6</td>
<td>N^3</td>
</tr>
<tr>
<td>N^2/2 - N/2</td>
<td>N^2/2</td>
<td>N^2</td>
</tr>
<tr>
<td>lgN+1</td>
<td>lgN</td>
<td>lgN</td>
</tr>
<tr>
<td>3</td>
<td>~3</td>
<td>1</td>
</tr>
</tbody></table>
<h2 id="常用的时间复杂度"><a href="#常用的时间复杂度" class="headerlink" title="常用的时间复杂度"></a>常用的时间复杂度</h2><p>下面便是代码中常会遇到的时间复杂度：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/algorithm/analyze_algorithm/pic/algorithm_complex.jpg?raw=true"><br>从这个趋势和左侧的数值可以看出来各种时间复杂度的执行时间差异是多么的大。</p>
<p>octave 测试代码如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;</span><br><span class="line">clc;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line">set(<span class="number">0</span>, <span class="string">&quot;defaulttextfontsize&quot;</span>, <span class="number">36</span>);  <span class="comment">% title</span></span><br><span class="line">set(<span class="number">0</span>, <span class="string">&quot;defaultaxesfontsize&quot;</span>, <span class="number">24</span>);  <span class="comment">% axes labels</span></span><br><span class="line"></span><br><span class="line">points = [<span class="number">1</span>:<span class="number">1</span>:<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line">ratio = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line">algo_1 = <span class="built_in">ones</span>(<span class="number">1</span>, <span class="built_in">length</span>(points));# O(<span class="number">1</span>)</span><br><span class="line">algo_2 = <span class="built_in">log10</span>(points); # O(<span class="built_in">log</span>(N))</span><br><span class="line">algo_3 = points; # O(N)</span><br><span class="line">algo_4 = points .* <span class="built_in">log10</span>(points); # O(N * <span class="built_in">log</span>(N))</span><br><span class="line"></span><br><span class="line">algo_5 = points .^ <span class="number">2</span>; # O(N^<span class="number">2</span>)</span><br><span class="line">algo_6 = points .^ <span class="number">3</span>; # O(N^<span class="number">3</span>)</span><br><span class="line">algo_7 = <span class="number">2</span> .^ points; # O(<span class="number">2</span>^N)</span><br><span class="line">algo_8 = <span class="built_in">factorial</span>(points); # O(N!)</span><br><span class="line"></span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">title(<span class="string">&quot;compare formulas&quot;</span>);</span><br><span class="line">xlabel(<span class="string">&quot;points&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(points, algo_1);</span><br><span class="line"><span class="built_in">plot</span>(points, algo_2);</span><br><span class="line"><span class="built_in">plot</span>(points, algo_3);</span><br><span class="line"><span class="built_in">plot</span>(points, algo_4);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;O(1)&quot;</span>, <span class="string">&quot;O(log(N))&quot;</span>, <span class="string">&quot;O(N)&quot;</span>, <span class="string">&quot;O(Nlog(N))&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(points, algo_5);</span><br><span class="line"><span class="built_in">plot</span>(points, algo_6);</span><br><span class="line"><span class="built_in">plot</span>(points, algo_7);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;O(N^2)&quot;</span>,<span class="string">&quot;O(N^3)&quot;</span>,<span class="string">&quot;O(2^N)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> off;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(points, algo_8);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;O(N!)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>

<h3 id="常量时间复杂度-O-1"><a href="#常量时间复杂度-O-1" class="headerlink" title="常量时间复杂度 O(1)"></a>常量时间复杂度 O(1)</h3><p>常量时间复杂度是指代码运行固定的语句数量，与输入参数的个数没有任何关系，所以其运行时间是固定的。</p>
<blockquote>
<p>当然这并不意味着 O(1) 就是运行时间短的代码，要看具体做什么工作。</p>
<p>比如之前我就看到过一万行的<code>main</code>函数……</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = b + c;</span><br></pre></td></tr></table></figure>

<h3 id="对数时间复杂度-O-log-N"><a href="#对数时间复杂度-O-log-N" class="headerlink" title="对数时间复杂度 O(log(N))"></a>对数时间复杂度 O(log(N))</h3><p>代码的运行时间与输入参数的个数呈对数关系，一般情况下其比 O(1) 会慢一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性时间复杂度-O-N"><a href="#线性时间复杂度-O-N" class="headerlink" title="线性时间复杂度 O(N)"></a>线性时间复杂度 O(N)</h3><p>代码的运行时间随着输入参数个数的增加而线性的增加，就是一个一次函数，一般情况下比 O(log(N) 慢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> max = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; max) &#123;</span><br><span class="line">        max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性对数时间复杂度-O-Nlog-N"><a href="#线性对数时间复杂度-O-Nlog-N" class="headerlink" title="线性对数时间复杂度 O(Nlog(N))"></a>线性对数时间复杂度 O(Nlog(N))</h3><p>代码的运行时间随着输入参数个数的增加以 N * log(N) 的时间增加，显然它会比 O(N) 和O(log(N)) 都慢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平方时间复杂度-O-N-2"><a href="#平方时间复杂度-O-N-2" class="headerlink" title="平方时间复杂度 O(N^2)"></a>平方时间复杂度 O(N^2)</h3><p>代码的运行时间随着输入参数个数的增加以 N^2 的时间增加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">count2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> run_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            run_cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; run_cnt &lt;&lt; <span class="string">&quot; times\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="立方时间复杂度-O-N-3"><a href="#立方时间复杂度-O-N-3" class="headerlink" title="立方时间复杂度 O(N^3)"></a>立方时间复杂度 O(N^3)</h3><p>代码的运行时间随着输入参数个数的增加以 N^3 的时间增加。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] + a[j] + a[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指数时间复杂度-O-2-N"><a href="#指数时间复杂度-O-2-N" class="headerlink" title="指数时间复杂度 O(2^N)"></a>指数时间复杂度 O(2^N)</h3><p>代码的运行时间随着输入参数个数的增加以 2^N 的时间增加，运行时间是极长的。</p>
<h3 id="阶层时间复杂度-O-N"><a href="#阶层时间复杂度-O-N" class="headerlink" title="阶层时间复杂度 O(N!)"></a>阶层时间复杂度 O(N!)</h3><p>这个是最恐怖的时间复杂度了，随着输入参数的增加，运行时间可以到天荒地老……</p>
<h1 id="优化测试代码"><a href="#优化测试代码" class="headerlink" title="优化测试代码"></a>优化测试代码</h1><p>目前已经知道了测试代码的时间复杂度是 O(N^3)，并且有了对前面常用的时间复杂度的认识。</p>
<p>那么要优化测试代码，就是尽量选择时间复杂度低于 O(N^3) 的算法就可以了。</p>
<h2 id="两层-for-循环优化"><a href="#两层-for-循环优化" class="headerlink" title="两层 for 循环优化"></a>两层 for 循环优化</h2><p>现在先简化一下模型，对两层<code>for</code>循环的代码（代码时间复杂度为 O(N^2)）进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] + a[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，既然<code>a[i] + a[j]</code>等于 0，那就意味着<code>a[i]</code>是<code>a[j]</code>的负数。</p>
<p>那么就可以对内层的<code>for</code>循环进行优化：</p>
<blockquote>
<p>查找<code>a[i]</code>的负数<code>a[j]</code>如果存在满足条件的<code>a[j]</code>则<code>cnt += 1</code></p>
</blockquote>
<p>对于查找方法，需要细化如下：</p>
<ol>
<li><p>在整个循环之外，先对输入的数据源进行排序</p>
</li>
<li><p>在内层<code>for</code>循环对下标为<strong>i+1 至 n-1</strong>的数据进行二分查找，寻找符合条件的值（i 及 i 以前的数据是不需要查找的）</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>现在先以前面<code>O(N^2)</code>复杂度的代码运行，查看运行时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Input file name: 32Kints.txt</span><br><span class="line">I have read 32000 integers</span><br><span class="line">result: 273</span><br><span class="line">function `count` took 0.069 seconds</span><br></pre></td></tr></table></figure>

<h3 id="c-优化"><a href="#c-优化" class="headerlink" title="c++ 优化"></a>c++ 优化</h3><p>下面是以 c++ 的方式来实现上面的优化代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = a.<span class="built_in">cbegin</span>(); it != a.<span class="built_in">cend</span>() - <span class="number">1</span>; ++it) &#123;</span><br><span class="line">        <span class="keyword">int</span> current_val = *it;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">binary_search</span>(it + <span class="number">1</span>, a.<span class="built_in">cend</span>(), -current_val)) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>书籍中使用的是归并排序，所以这里 c++ 也使用<code>std::stable_sort</code>来一一对应。</p>
<p>运行时间如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Input file name: 1Mints.txt</span><br><span class="line">I have read 1000000 integers</span><br><span class="line">result: 249838</span><br><span class="line">function `count` took 0.1 seconds</span><br></pre></td></tr></table></figure>

<h3 id="java-优化"><a href="#java-优化" class="headerlink" title="java 优化"></a>java 优化</h3><p>这我就直接搬书上的代码来测试了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.In;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.Stopwatch;</span><br><span class="line"><span class="keyword">import</span> edu.princeton.cs.algs4.BinarySearch;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BinarySearch.indexOf(a, -a[i]) &gt; i) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;working directory: &quot;</span> + System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;analyze file: &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] a = in.readAllInts();</span><br><span class="line"></span><br><span class="line">        Stopwatch timer = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">        <span class="keyword">int</span> count = count(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;elapsed time = &quot;</span> + timer.elapsedTime());</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时间如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">working directory: D:\lab\java\ij_hello</span><br><span class="line">analyze file: 1Mints.txt</span><br><span class="line">elapsed time = 0.229</span><br><span class="line">count = 249838</span><br></pre></td></tr></table></figure>

<p>归并排序的代码时间复杂度是<code>O(Nlog(N))</code>，二分查找的代码时间复杂度是<code>O(log(N))</code>，所以两层 for 循环的代码时间复杂度就是<code>O(Nlog(N))</code>。</p>
<h2 id="三层-for-循环优化"><a href="#三层-for-循环优化" class="headerlink" title="三层 for 循环优化"></a>三层 for 循环优化</h2><p>三层 for 循环优化的思路和两层 for 循环优化一致，相当于<code>a[k] = -(a[i] + a[j])</code>，那么代码就呼之欲出了。</p>
<h3 id="c-优化-1"><a href="#c-优化-1" class="headerlink" title="c++ 优化"></a>c++ 优化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">stable_sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">binary_search</span>(a.<span class="built_in">cbegin</span>() + j + <span class="number">1</span>, a.<span class="built_in">cend</span>(), -(a[i] + a[j]))) &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时间如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Input file name: 32Kints.txt</span><br><span class="line">I have read 32000 integers</span><br><span class="line">result: 2052358</span><br><span class="line">function `count` took 8.445 seconds</span><br></pre></td></tr></table></figure>

<h3 id="java-优化-1"><a href="#java-优化-1" class="headerlink" title="java 优化"></a>java 优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = a.length;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (BinarySearch.indexOf(a, -(a[i] + a[j])) &gt; j) &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时间如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">working directory: D:\lab\java\ij_hello</span><br><span class="line">analyze file: 32Kints.txt</span><br><span class="line">elapsed time = 19.039</span><br><span class="line">count = 2052358</span><br></pre></td></tr></table></figure>

<p>对于上面的代码：</p>
<ul>
<li><p>归并排序的时间复杂度是<code>O(Nlog(N))</code></p>
</li>
<li><p>两层<code>for</code>循环的次数是<code>N(N-1)/2</code></p>
</li>
<li><p>最内层的二分查找时间复杂度是<code>O(log(N))</code></p>
</li>
</ul>
<p>结合来就是<code>Nlog(N) + N(N-1)/2 * log(N)</code>那么就可以简化为<code>O(N^2log(N))</code>。</p>
<p>可以看到，经过优化后的代码执行速度比原来快了 100 多倍！</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>对 ARM 指令 WFI，WFE 的粗浅理解</title>
    <url>/2022/12/29/arm_instructions_wfi_wfe/</url>
    <content><![CDATA[<p>ARM 具有 <code>WFI</code> 和 <code>WFE</code> 两个指令，都可以让 SOC 进入低功耗模式，但在使用时有些注意的地方。</p>
<p>参考链接：</p>
<ul>
<li><p>窝窝科技 <a href="http://www.wowotech.net/armv8a_arch/wfe_wfi.html">ARM WFI和WFE指令</a></p>
</li>
<li><p><a href="https://developer.arm.com/documentation/ka001283/latest">Arm Developer</a> 上的回答</p>
</li>
<li><p>文档 <a href="https://www.arterytek.com/download/FAQ/FAQ0111_How_to_enter_low_power_mode_through_WFI_EN_V2.0.0.pdf">How to enter low-power mode through WFI instruction</a></p>
</li>
</ul>
<span id="more"></span>

<h1 id="WFI-和-WFE-的异同"><a href="#WFI-和-WFE-的异同" class="headerlink" title="WFI 和 WFE 的异同"></a><code>WFI</code> 和 <code>WFE</code> 的异同</h1><p><code>WFI</code> 是 Wait For Interrupt 的缩写，<code>WFE</code> 是 Wait For Event 的缩写。</p>
<p>显然 Event 是包含 Interrupt 的，也就是说 <code>WFE</code> 是可以被除中断外的其它事件唤醒的。</p>
<p>由于 <code>WFE</code> 可以被软件主动发出事件唤醒，那么在多核场景下就可以让部分核心进入低功耗的状态。</p>
<blockquote>
<p>比如 Linux kernel 里面使用的 spin lock，按照原始的定义：未获取到资源的核心应该进入 <code>while(1)</code>的状态。</p>
<p>如果使用了 WFE 就可以让未获取资源的核心主动进入低功耗模式省电，而获取到资源的核心在释放自旋锁时，就发送事件唤醒进入低功耗的核心。</p>
</blockquote>
<h1 id="WFI-的使用注意事项"><a href="#WFI-的使用注意事项" class="headerlink" title="WFI 的使用注意事项"></a><code>WFI</code> 的使用注意事项</h1><p><code>WFI</code> 由于可以被中断唤醒，所以需要在使用 <code>WFI</code> 指令前先关闭中断并清除 pending flags，否则具有 pending flags 的情况下，<code>WFI</code> 指令就会退化为 NOP 指令。</p>
<p>整个过程有严格的顺序：</p>
<ol>
<li><p>配置 NVIC 以关闭中断（首先关闭中断，以避免会产生新的 pending flags）</p>
</li>
<li><p>清除外设的 pending flags</p>
</li>
<li><p>清除 NVIC 的 pending flags（由于 NVIC pending flags 是由外设 pending flags 触发的，所以要先清除外设 pending flags）</p>
</li>
<li><p>使用<code>DSB</code>，<code>DSI</code>指令确保数据和指令的同步</p>
</li>
<li><p>调用<code>WFI</code>进入低功耗模式</p>
</li>
</ol>
]]></content>
      <categories>
        <category>processor</category>
        <category>arm</category>
      </categories>
      <tags>
        <tag>arm</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：设计可以并发操作的代码</title>
    <url>/2022/05/26/cpp_concurrency_code/</url>
    <content><![CDATA[<p>比起设计可并发访问的数据结构，现在需要站在更高的层次来看待并发。</p>
<span id="more"></span>

<h1 id="分离为多个线程的方法"><a href="#分离为多个线程的方法" class="headerlink" title="分离为多个线程的方法"></a>分离为多个线程的方法</h1><p>这里涉及到的一些需要考虑的方面：</p>
<ol>
<li>需要设计多少个线程？</li>
<li>是设计通用线程可以处理常用任务，还是设计专用线程处理特定的任务？</li>
<li>新增加的线程会提高整体的并发度吗，与代码的简洁性相比是否划算？</li>
</ol>
<h2 id="将数据分离到多个线程来处理"><a href="#将数据分离到多个线程来处理" class="headerlink" title="将数据分离到多个线程来处理"></a>将数据分离到多个线程来处理</h2><p>当需要使用简单的算法将一大堆数据进行处理时，就可以考虑将该数据分为多个组进行并行处理。</p>
<p>每个线程的处理算法是一样的（也就是说它们是通用线程），只是它们获取到的数据索引是不同的，最终的结果是由主线程来完成合并。</p>
<p>比较好的例子就是对一大堆数据进行求和时，分为多组进行求和，最后又来合并求和结果，示例代码<a href="http://kcmetercec.top/2022/05/16/cpp_concurrency_manage/#%E9%80%89%E6%8B%A9%E8%BF%90%E8%A1%8C%E6%97%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AA%E6%95%B0">在此</a>。</p>
<p>应用这种方法必须需要充分利用 CPU 的硬件核心来完成并行处理。</p>
<blockquote>
<p>如果只有一个 CPU 核心，那么这种分离数据到多线程的方法还比不上单线程。因为比起单线程，多线程还多了线程切换的开销。</p>
</blockquote>
<h2 id="递归的分解数据"><a href="#递归的分解数据" class="headerlink" title="递归的分解数据"></a>递归的分解数据</h2><p>前一种方法由于数据分解规律是已知的，所以可以一次性创建很多线程。</p>
<p>但有些时候数据是在运行到一定阶段才能获得的，这就需要边获取数据边创建线程。</p>
<p>比如之前使用并发方式来处理<a href="http://kcmetercec.top/2022/05/19/cpp_concurrency_synchronize/#%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>。</p>
<p>与上面处理方式不同的是，该代码在创建线程时使用了<code>std::async</code>，并没有明确指定其一定要异步运行。这就让标准库来根据当前的环境来决定是否需要真正创建一个线程来运行。这种方式就有了更大的灵活性。</p>
<h2 id="根据任务的类型来分离线程"><a href="#根据任务的类型来分离线程" class="headerlink" title="根据任务的类型来分离线程"></a>根据任务的类型来分离线程</h2><p>前面两种是站在数据的角度分离了多个相同任务的线程，现在需要站在功能的角度来分离多个不同任务的线程，每个线程都专注于独立做一件事。</p>
<p>数据分离的相同任务多线程：</p>
<ol>
<li>由于处理的数据地址都不同，所以不需要互斥操作。</li>
<li>主线程则是等待任务处理完后再来合并结果，所以各个子线程间也不需要同步操作。</li>
<li>并行处理数据需要硬件并行度来加速处理</li>
</ol>
<p>而以功能来划分的不同任务线程：</p>
<ol>
<li>由于多个线程可能会处理到相同的数据，则需要互斥操作。</li>
<li>多个线程的处理会有流水线形式的协同方式，所以会有同步机制来完成同步。</li>
<li>即使在单核的情况下，多任务线程也是适用的。因为它将一个复杂的任务分解为了多个子任务，以一定的优先级进行更为科学的处理。所以能提高系统的吞吐性能。</li>
</ol>
<h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>以前用合作式调度器来写单片机程序时，整个大循环就是一个单线程，该单线程轮询的调度每个任务。</p>
<p>这些任务有 IO 密集型的（比如获取用户按键，等待网络数据），也有 CPU 密集型的（比如获取到数据后进行一段运算）。</p>
<p>这些任务需要主动的让出 CPU 资源，以让其他任务能够及时的运行。但是当任务太多，或某个任务执行时间过长时，就会有以下问题：</p>
<ol>
<li>系统的响应速度不够：因为 IO 密集型任务不能被及时的调用，导致用户感觉到卡顿。</li>
<li>系统的吞吐量上不去：因为 CPU 密集型任务总是要主动让出资源来让其他任务可以调度，而很多时候 CPU 是在空转。</li>
</ol>
<p>这种单线程轮询下，只有当任务较少且相对轻量时可以使用，否则就是两头不讨好。</p>
<p>而使用多线程的情况下：</p>
<ul>
<li>IO 密集型任务设定为高优先级，一旦有数据输入该线程便能获取到，这就能提高响应速度。</li>
<li>CPU 密集型任务设定为低优先级，只要 IO 密集型线程没有运行，该线程就从 IO 密集型数据队列中取出数据处理。</li>
</ul>
<p>这样子，通过多线程就可以得到较高的响应速度和吞吐量。</p>
<p>但是，多线程就需要考虑好互斥和同步的问题。</p>
<blockquote>
<p>如果线程间需要共享的数据太多或者是有互相等待的情况，则需要警惕这种线程分割方法是否合理。</p>
</blockquote>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>如果数据流向是有顺序的，那么就可以将对该数据处理的任务分解为多个阶段来处理。</p>
<p>假设现在有 20 组数据，并且有 4 个核心来处理这 20 组数据，每组数据需要分为 4 个步骤来完成，且每步需要 3 秒来完成。</p>
<p>那么有两种方式来处理：</p>
<ol>
<li>将数据分离到 4 个通用线程来处理<ul>
<li>每个核心都依次处理一组数据，那么每个核心将要处理 5 组数据。</li>
<li>由于每个核心需要依次 4 步处理来完成一组数据，那么最终是每隔 12 秒可以生成 4 个最终数据</li>
<li>所有的数据处理完需要 60 秒</li>
</ul>
</li>
<li>将 4 个线程以流水线的形式排列，每个线程处理数据单独的一步<ul>
<li>第一组数据首先进入线程 1 ，处理第一步，然后再进入线程 2 ，处理第二步，这样第一组数据需要等 12 秒才可以生成最终结果</li>
<li>在第一组数据进入到线程 2 时，第二组数据就可以进入到线程 1，处理第一步了。那么就是说接下来的数据是每隔 3 秒就可以生成一个最终数据</li>
<li>所有的数据处理完需要 12 + 19 * 3 = 69 秒</li>
</ul>
</li>
</ol>
<p>虽然流水线方式比通用线程方式多花了 9 秒来完成所有数据，但是流水线可以以更高的频率来输出最终结果，这在有些场合是必须的。</p>
<p>比如在播放音频时，有个重要的指标叫做<strong>音频延迟</strong>：</p>
<ul>
<li>以通用线程的方式每次可以获取到一大块音频数据，但是大块数据之间是有延迟的，这就会造成了音频延迟（这个延迟是相当于一开始就要收集到一大块数据后，才开始处理而造成的延迟）</li>
<li>而以流水线的方式来处理音频数据，可以以更高频率每次产生小块数据，音频延迟就会很小，用户体验就好</li>
</ul>
<p>这就相当于以更小的颗粒度来完成数据处理。</p>
<h1 id="影响多线程性能的因素"><a href="#影响多线程性能的因素" class="headerlink" title="影响多线程性能的因素"></a>影响多线程性能的因素</h1><p>虽然说用到的多线程，但并不代表其就一定高效。这需要理解有哪些因素会影响到多线程的性能。</p>
<h2 id="硬件核心的数量"><a href="#硬件核心的数量" class="headerlink" title="硬件核心的数量"></a>硬件核心的数量</h2><p>线程的数量参考硬件核心的数量：</p>
<ul>
<li>如果线程的数量小于硬件核心数，则没有充分的利用 CPU 资源</li>
<li>如果线程的数量太过大于硬件核心数，则会多出很多上下文切换而降低 CPU 做有用功的效率（这称之为<code>over-subscription</code>）</li>
</ul>
<p>使用<code>std::thread::hardware_concurrency()</code>可以获取硬件的核心数量，在一个应用程序使用该函数应该要避免其他线程同时也在使用，不然大家都创建相当多的线程数就会极大影响系统效率。</p>
<blockquote>
<p><code>std::async</code>则是由标准库来根据当前核心数来判断是否应该创建新线程，这是一种比较优雅的做法。</p>
</blockquote>
<h2 id="数据竞争和-cache-乒乓"><a href="#数据竞争和-cache-乒乓" class="headerlink" title="数据竞争和 cache 乒乓"></a>数据竞争和 cache 乒乓</h2><p>当两个线程都分别运行在两个核心上时，如果它们仅仅是读同一份数据，那不会有任何影响。</p>
<p>但如果其中一个线程修改了数据，那么另一个核心的 cache 就需要被同步，这个过程就需要一些时间。在同步完成之前，另一个线程只有等待。</p>
<p>比如下面这个对原子整数的修改函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processing_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed) &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">        <span class="built_in">do_something</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它对原子整数执行读-修改-写的过程，这里面就包括：</p>
<ol>
<li>从其他核心同步<code>cache</code></li>
<li>修改<code>cache</code></li>
</ol>
<p>如果在多个核心的多个线程都在调用此函数，那么就会造成各自 cache 的频繁同步（cache 乒乓），相当于当前线程之间在相互等待从而造成性能下降。</p>
<p>这种操作就相当于在一个循环中，多个线程都在争抢互斥量一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line">my_data data;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processing_loop_with_mutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">done_processing</span>(data)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是这二者是不同的：</strong></p>
<ul>
<li>原子变量的互斥是在处理器级别的互斥，当需要 cache 同步时，当前核心上的所有线程只能等待，<strong>无法上下文切换</strong></li>
<li>互斥量的互斥是在操作系统层面的互斥，当一个线程阻塞等待时，操作系统会切换到其他线程运行</li>
</ul>
<p>上面两个情况都有一个简单的解法：使用在循环外使用互斥量来原子化整个循环，虽然临界区变大了，但可以避免频繁的切换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line">my_data data;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processing_loop_with_mutex</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">done_processing</span>(data)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">counter</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processing_loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (++counter &lt; <span class="number">100000000</span>) &#123;</span><br><span class="line">        <span class="built_in">do_something</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：初识并发</title>
    <url>/2022/05/15/cpp_concurrency_hello/</url>
    <content><![CDATA[<p>c++ 对于多线程的支持是在 c++11 出现的，这表示可以编写跨平台的多线程代码了。</p>
<span id="more"></span>

<h1 id="c-多线程的历史"><a href="#c-多线程的历史" class="headerlink" title="c++ 多线程的历史"></a>c++ 多线程的历史</h1><p>在 c++98 的年代，并不支持多线程。程序员只能调用系统 API 或 boost 这种第三方库完成多线程编程。</p>
<p>但由于缺乏标准的支持，c++ 在内存模型上对于多线程的支持并不友好，容易遇到很多坑。</p>
<p>c++11 在参考 boost 库的基础上将多线程支持纳入了标准，包括内存模型、多线程同步、原子操作等。</p>
<p>c++14 进而又增加了互斥类型，c++17 增加了并行算法。</p>
<p>当然，c++ 并没有完全支持对于多线程操作的所有封装，还是会有些时候需要使用系统 API。</p>
<p>这种情况下为了尽量的保证可移植性，应该使用<code>native_handle</code>方法来获取底层数据结构。</p>
<p>比如要修改 linux 下线程的调度策略：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::mutex iomutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    sched_param sch;</span><br><span class="line">    <span class="keyword">int</span> policy; </span><br><span class="line">    <span class="built_in">pthread_getschedparam</span>(<span class="built_in">pthread_self</span>(), &amp;policy, &amp;sch);</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(iomutex)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; is executing at priority &quot;</span></span><br><span class="line">              &lt;&lt; sch.sched_priority &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(f, <span class="number">1</span>)</span>, <span class="title">t2</span><span class="params">(f, <span class="number">2</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    sched_param sch;</span><br><span class="line">    <span class="keyword">int</span> policy;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_getschedparam</span>(t1.<span class="built_in">native_handle</span>(), &amp;policy, &amp;sch);</span><br><span class="line">    sch.sched_priority = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pthread_setschedparam</span>(t1.<span class="built_in">native_handle</span>(), SCHED_FIFO, &amp;sch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to setschedparam: &quot;</span> &lt;&lt; std::<span class="built_in">strerror</span>(errno) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="一个简易的多线程示例"><a href="#一个简易的多线程示例" class="headerlink" title="一个简易的多线程示例"></a>一个简易的多线程示例</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(hello)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程 t1 运行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：设计基于锁的可以并发操作的数据结构</title>
    <url>/2022/05/22/cpp_concurrency_lock_based_data_structures/</url>
    <content><![CDATA[<p>除了用户主动使用互斥锁来保护共享数据，也可以在设计共享数据结构的时候让其可以被并发的访问。</p>
<p>这样子的数据结构对用户就相对更加的友好，对于用户来说它就是多线程安全的。</p>
<p>但不管怎么说，这种数据结构在被并发访问的时候，其实是将多个线程的访问进行了串行化。那么就需要将互斥的区间设计的越小越好，以达到尽量高的并发性。</p>
<span id="more"></span>

<h1 id="设计可并发访问数据结构的基本原则"><a href="#设计可并发访问数据结构的基本原则" class="headerlink" title="设计可并发访问数据结构的基本原则"></a>设计可并发访问数据结构的基本原则</h1><p>设计可以并发访问的数据结构时，需要考虑这个数据结构可以安全的被多线程访问，且尽量的做到真正的并发。</p>
<p>那么就需要注意：</p>
<ol>
<li>操作数据结构一定要是互斥的</li>
<li>如果是基于其他数据结构的适配器，那么需要注意保证多个操作动作的完整性。避免在几个操作步骤中，可以被其他线程打断（比如基于<code>stack</code>的适配器<a href="http://kcmetercec.top/2022/05/17/cpp_concurrency_share_data/#%E6%9C%80%E7%BB%88%E7%89%88%E6%9C%AC">threadsafe_stack</a> ）</li>
<li>注意操作数据过程中可能会抛出异常而破坏了操作的完整性</li>
<li>尽量使得互斥区间小，且要避免死锁</li>
</ol>
<p>除此之外，还需要考虑：</p>
<ol>
<li>对于 c++ 而言，这里指的数据结构其实都是用类来表示的，那么当类支持赋值构造、swap、拷贝构造等这类函数时。它们是否与类的其他成员函数可以并发的访问，还是需要用户来主动的保证互斥？</li>
<li>当需要使得互斥区间尽量小时，需要考虑：</li>
</ol>
<ul>
<li>这段被锁保护的区间中的一部分，是否可以移除到锁的外面？</li>
<li>这个数据结构的不同部分，可以被不同的互斥量所保护吗？</li>
<li>所有的操作方法都需要同一等级的保护吗？</li>
<li>可以修改一下数据结构来提高并发度而不影响代码语义吗？</li>
</ul>
<p>总之来讲，一切的目的都是为了让临界区尽量的小，以达到较高的并发度。</p>
<h1 id="简易的方式"><a href="#简易的方式" class="headerlink" title="简易的方式"></a>简易的方式</h1><p>比较简单的方式，就是使用互斥锁来保护共享数据。使用多个互斥锁往往比使用 1 个互斥锁更加复杂，这可能会造成：</p>
<ol>
<li>多个临界区之间的抢占导致数据一致性出问题</li>
<li>多个锁的获取和释放会容易导致死锁</li>
</ol>
<h2 id="多线程安全stack"><a href="#多线程安全stack" class="headerlink" title="多线程安全stack"></a>多线程安全<code>stack</code></h2><p>多线程安全的栈在<a href="http://kcmetercec.top/2022/05/17/cpp_concurrency_share_data/#%E6%B3%A8%E6%84%8F%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%89%80%E9%80%A0%E6%88%90%E7%9A%84%E5%86%85%E9%83%A8%E7%AB%9E%E6%80%81">之前</a>就已经完成过了，但是有几点是需要注意的：</p>
<ol>
<li>该结构的构造及析构函数并不是多线程安全的，所以用户需要保证构造和析构时不能被多线程访问。这相对比较好实现。</li>
<li>该结构并没有同步机制，所以其他线程在想读取栈数据时，需要注意捕获当栈为空时会抛出的异常。</li>
</ol>
<p>所以，在多线程中需要使用容易进行通信时，同步机制是需要的。</p>
<h2 id="带同步机制的多线程安全queue"><a href="#带同步机制的多线程安全queue" class="headerlink" title="带同步机制的多线程安全queue"></a>带同步机制的多线程安全<code>queue</code></h2><p>与多线程安全的<code>stack</code>相仿，多线程安全的<code>queue</code>相当于是<code>std::queue</code>的适配器，并且在次基础上使用了条件变量以同步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 在 const 成员函数中需要获取互斥锁，所以需要修饰为 mutable</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(new_value));</span><br><span class="line">        <span class="comment">// 通知等待线程</span></span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="comment">// 等待消息唤醒</span></span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="comment">// 等待消息唤醒</span></span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);    </span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里已经确认队列不为空了，就可以直接获取数据了</span></span><br><span class="line">        value = std::<span class="built_in">move</span>(data_queue.<span class="built_in">front</span>());</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::shared_ptr&lt;T&gt;();    </span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这种加上同步的方式比起轮询检查队列是否有数据的方式更加的高效，这避免了 CPU 做的一些无用功。</p>
<p>对于上面的类还可以再改进一下，在智能指针重载版本的<code>wait_and_pop()</code>函数中，由于要创建智能指针，则有可能会在创建时抛出异常。</p>
<blockquote>
<p>其实这种情况下抛出异常不会对数据结构有损坏，因为<code>pop</code>是在创建智能指针之后才调用的。</p>
</blockquote>
<p>为了避免这种情况，可以将<code>queue</code>的每个元素用智能指针来表示，这样指针的拷贝就不会抛出异常了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 在 const 成员函数中需要获取互斥锁，所以需要修饰为 mutable</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;</span><br><span class="line">    <span class="comment">// 使用智能指针作为元素来存储</span></span><br><span class="line">    std::queue&lt;std::shared_ptr&lt;T&gt; &gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先创建对象再获取锁，以减少临界区</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">data</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;    </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">        <span class="comment">// 通知等待线程</span></span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="comment">// 等待消息唤醒</span></span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="comment">// 这里要解引用得到对象内容</span></span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());     </span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="comment">// 等待消息唤醒</span></span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk, [<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="comment">// 这里就直接是智能指针的拷贝了</span></span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 这里要解引用得到对象内容    </span></span><br><span class="line">        value = std::<span class="built_in">move</span>(*data_queue.<span class="built_in">front</span>());     </span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::shared_ptr&lt;T&gt;();</span><br><span class="line">        <span class="comment">// 这里就直接是智能指针的拷贝了    </span></span><br><span class="line">        std::shared_ptr&lt;T&gt; res = data_queue.<span class="built_in">front</span>();    </span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样子改动以后，还有一个好处是提高了并发度：在<code>push()</code>函数中，智能指针的创建是在临界区之外了。</p>
<p>如果为了更高的并发度，那就不能简单的使用标准库所提供的容器，而是要自己设计底层容器。只有这样子才能够做到更加细粒度的临界区。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：线程间共享数据</title>
    <url>/2022/05/17/cpp_concurrency_share_data/</url>
    <content><![CDATA[<p>避免<code>data race</code>的底层方法有 3 种：</p>
<ol>
<li>使用互斥机制，保证访问共享数据的原子性</li>
<li>使用无锁编程</li>
<li>使用事务机制（如同数据库一样，将多个操作做成日志形式，一旦日志被打断则重新开始）</li>
</ol>
<p>而互斥机制是相对简单易用的方式。</p>
<span id="more"></span>

<h1 id="使用互斥量保护临界区"><a href="#使用互斥量保护临界区" class="headerlink" title="使用互斥量保护临界区"></a>使用互斥量保护临界区</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>c++ 提供了<code>std::mutex</code>来表示一个互斥量，其对应的<code>lock()</code>和<code>unlock()</code>则分别代表获取和释放锁。</p>
<p>但如果直接这样使用，容易造成获取的锁忘了释放的情况（比如线程异常退出，还来不及释放锁）。那么下次再来获取锁就会造成死锁。</p>
<p>所以，c++ 提供了<code> std::lock_guard</code>，在构造函数中获取锁，在析构函数中释放锁。这种 RAII 操作大大的降低了程序员的心智负担。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> std::mutex val_mtx;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有了 RAII ，生活变得真美好</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">mtx_guard</span><span class="params">(val_mtx)</span></span>;</span><br><span class="line">    <span class="comment">//c++ 17 中，有模板参数推导，所以可以更加简洁(为了兼容性，建议使用上面的写法)</span></span><br><span class="line"><span class="comment">//    std::lock_guard mtx_guard(val_mtx);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        val += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(Task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : threads) &#123;</span><br><span class="line">        v.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用中，一般将临界区数据和互斥量放在类的私有权限中，通过成员函数的方式来进行互斥的操作。</p>
<h2 id="结构化共享数据"><a href="#结构化共享数据" class="headerlink" title="结构化共享数据"></a>结构化共享数据</h2><p>结构化共享数据需要注意的是要<strong>避免将共享数据的指针或引用传递出去，因为这样会绕过互斥量而造成未定义行为</strong>，这就包括以下几种情况：</p>
<ol>
<li>将共享数据的指针或引用通过函数返回</li>
<li>将共享数据的指针或引用赋值给全局指针</li>
<li>将共享数据的指针或引用传递给其他用户可调用函数，而该函数参数是以指针或引用的方式获取该共享数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    std::string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_data data;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这里虽然使用了互斥量保护了 data，</span></span><br><span class="line">		<span class="comment">//但是却将 data 传递给了外部函数 func </span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="built_in">func</span>(data);                      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">some_data* unprotected;</span><br><span class="line"><span class="comment">//将被保护数据的地址赋值给了 unprotected</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span> </span>&#123;</span><br><span class="line">    unprotected = &amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x.<span class="built_in">process_data</span>(malicious_function);</span><br><span class="line">    <span class="comment">//最后 unprotected 就可以绕过互斥量 m 而随意的操作 data   </span></span><br><span class="line">    unprotected-&gt;<span class="built_in">do_something</span>();         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意接口调用所造成的内部竞态"><a href="#注意接口调用所造成的内部竞态" class="headerlink" title="注意接口调用所造成的内部竞态"></a>注意接口调用所造成的内部竞态</h2><p>以<code>std::stack</code>为例，假设它的每个接口都保证是多线程的安全的。但是对其接口的应用却需要特别注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">	<span class="comment">//假设目前 s 中只有一个元素了</span></span><br><span class="line">	<span class="comment">//如果在这之间，有另外一个线程抢占并执行了 s.pop()</span></span><br><span class="line">	<span class="comment">//那么下面这两行代码的访问行为便是未知的</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> value = s.<span class="built_in">top</span>();</span><br><span class="line">    <span class="comment">//同样的，假设是在下面这行之间发生了抢占并执行了 s.pop()，下面这段代码也会出问题</span></span><br><span class="line">    s.<span class="built_in">pop</span>();               </span><br><span class="line">    <span class="built_in">do_something</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，最简单粗暴的方式就是使用互斥量将这整个步骤原子化。但如果 stack 元素所占内存太大时，进行元素拷贝的时间过长占用内存过大，有些类型将会抛出<code>std::bad_alloc</code>异常。那么这种解决方案在元素占用内存大的情况下就不适用了。</p>
<blockquote>
<p>比如在<code>stack</code>中的元素是<code>vector</code>，而<code>vector</code>的内存是从堆中申请的。<br>在执行<code>top()</code>操作时，会进行整个<code>vector</code>拷贝，这意味着需要申请堆内存。<br>如果<code>vector</code>很大，则可能由于内存不够或被限制而抛出异常。<br>所以标准库将<code>top()</code>和<code>pop()</code>拆分成两个动作，如果<code>top()</code>失败，则<code>stack</code>内的内容仍然没有被改变。<br>现在使用互斥量将它们捆绑在一起，如果由于内存过大而失败，又继续执行后面的<code>pop()</code>，则会导致<code>stack</code>内容被删除了一个元素，而用户又没有获取到该元素的内容。</p>
</blockquote>
<p>为了避免大内存抛异常的情况，有以下几个解决方案：</p>
<h3 id="形参传递使用引用"><a href="#形参传递使用引用" class="headerlink" title="形参传递使用引用"></a>形参传递使用引用</h3><p>在调用函数前，首先用户申请内存。如果申请失败，也不会导致<code>pop</code>的问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">some_stack.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure>

<p>但是这有一定的局限性：有些用户数据是不太容易构建对象的或者是构建成本比较高</p>
<h3 id="使用不会抛出异常的元素"><a href="#使用不会抛出异常的元素" class="headerlink" title="使用不会抛出异常的元素"></a>使用不会抛出异常的元素</h3><p>有些类型进行拷贝或移动时并不会抛出异常，那么就可以限制<code>stack</code>只使用这些类型。</p>
<h3 id="返回元素的地址"><a href="#返回元素的地址" class="headerlink" title="返回元素的地址"></a>返回元素的地址</h3><p>另外一个避免拷贝的方式就是返回元素的地址，然后使用<code>std::shared_ptr</code>来管理元素的内存。</p>
<h3 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h3><p>上面解决方案的 1 和 3 是比较合理的，最终对<code>std::stack</code>的封装如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> std::exception &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;empty stack&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">threadsafe_stack</span>(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(new_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        <span class="comment">// 将申请新内存存储接下来要弹出的值，然后再销毁该值</span></span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让用户先申请内存，然后通过赋值的方式传递</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line">        value = data.<span class="built_in">top</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    threadsafe_stack&lt;<span class="keyword">int</span>&gt; si;</span><br><span class="line">    si.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (!si.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        </span><br><span class="line">        si.<span class="built_in">pop</span>(x);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of x is &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<ol>
<li>使用互斥量将原始的<code>top()</code>和<code>pop()</code>进行原子化以避免竞态</li>
<li>返回元素使用引用或地址，以避免拷贝出现异常</li>
<li>当元素为空时，抛出异常以提醒用户代码</li>
</ol>
<h2 id="死锁问题及其解决"><a href="#死锁问题及其解决" class="headerlink" title="死锁问题及其解决"></a>死锁问题及其解决</h2><p>死锁问题在编码中经常遇到，其中一个比较简单的解决办法就是：保持获取和释放互斥量的顺序一致。</p>
<blockquote>
<p>但是这在实际的操作中并不是那么的容易。</p>
</blockquote>
<p>c++ 提供了<code>std::lock</code>用于一次性获取多个锁，以避免死锁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//std::lock 尝试同时获取两个互斥量，如果只能获取到其中一个，那么会自动释放获取到的互斥量</span></span><br><span class="line">        std::<span class="built_in">lock</span>(lhs.m,rhs.m);</span><br><span class="line">        <span class="comment">//使用 std::adopt_lock 以让 lock_guard 析构时释放锁，但不会在构造时获取锁    </span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>;  </span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>;</span><br><span class="line">        <span class="comment">//在 c++17 中，可以使用 scoped_lock 来替换上面 3 行代码</span></span><br><span class="line">        <span class="comment">//std::scoped_lock guard(lhs.m,rhs.m);</span></span><br><span class="line">        <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::lock</code>加上<code>std::lock_guard</code>的 RAII 机制，就能避免很多场合的死锁情况。</p>
<p>当然，实际编码场景中也会有散布在各处的获取互斥量的操作，这就需要程序员有良好的习惯来避免死锁了。</p>
<h2 id="避免死锁的一些编码准则"><a href="#避免死锁的一些编码准则" class="headerlink" title="避免死锁的一些编码准则"></a>避免死锁的一些编码准则</h2><p>除了获取锁会导致死锁以外，两个线程的相互<code>join()</code>也会导致死锁，这些都是需要在编码过程中尽量避免的。</p>
<h3 id="避免嵌套获取锁"><a href="#避免嵌套获取锁" class="headerlink" title="避免嵌套获取锁"></a>避免嵌套获取锁</h3><p>当一个线程已经获取了一个锁并且还未释放的时候，就不要再获取其它的锁了。</p>
<p>如果每个线程都遵守这个规则，那么就不会那么容易造成死锁，因为每个线程都获取单独的锁。</p>
<blockquote>
<p>即使别的线程已经获取了该锁，那么该线程所做的就是等待。但别的线程不会等待该线程，所以也不会造成死锁。</p>
</blockquote>
<p>如果确实需要同时获取到多个锁，那么使用<code>std::lock</code>和<code>std::lock_guard</code>来管理这些锁以避免死锁。</p>
<h3 id="获取锁时避免调用用户提供的代码"><a href="#获取锁时避免调用用户提供的代码" class="headerlink" title="获取锁时避免调用用户提供的代码"></a>获取锁时避免调用用户提供的代码</h3><p>当获取到一个锁时，要避免调用用户提供的代码。因为并不知道用户提供的代码是否也获取了其它的锁。</p>
<h3 id="按确定的顺序获取锁"><a href="#按确定的顺序获取锁" class="headerlink" title="按确定的顺序获取锁"></a>按确定的顺序获取锁</h3><p>有的时候获取锁的代码散布在多处，获取多个锁时不能使用<code>std::lock</code>这种简单的写法。</p>
<p>这种情况下就需要所有相关线程按照统一的顺序进行锁的获取和释放，以避免死锁。</p>
<h3 id="使用一个获取锁的层级"><a href="#使用一个获取锁的层级" class="headerlink" title="使用一个获取锁的层级"></a>使用一个获取锁的层级</h3><p>简单的说就是：为各个锁分一个高低层级，并且获取锁的顺序必须是由高向低层级的方向获取，然后由低到高的方向释放。</p>
<p>那么这里的重点就是要设计一个可以识别出层级高低的锁，核心就在于使用<code>thread_local</code>变量以共享同一个线程中的层级：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span> &#123;</span></span><br><span class="line">    std::mutex internal_mutex;</span><br><span class="line">    <span class="comment">//保存当前锁代表的层级</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">    <span class="comment">//存储上一级锁的层级值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">    <span class="comment">//使用线程生命周期变量 this_thread_hierarchy_value 保存当前线程的层级</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//新获取的锁层级必须要低于当前的层级，否则就抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (this_thread_hierarchy_value &lt;= hierarchy_value) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前层级进行存储，类似于压栈的操作</span></span><br><span class="line">        previous_hierarchy_value = this_thread_hierarchy_value;</span><br><span class="line">        <span class="comment">//更新当前线程所处于的层级</span></span><br><span class="line">        this_thread_hierarchy_value = hierarchy_value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line"><span class="function">    	//创建锁的时候，就规定好了它的层级，以后就不能改了</span></span><br><span class="line"><span class="function">        hierarchy_value(value),</span></span><br><span class="line"><span class="function">        previous_hierarchy_value(<span class="number">0</span>) &#123;</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="comment">//这里需要先获取锁，然后再修改变量以保证原子性 </span></span><br><span class="line">        internal_mutex.<span class="built_in">lock</span>();          </span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//保证释放的时候也必须是由低到高释放</span></span><br><span class="line">        <span class="keyword">if</span> (this_thread_hierarchy_value != hierarchy_value)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);  </span><br><span class="line">        <span class="comment">//将存储的上一级的值取出来，相当于出栈</span></span><br><span class="line">        this_thread_hierarchy_value = previous_hierarchy_value;    </span><br><span class="line">        internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">        <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())     </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//最开始使用最大值，以保证最开始的互斥量是可以被获取的</span></span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么在使用的时候，只要是按照层级顺序进行获取就可以正常工作，否则就会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>;    </span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;    </span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先获取的高层级，再获取低层级，这个顺序是没有问题的</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>;  </span><br><span class="line">    <span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>());         </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">high_level_func</span>();     </span><br><span class="line">    <span class="built_in">do_other_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//先获取低层级，然后又获取高层级，就会抛出异常</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>;    </span><br><span class="line">    <span class="built_in">other_stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hierarchical_mutex 可以被<code>std::lock_guard</code>所使用，是因为它提供 <code>lock</code>,<code>unlock</code>,<code>try_lock</code>标准处理函数。</p>
<h2 id="使用std-unique-lock来灵活的使用锁"><a href="#使用std-unique-lock来灵活的使用锁" class="headerlink" title="使用std::unique_lock来灵活的使用锁"></a>使用<code>std::unique_lock</code>来灵活的使用锁</h2><p><code>std::defer_lock</code>使得<code>std::unique_lock</code>只是刚开始获得锁的关联，但并不会<code>lock()</code>这个锁。</p>
<p><code>std::unique_lock</code>可以在后面主动使用<code>lock()</code>、<code>unlock()</code>这些方法来主动获取和释放锁。</p>
<blockquote>
<p>由于可以主动的释放锁，所以在操作完以后立即释放锁，可以提高整个系统的并发性能</p>
</blockquote>
<p>这里的应用场景主要是在于灵活的使用锁，前面的 swap 函数还有更好的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)                                </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 这里使用 defer_lock ，代表先不获取锁，而是后面使用 lock 成员函数获取锁，或传递给 std::lock</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>;  </span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::defer_lock)</span></span>;  </span><br><span class="line">        std::<span class="built_in">lock</span>(lock_a,lock_b);                        </span><br><span class="line">        <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果<code>std::lock</code>成功获取了锁，则在析构时，<code>std::unique_lock</code>会释放该锁。反之则不会。</p>
<h2 id="传递互斥量的所有权"><a href="#传递互斥量的所有权" class="headerlink" title="传递互斥量的所有权"></a>传递互斥量的所有权</h2><p>当一个函数获取了一个锁，然后需要该函数的使用者来释放该锁，这种情况下就需要传递锁的所有权了。而<code>std::unique_lock</code>内部私有成员保存了该锁，所以使用它来移动所有权是最合适的。</p>
<p>当传递的锁本就是一个右值，那么这种传递会自动完成（比如返回一个临时的锁）。</p>
<p>当传递的锁是左值时，就需要使用<code>std::move</code>来显示的指定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    <span class="built_in">prepare_data</span>();</span><br><span class="line">    <span class="keyword">return</span> lk;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//get_lock 获取的锁传递到了 process_data，于是 do_something 依然可以安全的执行</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;    </span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多个线程在获取锁之后都需要一个共同的处理过程，那么可以将这个处理过程和<code>std::unique_lock</code>封装为一个函数：</p>
<ul>
<li>在函数内部先获取锁，然后在处理共有过程</li>
<li>将锁的所有权传递出去，以继续各个线程独有的处理流程</li>
</ul>
<h2 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h2><p>基本原则是：尽量保证临界区的执行时间最短，以保证系统的运行效率。</p>
<p><code>std::unique_lock</code>在这种情况下可以比较灵活的使用，因为它既可以主动的获取和释放锁，也可以在其本身被释放时，自动的释放锁。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">    some_class data_to_process = <span class="built_in">get_next_data_chunk</span>();</span><br><span class="line">    my_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    <span class="comment">//这段区域不是临界区，所以可以先释放锁</span></span><br><span class="line">    result_type result = <span class="built_in">process</span>(data_to_process);</span><br><span class="line">    my_lock.<span class="built_in">lock</span>();                              </span><br><span class="line">    <span class="built_in">write_result</span>(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的时候，为了降低锁保持的时间，可以先将共享的数据在栈上做一次拷贝，然后再进行接下来的操作，这样锁的粒度就只有对共享数据进行拷贝的那一小段。</p>
<p>但有些情况下需要格外注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;    </span><br><span class="line">        <span class="keyword">return</span> some_detail;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>(<span class="keyword">int</span> sd):<span class="built_in">some_detail</span>(sd) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Y <span class="keyword">const</span>&amp; lhs, Y <span class="keyword">const</span>&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">const</span> lhs_value=lhs.<span class="built_in">get_detail</span>();    </span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">const</span> rhs_value=rhs.<span class="built_in">get_detail</span>();   </span><br><span class="line">        <span class="keyword">return</span> lhs_value==rhs_value;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果两个对象的值再两个<code>get_detail()</code>方法之间被改变了，则它们是不等的。</p>
<p>这种情况下需要再将两个操作打包为一个临界区。</p>
<blockquote>
<p>但很多情况下，即使出现了这种情况也不会有什么影响。这是根据业务逻辑而定的。<br>比如有些业务逻辑已经完全考虑了这种情况，只要保证获取<code>some_detail</code>对象是原子性的就行了。</p>
</blockquote>
<h1 id="保护临界区的其它方法"><a href="#保护临界区的其它方法" class="headerlink" title="保护临界区的其它方法"></a>保护临界区的其它方法</h1><h2 id="在共享数据初始化的时候给予保护"><a href="#在共享数据初始化的时候给予保护" class="headerlink" title="在共享数据初始化的时候给予保护"></a>在共享数据初始化的时候给予保护</h2><p>有些数据仅仅是在初始化的时候需要考虑并发问题，初始化完毕后，这些数据可能是以只读的形式访问，那么就不会存在并发问题。</p>
<p>假设有一个类的构造所需要花费的时间较长，一般情况下会在需要使用该类的时候才进行构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 延迟初始化，在使用的时候才初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!resource_ptr) &#123;</span><br><span class="line">        resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);    </span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果简单粗暴的使用互斥量以避免构造时的并发问题的话，就会导致不管类是否已经构造，都需要获取一次锁从而降低了程序的吞吐量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;   </span><br><span class="line">    <span class="keyword">if</span> (!resource_ptr) &#123;</span><br><span class="line">        resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  </span><br><span class="line">    &#125;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的方式优化一下，就是使用二次判断的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!resource_ptr) &#123;</span><br><span class="line">            resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;<span class="built_in">do_something</span>();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式可能会出现未定义行为，因为第一次检查<code>resource_ptr</code>时并没有互斥。</p>
<p>那么就有可能在另一个线程初始化到一半的时候，当前线程就判定指针已经被初始化了，继而直接去执行<code>do_something</code>，这就会造成未定义行为。</p>
<p>c++ 标准库提供了<code>std::once_flag</code>和<code>std::call_once</code>来应对这种需求，它比使用互斥量在性能上有所提升：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实际上真正的初始化只会调用一次</span></span><br><span class="line">    <span class="comment">//有点类似于 c++11 及以后的 static 对象的初始化</span></span><br><span class="line">    std::<span class="built_in">call_once</span>(resource_flag,init_resource);   </span><br><span class="line">    resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了初始化类，它们也可以用于类中，对于一个对象的部分操作<strong>只执行一次</strong>，比如下面这个类，无论是在操作读还是写，都需要且仅需要一次的提前连接：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    connection_info connection_details;</span><br><span class="line">    connection_handle connection;</span><br><span class="line">    std::once_flag connection_init_flag;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        connection = connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(connection_info <span class="keyword">const</span>&amp; connection_details_):</span><br><span class="line">        <span class="built_in">connection_details</span>(connection_details_)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  </span><br><span class="line">        connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  </span><br><span class="line">        <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="保护非频繁更新的数据结构"><a href="#保护非频繁更新的数据结构" class="headerlink" title="保护非频繁更新的数据结构"></a>保护非频繁更新的数据结构</h2><p>当一个数据结构更新频率很低，大部分时候都是读操作时。使用读写锁是最为合适的，因为这可以保证读的并发性，从而相比互斥锁有更高的吞吐量。</p>
<p>c++11 并没有提供读写锁，c++14 提供了<code>std::shared_timed_mutex</code>，c++17 在 14 的基础上还增加了<code> std::shared_mutex</code>。</p>
<blockquote>
<p><code> std::shared_mutex</code>是<code>std::shared_timed_mutex</code>的简易版本，少了一些操作。</p>
</blockquote>
<p>它们可以和<code>std::lock_guard</code>、<code>std::unique_lock</code>联合使用，但更为合适的是<strong>在读线程中</strong>使用<code>std::shared_lock</code>，以使得可以并发的进行读取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"><span class="comment">//这个类代表 dns 的一个地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span> &#123;</span></span><br><span class="line">	<span class="comment">//将 url 与地址使用 map 来进行存储</span></span><br><span class="line">    std::map&lt;std::string,dns_entry&gt; entries;</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex entry_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="comment">//查找 dns 列表时，使用 std::shared_lock 以保证可以多线程并发访问</span></span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;      </span><br><span class="line">        std::map&lt;std::string,dns_entry&gt;::const_iterator <span class="keyword">const</span> it =</span><br><span class="line">            entries.<span class="built_in">find</span>(domain);</span><br><span class="line">        <span class="keyword">return</span> (it == entries.<span class="built_in">end</span>()) ? <span class="built_in">dns_entry</span>() : it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                             dns_entry <span class="keyword">const</span>&amp; dns_details)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//修改 dns 列表时，需要使用 std::lock_guard 以保证独占的访问</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  </span><br><span class="line">        entries[domain] = dns_details;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h2><p>同一个线程如果递归的获取<code>std::mutex</code>则可能会导致死锁或其它未定义的行为，c++ 标准库为此提供了<code>std::recursive_mutex</code>以保证可以递归的获取锁。</p>
<p>需要注意的时，递归获取<code>std::recursive_mutex</code>的次数和释放的次数需要等同，所以使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code> 和<code>std::unique_lock&lt;std::recursive_mutex&gt;</code> 是明智的做法。</p>
<blockquote>
<p>但一般情况下都不建议这么做，如果代码中出现了递归锁，建议还是要重新思考代码逻辑是否可以优化。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：线程管理</title>
    <url>/2022/05/16/cpp_concurrency_manage/</url>
    <content><![CDATA[<p>理解 c++ 对线程的管理。</p>
<span id="more"></span>

<h1 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h1><h2 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h2><p>在 c++ 中，线程也是一个对象，该对象与对应的执行函数、对象相关联而执行对应的操作。</p>
<p>当创建该对象后，与其相关联的可执行对象就会被并发执行。</p>
<blockquote>
<p>这就和使用 pthread_create 一样，创建一个 pthread 与之关联的函数便会并发执行。</p>
</blockquote>
<h3 id="与普通函数关联"><a href="#与普通函数关联" class="headerlink" title="与普通函数关联"></a>与普通函数关联</h3><p>最简单的创建线程的方式便是将一个普通函数与线程对象关联，线程启动后便会执行该函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(hello)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程 t1 运行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与可调用类关联"><a href="#与可调用类关联" class="headerlink" title="与可调用类关联"></a>与可调用类关联</h3><p>类中使用运算符重载 () 时，该类的实例也可以被调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackGroundTask</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      @brief : 方法1，创建实例，将实例传给对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//    BackGroundTask bk;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    std::thread t1(bk);</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      @brief : 方法2，创建匿名实例，将实例传给对象</span></span><br><span class="line"><span class="comment">      @note: 注意这里需要用括号包含 BackGroundTask() 包含，以表示要创建对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"><span class="comment">//    std::thread t1((BackGroundTask()));</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      @brief : 方法3，使用列表初始化创建匿名实例，将实例传给对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    std::thread t1&#123;<span class="built_in">BackGroundTask</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程 t1 运行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别要注意括号初始化，如果是以<code>std::thread t1(BackGroundTask());</code>形式，则是代表声明了一个函数。其参数是函数指针，返回类型是<code>std::thread</code>。关于初始化的坑，在<a href="http://kcmetercec.top/2022/04/12/effective_cpp_obj_initialize/">这篇文章</a>有详细说明。</p>
<h3 id="与-Lambda-表达式关联"><a href="#与-Lambda-表达式关联" class="headerlink" title="与 Lambda 表达式关联"></a>与 Lambda 表达式关联</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = []() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程 t1 运行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与类内的静态函数关联"><a href="#与类内的静态函数关联" class="headerlink" title="与类内的静态函数关联"></a>与类内的静态函数关联</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskObj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskObj</span>(<span class="keyword">int</span> i):<span class="built_in">i_</span>(i) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Task</span><span class="params">(TaskObj *obj)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskObj::Task</span><span class="params">(TaskObj *obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of obj is &quot;</span> &lt;&lt; obj-&gt;i_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TaskObj <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(TaskObj::Task, &amp;obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待线程 t1 运行完毕</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="与类普通成员函数关联"><a href="#与类普通成员函数关联" class="headerlink" title="与类普通成员函数关联"></a>与类普通成员函数关联</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Obj</span>(<span class="keyword">int</span> val):<span class="built_in">val_</span>(val) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Exec</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value is &quot;</span> &lt;&lt; val_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Obj <span class="title">obj</span><span class="params">(<span class="number">89</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(&amp;Obj::Exec, &amp;obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实际上是将对象<code>obj</code>与其成员函数进行了绑定，实际上是以线程的形式调用了<code>obj.Exec()</code>。</p>
<h2 id="等待线程的完成"><a href="#等待线程的完成" class="headerlink" title="等待线程的完成"></a>等待线程的完成</h2><p>必须要为线程指定是使用<code>join()</code>（等待线程完成）还是<code>detach()</code>（分离方式运行，当前线程继续执行后面的任务）方式，否则线程对象退出后会调用<code>std::terminate()</code>，而使得整个进程退出。</p>
<blockquote>
<p>使用<code>detach()</code>以后，即使<code>std::thread</code>被析构，其关联的线程仍然会处于执行状态。<br>当该线程退出后，会自动释放其线程资源。</p>
</blockquote>
<blockquote>
<p><code>std::terminate()</code>是一个好的约束方式，以保证线程资源能够被完整的释放掉，若代码没有使用<code>join()</code>或<code>detach()</code>，则会抛出该异常来提醒。</p>
</blockquote>
<p>有的时候，并不能明确一个线程是否可以被<code>join()</code>，这个时候可以使用<code>joinable()</code>方法先确定一下。</p>
<h2 id="在异常的环境下等待"><a href="#在异常的环境下等待" class="headerlink" title="在异常的环境下等待"></a>在异常的环境下等待</h2><p>当以分离方式运行线程时，在创建线程后便可以调用<code>detach()</code>，这不会有什么问题。</p>
<p>但如果要等待线程完成时，需要注意在调用<code>join()</code>之前，抛出了异常的情况。</p>
<p>也就是说，不能因为抛出了异常，而忽略了使用<code>join()</code>。</p>
<h3 id="使用try-catch"><a href="#使用try-catch" class="headerlink" title="使用try...catch()"></a>使用<code>try...catch()</code></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span>         </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，使用<code>try...catch()</code>以保证是否发生异常，都可以<code>join</code>到线程。</p>
<p>但是这个方式太繁琐，一不小心就会出错。</p>
<h3 id="使用-RAII-编码方式"><a href="#使用-RAII-编码方式" class="headerlink" title="使用 RAII 编码方式"></a>使用 RAII 编码方式</h3><p>使用 RAII 编码方式，可以说时借助了编译器来保证能正常的调用<code>join()</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskGuard</span>(std::thread &amp;t):<span class="built_in">t_</span>(t) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TaskGuard</span>() &#123;</span><br><span class="line">        <span class="comment">//保证一个线程是可以 join 的，并且目前没有其它代码使用该 join</span></span><br><span class="line">        <span class="keyword">if</span>(t_.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">            t_.<span class="built_in">join</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Waiting for thread completely\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象只能与一个线程对象绑定，不能被拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">TaskGuard</span>(<span class="keyword">const</span> TaskGuard&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskGuard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TaskGuard &amp;obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread &amp;t_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TaskGuard <span class="title">guard</span><span class="params">(t1)</span></span>;</span><br><span class="line"><span class="comment">// 即使下面这个函数抛出了异常，也不用担心 join 不到 t1</span></span><br><span class="line"><span class="comment">//    dosomethingelse();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在后台运行线程"><a href="#在后台运行线程" class="headerlink" title="在后台运行线程"></a>在后台运行线程</h2><p>当对线程对象使用<code>detach()</code>后，这个线程就无法被<code>join()</code>了，它以后台的方式运行，其资源也由 c++ 运行时库进行释放。</p>
<p>在调用<code>detach()</code>之前，如果不确定是否已经被 detach，或被其它代码 join。那么先使用<code>joinable()</code>是个好习惯，当<code>joinable()</code>返回<code>true</code>则代表当前线程对象并没有被 detach，并且也没有其它代码使用 join，那么就可以安全的调用<code>detach()</code>了。</p>
<h1 id="给线程传递参数"><a href="#给线程传递参数" class="headerlink" title="给线程传递参数"></a>给线程传递参数</h1><p>参数的传递是直接在线程对象的构造函数中依次传入参数即可，比如<code>std::thread t1(TaskObj::Task, &amp;obj);</code>。</p>
<p>但是需要特别注意的是：**<code>std::thread</code>会根据传入的参数进行一次拷贝，然后在线程函数执行时，默认会将此参数转换为右值引用类型传递给函数**。</p>
<blockquote>
<p>比如传入的是一段字符串 “Hello”，那么<code>std::thread</code>就会以<code>const char*</code>形式在内部保存其地址，然后在对应的线程运行时，根据线程所需求的参数类型进行转换。</p>
</blockquote>
<blockquote>
<p>传递右值引用是为了：</p>
<ol>
<li>充分利用移动语义以提高参数传递的效率。</li>
<li>有些对象仅支持移动操作而不支持拷贝操作（比如<code>std::unique_ptr</code>）</li>
</ol>
</blockquote>
<p>比如下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hello</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;default constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hello</span>(<span class="keyword">const</span> Hello&amp; rhs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hello</span>(Hello&amp;&amp; rhs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">const</span> Hello &amp;obj)</span> </span>&#123;</span><br><span class="line">    obj.<span class="built_in">Put</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Hello obj;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintStr, obj)</span></span>;</span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2000</span>ms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">default constructor!</span><br><span class="line">copy constructor!</span><br><span class="line">move constructor!</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure>
<ol>
<li>实例化对象，会调用默认构造函数</li>
<li>将 obj 传递给 <code>std::thread</code>，<code>std::thread</code>会将对象拷贝到内部私有成员中，所以会调用拷贝构造函数</li>
<li>当线程运气起来时，<code>std::thread</code>会将私有成员以右值的方式传递给线程，而该类具有移动构造函数，所以就可以调用其移动构造函数来提高效率。</li>
</ol>
<h2 id="注意栈上的参数"><a href="#注意栈上的参数" class="headerlink" title="注意栈上的参数"></a>注意栈上的参数</h2><p>比如下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The str is : &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Oops</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintStr, str)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Oops</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2000</span>ms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时的输出内容是无法预知的，因为给线程对象<code>t1</code>传入的参数实际上是<code>char *</code>类型，<strong>而此时仅仅是拷贝了这个地址而已</strong>。</p>
<p>在线程函数启动时，<code>str</code>的栈内存已经被释放掉了，此时线程函数获取的内存内容便是无法预知的。</p>
<blockquote>
<p>虽然说这个时候也会给其转递<code>std::string</code>临时对象，但对象的内容就是非预期的。</p>
</blockquote>
<p>解决方法是：将<code>std::sting</code>为参数传递给<code>t1</code>，这样<code>t1</code>就拷贝了<code>std::string</code>，在运行时将<code>std::string</code>传递给<code>PrintStr</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The str is : &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Oops</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 std::string 类型的临时对象，str 作为构造参数参数 </span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintStr, std::string(str))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Oops</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2000</span>ms);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意类型传递"><a href="#注意类型传递" class="headerlink" title="注意类型传递"></a>注意类型传递</h2><p>前面讲过，<code>std::thread</code>传递给线程函数的是右值引用，这需要注意：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value is : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintStr, val)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PrintStr</code>接受的参数是<code>non const int&amp;</code>，而无法接受右值引用，此时便会编译出错。</p>
<blockquote>
<p><code>std::thread</code>会先拷贝 val 到内部，然后再传递右值引用到线程</p>
</blockquote>
<p>解决方法是：显示的使用<code>std::ref</code>以让<code>std::thread</code>传递引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStr</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value is : &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(PrintStr, std::ref(val))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这相当于显示告诉了<code>std::thread</code>需要获取的是引用，而不是对象的拷贝。</p>
<h2 id="当形参是只移动对象时"><a href="#当形参是只移动对象时" class="headerlink" title="当形参是只移动对象时"></a>当形参是只移动对象时</h2><p>当线程可执行函数的形参是只能移动不能拷贝时（比如<code>std::unique_ptr</code>），那就需要显示的使用移动语义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread</span><span class="params">(std::unique_ptr&lt;<span class="keyword">int</span>&gt; par)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of par is &quot;</span> &lt;&lt; *par &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; val = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Thread, std::move(val))</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>std::unique_ptr</code>限制了同时只能有一个能关联资源，所以它是不可被复制的。</p>
<p>这个时候就需要显示的使用移动语义，也就是说将当前实参<code>std::unique_ptr</code>移动到内部私有的一个<code>std::unique_ptr</code>。</p>
<p>在线程函数执行时，私有的<code>std::unique_ptr</code>又移动给函数的形参。</p>
<blockquote>
<p>当对象是临时对象时，移动的操作不需要显示的指明（比如函数返回一个<code>std::unique_ptr</code>，则不需要显示使用<code>std::move</code>）。</p>
</blockquote>
<h1 id="传递线程的所有者"><a href="#传递线程的所有者" class="headerlink" title="传递线程的所有者"></a>传递线程的所有者</h1><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p><code>std::thread</code>也是只能移动而不能拷贝的，也就意味着一个线程函数只能关联一个线程对象，这在逻辑上也是说得通的。不然多个线程对象关联同一个线程函数，那么就会在控制线程上乱套。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread</span><span class="params">(<span class="keyword">int</span> par)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of par is &quot;</span> &lt;&lt; par &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Thread, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//由于 t1 不是一个匿名的临时对象，所以需要显示的使用 std::move</span></span><br><span class="line">    <span class="comment">//t1 目前没有关联任何线程函数</span></span><br><span class="line">    std::thread t2 = std::<span class="built_in">move</span>(t1);</span><br><span class="line">    <span class="comment">//这里使用了 std::thread 创建了匿名临时对象，可以不用显示使用 std::move 就可以传递给 t3</span></span><br><span class="line">    std::thread t3 = std::<span class="built_in">thread</span>(Thread, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于 t2 也关联了线程函数，t3 转移给 t2 时，t2 关联的线程函数就会调用 std::terminal()</span></span><br><span class="line">    <span class="comment">//所以在这之前必须等待 t2 关联的函数执行完毕(join)，或将其分离(detach)</span></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    t2 = std::<span class="built_in">move</span>(t3);</span><br><span class="line"></span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以在函数返回或形参中使用<code>std::thread</code>，并且由于返回的是匿名临时对象，可以不用显示使用<code>std::move</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 返回值优化，编译器会使用移动版本</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::thread t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">thread</span>(some_function));</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="改进TaskGuard"><a href="#改进TaskGuard" class="headerlink" title="改进TaskGuard"></a>改进<code>TaskGuard</code></h2><p>前面使用<code>TaskGuard</code>以保证函数无论以何种方式退出，线程资源可以被正常释放。但是由于<code>TaskGuard</code>中使用的是引用，那么就无法避免被移动的<code>std::thread</code>实例也会控制线程，这引入了不安全因素。</p>
<p>由于<code>std::thread</code>只能被移动，所以我们可以直接使用移动的方式获取实例，以保证只有一个实例可以操作线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//多线程管理的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskGuard</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskGuard</span>(std::thread t):<span class="built_in">t_</span>(std::<span class="built_in">move</span>(t)) &#123;</span><br><span class="line">        <span class="comment">//由于可以保证当前只有 t_ 与线程关联，所以可以来判定是否有线程</span></span><br><span class="line">        <span class="keyword">if</span>(!t_.<span class="built_in">joinable</span>())</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;No thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TaskGuard</span>() &#123;</span><br><span class="line">        t_.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象只能与一个线程对象绑定，不能被拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">TaskGuard</span>(<span class="keyword">const</span> TaskGuard&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskGuard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TaskGuard &amp;obj) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::thread t_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Task</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(Task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TaskGuard <span class="title">guard</span><span class="params">(std::move(t1))</span></span>;</span><br><span class="line"><span class="comment">// 即使下面这个函数抛出了异常，也不用担心 join 不到 t1</span></span><br><span class="line"><span class="comment">//    dosomethingelse();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程对象与容器"><a href="#线程对象与容器" class="headerlink" title="线程对象与容器"></a>线程对象与容器</h2><p>既然线程对象是只可移动的，那么就可以批量创建线程，而后进行批量操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread</span><span class="params">(<span class="keyword">int</span> par)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of par is &quot;</span> &lt;&lt; par &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; vt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>(Thread, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; v : vt) &#123;</span><br><span class="line">        v.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要短暂的对一个复杂的数据结构进行并发操作时，可以使用这种简易的方式。</p>
<p>当所有线程都完成后，意味着这个并发操作就完成了。</p>
<h1 id="选择运行时线程的个数"><a href="#选择运行时线程的个数" class="headerlink" title="选择运行时线程的个数"></a>选择运行时线程的个数</h1><p>c++ 提供了函数<code>std::thread::hardware_concurrency()</code>来返回硬件所支持的并行线程个数，这有助于我们作为参考来创建线程的个数。</p>
<p>比如下面的并行求和：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个类以封装 std::accumulate</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span> </span>&#123;</span><br><span class="line">        result=std::<span class="built_in">accumulate</span>(first,last,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 计算需要处理多少个元素</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line">    <span class="comment">// 如果没有元素要处理，那就直接返回初值</span></span><br><span class="line">    <span class="keyword">if</span>(!length)                                            </span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    <span class="comment">// 每个线程至少处理 25 个元素</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread = <span class="number">25</span>;</span><br><span class="line">    <span class="comment">// 计算需要的最大线程数，确保其最小值为 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads=</span><br><span class="line">        (length + min_per_thread<span class="number">-1</span>) / min_per_thread;</span><br><span class="line">    <span class="comment">// 获取当前 CPU 可以硬件并发核心    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=</span><br><span class="line">        std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line">    <span class="comment">// 取最小线程数，最为最终要运行的线程数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads=            </span><br><span class="line">        std::<span class="built_in">min</span>(hardware_threads !=<span class="number">0</span> ? hardware_threads : <span class="number">2</span> , max_threads);</span><br><span class="line">    <span class="comment">// 再来计算每个线程需要处理的元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size= length / num_threads;  </span><br><span class="line">    <span class="comment">// 创建临时缓存存放每个线程的处理结果    </span></span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;std::thread&gt;  <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;       </span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="comment">// 除了本线程以外，还要创建 num_threads - 1 个线程来处理数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;i &lt; (num_threads - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end , block_size);                 </span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(                             </span><br><span class="line">            accumulate_block&lt;Iterator, T&gt;(),</span><br><span class="line">            <span class="comment">// 这里以引用的形式传入 results[i]，这样才能保存结果</span></span><br><span class="line">            block_start, block_end, std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">        block_start = block_end;                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本线程处理最后剩下的数据</span></span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;()(</span><br><span class="line">        block_start, last, results[num_threads - <span class="number">1</span>]);    </span><br><span class="line">    <span class="comment">// 等待其他的线程完成计算</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; entry: threads)</span><br><span class="line">           entry.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">// 将临时结果再进行一次求和，就可以得到最终的结果了                             </span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(), results.<span class="built_in">end</span>(), init);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="识别线程"><a href="#识别线程" class="headerlink" title="识别线程"></a>识别线程</h1><h2 id="获取线程-id"><a href="#获取线程-id" class="headerlink" title="获取线程 id"></a>获取线程 id</h2><p>获取线程 id 有两种方法：</p>
<ol>
<li>线程对象使用<code>get_id()</code>成员函数，返回关联线程的 id 或是<code>0</code>以代表没有关联线程。</li>
<li>在线程函数中使用<code>std::this_thread::get_id()</code>来获取当前线程的 id</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Thread</span><span class="params">(<span class="keyword">int</span> par)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of par is &quot;</span> &lt;&lt; par &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The id of mine is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> number = std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hardware concurrency &quot;</span> &lt;&lt; number &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; vt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        vt.<span class="built_in">emplace_back</span>(Thread, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : vt) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;join thread: &quot;</span> &lt;&lt; v.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        v.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用线程-id"><a href="#使用线程-id" class="headerlink" title="使用线程 id"></a>使用线程 id</h2><h3 id="线程之间的比较"><a href="#线程之间的比较" class="headerlink" title="线程之间的比较"></a>线程之间的比较</h3><p>有的时候需要判定两个函数是否在同一个线程中执行，可以判断 id 是否相等来实现。</p>
<p>当二者相等时，则代表二者处于同一个线程（或都是无效线程），否则不是同一个线程。</p>
<h3 id="线程-id-与查表"><a href="#线程-id-与查表" class="headerlink" title="线程 id 与查表"></a>线程 id 与查表</h3><p>线程 id 可以与哈希表这种数据结构绑定，将其作为一个 Key，以实现对应数据与线程的一一对应关系。</p>
<h3 id="线程-id-与功能对应"><a href="#线程-id-与功能对应" class="headerlink" title="线程 id 与功能对应"></a>线程 id 与功能对应</h3><p>通过与线程 id 进行比较，以执行对应不同的功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::thread::id master_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() == master_thread) &#123;</span><br><span class="line">        <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：线程间同步</title>
    <url>/2022/05/19/cpp_concurrency_synchronize/</url>
    <content><![CDATA[<p>熟悉用 c++ 来编写可以跨平台的数据同步操作。</p>
<span id="more"></span>

<h1 id="等待事件或条件"><a href="#等待事件或条件" class="headerlink" title="等待事件或条件"></a>等待事件或条件</h1><h2 id="使用条件变量"><a href="#使用条件变量" class="headerlink" title="使用条件变量"></a>使用条件变量</h2><p>之前在看 <a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">ostep</a> 的时候熟悉过条件变量，但只是 Linux 平台下的。现在看看 c++ 标准库是如何使用的。</p>
<p>c++ 标准库在<code> &lt;condition_variable&gt;</code>头文件中提供了<code> std::condition_variable</code>和<code>std::condition_variable_any</code>两种条件变量。</p>
<p>其中<code> std::condition_variable</code>只能与<code>std::mutex</code>结合使用，而<code>std::condition_variable_any</code>可以与任何具有互斥作用的对象结合使用。但是后者的效率比不上前者，所以大部分时候还是使用的<code> std::condition_variable</code>。</p>
<p>最基本的使用如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"><span class="comment">//用于存放数据的队列</span></span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;      </span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">more_data_to_prepare</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> data_chunk data = <span class="built_in">prepare_data</span>();</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">//将数据写入队列</span></span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">            data_queue.<span class="built_in">push</span>(data);</span><br><span class="line">            <span class="comment">//在退出这个局部区以后，互斥量就释放掉了              </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒一个消费者</span></span><br><span class="line">        <span class="comment">//在互斥量释放之后再来唤醒消费者</span></span><br><span class="line">        <span class="comment">//如果在互斥量释放前唤醒消费者，那么此时很可能互斥量还没有释放完毕，那么消费者又需要进入一次等待，执行效率没有那么高</span></span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="comment">//等待数据，当 lambda 中的返回为真时，则会继续处理后面的数据，否则会释放互斥量然后继续睡眠    </span></span><br><span class="line">        data_cond.<span class="built_in">wait</span>(</span><br><span class="line">            lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="comment">//拷贝一个数据的副本，这样可以让临界区的执行时间尽量的短     </span></span><br><span class="line">        data_chunk data = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//操作完数据需要释放互斥量</span></span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="comment">//到这里才是处理刚刚收到的数据          </span></span><br><span class="line">        <span class="built_in">process</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在消费者线程中，使用的是<code>std::unique_lock</code>。这是因为当条件变量不满足的时候，需要主动释放互斥量然后进入睡眠。而<code>std::lock_guard</code>并没有提供这些灵活操作的接口（并且在获取数据的副本后，也会主动释放互斥量以提高系统的并发度）。<code>wait</code>方法的执行逻辑就如同下面这段代码一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minimal_wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lk,Predicate pred)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">pred</span>()) &#123;</span><br><span class="line">        lk.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待唤醒</span></span><br><span class="line">        </span><br><span class="line">        lk.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个多线程安全的队列"><a href="#创建一个多线程安全的队列" class="headerlink" title="创建一个多线程安全的队列"></a>创建一个多线程安全的队列</h2><p>我们可以基于前面的代码，将<code>std::queue</code>封装为一个多线程安全的队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">//在多线程环境下，互斥量会在 const 成员函数中被使用，需要加上 mutable 修饰</span></span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mut;    </span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="keyword">const</span>&amp; other) &#123;</span><br><span class="line">		<span class="comment">//使用拷贝构造函数也需要做到互斥</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">        data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//既然是试探性的获取数据，就不需要用到条件变量了</span></span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.<span class="built_in">front</span>();</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> std::shared_ptr&lt;T&gt;();</span><br><span class="line">        <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使用的时候就更加简洁了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>()) &#123;</span><br><span class="line">        <span class="keyword">const</span> data_chunk data = <span class="built_in">prepare_data</span>();</span><br><span class="line">        data_queue.<span class="built_in">push</span>(data);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        data_chunk data;</span><br><span class="line">        data_queue.<span class="built_in">wait_and_pop</span>(data);    </span><br><span class="line">        <span class="built_in">process</span>(data);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要同时唤醒多个线程，那就应该使用<code>notify_all()</code>方法。</p>
<p>信号量是 <a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore">c++ 20</a> 才提供的，如果在之前的版本要使用信号量，那就使用条件变量和互斥锁来实现信号量。被互斥的变量其实就是计数值：</p>
<ul>
<li>释放信号量时计数值加 1</li>
<li>获取信号量时计数值减一</li>
</ul>
<h1 id="使用future等待一次性事件"><a href="#使用future等待一次性事件" class="headerlink" title="使用future等待一次性事件"></a>使用<code>future</code>等待一次性事件</h1><p>future 用于标识等待一个一次性事件的发生，一旦该事件发生了，其<code>ready</code>标记为真且无法被清除。</p>
<p>在<code> &lt;future&gt;</code>头文件中提供了<code>std::future&lt;&gt;</code>和<code>std::shared_future&lt;&gt;</code>分别对应于独立和共享，就如同<code>std::unique_ptr</code>和<code>std::shared_ptr</code>一样。一个事件，只能有一个<code>std::future&lt;&gt;</code>与之关联。而多个<code>std::shared_future&lt;&gt;</code>可以关联同一个事件。</p>
<p>多个线程如果要并发的访问<code>std::future&lt;&gt;</code>则需要使用互斥量这些来保证互斥，而<code>std::shared_future&lt;&gt;</code>则没有这个限制。</p>
<h2 id="获取线程的返回参数"><a href="#获取线程的返回参数" class="headerlink" title="获取线程的返回参数"></a>获取线程的返回参数</h2><p>假设需要一个线程来进行一个比较耗时的计算，如果使用<code>std::thread</code>来关联一个函数，那么获取其计算的结果还比较麻烦。这种情况下使用<code>std::async</code>与执行函数相关联，它会返回一个<code>std::future</code>以让使用者比较优雅的就可以获取到执行的返回值。</p>
<p>一个简单而优雅的示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::future&lt;<span class="keyword">int</span>&gt; the_answer = std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果在使用 get() 时线程还没有运行完成，那么在此处则会阻塞等待线程运行完毕</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The answer is &quot;</span> &lt;&lt; the_answer.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::async</code>的也可以给执行函数传递参数，和<code>std::thread</code>的使用方式是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">bar</span><span class="params">(std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">//这里拷贝的是对象 x 的地址，所以其调用方式是： (&amp;x)-&gt;foo(42, &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//这里拷贝的是对象 x，所以其调用方式是：x.bar(&quot;goodbye&quot;)      </span></span><br><span class="line"><span class="keyword">auto</span> f2 = std::<span class="built_in">async</span>(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="comment">//这里通过类 Y 创建了一个临时对象，然后在内部以右值引用的方式传递给其 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f3 = std::<span class="built_in">async</span>(<span class="built_in">Y</span>(),<span class="number">3.141</span>);</span><br><span class="line"><span class="comment">//这里拷贝的是引用，所以其调用方式是y(2.718)       </span></span><br><span class="line"><span class="keyword">auto</span> f4 = std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y),<span class="number">2.718</span>);     </span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line"><span class="comment">//由于 baz 这个函数需求的是左值引用，所以传递参数必须要使用 std::ref </span></span><br><span class="line">std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">move_only</span>();</span><br><span class="line">    <span class="built_in">move_only</span>(move_only&amp;&amp;)</span><br><span class="line">    <span class="built_in">move_only</span>(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">    move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建临时对象，内部以右值引用的方式移动给 operator()</span></span><br><span class="line"><span class="keyword">auto</span> f5 = std::<span class="built_in">async</span>(<span class="built_in">move_only</span>());</span><br></pre></td></tr></table></figure>

<p>可以对<code>std::async</code>配置策略，以显示的指定其执行策略是同步还是异步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以异步的方式执行，也就是会在另外一个线程中执行</span></span><br><span class="line"><span class="keyword">auto</span> f6 = std::<span class="built_in">async</span>(std::launch::async,<span class="built_in">Y</span>(),<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">//推迟执行，在使用 wait() 或 get() 时才执行，相当于同步执行     </span></span><br><span class="line"><span class="keyword">auto</span> f7 = std::<span class="built_in">async</span>(std::launch::deferred,baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line"><span class="comment">//下面这两种方式会根据代码的具体实现方式来选择是同步还是异步执行    </span></span><br><span class="line"><span class="keyword">auto</span> f8 = std::<span class="built_in">async</span>(                           </span><br><span class="line">   std::launch::deferred | std::launch::async,</span><br><span class="line">   baz,std::<span class="built_in">ref</span>(x));                          </span><br><span class="line"><span class="keyword">auto</span> f9 = std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">//比如 f7 使用 wait() 的时候， baz(x) 才执行          </span></span><br><span class="line">f7.<span class="built_in">wait</span>();</span><br></pre></td></tr></table></figure>

<h2 id="将-future-与一个任务关联"><a href="#将-future-与一个任务关联" class="headerlink" title="将 future 与一个任务关联"></a>将 future 与一个任务关联</h2><p><code>std::packaged_task</code>提供了更为灵活的方式，它可以将一个可执行函数、可执行对象等与一个<code>std::future</code>绑定在一起，形成一个可执行对象。</p>
<p>然后这个可执行对象可以被同步或异步的被执行。执行的时候其返回值便会自动存储，而后可以通过关联的<code>std::future</code>来获取。</p>
<p>比如  <code>std::packaged_task&lt;std::string(std::vector&lt;char&gt;*,int)&gt;</code>打包后实例化的类就如同下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">packaged_task</span>&lt;</span>std::<span class="built_in">string</span>(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>;</span><br><span class="line">    <span class="comment">// std::future 类型和模板里面传入的返回值一致</span></span><br><span class="line">    <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 函数参数和模板里面传入的参数一致</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于处理批量任务，使用这个打包的方式，可以将这种多个对象都放入容器中便于管理:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// unique function to avoid disambiguating the std::pow overload set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">pow</span>(x,y); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">return</span> std::pow(a, b); </span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个是同步执行，调用该函数的时候才执行，返回值会保存在 future 中</span></span><br><span class="line">    <span class="built_in">task</span>(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;task_lambda:\t&quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_bind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::bind(f, <span class="number">2</span>, <span class="number">11</span>))</span></span>;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个是同步执行，调用该函数的时候才执行，返回值会保存在 future 中</span></span><br><span class="line">    <span class="built_in">task</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;task_bind:\t&quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这个是异步执行，调用该函数的时候才执行，返回值会保存在 future 中</span></span><br><span class="line">    <span class="function">std::thread <span class="title">task_td</span><span class="params">(std::move(task), <span class="number">2</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    task_td.<span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;task_thread:\t&quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">task_lambda</span>();</span><br><span class="line">    <span class="built_in">task_bind</span>();</span><br><span class="line">    <span class="built_in">task_thread</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，GUI 有个独立的线程执行刷新任务，其它的任务要刷新线程必须要给这个 GUI 任务发送消息，这些线程或许还需要得到 GUI 线程执行该消息后的返回值。那么使用<code>std::package_task</code>就是合理的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="comment">//存放消息的队列，每个元素都是一个 std::packaged_task</span></span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//事件循环，获取消息</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">gui_shutdown_message_received</span>()) &#123;</span><br><span class="line">        <span class="built_in">get_and_process_gui_message</span>();    </span><br><span class="line">        std::packaged_task&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (tasks.<span class="built_in">empty</span>())                 </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//从消息队列中取出一个消息</span></span><br><span class="line">            task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());   </span><br><span class="line">            tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行该消息，同时与之关联的 std::future 也 reday 了</span></span><br><span class="line">        <span class="built_in">task</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将一个消息任务与 future 绑定</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;       </span><br><span class="line">    std::future&lt;<span class="keyword">void</span>&gt; res = task.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="comment">//消息存入消息队列     </span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    <span class="comment">// 返回与该消息绑定的 future，用户可以在需要的时候获取这个消息的执行返回结果</span></span><br><span class="line">    <span class="comment">// 如果对结果不感兴趣，也可以丢弃这个返回</span></span><br><span class="line">    <span class="keyword">return</span> res;                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-std-promises"><a href="#使用-std-promises" class="headerlink" title="使用 std::promises"></a>使用 std::promises</h2><p><code>std::promises</code>和<code>std::packaged_task</code>很类似，也是可以通过其<code> get_future()</code>方法获取一个<code>std::future</code>，然后它就可以组合使用。</p>
<p><code>std::packaged_task</code>是用于执行一个函数，其返回值与<code>std::future</code>绑定。而<code>std::promises</code>是当其使用<code>set_value()</code>方法后，与其绑定的<code>std::future</code>便会是 ready 状态，如果<code>std::future</code>在其 ready 之前使用了 <code>get()</code>方法，那么将会阻塞的等待。</p>
<p>所以既可以使用<code>std::promises</code>实现线程间同步，也可以实现线程间的同步通信。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;::iterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">                std::vector&lt;<span class="keyword">int</span>&gt;::iterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                std::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = std::<span class="built_in">accumulate</span>(first, last, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 执行这一步操作后，与 promise 绑定的 future 状态就会是 reday 状态</span></span><br><span class="line">    accumulate_promise.<span class="built_in">set_value</span>(sum);  <span class="comment">// Notify future</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(std::promise&lt;<span class="keyword">void</span>&gt; barrier)</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 等待 3 秒后，等待它的 future 就会被唤醒</span></span><br><span class="line">    barrier.<span class="built_in">set_value</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;int&gt; to transmit a result between threads.</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; numbers = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    std::promise&lt;<span class="keyword">int</span>&gt; accumulate_promise;</span><br><span class="line">    std::future&lt;<span class="keyword">int</span>&gt; accumulate_future = accumulate_promise.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">work_thread</span><span class="params">(accumulate, numbers.begin(), numbers.end(),</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::move(accumulate_promise))</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// future::get() will wait until the future has a valid result and retrieves it.</span></span><br><span class="line">    <span class="comment">// Calling wait() before get() is not needed</span></span><br><span class="line">    <span class="comment">//accumulate_future.wait();  // wait for result</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result=&quot;</span> &lt;&lt; accumulate_future.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    work_thread.<span class="built_in">join</span>();  <span class="comment">// wait for thread completion</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Demonstrate using promise&lt;void&gt; to signal state between threads.</span></span><br><span class="line">    std::promise&lt;<span class="keyword">void</span>&gt; barrier;</span><br><span class="line">    std::future&lt;<span class="keyword">void</span>&gt; barrier_future = barrier.<span class="built_in">get_future</span>();</span><br><span class="line">    <span class="function">std::thread <span class="title">new_work_thread</span><span class="params">(do_work, std::move(barrier))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wait result\n&quot;</span>;</span><br><span class="line">    barrier_future.<span class="built_in">wait</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;wait result done\n&quot;</span>;</span><br><span class="line">    new_work_thread.<span class="built_in">join</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将异常存入-future"><a href="#将异常存入-future" class="headerlink" title="将异常存入 future"></a>将异常存入 future</h2><p>正常情况下，当一个函数抛出异常时，会层层向上传递，如果没有用户代码 catch 它，那么将会由标准库处理并退出用户进程。但是当使用了<code>std::future</code>，<code>std::promises</code>，<code>std::packaged_task</code>时，如果其关联函数抛出了异常，这个异常的值会被存储在 future 中。</p>
<p>使用<code>std::promises</code>来存储异常，然后在获取线程中获取异常才是一个优雅的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> std::promise&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        result.<span class="built_in">set_exception</span>(</span><br><span class="line">                    std::<span class="built_in">make_exception_ptr</span>(std::<span class="built_in">out_of_range</span>(<span class="string">&quot;input out of range!\n&quot;</span>))</span><br><span class="line">                    );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.<span class="built_in">set_value</span>(a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(func_div, <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sleep 3 seconds\n&quot;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;get result\n&quot;</span>;</span><br><span class="line">    <span class="comment">//在获取结果的时候，才抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> ret = result.<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;get result: &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个线程等待同一个事件"><a href="#多个线程等待同一个事件" class="headerlink" title="多个线程等待同一个事件"></a>多个线程等待同一个事件</h2><p>当有多个线程在使用同一个<code>std::future</code>时，便会造成竞态。这种情况下应该使用<code>std::shared_future</code>。</p>
<p>这并不是说多个线程使用同一个<code>std::shared_future</code>，而是说每个线程都有一份对<code>std::shared_future</code>的拷贝，它们都访问自己的<code>std::shared_future</code>：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/concurrency_in_action/pic/c4_shared_future.jpg?raw=true"></p>
<p><code>std::shared_future</code>是通过<code>std::future</code>来获取，又由于<code>std::future</code>是不能被拷贝的，只能被移动，所以需要使用<code>std::move</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;                      </span><br><span class="line"><span class="function">std::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(std::move(f))</span></span>;</span><br></pre></td></tr></table></figure>

<p>当然，对于创建的临时对象，也可以更加简单粗暴：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::promise&lt;std::string&gt; p;</span><br><span class="line"><span class="function">std::shared_future&lt;std::string&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;</span><br></pre></td></tr></table></figure>

<p>除此之外，<code>std::future</code>也具有一个<code>share()</code>方法来创建<code>std::shared_future</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,</span><br><span class="line">    SomeAllocator&gt;::iterator&gt; p;</span><br><span class="line"><span class="comment">//sf 推导为  std::shared_future&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator, //SomeAllocator&gt;::iterator&gt;</span></span><br><span class="line"><span class="keyword">auto</span> sf = p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure>

<h1 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h1><p>对于时间的设定，可以设置相对时间（比如等待 100 毫秒）和绝对时间（比如等待至 2023年……）。</p>
<p>c++ 标准库提供了这两种时间的设定，对于相对时间，其操作方法以<code>_for</code>作为后缀，对于绝对时间，其操作方法以<code>_until</code>作为后缀。</p>
<blockquote>
<p>比如对于 condition_variable 的 wait() 方法就有 wait_for() 和 wait_until() 两种超时等待。</p>
</blockquote>
<h2 id="c-的时钟"><a href="#c-的时钟" class="headerlink" title="c++ 的时钟"></a>c++ 的时钟</h2><p>c++ 标准库提供了头文件<code> &lt;chrono&gt;</code>以支持时钟相关的操作：</p>
<ul>
<li><code>std::chrono::steady_clock</code>提供了具有固定不可被修改的时钟</li>
<li><code>std::chrono::system_clock</code>提供了通用时钟操作，可以被设定修改</li>
<li><code>std::chrono::high_resolution_clock</code>提供了高精度时钟操作</li>
</ul>
<p>以上 3 个时钟都具有静态函数<code>now()</code>以获取一个绝对的时间点<code>time_point</code>。</p>
<h2 id="时间段"><a href="#时间段" class="headerlink" title="时间段"></a>时间段</h2><h3 id="ratio"><a href="#ratio" class="headerlink" title="ratio"></a>ratio</h3><p><code>ratio</code>头文件提供了模板类<code>std::ratio&lt;num, den&gt;</code>，其值代表分数，<code>num</code>就是分子（Numerator）的简写，<code>den</code>就是分母（denominator）的简写。</p>
<p>而在时间的角度来看的话，可以理解为<code>num</code>秒内有<code>den</code>次发生，也就是频率的表示。</p>
<blockquote>
<p>比如 1毫秒，就是 1 秒内有 1000 次，那么就表示为：<code>std::ratio&lt;1,1000&gt;</code>。</p>
</blockquote>
<p>该头文件还提供了很多实现定义的类型，便于用户直接使用：（详见<a href="https://en.cppreference.com/w/cpp/numeric/ratio/ratio">cppreference</a>）</p>
<table>
<thead>
<tr>
<th align="center">定义</th>
<th align="center">等同于</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nano</td>
<td align="center">std::ratio&lt;1, 1000000000&gt;</td>
</tr>
<tr>
<td align="center">micro</td>
<td align="center">std::ratio&lt;1, 1000000&gt;</td>
</tr>
<tr>
<td align="center">……</td>
<td align="center">……</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;::num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::ratio&lt;<span class="number">1</span>, <span class="number">1000</span>&gt;::den &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::micro::num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::micro::den &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<blockquote>
<p>1<br>1000<br>1<br>1000000</p>
</blockquote>
<h3 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h3><p>头文件<code>&lt;chrono&gt;</code>提供了<code>std::chrono::duration&lt;Rep,Period&gt;</code>模板。</p>
<p>它与<code>std::ratio</code>联合使用，以表示在时间段内有多少个计数值。</p>
<p>第一个参数指定存储时间段的类型值，第二个参数指定<code>std::ratio</code>。</p>
<p>比如：</p>
<ul>
<li>使用<code>short</code>存储一分钟的计数值：<code>std::chrono::duration&lt;short,std::ratio&lt;60,1&gt;&gt;</code></li>
<li>使用<code>double</code>存储毫秒： <code>std::chrono::duration&lt;double,std::ratio&lt;1,1000&gt;&gt;</code></li>
</ul>
<p>为了方便，标准库还提供了<code>std::nanoseconds,  std::microseconds,  std::milliseconds,  std::seconds, std::minutes, std::hours</code>等这些定义好的时间段值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到一个代表两秒的值</span></span><br><span class="line">    <span class="keyword">auto</span> t = std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前频率是 1 秒钟有 50 次跳动</span></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">int</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">50</span>&gt;&gt; <span class="built_in">val</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//那么两秒对应的就是 100 次跳动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count of val &quot;</span> &lt;&lt; val.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 c++14 及以后，还提供了<code>std::chrono_literals</code>以使用字面值来表示时间段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">auto</span> one_day = <span class="number">24</span>h;</span><br><span class="line"><span class="keyword">auto</span> half_an_hour= <span class="number">30</span>min;</span><br><span class="line"><span class="keyword">auto</span> max_time_between_messages= <span class="number">30</span>ms;</span><br></pre></td></tr></table></figure>

<p> 这样<code>15ns</code> 就等同于 <code>std::chrono::nanoseconds(15)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">    <span class="comment">//得到一个代表两秒的值</span></span><br><span class="line">    <span class="keyword">auto</span> t = <span class="number">2</span>s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前频率是 60 秒钟有 1 次跳动，也就是一分钟</span></span><br><span class="line">    std::chrono::duration&lt;<span class="keyword">double</span>, std::ratio&lt;<span class="number">60</span>, <span class="number">1</span>&gt;&gt; <span class="built_in">val</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//那么两秒对应的就是 0.0333 次跳动，也就是 0.0333 分钟</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count of val &quot;</span> &lt;&lt; val.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::chrono::duration_cast&lt;&gt;</code>用于时间之间的转换，这里可能会有精度的损失（比如毫秒转换到秒）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">    <span class="comment">//最终转换为 54 秒</span></span><br><span class="line">    std::chrono::seconds s = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(ms);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;conver &quot;</span> &lt;&lt; ms.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; ms to &quot;</span> &lt;&lt; s.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; s\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>周期之间也可以进行简单的运算，比如 5 秒可以使用：<code>5*seconds(1)</code>或<code>minutes(1) – seconds(55)</code>，它们都等同于<code> seconds(5)</code>。</p>
<h2 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h2><p><code>std::chrono::time_point&lt;&gt;</code>用于表示一个绝对的时间点，它有两个参数。第一个参数用于表示这个时间点的参考时钟，第二个参数用于表示时间段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals; <span class="comment">// enables the usage of 24h, 1ms, 1s instead of</span></span><br><span class="line">                                   <span class="comment">// e.g. std::chrono::hours(24), accordingly</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以系统时钟作为参考，周期是 100 纳秒</span></span><br><span class="line">    <span class="keyword">const</span> std::chrono::time_point&lt;std::chrono::system_clock,</span><br><span class="line">            std::chrono::duration&lt;<span class="keyword">long</span> <span class="keyword">long</span>, std::ratio&lt;<span class="number">1</span>, <span class="number">10000000</span>&gt;&gt;&gt; now =</span><br><span class="line">        std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;time since epoch with seconds &quot;</span> &lt;&lt;</span><br><span class="line">                std::chrono::duration_cast&lt;std::chrono::seconds&gt;(now.<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> std::<span class="keyword">time_t</span> t_c = std::chrono::system_clock::<span class="built_in">to_time_t</span>(now - <span class="number">24</span>h);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;24 hours ago, the time was &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">put_time</span>(std::<span class="built_in">localtime</span>(&amp;t_c), <span class="string">&quot;%F %T.\n&quot;</span>) &lt;&lt; std::flush;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于使用相同参考时钟的时间点，也可以进行加减运算。比如下面经过时间点求差得出一段代码的运行时间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0xffffff</span>; ++i)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> stop = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;for loop took &quot;</span></span><br><span class="line">             &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (stop-start).<span class="built_in">count</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="超时等待相关的函数"><a href="#超时等待相关的函数" class="headerlink" title="超时等待相关的函数"></a>超时等待相关的函数</h2><p>以延迟为例可以通过<code>std::this_thread::sleep_for</code>使用相对的延迟，和通过<code>std::this_thread::sleep_until</code>使用绝对延迟：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">//使用相对延迟，延迟两秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> stop = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;relative delay took &quot;</span></span><br><span class="line">             &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (stop-start).<span class="built_in">count</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">//使用绝对延迟，延迟 800 毫秒</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_until</span>(std::chrono::system_clock::<span class="built_in">now</span>() + std::chrono::<span class="built_in">milliseconds</span>(<span class="number">800</span>));</span><br><span class="line"></span><br><span class="line">    stop = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;absolute delay took &quot;</span></span><br><span class="line">             &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt; (stop-start).<span class="built_in">count</span>()</span><br><span class="line">             &lt;&lt; <span class="string">&quot; microseconds&quot;</span> &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了延迟以外，其它的便是超时等待相关的函数。同样的，使用<code>xxx_for</code>便是相对时间，而使用<code>xxx_until</code>则是绝对时间。常用的功能函数总结如下：</p>
<ul>
<li><code>std::this_thread::sleep_for</code> / <code>std::this_thread::sleep_until</code></li>
<li><code>std::condition_variable::wait_for</code> / <code>std::condition_variable::wait_until</code></li>
<li><code>std::condition_variable_any::wait_for</code> / <code>std::condition_variable_any::wait_until</code></li>
<li><code>std::timed_mutex::try_lock_for</code> / <code>std::timed_mutex::try_lock_until</code></li>
<li><code>std::recursive_timed_mutex::try_lock_for</code> / <code>std::recursive_timed_mutex::try_lock_until</code></li>
<li><code>std::shared_timed_mutex::try_lock_for</code> / <code>std::shared_timed_mutex::try_lock_until</code></li>
<li><code>std::shared_timed_mutex::try_lock_shared_for</code> / <code>std::shared_timed_mutex::try_lock_shared_until</code></li>
<li><code>std::unique_lock&lt;Mutex&gt;::try_lock_for</code> / <code>std::unique_lock&lt;Mutex&gt;::try_lock_until</code></li>
<li><code>std::shared_lock&lt;Mutex&gt;::try_lock_for</code> / <code>std::shared_lock&lt;Mutex&gt;::try_lock_for</code></li>
<li><code>std::future&lt;T&gt;::wait_for</code> / <code>std::future&lt;T&gt;::wait_until</code></li>
<li><code>std::shared_future&lt;T&gt;::wait_for</code> / <code>std::shared_future&lt;T&gt;::wait_until</code></li>
</ul>
<h1 id="线程间同步的应用"><a href="#线程间同步的应用" class="headerlink" title="线程间同步的应用"></a>线程间同步的应用</h1><p>比起简单的将数据暴露出来给多个线程共享，使用函数式编程是可以简化代码的一个好方法。</p>
<h2 id="函数式编程与std-future"><a href="#函数式编程与std-future" class="headerlink" title="函数式编程与std::future"></a>函数式编程与<code>std::future</code></h2><p>下面以快速排序为例，来展示函数式编程是如何做到多线程安全的。</p>
<h3 id="c-代码实现快速排序"><a href="#c-代码实现快速排序" class="headerlink" title="c 代码实现快速排序"></a>c 代码实现快速排序</h3><p>快速排序思路如下：</p>
<ol>
<li>选择数据的一个点作为 pivot 与其他数做比较</li>
<li>小于 pivot 的数放一边，大于或等于 pivot 的数放另外一半</li>
<li>递归的进行步骤 2，递归的终止条件便是当前需要判断的数组值只有 1 个时，排序便完成了</li>
</ol>
<p>下面是一个简易的 c 代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *buf, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里选取 r 作为 pivot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt;= r - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[j] &lt; buf[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                swap(&amp;buf[j], &amp;buf[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(&amp;buf[i], &amp;buf[r]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort_frame</span><span class="params">(<span class="keyword">int</span> *buf, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = partition(buf, p, r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;quick_sort p = %d, r = %d, q = %d\n&quot;</span>, p, r, q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    quick_sort_frame(buf, p, q - <span class="number">1</span>);</span><br><span class="line">    quick_sort_frame(buf, q + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> *buf, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    quick_sort_frame(buf, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 10</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> buf[BUF_SIZE];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before sort, buffer contents are:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int8_t</span> i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;</span><br><span class="line">            buf[i] = BUF_SIZE - i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    quick_sort(buf, BUF_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after sort, buffer contents are:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int8_t</span> i = <span class="number">0</span>; i &lt; BUF_SIZE; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">before sort, buffer contents are:</span><br><span class="line">10,9,8,7,6,5,4,3,2,1,</span><br><span class="line">quick_sort p = 0, r = 9, q = 0</span><br><span class="line">1,9,8,7,6,5,4,3,2,10,</span><br><span class="line">quick_sort p = 1, r = 9, q = 9</span><br><span class="line">9,8,7,6,5,4,3,2,10,</span><br><span class="line">quick_sort p = 1, r = 8, q = 1</span><br><span class="line">2,8,7,6,5,4,3,9,</span><br><span class="line">quick_sort p = 2, r = 8, q = 8</span><br><span class="line">8,7,6,5,4,3,9,</span><br><span class="line">quick_sort p = 2, r = 7, q = 2</span><br><span class="line">3,7,6,5,4,8,</span><br><span class="line">quick_sort p = 3, r = 7, q = 7</span><br><span class="line">7,6,5,4,8,</span><br><span class="line">quick_sort p = 3, r = 6, q = 3</span><br><span class="line">4,6,5,7,</span><br><span class="line">quick_sort p = 4, r = 6, q = 6</span><br><span class="line">6,5,7,</span><br><span class="line">quick_sort p = 4, r = 5, q = 4</span><br><span class="line">5,6,</span><br><span class="line">after sort, buffer contents are:</span><br><span class="line">1,2,3,4,5,6,7,8,9,10,</span><br></pre></td></tr></table></figure>

<h3 id="c-代码实现快速排序-1"><a href="#c-代码实现快速排序-1" class="headerlink" title="c++ 代码实现快速排序"></a>c++ 代码实现快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    <span class="comment">// 取 list 头的元素作为 pivot</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    T <span class="keyword">const</span>&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 list 中剩余的元素和 pivot 做比较</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t &lt; pivot;&#125;);</span><br><span class="line">    <span class="comment">// 将分类好的小于 pivot 的元素放入 lower_part</span></span><br><span class="line">    <span class="comment">// 那么 input 中的剩余元素便是大于或等于 pivot 的元素</span></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(),</span><br><span class="line">        divide_point);</span><br><span class="line">    <span class="comment">// 将两个区间的元素递归</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_lower</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        sequential_quick_sort(std::move(lower_part)))</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        sequential_quick_sort(std::move(input)))</span></span>;</span><br><span class="line">    <span class="comment">// 大于或等于 pivot 的元素依次放在 pivot 的右边</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(), new_higher);</span><br><span class="line">    <span class="comment">// 小于 pivot 的元素依次放在 pivot 的左边</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), new_lower);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; vals = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of vals before sort:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vals) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    vals = <span class="built_in">sequential_quick_sort</span>(vals);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of vals after sort:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vals) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，与上面 c 版本的实现思路是完全一样的，只是有标准库的加持，使得代码看起来更为简洁。</p>
<h3 id="并行实现快速排序"><a href="#并行实现快速排序" class="headerlink" title="并行实现快速排序"></a>并行实现快速排序</h3><p>以上的 c++ 代码是由一个线程来完成了，如果可以由多个线程来完成并行排序便可以更加快速的得出结果。</p>
<p>这里就需要考虑到 data race 的问题了，使用<code>std::future</code>是一个比较优雅的解决方案。</p>
<p>由于每次分为两个部分后，又需要对这两个部分递归，所以将其中一个部分分离为一个单独的线程是可以提供并发度的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">std::list&lt;T&gt; <span class="title">sequential_quick_sort</span><span class="params">(std::list&lt;T&gt; input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    <span class="comment">// 取 list 头的元素作为 pivot</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(), input, input.<span class="built_in">begin</span>());</span><br><span class="line">    T <span class="keyword">const</span>&amp; pivot = *result.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 list 中剩余的元素和 pivot 做比较</span></span><br><span class="line">    <span class="keyword">auto</span> divide_point = std::<span class="built_in">partition</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;](T <span class="keyword">const</span>&amp; t)&#123;<span class="keyword">return</span> t &lt; pivot;&#125;);</span><br><span class="line">    <span class="comment">// 将分类好的小于 pivot 的元素放入 lower_part</span></span><br><span class="line">    <span class="comment">// 那么 input 中的剩余元素便是大于或等于 pivot 的元素</span></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.<span class="built_in">splice</span>(lower_part.<span class="built_in">end</span>(), input, input.<span class="built_in">begin</span>(),</span><br><span class="line">        divide_point);</span><br><span class="line">    <span class="comment">// 将小于区间的元素放在另一个线程访问</span></span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; <span class="built_in">new_lower</span>(</span><br><span class="line">        	<span class="comment">// 最后会使用 new_lower.get() 来获取结果，所以这里可以使用移动语义</span></span><br><span class="line">            <span class="comment">// 因为栈上的变量可以确保有效性</span></span><br><span class="line">            std::<span class="built_in">async</span>(&amp;sequential_quick_sort&lt;T&gt;, std::<span class="built_in">move</span>(lower_part))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">new_higher</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        sequential_quick_sort(std::move(input)))</span></span>;</span><br><span class="line">    <span class="comment">// 大于或等于 pivot 的元素依次放在 pivot 的右边</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">end</span>(),new_higher);</span><br><span class="line">    <span class="comment">// 小于 pivot 的元素依次放在 pivot 的左边</span></span><br><span class="line">    result.<span class="built_in">splice</span>(result.<span class="built_in">begin</span>(),new_lower.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; vals = &#123;<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of vals before sort:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vals) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    vals = <span class="built_in">sequential_quick_sort</span>(vals);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of vals after sort:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vals) &#123;</span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于两个线程分别是处理两边的数据，也不会有 data race 的情况出现。</p>
<p>这里需要注意的是线程的并发数量，是递归的 2^n 次方。</p>
<blockquote>
<p>比如递归 10 次，线程的数量就是 1024 个。</p>
</blockquote>
<p>所以，要根据当前硬件所支持的并发数来决定是使用<code>std::launch::deferrred</code>还是<code>std::launch::async</code>。</p>
<blockquote>
<p>默认情况下不填这项，那就依赖编译器的实现来完成不同的策略。</p>
</blockquote>
<p>如果要使用纯 c 来实现这个并行方式，则需要更多的代码且不易维护。</p>
<h2 id="通过消息传递来完成同步"><a href="#通过消息传递来完成同步" class="headerlink" title="通过消息传递来完成同步"></a>通过消息传递来完成同步</h2><p>CSP（Communicating Sequential Process）编程方式就是指：以消息传递的方式在各个线程间共享数据。</p>
<p>每个线程当前的状态根据接收到的消息而定，在处理消息时各个线程都是完全独立的而不会有 data race 的情况出现。</p>
<p>这种方式使得并发编程变得简单而易于维护。</p>
<blockquote>
<p>这个过程中的临界资源便是消息队列，可以使用类将其封装起来而易于使用。</p>
</blockquote>
<p>一个比较简单的示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">card_inserted</span> &#123;</span></span><br><span class="line">    std::string account;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">atm</span> &#123;</span></span><br><span class="line">    messaging::receiver incoming;</span><br><span class="line">    messaging::sender bank;</span><br><span class="line">    messaging::sender interface_hardware;</span><br><span class="line">    <span class="comment">// 这个函数指针指向当前正在执行的状态</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (atm::*state)();</span><br><span class="line">    std::string account;</span><br><span class="line">    std::string pin;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waiting_for_card</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interface_hardware.<span class="built_in">send</span>(<span class="built_in">display_enter_card</span>());   </span><br><span class="line">        incoming.<span class="built_in">wait</span>()                             </span><br><span class="line">            .handle&lt;card_inserted&gt;(</span><br><span class="line">                [&amp;](card_inserted <span class="keyword">const</span>&amp; msg) &#123;</span><br><span class="line">                    account = msg.account;</span><br><span class="line">                    pin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    interface_hardware.<span class="built_in">send</span>(<span class="built_in">display_enter_pin</span>());</span><br><span class="line">                    <span class="comment">// 当满足条件后，便切换状态</span></span><br><span class="line">                    state = &amp;atm::getting_pin;</span><br><span class="line">                &#125;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getting_pin</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 默认的初始状态</span></span><br><span class="line">        state = &amp;atm::waiting_for_card;     </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">				<span class="comment">// 执行当前状态</span></span><br><span class="line">                (<span class="keyword">this</span>-&gt;*state)();    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">catch</span></span>(messaging::close_queue <span class="keyword">const</span>&amp;) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<ol>
<li>一个线程只执行当前的状态，状态的切换并不会引起临界区的问题</li>
<li>多个线程都维护自己的状态，这使得并发逻辑变得非常简单</li>
<li>唯一需要注意的便是消息队列的互斥问题</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ concurrency：进一步的线程管理</title>
    <url>/2022/05/28/cpp_concurrency_thread_pool/</url>
    <content><![CDATA[<p>线程除了创建和销毁外，还需要控制其暂停、继续运行等状态。</p>
<span id="more"></span>

<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池就相当于提前创建好的多个工作线程，从任务队列上获取任务并执行。这种方式可以避免系统中的线程过多，因为很多任务都是隔较长时间才会执行一次，如果为每个任务都单独分配一个线程则会消耗过多的系统资源。</p>
<h2 id="简易的线程池"><a href="#简易的线程池" class="headerlink" title="简易的线程池"></a>简易的线程池</h2><p>根据当前硬件核心数确定线程数，当有任务需要处理时，便将任务放入队列，工作线程依次从队列中取出任务执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">join_threads</span> &#123;</span></span><br><span class="line">    std::vector&lt;std::thread&gt;&amp; threads;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">join_threads</span><span class="params">(std::vector&lt;std::thread&gt;&amp; threads_)</span>:</span></span><br><span class="line"><span class="function">        threads(threads_)</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">join_threads</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; threads.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (threads[i].<span class="built_in">joinable</span>())</span><br><span class="line">                threads[i].<span class="built_in">join</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_pool</span> &#123;</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> done;</span><br><span class="line">    <span class="comment">// 线程安全队列，包含互斥及同步机制</span></span><br><span class="line">    threadsafe_queue&lt;std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; &gt; work_queue;</span><br><span class="line">    <span class="comment">// 线程池，使用 vector 来存放     </span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;             </span><br><span class="line">    join_threads joiner; </span><br><span class="line">               </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">            std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">            <span class="comment">// 从队列中取出一个任务并执行</span></span><br><span class="line">            <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task)) &#123;</span><br><span class="line">                <span class="built_in">task</span>();    </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 如果队列中没有任务了，便主动让出 CPU</span></span><br><span class="line">                std::this_thread::<span class="built_in">yield</span>();    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_pool</span>():</span><br><span class="line">        <span class="built_in">done</span>(<span class="literal">false</span>),<span class="built_in">joiner</span>(threads) &#123;</span><br><span class="line">        <span class="comment">// 创建与硬件核心数相同的工作线程池</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i&lt; thread_count; ++i) &#123;</span><br><span class="line">            <span class="comment">// 创建后，这些线程就在运行了</span></span><br><span class="line">                threads.<span class="built_in">push_back</span>(</span><br><span class="line">                    std::<span class="built_in">thread</span>(&amp;thread_pool::worker_thread, <span class="keyword">this</span>));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            done = <span class="literal">true</span>;    </span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构时，done 标志为 true，所有的工作线程便退出了</span></span><br><span class="line">    ~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">        done = <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入一个任务到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">submit</span><span class="params">(FunctionType f)</span> </span>&#123;</span><br><span class="line">        work_queue.<span class="built_in">push</span>(std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;(f));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当该线程池对象被销毁时，<code>joiner</code>在析构中会等待所有的线程完成并回收它们的资源。</p>
<h2 id="等待任务处理的结果"><a href="#等待任务处理的结果" class="headerlink" title="等待任务处理的结果"></a>等待任务处理的结果</h2><p>简易方式的线程池适合处理无返回的简单任务，但如果需要获取到任务处理后的结果，则还需要调整。</p>
<p>最符合直觉的便是使用<code>std::packaged_task</code>将要执行函数以及<code>future</code>绑定，用户通过获取到的<code>future</code>来获取执行的结果。</p>
<p>但由于<code>std::packaged_task</code>是不能拷贝，只能移动的，所以需要构建一个支持移动语义的可执行类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function_wrapper</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">impl_base</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">impl_base</span>() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::unique_ptr&lt;impl_base&gt; impl;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">impl_type</span>:</span> impl_base &#123;</span><br><span class="line">        F f;</span><br><span class="line">        <span class="built_in">impl_type</span>(F&amp;&amp; f_): <span class="built_in">f</span>(std::<span class="built_in">move</span>(f_)) &#123;&#125;</span><br><span class="line">        <span class="comment">// 虽然 call 的形式固定了，但是 f 的形式却没有固定</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span></span><br><span class="line"><span class="function">    <span class="title">function_wrapper</span><span class="params">(F&amp;&amp; f)</span>:</span></span><br><span class="line"><span class="function">        impl(new impl_type&lt;F&gt;(std::move(f)))</span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; impl-&gt;<span class="built_in">call</span>(); &#125;</span><br><span class="line">    <span class="built_in">function_wrapper</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">function_wrapper</span>(function_wrapper&amp;&amp; other):</span><br><span class="line">        <span class="built_in">impl</span>(std::<span class="built_in">move</span>(other.impl))</span><br><span class="line">    &#123;&#125;    </span><br><span class="line">    function_wrapper&amp; <span class="keyword">operator</span> = (function_wrapper&amp;&amp; other) &#123;</span><br><span class="line">        impl = std::<span class="built_in">move</span>(other.impl);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 禁用拷贝构造和拷贝赋值</span></span><br><span class="line">    <span class="built_in">function_wrapper</span>(<span class="keyword">const</span> function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">function_wrapper</span>(function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    function_wrapper&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> function_wrapper&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后优化<code>submit</code>函数，可以获取到<code>future</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_pool</span> &#123;</span></span><br><span class="line">    std::<span class="keyword">atomic_bool</span> done;</span><br><span class="line">    thread_safe_queue&lt;function_wrapper&gt; work_queue; </span><br><span class="line">    <span class="comment">// 线程池，使用 vector 来存放     </span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;             </span><br><span class="line">    join_threads joiner;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">worker_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!done) &#123;</span><br><span class="line">            function_wrapper task;                    </span><br><span class="line">            <span class="keyword">if</span> (work_queue.<span class="built_in">try_pop</span>(task)) &#123;</span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">thread_pool</span>():</span><br><span class="line">        <span class="built_in">done</span>(<span class="literal">false</span>),<span class="built_in">joiner</span>(threads) &#123;</span><br><span class="line">        <span class="comment">// 创建与硬件核心数相同的工作线程池</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">const</span> thread_count = std::thread::<span class="built_in">hardware_concurrency</span>(); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i&lt; thread_count; ++i) &#123;</span><br><span class="line">            <span class="comment">// 创建后，这些线程就在运行了</span></span><br><span class="line">                threads.<span class="built_in">push_back</span>(</span><br><span class="line">                    std::<span class="built_in">thread</span>(&amp;thread_pool::worker_thread, <span class="keyword">this</span>));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">            done = <span class="literal">true</span>;    </span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构时，done 标志为 true，所有的工作线程便退出了</span></span><br><span class="line">    ~<span class="built_in">thread_pool</span>() &#123;</span><br><span class="line">        done = <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> FunctionType&gt;</span><br><span class="line">    std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type&gt;   </span><br><span class="line">        <span class="built_in">submit</span>(FunctionType f) &#123;</span><br><span class="line">        <span class="comment">// std::result_of 用于获取执行任务的返回类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::result_of&lt;<span class="built_in">FunctionType</span>()&gt;::type</span><br><span class="line">            result_type;</span><br><span class="line">        <span class="comment">//  使用 package_task 将任务与 future 联系起来                                 </span></span><br><span class="line">        <span class="function">std::packaged_task&lt;<span class="title">result_type</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(std::move(f))</span></span>;    </span><br><span class="line">        <span class="function">std::future&lt;result_type&gt; <span class="title">res</span><span class="params">(task.get_future())</span></span>;     </span><br><span class="line">        work_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 future 以让用户可以获取到结果    </span></span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了这种线程池，来处理并行计算就更加简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length = std::<span class="built_in">distance</span>(first,last);</span><br><span class="line">    <span class="keyword">if</span>(!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_blocks = (length + block_size - <span class="number">1</span>) / block_size;   </span><br><span class="line">    std::vector&lt;std::future&lt;T&gt; &gt; <span class="built_in">futures</span>(num_blocks - <span class="number">1</span>);</span><br><span class="line">    thread_pool pool;</span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;i &lt; (num_blocks - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        std::<span class="built_in">advance</span>(block_end, block_size);</span><br><span class="line">        <span class="comment">// 将一段要运算的输入放入到工作队列，并返回 future</span></span><br><span class="line">        futures[i] = pool.<span class="built_in">submit</span>([=]&#123;</span><br><span class="line">            accumulate_block&lt;Iterator,T&gt;()(block_start,block_end);</span><br><span class="line">        &#125;);   </span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    T last_result = accumulate_block&lt;Iterator,T&gt;()(block_start,last);</span><br><span class="line">    T result = init;</span><br><span class="line">    <span class="comment">// 依次与运算的结果累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>;i &lt; (num_blocks - <span class="number">1</span>); ++i) &#123;</span><br><span class="line">        result += futures[i].<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    result += last_result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种线程池适合用于主线程在等待工作线程的结果。</p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><p>下面是一个简易的控制线程暂停、继续、停止的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ControlThread</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ControlThread</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ControlThread</span>(<span class="keyword">const</span> ControlThread&amp; rhs) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ControlThread&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> ControlThread&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!running_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            running_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">            <span class="function">std::thread <span class="title">t</span><span class="params">(&amp;ControlThread::ExecThread, <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">            t.<span class="built_in">detach</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pause</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        pause_.<span class="built_in">store</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Continue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        pause_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Stop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        running_.<span class="built_in">store</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ExecThread</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (running_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pause_.<span class="built_in">load</span>()) &#123;</span><br><span class="line">                std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">50</span>));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> running_;</span><br><span class="line">    std::<span class="keyword">atomic_bool</span> pause_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要考虑的是：如果在执行线程中有阻塞的操作，该如何控制该线程？</p>
<p>一般的思路就是，创造条件来主动的唤醒该线程继续执行到控制点。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>concurrency</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Core Guidelines：接口</title>
    <url>/2022/07/26/cpp_coreguidelines_interface/</url>
    <content><![CDATA[<p>通过阅读 <a href="https://github.com/isocpp/CppCoreGuidelines">CppCoreGuidelines</a> 来理解现代 c++ 编码规范，同时也是对 <a href="https://book.douban.com/subject/1842426/">Effective C++</a>，<a href="https://book.douban.com/subject/25923597/">Effective Modern C++</a>，<a href="https://book.douban.com/subject/27036085/">C++ Concurrency in Action</a> 的温习。</p>
<span id="more"></span>

<h1 id="让接口清晰"><a href="#让接口清晰" class="headerlink" title="让接口清晰"></a>让接口清晰</h1><p>不能让接口还有一些隐藏属性，导致接口的行为是用户无法预知的。</p>
<p>比如下面的对浮点数取整：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (round_up) ? std::<span class="built_in">ceil</span>(d) : d;    <span class="comment">// don&#x27;t: &quot;invisible&quot; dependency</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有全局变量<code>round_up</code>来决定函数<code>round</code>来进行向上取整还是向下取整，这对用户来说是无法预知的。</p>
<p>为了使得接口清晰，需要让用户了解有这个设置项：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">round</span><span class="params">(<span class="keyword">bool</span> round_up, <span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (round_up) ? std::<span class="built_in">ceil</span>(d) : d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="尽量避免non-const全局变量"><a href="#尽量避免non-const全局变量" class="headerlink" title="尽量避免non-const全局变量"></a>尽量避免<code>non-const</code>全局变量</h1><p><code>non-const</code>全局变量就可能：</p>
<ol>
<li>导致该变量被多处使用，造成依赖关系</li>
<li><code>data race</code></li>
</ol>
<h1 id="形参的检查"><a href="#形参的检查" class="headerlink" title="形参的检查"></a>形参的检查</h1>]]></content>
      <categories>
        <category>cpp</category>
        <category>CoreGuidelines</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Core Guidelines：一些基本规则</title>
    <url>/2022/07/14/cpp_coreguidelines_philosophy/</url>
    <content><![CDATA[<p>通过阅读 <a href="https://github.com/isocpp/CppCoreGuidelines">CppCoreGuidelines</a> 来理解现代 c++ 编码规范，同时也是对 <a href="https://book.douban.com/subject/1842426/">Effective C++</a>，<a href="https://book.douban.com/subject/25923597/">Effective Modern C++</a>，<a href="https://book.douban.com/subject/27036085/">C++ Concurrency in Action</a> 的温习。</p>
<span id="more"></span>

<h1 id="准确清晰的表达代码意图"><a href="#准确清晰的表达代码意图" class="headerlink" title="准确清晰的表达代码意图"></a>准确清晰的表达代码意图</h1><p>表达的代码意图越完整清晰，越有利于利用编译器来帮我们排除问题。</p>
<h2 id="约束限定"><a href="#约束限定" class="headerlink" title="约束限定"></a>约束限定</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Month <span class="title">month</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// do</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">month</span><span class="params">()</span></span>;          <span class="comment">// don&#x27;t</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个函数声明优于第二个函数声明：第一个函数明确表示了返回类型是 Month，且不会改变对象的成员变量。这不仅利于编译器检查，更让代码的可读性更好。</p>
<blockquote>
<p>关于<code>const</code>的相关事项，在<a href="http://kcmetercec.top/2022/04/10/effective_cpp_use_const/">这里有了详细的说明</a>。</p>
</blockquote>
<h2 id="充分利用标准库"><a href="#充分利用标准库" class="headerlink" title="充分利用标准库"></a>充分利用标准库</h2><p>要善于利用标准库提供的工具，不仅使得代码简短清晰，效率也非常高。</p>
<p>比如，要实现一个函数，比较用户输入的字符串与字符串容器是否有匹配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;string&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    cin &gt;&gt; val;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] == val) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这种方式就是便利的比较，以返回符合条件的索引，那么标准库的<code>std::find</code>则更加的简洁明了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(vector&lt;string&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    cin &gt;&gt; val;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">find</span>(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), val);  <span class="comment">// better</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上一行代码，便清晰明确的表达了上面 7 行代码想要表达的意图。</p>
<p>再比如要将标准输入的值存入内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sz = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * sz);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// ... read an int into x, exit loop if end of file is reached ...</span></span><br><span class="line">    <span class="comment">// ... check that x is valid ...</span></span><br><span class="line">    <span class="keyword">if</span> (count == sz)</span><br><span class="line">        p = (<span class="keyword">int</span>*) <span class="built_in">realloc</span>(p, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * sz * <span class="number">2</span>);</span><br><span class="line">    p[count++] = x;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上杂乱的代码，使用<code>std::vector</code>是个更好的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x; cin &gt;&gt; x; ) &#123;</span><br><span class="line">    <span class="comment">// ... check that x is valid ...</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数的正确命名"><a href="#参数的正确命名" class="headerlink" title="参数的正确命名"></a>参数的正确命名</h2><p>为了更好的可读性，变量、函数参数的名称等都需要一个清晰的命名，必要时候需要为其自定义类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">change_speed</span>(<span class="keyword">double</span> s);   <span class="comment">// bad: what does s signify?</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">change_speed</span>(<span class="number">2.3</span>);</span><br></pre></td></tr></table></figure>

<p>上面这个代码，并没有明确标出 s 所对应的单位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">change_speed</span>(Speed s);    <span class="comment">// better: the meaning of s is specified</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">change_speed</span>(<span class="number">2.3</span>);        <span class="comment">// error: no unit</span></span><br><span class="line"><span class="built_in">change_speed</span>(<span class="number">23</span>_m / <span class="number">10</span>s);  <span class="comment">// meters per second</span></span><br></pre></td></tr></table></figure>

<p>这里定义了新的类型，便可以带有单位。</p>
<h1 id="编译时检查优于运行时检查"><a href="#编译时检查优于运行时检查" class="headerlink" title="编译时检查优于运行时检查"></a>编译时检查优于运行时检查</h1><p>在编译时检查既能很好的表达意图，还能提高代码的运行性能。</p>
<p>比如，下面的代码想要检查<code>int</code>类型是否大于 32 位：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bits = <span class="number">0</span>;         </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i; i &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    ++bits;</span><br><span class="line"><span class="keyword">if</span> (bits &lt; <span class="number">32</span>)</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;int too small\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码可读性不好，且会占用运行时时间，而在编译时检查则一行代码就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) &gt;= <span class="number">4</span>);    <span class="comment">// do: compile-time check</span></span><br></pre></td></tr></table></figure>

<p>在比如需要给函数传入数组地址，那么一般也会需要传入数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span>;   <span class="comment">// read max n integers into *p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">read</span>(a, <span class="number">1000</span>);    <span class="comment">// bad, off the end</span></span><br></pre></td></tr></table></figure>

<p>但是当数组大小值传入大于数组时，就会引发数组越界。这种情况下一个方法是使用<code>std::array&lt;T&gt;</code>替代传统数组，另一个方法是使用<code>std::span&lt;T&gt;</code>由编译器来获取数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadArray</span><span class="params">(std::span&lt;<span class="keyword">int</span>&gt; array)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of array is &quot;</span> &lt;&lt; array.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ReadArray</span>(array);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译时无法检查的运行时应尽量检查"><a href="#编译时无法检查的运行时应尽量检查" class="headerlink" title="编译时无法检查的运行时应尽量检查"></a>编译时无法检查的运行时应尽量检查</h1><p>很多错误无法在编译期完成检查，那么在运行期，需要尽可能的检查其余错误，避免程序漏洞。</p>
<p>比如下面的代码就忽略了运行期检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// separately compiled, possibly dynamically loaded</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>* p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad: the number of elements is not passed to f()</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="keyword">new</span> <span class="keyword">int</span>[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面直接在形参处申请了动态内存传给外部库函数<code>f</code>，那么当前代码都无法获取到动态内存的地址，就无法做任何错误检查（包括申请的地址，以及申请的大小）。</p>
<p>下面假设库函数加上了数组大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// separately compiled, possibly dynamically loaded</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f2</span>(<span class="keyword">new</span> <span class="keyword">int</span>[n], m);  <span class="comment">// bad: a wrong number of elements can be passed to f()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接以<code>new</code>的形式传入参数也是不可取的，因为并不知道<code>f2</code>内部是否会<code>delete</code>这段内存，且传入数组的大小也会出错。</p>
<p>下面再改进使参数成为智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// separately compiled, possibly dynamically loaded</span></span><br><span class="line"><span class="comment">// NB: this assumes the calling code is ABI-compatible, using a</span></span><br><span class="line"><span class="comment">// compatible C++ compiler and the same stdlib implementation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">(std::unique_ptr&lt;<span class="keyword">int</span>[]&gt;, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f3</span>(std::make_unique&lt;<span class="keyword">int</span>[]&gt;(n), m);    <span class="comment">// bad: pass ownership and size separately</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式就不用担心指针释放的问题，但是智能指针不能传入申请内存的大小，所以还是可能出错。</p>
<p>所以最好的方式就是传入对象，该对象包含了内存的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;)</span></span>;   <span class="comment">// separately compiled, possibly dynamically loaded</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">(span&lt;<span class="keyword">int</span>&gt;)</span></span>;      <span class="comment">// separately compiled, possibly dynamically loaded</span></span><br><span class="line">                                <span class="comment">// NB: this assumes the calling code is ABI-compatible, using a</span></span><br><span class="line">                                <span class="comment">// compatible C++ compiler and the same stdlib implementation</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="built_in">f4</span>(v);                     <span class="comment">// pass a reference, retain ownership</span></span><br><span class="line">    <span class="built_in">f4</span>(span&lt;<span class="keyword">int</span>&gt;&#123;v&#125;);          <span class="comment">// pass a view, retain ownership</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="尽早的捕获运行时错误"><a href="#尽早的捕获运行时错误" class="headerlink" title="尽早的捕获运行时错误"></a>尽早的捕获运行时错误</h1><p>比如下面的代码，当 m &gt; n 时，就会发生数组越界：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment1</span><span class="params">(<span class="keyword">int</span>* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ++p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use1</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[n] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">increment1</span>(a, m);   <span class="comment">// maybe typo, maybe m &lt;= n is supposed</span></span><br><span class="line">                        <span class="comment">// but assume that m == 20</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而通过使用<code>std::span</code>则可以捕获该问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;span&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment2</span><span class="params">(std::span&lt;<span class="keyword">int</span>&gt; p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array size: &quot;</span> &lt;&lt; p.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; x : p) ++x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a[n] = &#123;&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">increment2</span>(a);    <span class="comment">// maybe typo, maybe m &lt;= n is supposed</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">use2</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="尽量避免资源泄露"><a href="#尽量避免资源泄露" class="headerlink" title="尽量避免资源泄露"></a>尽量避免资源泄露</h1><p>这里的资源除了内存，还有文件句柄、socket、控制权等等。</p>
<p>就算是很小的几个字节泄露，对于需要长时间运行的程序而言都会最终造成灾难。</p>
<p>比如下面这个文件句柄泄露的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    FILE* input = <span class="built_in">fopen</span>(name, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (something) <span class="keyword">return</span>;   <span class="comment">// bad: if something == true, a file handle is leaked</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">fclose</span>(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>if</code>为真时，该文件句柄便泄露了，长时间运行该函数，会到达操作系统限制量而杀死该进程。</p>
<p>显然，这种情况使用 RAII 是最合适不过了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    std::ifstream input &#123;name&#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (something) <span class="keyword">return</span>;   <span class="comment">// OK: no leak</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当该函数退出后，<code>std::ifstream</code>的析构被调用，从而会释放该资源。</p>
<h1 id="不要浪费时间和空间"><a href="#不要浪费时间和空间" class="headerlink" title="不要浪费时间和空间"></a>不要浪费时间和空间</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">char</span> ch2;</span><br><span class="line"></span><br><span class="line">    X&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> X&amp; a) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">X</span>(<span class="keyword">const</span> X&amp;) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">X</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">waste</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;nullptr&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = std::<span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">auto</span> buf = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    <span class="keyword">if</span> (!buf) <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) buf[i] = p[i];</span><br><span class="line">    <span class="comment">// ... manipulate buffer ...</span></span><br><span class="line">    X x;</span><br><span class="line">    x.ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    x.s = std::<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>, n);    <span class="comment">// give x.s space for *p</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.s.<span class="built_in">size</span>(); ++i) x.s[i] = buf[i];  <span class="comment">// copy buf into x.s</span></span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x = <span class="built_in">waste</span>(<span class="string">&quot;Typical argument&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of x : &quot;</span> &lt;&lt; x.s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">driver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这段代码，在时间和空间上都有所浪费：</p>
<ol>
<li>类<code>X</code>中的成员<code>i</code>和<code>ch2</code>都没有被使用，这造成了内存空间的浪费</li>
<li>由于类<code>X</code>显示定义了拷贝构造和拷贝赋值函数，导致编译期没有默认生成移动构造函数，所以无法使用返回值优化（RVO），造成了运行时间的浪费（默认函数参考<a href="http://kcmetercec.top/2022/04/13/effective_cpp_default_func/">此文章</a>）</li>
<li>将形参<code>p</code>拷贝到<code>string</code>，并不需要再申请一段临时的空间来存储数据后再来拷贝，这造成了运行时间的浪费</li>
</ol>
<p>修改后的高效代码应该如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    std::string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">waste</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;nullptr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    X x;</span><br><span class="line">    x.ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    x.s = std::<span class="built_in">string</span>(p, std::<span class="built_in">strlen</span>(p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">driver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    X x = <span class="built_in">waste</span>(<span class="string">&quot;Typical argument&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;contents of x : &quot;</span> &lt;&lt; x.s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">driver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再比如下面的循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower</span><span class="params">(zstring s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i) s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每执行一次，都要执行<code>std::strlen</code>，这浪费了很多时间。正确的做法是进入循环前首先获取一次长度存入变量，然后直接使用该变量即可。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>CoreGuidelines</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：属性</title>
    <url>/2025/02/15/effective_cpp_attribute/</url>
    <content><![CDATA[<p>从 c++11 开始，就具备了一些属性，其语法是 <code>[[attribute]]</code> 。</p>
<span id="more"></span>

<h1 id="fallthrough"><a href="#fallthrough" class="headerlink" title="[[fallthrough]]"></a>[[fallthrough]]</h1><p>如果在 <code>switch</code> 语句中的 <code>case</code> 后没有跟 <code>break</code>，则编译器会给出警告。</p>
<p>使用 <code>[[fallthrough]]</code> 可以阻止编译器发出这种警告：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 0\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 1\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;i == 2\n&quot;</span>;</span><br><span class="line">            [[fallthrough]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="nodiscard"><a href="#nodiscard" class="headerlink" title="[[nodiscard]]"></a>[[nodiscard]]</h1><p>如果一个函数有返回值，而调用者没有使用该返回值，使用 <code>[[nodiscard]]</code>可以让编译器发出警告。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[nodiscard]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码编译将会给出警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">test.cc: In function ‘int main(int, char**)’:</span><br><span class="line">test.cc:15:9: warning: ignoring return value of ‘int func()’, declared with attribute nodiscard [-Wunused-result]</span><br><span class="line">   15 |     func();</span><br><span class="line">      |     ~~~~^~</span><br><span class="line">test.cc:8:19: note: declared here</span><br><span class="line">    8 | [[nodiscard]] int func(void) &#123;</span><br><span class="line">      |  </span><br></pre></td></tr></table></figure>

<p>此属性可以用于有返回错误状态的函数，以告知用户不要忽略函数的返回。</p>
<p>c++ 20 及以后，可以在 <code>[[nodiscard]]</code>中加入提示的字符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">nodiscard</span>(<span class="string">&quot;Hello&quot;</span>)]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译将会输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">main.cpp: In function &#x27;int main(int, char**)&#x27;:</span><br><span class="line">main.cpp:15:10: warning: ignoring return value of &#x27;int func()&#x27;, declared with attribute &#x27;nodiscard&#x27;: &#x27;Hello&#x27; [-Wunused-result]</span><br><span class="line">   15 |      func();</span><br><span class="line">      |      ~~~~^~</span><br><span class="line">main.cpp:8:29: note: declared here</span><br><span class="line">    8 |  [[nodiscard(&quot;Hello&quot;)]] int func(void) &#123;</span><br></pre></td></tr></table></figure>

<p>这个属性主要是对一些重要的函数、类使用，便于提示调用者不要忽视返回值。</p>
<blockquote>
<p>如果对类使用，则调用类中的任何方法都会应用该属性。</p>
</blockquote>
<h1 id="maybe-unused"><a href="#maybe-unused" class="headerlink" title="[[maybe_unused]]"></a>[[maybe_unused]]</h1><p>当某些变量、参数、函数未被使用时，编译器会给出警告。此属性可以抑制该警告：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var2 加了此属性后便不会给出警告，var1 则会给出警告</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var1, [[maybe_unused]]<span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="noreturn"><a href="#noreturn" class="headerlink" title="[[noreturn]]"></a>[[noreturn]]</h1><p>此属性抑制无返回函数的警告，比如下面的代码进入 func2() 会无返回退出进程。加上该属性，编译器便不会给出警告。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[noreturn]] <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (var1 &gt; <span class="number">10</span>) &#123;</span><br><span class="line">       <span class="built_in">func2</span>();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> result = <span class="built_in">func</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="deprecated"><a href="#deprecated" class="headerlink" title="[[deprecated]]"></a>[[deprecated]]</h1><p>使用此属性用于提醒用户，该 API 已被弃用，可以通过提示信息告知用户使用对应的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;Unsafe method, please use func2&quot;</span>)]] <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="likely-和-unlikely"><a href="#likely-和-unlikely" class="headerlink" title="[[likely]] 和 [[unlikely]]"></a>[[likely]] 和 [[unlikely]]</h1><p>这两个属性用于更好的帮助编译器做优化，一般是用在具有判断的代码处：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    [[likely]] <span class="keyword">if</span> (v &gt; <span class="number">8</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v &gt; 8\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;v &lt;= 8\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="assume"><a href="#assume" class="headerlink" title="[[assume]]"></a>[[assume]]</h1><p><code>[[assume]]</code>是 c++ 23 增加的属性，告知编译器假定当前表达式条件在编译时判断，而不是在运行时再来判断，以优化代码性能。</p>
<p>比如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideBy32</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下编译器会产生可以处理正负两种情况的除法，如果确认<code>x</code>的值不会为负数，那么就可以加上<code>[[assume]]</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divideBy32</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [[<span class="built_in">assume</span>(x&gt;=<span class="number">0</span>)]];</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子编译器就可以针对非负数除法做优化，比如上面的代码可以优化为<code>x&gt;&gt;5</code>，以单条指令就可以完成达到优化性能的目的。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>professional</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：理解 auto</title>
    <url>/2022/05/02/effective_cpp_auto/</url>
    <content><![CDATA[<p>理解了 <code>auto</code>的推导原则后，就需要认识到使用 <code>auto</code>所带来的便利性和缺陷，才能正确的使用它。</p>
<span id="more"></span>

<h1 id="认识到使用-auto-的好处’"><a href="#认识到使用-auto-的好处’" class="headerlink" title="认识到使用 auto 的好处’"></a>认识到使用 auto 的好处’</h1><h2 id="auto-与初始化"><a href="#auto-与初始化" class="headerlink" title="auto 与初始化"></a>auto 与初始化</h2><p>当我们定义一个局部变量时，如果该局部变量没有被初始化，那么它的值就是无法预知的。有的时候会由于未初始化的局部变量而导致程序 BUG。</p>
<p>由于 <code>auto</code>的推导是依赖于其右值的，也就是说如果没有右值，使用<code>auto</code>就会出错。基于此特性，我们可以使用 auto 来定义一个变量，以让编译器来帮助我们查看一个局部变量是否已经被初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">auto</span> y;</span><br><span class="line">	<span class="keyword">auto</span> z = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>y</code>没有右值，这将导致编译失败：</p>
<blockquote>
<p>[Error] declaration of ‘auto y’ has no initializer</p>
</blockquote>
<h2 id="auto-与函数指针"><a href="#auto-与函数指针" class="headerlink" title="auto 与函数指针"></a>auto 与函数指针</h2><p>在不使用 <code>auto</code>的情况下，使用<code>std::function</code>方式来调用 lambda：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br><span class="line">	func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，使用<code>std::function</code>的方式，需要在模板参数里面填入指向函数的参数类型，当函数的参数类型改变后，模板里的参数也得改一次，很是麻烦。</p>
<p>使用<code>auto</code>来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">auto</span> func = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">		<span class="keyword">return</span> a &lt; b;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就优雅太多了。</p>
<p><strong>除此之外，<code>auto</code>实际上执行效率高于<code>std::function</code>，且不会占用额外内存。</strong></p>
<p>由于<code>auto</code>是在编译器推导的，并不会占用额外的内存，在执行时也是直接调用该函数体。</p>
<p>但<code>std::function</code>本身就是一个对象，对象本身就会占用更多的内存，在执行时代码也会先执行<code>std::function</code>中的代码然后最终才会跳转到函数体执行。</p>
<h2 id="auto-与可移植性"><a href="#auto-与可移植性" class="headerlink" title="auto 与可移植性"></a>auto 与可移植性</h2><p>假设有变量 <code>v</code>其类似是<code>std::vector&lt;int&gt;</code>，那么获取其大小的类型就是<code>std::vector&lt;int&gt;::size_type</code>。</p>
<p>在 32 位系统中该值就是 32 位的<code>unsigned int</code>，在 64 位机中就是 64 位的<code>unsigned int</code>，为了保证移植性，正确的做法是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;::size_type sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>但是上面这个写法，依然要确定模板元素的类型。假设以后需求的变动，使得<code>v</code>的元素类型为<code>float</code>。那么所有以上代码都需要将模板类型替换为<code>float</code>，烦人的体力劳动……</p>
<p>在使用<code>auto</code>后就是这样了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sz = v.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>可以看到这样写的优点：</p>
<ol>
<li>不用关心模板元素的类型，代码更简洁</li>
<li>后期需求变动，就算改变了<code>v</code>的元素类型，以上代码都不需要做任何变动</li>
</ol>
<h2 id="auto-与歧义性"><a href="#auto-与歧义性" class="headerlink" title="auto 与歧义性"></a>auto 与歧义性</h2><p>使用<code>auto</code>能在一些时候避免一些歧义性的坑。</p>
<p>比如使用范围<code>for</code>从容器中获取一个<code>const</code>引用可能会引起歧义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unorderd_map&lt;std::string, <span class="keyword">int</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">int</span>&gt;&amp; p : m)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用范围<code>for</code>的原意是从容器<code>m</code>中取出一个元素，并以<code>const</code>引用的方式访问里面的元素。</p>
<p>但是需要注意的是：**<code>std::unorderd_map</code>的<code>value_type</code>类型定义原型是<code>std::pair&lt;const Key, T&gt;</code>**。</p>
<p>也就是说，对于<code>m</code>来讲，它的元素类型是<code>std::pair&lt;const std::string, int&gt;</code>，那么<code>p</code>就和<code>m</code>的元素类型不匹配，这就很坑了。</p>
<p>这种情况下，编译器往往会拷贝<code>m</code>中元素的副本，由<code>p</code>来进行绑定，最终搞了半天，<code>p</code>操作的不过就是个副本而已！</p>
<p>使用<code>auto</code>就可以避免这种坑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p: m) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="auto-初始化可能会遇到的坑’"><a href="#auto-初始化可能会遇到的坑’" class="headerlink" title="auto 初始化可能会遇到的坑’"></a>auto 初始化可能会遇到的坑’</h1><h2 id="类型的隐式转换"><a href="#类型的隐式转换" class="headerlink" title="类型的隐式转换"></a>类型的隐式转换</h2><p>假设要从一个<code>std::vector&lt;bool&gt;</code>类型容器中获取一个结果，可以像如下的编写方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">GetResult</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">bool</span>&gt; ret = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="built_in">GetResult</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret value is &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果是：</p>
<blockquote>
<p>ret value is 1</p>
</blockquote>
<p>这个代码验证无误，但是为了在获取返回值时更为智能一点，我们将返回类型用<code>auto</code>进行推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">GetResult</span>()[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>在 MSVC 环境下运行便会报错：</p>
<blockquote>
<p>Expression:cannot dereference value-initialized vector<bool> iterator.</p>
</blockquote>
<p>接下来我们主动让编译器在编译时报错来查看该<code>auto</code>推导的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeDisplay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">GetResult</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">bool</span>&gt; ret = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">GetResult</span>()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    TypeDisplay&lt;<span class="keyword">decltype</span>(ret)&gt; type;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret value is &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时报错如下：</p>
<blockquote>
<p>hello.cc:16:32: error: aggregate ‘TypeDisplay<a href="std::_Bit_reference">std::_Bit_reference</a> type’ has incomplete type and cannot be defined</p>
</blockquote>
<p>按照正常理解，<code>auto</code>应该推导出<code>bool</code>类型才是，结果却是<code>std::vector&lt;bool&gt;::reference</code>。</p>
<p>大部分情况下，<code>std::vector::operator[]</code>会返回该容器元素的引用，但是由于上面定义的容器元素类型为<code>bool</code>。</p>
<p>这在底层的表示为，一个<code>bool</code>占用一个<code>bit</code>，而<strong>c++ 是禁止返回一个位的引用的</strong>。</p>
<p>所以实际上<code>bool ret = GetResult()[2]</code>的操作顺序是：</p>
<ol>
<li>返回<code>std::vector&lt;bool&gt;::reference</code>类型</li>
<li>取第 3 位的值，隐式转换为<code>bool</code>类型</li>
</ol>
<p>而<code>auto ret = GetResult()[2]</code>得到的类型确是<code>std::vector&lt;bool&gt;::reference</code>，实际上这个步骤比想象的复杂：</p>
<ol>
<li><code>GetResult()</code>函数返回的是<code>std::vector&lt;bool&gt;</code>的副本，也就是一个临时对象<code>tmp</code></li>
<li>接下来<code>operator[]</code>由于不能返回位的引用，所以得到的是<code>std::vector&lt;bool&gt;::reference</code>对象</li>
<li>这个对象实际上是指向<code>bool</code>的指针，接下来再索引到下标为 2 的地址处，也就指向了第 3 位</li>
<li><code>ret</code>得到的就是第 3 位的地址（在上面正确的结果中，如果进行了隐式转换，是将第 3 位的值拷贝了一次，而此处并未拷贝）</li>
<li><code>tmp</code>临时对象内存被释放，最终<code>std::cout</code>语句所获取的就是个野指针！</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决办法就是明确的限定需要进行一次类型转换，使用<code>static_cast</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">GetResult</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">bool</span>&gt; ret = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(<span class="built_in">GetResult</span>()[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ret value is &quot;</span> &lt;&lt; ret &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实在很多有隐式类型转换的位置，显示的使用 cast 是一个很好的习惯。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：构造，析构和继承</title>
    <url>/2022/04/15/effective_cpp_condestruct_virtual/</url>
    <content><![CDATA[<ol>
<li>构造和析构函数中调用虚函数，由于其派生类还未被构造和已被析构，所以得到的结果不会是预期的。</li>
<li>重载父类虚函数，需要加上<code>override</code>关键字</li>
</ol>
<span id="more"></span>

<h1 id="构造和析构中使用虚函数"><a href="#构造和析构中使用虚函数" class="headerlink" title="构造和析构中使用虚函数"></a>构造和析构中使用虚函数</h1><p>直接看下面代码，一目了然：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BasicClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass constructor!\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 此时子类还没有被初始化，所以这里调用的还是自己的 func()</span></span><br><span class="line">            <span class="built_in">func</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">BasicClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass destructor!\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 此时子类已经被释放了，所以这里调用的还是自己的 func2()</span></span><br><span class="line">            <span class="built_in">func2</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass func!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass func2!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BasicClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DerivedClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DerivedClass constructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">DerivedClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DerivedClass destructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DerivedClass func!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DerivedClass func2!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        DerivedClass drived_class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BasicClass constructor!</span><br><span class="line">BasicClass func!</span><br><span class="line">DerivedClass constructor!</span><br><span class="line">DerivedClass destructor!</span><br><span class="line">BasicClass destructor!</span><br><span class="line">BasicClass func2!</span><br></pre></td></tr></table></figure>

<h1 id="使用-override"><a href="#使用-override" class="headerlink" title="使用 override"></a>使用 <code>override</code></h1><h2 id="满足多态的条件"><a href="#满足多态的条件" class="headerlink" title="满足多态的条件"></a>满足多态的条件</h2><p>在 cpp 中，要使多态生效，那么必须满足下面这些条件：</p>
<ol>
<li>基类中的方法必须是虚方法（<code>virtual</code>）</li>
<li>派生类的方法必须与基类虚方法名称及参数保持一致</li>
<li>派生类的方法的<code>const</code>限定也必须与基类虚方法保持一致</li>
<li>派生类的方法的返回类型必须与基类虚方法的返回保持<strong>兼容</strong></li>
</ol>
<p>到了 c++11 还增加了以下一个条件：</p>
<ol>
<li>基类中的方法的引用限定必须与基类虚方法保持一致<blockquote>
<p>引用限定就是限定方法只能在对象是左值还是右值时被使用</p>
</blockquote>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;</span>;       <span class="comment">// this version of doWork applies</span></span><br><span class="line">                         <span class="comment">// only when *this is an lvalue</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> &amp;&amp;</span>;      <span class="comment">// this version of doWork applies</span></span><br><span class="line">&#125;;                       <span class="comment">// only when *this is an rvalue</span></span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;     <span class="comment">// factory function (returns rvalue)</span></span><br><span class="line">Widget w;                <span class="comment">// normal object (an lvalue)</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">doWork</span>();              <span class="comment">// calls Widget::doWork for lvalues</span></span><br><span class="line">                         <span class="comment">// (i.e., Widget::doWork &amp;)</span></span><br><span class="line"><span class="built_in">makeWidget</span>().<span class="built_in">doWork</span>();   <span class="comment">// calls Widget::doWork for rvalues</span></span><br><span class="line">                         <span class="comment">// (i.e., Widget::doWork &amp;&amp;)</span></span><br></pre></td></tr></table></figure>

<p>以上 5 个条件必须都要满足，所以在重载父类虚函数时，一定要多加审查。</p>
<h2 id="为什么需要加-override"><a href="#为什么需要加-override" class="headerlink" title="为什么需要加 override?"></a>为什么需要加 <code>override</code>?</h2><p>根据上面的满足条件来看，我们平时是很容易写错的，并且编译器并不会报错。</p>
<p>但如果在方法声明后增加了<code>override</code>关键字，编译器可以代我们完成检查。</p>
<p>假设以后基类的虚函数这些元素发生了变化，编译器也可以帮我们检查。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：尽可能的使用 constexpr</title>
    <url>/2022/05/04/effective_cpp_constexpr/</url>
    <content><![CDATA[<p>使用<code>constexpr</code>以让编译器来检查该值是否是常量表达式，降低程序员负担。</p>
<span id="more"></span>

<h1 id="const-与-constexpr"><a href="#const-与-constexpr" class="headerlink" title="const 与 constexpr"></a><code>const</code> 与 <code>constexpr</code></h1><p><code>constexpr</code>修饰的表达式，需要在<strong>编译时</strong>就确定其值，且该值以后不可被改变。而<code>const</code>修饰的表达式，是在运行时才能够确定其值：</p>
<blockquote>
<p>所有的<code>constexpr</code>都是<code>const</code>的，但所有的<code>const</code>都不一定是<code>constexpr</code>的</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sz; <span class="comment">//非常量表达式</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> array_size = sz; <span class="comment">//由于 sz 不是常量表达式，所以 array_size 无法编译通过</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, sz&gt; array1; <span class="comment">//由于 sz 不是常量表达式，所以无法创建该数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> sz2 = <span class="number">20</span>;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, sz2&gt; array2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sz; <span class="comment">//非常量表达式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> array_size = sz; <span class="comment">//array_size 的值由运行时确定</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, array_size&gt; array1; <span class="comment">//由于 array_size 不是常量表达式，所以无法创建该数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h1><p><code>constexpr</code>函数具有的特性：</p>
<ul>
<li>当传入该函数的实参是<code>constexpr</code>时，该函数的结果就是可以在编译期确定的。</li>
<li>如果传入的实参不是<code>constexpr</code>的，该函数就是普通的在运行时确定的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> exp)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">//c++ 11 仅允许一条 return 语句</span></span><br><span class="line">    <span class="keyword">return</span> (exp == <span class="number">0</span> ? <span class="number">1</span> : base * <span class="built_in">pow</span>(base, exp - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c++ 14 允许多条语句</span></span><br><span class="line"><span class="comment">//    int result = 1;</span></span><br><span class="line"><span class="comment">//    for (int i = 0; i &lt; exp; ++i) &#123;</span></span><br><span class="line"><span class="comment">//        result *= base;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    return result;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> exp = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//当传入的值是 constexpr 时，可以用在编译时确定值</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, pow(3, exp)&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当传入的值不是 constexpr 时，就用在运行时</span></span><br><span class="line">    <span class="keyword">int</span> exp2 = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result &quot;</span> &lt;&lt; <span class="built_in">pow</span>(<span class="number">2</span>, exp2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="constexpr类"><a href="#constexpr类" class="headerlink" title="constexpr类"></a><code>constexpr</code>类</h1><p>如下的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">Point</span><span class="params">(<span class="keyword">double</span> xVal = <span class="number">0</span>, <span class="keyword">double</span> yVal = <span class="number">0</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  : x(xVal), y(yVal)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">xValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="keyword">double</span> <span class="title">yValue</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">double</span> newX)</span> <span class="keyword">noexcept</span> </span>&#123; x = newX; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">double</span> newY)</span> <span class="keyword">noexcept</span> </span>&#123; y = newY; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当构造函数被传入的实参是<code>constexpr</code>的是，这个类所实例化的对象也是<code>constexpr</code>的，进而该类就可以被<code>constexpr</code>函数所调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span>    </span></span><br><span class="line"><span class="function">Point <span class="title">midpoint</span><span class="params">(<span class="keyword">const</span> Point&amp; p1, <span class="keyword">const</span> Point&amp; p2)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; (p1.<span class="built_in">xValue</span>() + p2.<span class="built_in">xValue</span>()) / <span class="number">2</span>,    <span class="comment">// call constexpr</span></span><br><span class="line">           (p1.<span class="built_in">yValue</span>() + p2.<span class="built_in">yValue</span>()) / <span class="number">2</span> &#125;;  <span class="comment">// member funcs</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p1</span><span class="params">(<span class="number">9.4</span>, <span class="number">27.7</span>)</span></span>;      <span class="comment">// fine, &quot;runs&quot; constexpr</span></span><br><span class="line">                                    <span class="comment">// ctor during compilation</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Point <span class="title">p2</span><span class="params">(<span class="number">28.8</span>, <span class="number">5.3</span>)</span></span>;      <span class="comment">// also fine</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> mid = <span class="built_in">midpoint</span>(p1, p2);     <span class="comment">// init constexpr</span></span><br><span class="line">                                           <span class="comment">// object w/result of</span></span><br><span class="line">                                           <span class="comment">// constexpr function</span></span><br></pre></td></tr></table></figure>

<p>最终以上对象的创建都是在<strong>编译期</strong>就完成了，虽然编译的时间会加长，但是代码的运行效率确更高。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：认识编译器的默认生成函数</title>
    <url>/2022/04/13/effective_cpp_default_func/</url>
    <content><![CDATA[<p>编译器默认会为一个类提供（如果它们需要被使用的话）：</p>
<ul>
<li>默认构造函数：如果类编写了构造函数，则编译器就不会自动提供默认构造函数了<ul>
<li>使用 <code>default</code> 显示声明也可以在有其他构造函数的情况下，让编译器产生默认构造函数</li>
</ul>
</li>
<li>拷贝构造函数：<strong>没有移动函数显示定义时，拷贝函数才会被隐式的创建</strong>。其单纯地将每一个数据成员进行拷贝<ul>
<li>如果数据成员中的对象具有它自己的拷贝构造函数，则也会调用它</li>
</ul>
</li>
<li>拷贝赋值函数：单纯地将每一个数据成员进行拷贝<ul>
<li>如果数据成员中的对象具有它自己的拷贝赋值函数，则也会调用它</li>
</ul>
</li>
<li>析构函数：隐式的<code>noexcept</code></li>
<li>移动构造函数：当没有显示定义移动、拷贝、析构函数时，默认移动函数才会被隐式的创建</li>
<li>移动赋值函数</li>
</ul>
<p>生成的特殊函数是隐含的<code>public</code>和<code>inline</code>的，但大部分情况下都是非虚函数。</p>
<blockquote>
<p>只有当一个类继承自基类，基类的析构函数是虚函数时，生成派生类的析构函数才也是虚函数</p>
</blockquote>
<span id="more"></span>

<h1 id="拷贝与赋值"><a href="#拷贝与赋值" class="headerlink" title="拷贝与赋值"></a>拷贝与赋值</h1><p>但有些时候，并不是都可以使用默认拷贝构造和拷贝赋值函数。</p>
<p>比如类中有指针的情况下，不能简单的进行成员变量拷贝就行了，还要拷贝指针所指向的内存。</p>
<blockquote>
<p>这个时候就需要用户自己定义拷贝构造和拷贝赋值</p>
</blockquote>
<p>还有一种情况，是编译器无法生成拷贝构造和拷贝赋值，在比如下面这种情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Hello</span>(std::string&amp; name): <span class="built_in">name_</span>(name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string&amp; name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">name1</span><span class="params">(<span class="string">&quot;hello1&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">name2</span><span class="params">(<span class="string">&quot;hello2&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Hello <span class="title">hello1</span><span class="params">(name1)</span></span>;</span><br><span class="line">    <span class="function">Hello <span class="title">hello2</span><span class="params">(name2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里想使用拷贝赋值函数，但是如果是单纯的位拷贝，</span></span><br><span class="line">    <span class="comment">// 相当于要将对象 hello1 中的引用改变，这就和引用的概念相冲突了</span></span><br><span class="line">    <span class="comment">// 编译器就不会为这个类生成默认的拷贝赋值函数</span></span><br><span class="line">    hello1 = hello2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时错误如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hello.cc:23:12: error: object of type &#x27;Hello&#x27; cannot be assigned because its copy assignment operator is implicitly deleted hello1 = hello2;</span><br><span class="line">                 ^</span><br><span class="line">hello.cc:10:22: note: copy assignment operator of &#x27;Hello&#x27; is implicitly deleted because field &#x27;name_&#x27; is of reference type &#x27;std::string &amp;&#x27; (aka &#x27;basic_string&lt;char&gt; &amp;&#x27;) std::string&amp; name_;</span><br></pre></td></tr></table></figure>

<h1 id="移动构造与移动赋值的特殊性"><a href="#移动构造与移动赋值的特殊性" class="headerlink" title="移动构造与移动赋值的特殊性"></a>移动构造与移动赋值的特殊性</h1><h2 id="逐字节的移动"><a href="#逐字节的移动" class="headerlink" title="逐字节的移动"></a>逐字节的移动</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);              <span class="comment">// move constructor</span></span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);   <span class="comment">// move assignment operator</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只有当使用移动构造和移动赋值，并且被操作的对象允许移动时，编译器才会生成其默认移动构造与移动赋值。</p>
<blockquote>
<p>移动的时候就是很忠实的将一个对象的非静态成员变量逐字节的移动过去。</p>
<p>拷贝构造和拷贝赋值则是很忠实的将对象的非静态成员变量逐字节拷贝过去。</p>
</blockquote>
<h2 id="两个并不独立"><a href="#两个并不独立" class="headerlink" title="两个并不独立"></a>两个并不独立</h2><p>需要注意的是：这两个移动函数并不是独立的，一旦用户定义了其中任意一个函数，另一个函数如果不显示定义，编译器也不会在需要的时候主动生成。</p>
<blockquote>
<p>拷贝构造与拷贝赋值确实独立的，就算用户只定义了其中一个，一旦需要使用另一个函数时，编译器也会默认创建。</p>
</blockquote>
<h2 id="拷贝与移动"><a href="#拷贝与移动" class="headerlink" title="拷贝与移动"></a>拷贝与移动</h2><p>一旦一个类显示的定义了拷贝构造或拷贝赋值函数，移动构造和移动赋值函数便不会被隐式的创建了。</p>
<p>其逻辑在于：既然显示的创建了拷贝操作，那就说明逐个字节的拷贝是不能满足要求的，那么进而说明逐个字节的移动也是不能满足要求的。</p>
<p>同理，当一个类显示的定义了移动操作，那么编译器也不会隐式的创建拷贝操作了。理由同上。</p>
<h1 id="The-Big-Three"><a href="#The-Big-Three" class="headerlink" title="The Big Three"></a>The Big Three</h1><p>基于以上的基础认识，就有一个基本的类定义法则：</p>
<blockquote>
<p>一旦定义了拷贝构造函数、拷贝赋值函数、析构函数中的任何一个，那么这 3 个函数都应该被显示的定义。</p>
</blockquote>
<p>这是因为只要显示定义了这 3 个函数中的其中一个，必然会涉及到一些内存管理，这是编译器的默认操作所不能完成的。</p>
<p>所以移动操作只有当以下 3 个条件同时满足时，编译器才会隐式的构建：</p>
<ol>
<li>没有显示定义拷贝操作</li>
<li>没有显示定义移动操作</li>
<li>没有显示定义析构函数</li>
</ol>
<h1 id="default-修饰"><a href="#default-修饰" class="headerlink" title="default 修饰"></a>default 修饰</h1><p>当需要依赖编译器隐式构建的特殊函数时，使用<code>default</code>进行修饰不仅可以更能展现自己的意图，更能避免一些坑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;                <span class="comment">// make dtor virtual</span></span><br><span class="line">  <span class="built_in">Base</span>(Base&amp;&amp;) = <span class="keyword">default</span>;                   <span class="comment">// support moving</span></span><br><span class="line">  Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Base</span>(<span class="keyword">const</span> Base&amp;) = <span class="keyword">default</span>;              <span class="comment">// support copying</span></span><br><span class="line">  Base&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上代码描述，基类的析构需要被声明为<code>virtual</code>才能在多态析构时行为正确，如果析构什么事情都不用做，那么使用<code>default</code>是个简而美的办法。</p>
<p>比如下面这个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringTable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StringTable</span>()</span><br><span class="line">  &#123; <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Creating StringTable object&quot;</span>); &#125;     <span class="comment">// added</span></span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">StringTable</span>()                                       <span class="comment">// also</span></span><br><span class="line">  &#123; <span class="built_in">makeLogEntry</span>(<span class="string">&quot;Destroying StringTable object&quot;</span>); &#125;   <span class="comment">// added</span></span><br><span class="line">  …                                     <span class="comment">// other funcs as before</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::map&lt;<span class="keyword">int</span>, std::string&gt; values;    <span class="comment">// as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于显示的定义了析构函数，编译器有可能不会隐式创建移动构造和移动拷贝函数。</p>
<p>那么在实际需要移动的场景，是会使用拷贝操作来完成的，这效率就大打折扣了。</p>
<p>比较简单的解决办法就是使用<code>dafault</code>显示声明移动操作。</p>
<h1 id="模板的特殊行为"><a href="#模板的特殊行为" class="headerlink" title="模板的特殊行为"></a>模板的特殊行为</h1><p>当类中以函数模板的形式定义拷贝构造和拷贝赋值时，编译器还是会隐式的创建默认和移动操作函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// construct Widget</span></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="keyword">const</span> T&amp; rhs);               <span class="comment">// from anything</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                <span class="comment">// assign Widget</span></span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> T&amp; rhs);    <span class="comment">// from anything</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：delete 优于私有未定义行为</title>
    <url>/2022/04/14/effective_cpp_delete_func/</url>
    <content><![CDATA[<p>如果不想让用户使用某个函数，那么有以下 3 种做法：</p>
<ol>
<li>使用<code>delete</code>限定</li>
<li>将该函数设定为私有</li>
<li>直接不定义该函数</li>
</ol>
<p>最为合适的做法，就是使用<code>delete</code>限定。</p>
<span id="more"></span>

<h1 id="3-种方法的差别"><a href="#3-种方法的差别" class="headerlink" title="3 种方法的差别"></a>3 种方法的差别</h1><p>如果一个函数完成度不够或在实际行为上不允许用户调用该函数，那么：</p>
<h2 id="直接将该函数屏蔽或删除"><a href="#直接将该函数屏蔽或删除" class="headerlink" title="直接将该函数屏蔽或删除"></a>直接将该函数屏蔽或删除</h2><p>对于自己定义的函数，屏蔽它是一个做法，但这样总是看起来不优雅。</p>
<p>对于拷贝构造，拷贝赋值这类函数，如果不定义编译器也会有个默认版本，是无法将其直接删除的。</p>
<h2 id="将该函数设定为私有"><a href="#将该函数设定为私有" class="headerlink" title="将该函数设定为私有"></a>将该函数设定为私有</h2><p>私有成员不能被用户调用，但是可以被<code>friend</code>或其它成员函数无意调用，这会造成逻辑漏洞。</p>
<blockquote>
<p>当然可以只在类中声明它们，而不定义。这样在其被调用到时，编译器就会报错。但这报错并不能直接体现出类设计者的意图。</p>
</blockquote>
<h2 id="使用delete限定"><a href="#使用delete限定" class="headerlink" title="使用delete限定"></a>使用<code>delete</code>限定</h2><p>使用<code>delete</code>是作为稳妥的办法，因为这是由编译器帮你把各个环节都限定了该函数不能被访问。</p>
<h1 id="delete函数需要被设定为public访问权限"><a href="#delete函数需要被设定为public访问权限" class="headerlink" title="delete函数需要被设定为public访问权限"></a><code>delete</code>函数需要被设定为<code>public</code>访问权限</h1><p>用户在访问一个方法的时候，编译器首先是检查其访问权限，然后才是检查其相关限定。</p>
<p>如果将一个<code>delete</code>函数放在<code>private</code>区，那么当用户访问的时候，就只会出现访问权限错误的警告。</p>
<p>而如果将一个<code>delete</code>函数放在<code>public</code>区，那么编译器就会给出正确的提示警告。</p>
<h1 id="使用delete限定参数类型"><a href="#使用delete限定参数类型" class="headerlink" title="使用delete限定参数类型"></a>使用<code>delete</code>限定参数类型</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">int</span> number)</span></span>;            <span class="comment">// original function</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">char</span>)</span> </span>= <span class="keyword">delete</span>;         <span class="comment">// reject chars</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">bool</span>)</span> </span>= <span class="keyword">delete</span>;         <span class="comment">// reject bools</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLucky</span><span class="params">(<span class="keyword">double</span>)</span> </span>= <span class="keyword">delete</span>;       <span class="comment">// reject doubles and</span></span><br><span class="line">                                     <span class="comment">// floats</span></span><br></pre></td></tr></table></figure>

<p>以上就限定了<code>isLucky</code>的输入参数必须是<code>int</code>类型。</p>
<p>对于模板函数，也可以对特点类型进行限定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line"><span class="comment">//限制 void* 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">void</span>&gt;(<span class="keyword">const</span> <span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">void</span>&gt;(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="comment">//限制 char* 偏特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">char</span>&gt;(<span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> processPointer&lt;<span class="keyword">const</span> <span class="keyword">char</span>&gt;(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>在类中的函数模板，也可以如此使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function">  </span>&#123; … &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;                                          <span class="comment">// still</span></span><br><span class="line"><span class="keyword">void</span> Widget::processPointer&lt;<span class="keyword">void</span>&gt;(<span class="keyword">void</span>*) = <span class="keyword">delete</span>;  <span class="comment">// public,</span></span><br><span class="line">                                                    <span class="comment">// but</span></span><br><span class="line">                                                    <span class="comment">// deleted</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：考虑用 emplacement 替代 insertion</title>
    <url>/2022/05/14/effective_cpp_emplacement/</url>
    <content><![CDATA[<p>对容器的 insertion 操作，比如 <code>push_back</code>，有的时候效率并不高。</p>
<span id="more"></span>

<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;         </span><br><span class="line">vs.<span class="built_in">push_back</span>(<span class="string">&quot;xyzzy&quot;</span>);               </span><br></pre></td></tr></table></figure>

<p>上面这个<code>push_back</code>真实的执行流程如下：</p>
<ol>
<li>由于输入的是字面值，需要为其创建一个临时对象。这个时候会调用<code>std::string</code>的构造函数</li>
<li>由于是临时对象，所以会调用对应的移动构造函数，来在 vector 中创建一个对象</li>
<li>最后释放临时对象占用的内存，那么就会调用析构函数</li>
</ol>
<p>这个使用使用<code>emplace_back</code>则是直接调用构造函数，在 vector 中创建对象，也就没有了步骤 1，3的性能消耗：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当下面的条件都满足时，使用 emplacement 操作比插入操作更合理，效率更高：</p>
<ul>
<li>需要创建一个临时对象加入到容器时，如上面所示</li>
<li>加入数据的类型与容器包含数据的类型不一致<blockquote>
<p>因为类型不一致，使用 emplacement 调用构造函数即可。如果用 push_back 这种则会创建临时对象</p>
</blockquote>
</li>
<li>容器允许加入相同的值<blockquote>
<p>比如 std::set, std::map 这类容器不允许有重复的值，如果使用 emplacement 加入相同的值，则会先创建一个临时变量，然后又将其销毁。</p>
</blockquote>
</li>
</ul>
<p>比如下面这个情况就是 emplacement 快于 push_back：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="string">&quot;xyzzy&quot;</span>);   <span class="comment">// construct new value at end of</span></span><br><span class="line">                            <span class="comment">// container; don&#x27;t pass the type in</span></span><br><span class="line">                            <span class="comment">// container; don&#x27;t use container</span></span><br><span class="line">                            <span class="comment">// rejecting duplicates</span></span><br><span class="line">vs.<span class="built_in">emplace_back</span>(<span class="number">50</span>, <span class="string">&#x27;x&#x27;</span>);   <span class="comment">// ditto</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：异常的注意点</title>
    <url>/2022/04/14/effective_cpp_excption/</url>
    <content><![CDATA[<p>个人认为，异常会增加程序员的负担，还是像 C 那样使用返回错误、断言这些方式来捕捉错误比较简洁。</p>
<blockquote>
<p>google 编码规范<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#exceptions">不建议使用异常</a>。</p>
</blockquote>
<span id="more"></span>

<h1 id="使用别人的代码"><a href="#使用别人的代码" class="headerlink" title="使用别人的代码"></a>使用别人的代码</h1><p>我们所使用的第三方库很可能会抛出异常，那么就谨记以下原则：</p>
<ul>
<li>如果该操作不在析构/构造函数中，那么就在调用可能抛出异常的对象上使用捕获异常。<ul>
<li>这样可以尽量缩小异常的范围</li>
</ul>
</li>
<li>如果该操作存在于析构/构造函数中，就需要在捕获异常后做出对应的反应。要么停止程序，要么记录该错误后继续运行。<ul>
<li>为了提供更好的灵活性，可以将操作移动到普通成员函数中供用户调用。析构函数中再做一下检查（是否需要释放资源）即可。</li>
</ul>
</li>
</ul>
<h1 id="自己写代码"><a href="#自己写代码" class="headerlink" title="自己写代码"></a>自己写代码</h1><p>当确认一个函数不会抛出异常时，应该使用<code>noexcept</code>修饰。</p>
<blockquote>
<p>但是大部分情况下都不会增加这个修饰，因为并不能特别的肯定它以后不会抛出异常，如果以后要改的话，就会比较麻烦。额，主要是写起来麻烦……</p>
</blockquote>
<blockquote>
<p>目前已知的是，在类的移动构造和移动赋值函数后加入 <code>noexecpt</code>修饰，以保证 <code>vector</code>这种容器可以正常调用，以提高容器的搬移效率。</p>
</blockquote>
<p>这样的好处在于：</p>
<ol>
<li>增加代码的可读性</li>
<li>提高代码的运行效率</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：以自己熟悉的方式代替重载通用引用的方式</title>
    <url>/2022/05/09/effective_cpp_familiarize_yourself/</url>
    <content><![CDATA[<p>前面提到过，重载通用引用函数，得到的结果往往不是预期的，那么就应该以其它的方式来替代这种迷惑的方式。</p>
<span id="more"></span>

<h1 id="以其它的名字命名重载函数"><a href="#以其它的名字命名重载函数" class="headerlink" title="以其它的名字命名重载函数"></a>以其它的名字命名重载函数</h1><p>既然对通用引用函数的重载会导致非预期的调用，那么就将那些重载函数以其它名字命名，就绕过了这个坑。</p>
<blockquote>
<p>对于常年写 c 的人来说，这个方法是最自然而然地。</p>
</blockquote>
<h1 id="函数参数使用const-T-amp"><a href="#函数参数使用const-T-amp" class="headerlink" title="函数参数使用const T&amp;"></a>函数参数使用<code>const T&amp;</code></h1><p>当重载函数不会改变实参内容时，可以使用<code>const T&amp;</code>来做参数限定，以替代通用引用。</p>
<blockquote>
<p>这种方式在遇到右值时，也会以拷贝的方式进行创建新对象，虽然效率不高。但是很多时候可以让代码更易于理解。</p>
</blockquote>
<h1 id="参数以值传递，并且辅以std-move"><a href="#参数以值传递，并且辅以std-move" class="headerlink" title="参数以值传递，并且辅以std::move"></a>参数以值传递，并且辅以<code>std::move</code></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(std::string n)</span> <span class="comment">// replaces T&amp;&amp; ctor</span></span></span><br><span class="line"><span class="function">        : name(std::move(n)) &#123;</span>&#125;        </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> idx)</span>       </span></span><br><span class="line"><span class="function">  : name(nameFromIdx(idx)) &#123;</span>&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样既不会造成重载调用的非预期，还可以使用移动语义提高效率。</p>
<h1 id="使用标记分发"><a href="#使用标记分发" class="headerlink" title="使用标记分发"></a>使用标记分发</h1><p>简单的说就是在通用引用函数中使用标记分发，使得编译器在编译时就可以确定调用匹配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当 std::false_type 满足后，此函数才会被调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                             <span class="comment">// non-integral</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(T&amp;&amp; name, std::false_type)</span>    <span class="comment">// argument:</span></span></span><br><span class="line"><span class="function"></span>&#123;                                                <span class="comment">// add it to</span></span><br><span class="line">  <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();   <span class="comment">// global data</span></span><br><span class="line">  <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);                         <span class="comment">// structure</span></span><br><span class="line">  names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当 std::true_type 满足后，此函数才会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAddImpl</span><span class="params">(<span class="keyword">int</span> idx, std::true_type)</span>   <span class="comment">// integral</span></span></span><br><span class="line"><span class="function"></span>&#123;                                             <span class="comment">// argument: look</span></span><br><span class="line">  <span class="built_in">logAndAdd</span>(<span class="built_in">nameFromIdx</span>(idx));                <span class="comment">// up name and</span></span><br><span class="line">&#125;                                             <span class="comment">// call logAndAdd</span></span><br><span class="line">                                              <span class="comment">// with it</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在编译期使用 std::is_intergral 来判定应该调用哪个函数</span></span><br><span class="line"><span class="comment">//当传入的是 int 型时，调用 idx 参数的函数</span></span><br><span class="line"><span class="comment">//当传入的不是 int 型时，才调用函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">logAndAddImpl</span>(</span><br><span class="line">    std::forward&lt;T&gt;(name),</span><br><span class="line">    <span class="comment">// 当实参是左值时，T 会被推导为左值引用，所以这里需要使用 std::remove_reference</span></span><br><span class="line">    <span class="comment">// 来去除引用</span></span><br><span class="line">    std::is_integral&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对通用引用进行限制"><a href="#对通用引用进行限制" class="headerlink" title="对通用引用进行限制"></a>对通用引用进行限制</h1><p>通过<code>std::enable_if</code>这种黑魔法，可以做到直接在通用引用函数上做限制，比如下面就限定，当实参类型不是<code>Person</code>时，才使用通用引用的构造函数。否则就使用拷贝构造、拷贝赋值这类构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                 !std::is_same&lt;Person,</span><br><span class="line">                               <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                              &gt;::value</span><br><span class="line">               &gt;::type</span><br><span class="line">  &gt;</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>std::decay</code>用于将推导出的 T 中的引用、<code>const</code>、<code>volatile</code>限定给去除。以表示带引用、<code>const</code>、<code>volatile</code>的<code>Person</code>对象都是一样的。<blockquote>
<p><code>typename std::decay&lt;T&gt;::type</code> 之后得到的就是去除约束后的<code>T</code>。</p>
</blockquote>
</li>
<li><code>std::is_same</code>是用于比较，传入的类型是否与<code>Person</code>一致</li>
<li><code>std::enable_if</code>则是当其条件为真时，才会使能该函数</li>
</ul>
<p>以上的所有步骤都是在编译期完成的，这就是模板元编程的魅力所在。</p>
<p>对于有继承的情况下，情况还要复杂一点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SpecialPerson</span>(<span class="keyword">const</span> SpecialPerson&amp; rhs)  <span class="comment">// copy ctor; calls</span></span><br><span class="line">  : <span class="built_in">Person</span>(rhs)                            <span class="comment">// base class</span></span><br><span class="line">  &#123;  &#125;                                    <span class="comment">// forwarding ctor!</span></span><br><span class="line">  <span class="built_in">SpecialPerson</span>(SpecialPerson&amp;&amp; rhs)       <span class="comment">// move ctor; calls</span></span><br><span class="line">  : <span class="built_in">Person</span>(std::<span class="built_in">move</span>(rhs))                 <span class="comment">// base class</span></span><br><span class="line">  &#123;  &#125;                                    <span class="comment">// forwarding ctor!</span></span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面这种情况下，基类<code>Person</code>被传入的是子类，所以原来的那种写法也会导致通用引用版本的构造函数被调用。</p>
<p>这个时候，需要使用<code>std::is_base_of</code>来替换<code>std::is_same</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">typename</span> T,</span><br><span class="line">    <span class="keyword">typename</span> = <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">                 !std::is_base_of&lt;Person,</span><br><span class="line">                                  <span class="keyword">typename</span> std::decay&lt;T&gt;::type</span><br><span class="line">                                 &gt;::value</span><br><span class="line">               &gt;::type</span><br><span class="line">  &gt;</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">Person</span>(T&amp;&amp; n);</span><br><span class="line">  <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::is_base_of</code>之后，无论<code>T</code>是基类还是子类，都得到结果为<code>true</code>，这样就可以避免上面的问题了。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：熟悉完美转发的错误情况</title>
    <url>/2022/05/12/effective_cpp_forward_failed/</url>
    <content><![CDATA[<p>要认识到完美转发的一些错误用例，才能够很好的使用它。</p>
<span id="more"></span>

<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>再来看看完美转发的基本使用：根据输入参数的类型，调用对应的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::string&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is lvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::string&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is rvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不使用完美转发，那么最终只会调用到其左值版本</span></span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">a</span><span class="params">(<span class="string">&quot;Hello world!\n&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hello</span>(a);</span><br><span class="line">    <span class="built_in">hello</span>(std::<span class="built_in">string</span>(<span class="string">&quot;haha&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅仅是一般的模板函数，可变参模板也是可以这样用的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fwd</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;             <span class="comment">// accept any arguments</span></span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;Ts&gt;(params)...);      <span class="comment">// forward them to f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完美转发失败的情况"><a href="#完美转发失败的情况" class="headerlink" title="完美转发失败的情况"></a>完美转发失败的情况</h1><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>列表初始化对于转发函数无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is lvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is rvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用可以通过编译</span></span><br><span class="line">    <span class="built_in">func</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">	<span class="comment">// 无法通过编译</span></span><br><span class="line">    <span class="built_in">hello</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">move.cc: In function ‘int main(int, char**)’:</span><br><span class="line">move.cc:24:26: error: no matching function for call to ‘hello(&lt;brace-enclosed initializer list&gt;)’</span><br><span class="line">     hello(&#123;1, 2, 3, 4, 5&#125;);</span><br><span class="line">                          ^</span><br><span class="line">move.cc:16:6: note: candidate: template&lt;class T&gt; void hello(T&amp;&amp;)</span><br><span class="line"> void hello(T&amp;&amp; param) &#123;</span><br><span class="line">      ^~~~~</span><br><span class="line">move.cc:16:6: note:   template argument deduction/substitution failed:</span><br><span class="line">move.cc:24:26: note:   couldn&#x27;t deduce template parameter ‘T’</span><br><span class="line">     hello(&#123;1, 2, 3, 4, 5&#125;);</span><br></pre></td></tr></table></figure>

<p>这是因为直接调用的情况下，编译器可以通过函数形参来推导出实参的类型。而通用引用函数则无法完成推导。</p>
<p>解决办法是，我们可以将列表的类型传递进去：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is lvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is rvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种方式也可以</span></span><br><span class="line">    <span class="comment">//hello(std::initializer_list&lt;int&gt;(&#123;1, 2, 3, 4, 5&#125;));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但这种方式更优雅</span></span><br><span class="line">    <span class="keyword">auto</span> v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">hello</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="以-0-或-NULL-来表示空指针"><a href="#以-0-或-NULL-来表示空指针" class="headerlink" title="以 0 或 NULL 来表示空指针"></a>以 0 或 NULL 来表示空指针</h2><p>这是因为<code>nullptr</code>是空指针，而 0 或 NULL 则无法被通用引用函数正确的推导。</p>
<h2 id="仅声明static-const数据成员"><a href="#仅声明static-const数据成员" class="headerlink" title="仅声明static const数据成员"></a>仅声明<code>static const</code>数据成员</h2><p>可以直接在类内声明<code>static const</code>数据成员，只要不取其地址，那么可以正常使用。</p>
<p>但在通用引用函数中，由于引用在编译器内部也是一个指针，所以在这种情况下就需要提供其定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用通用引用时，如果没有定义则无法编译通过</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Player::count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::<span class="keyword">size_t</span>&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is lvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::<span class="keyword">size_t</span>&amp;&amp; val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is rvalue function!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">hello</span>(Player::count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重载函数名和模板"><a href="#重载函数名和模板" class="headerlink" title="重载函数名和模板"></a>重载函数名和模板</h2><p>当通用引用函数的形参是函数指针时，如果输入的函数还有重载（重载函数或函数模板），那么将无法推导。</p>
<h2 id="位字段"><a href="#位字段" class="headerlink" title="位字段"></a>位字段</h2><p>如果通用引用函数的输入是位字段，则无法完成推导，因为引用在编译器内部是指针，而无法获取位字段的地址。</p>
<blockquote>
<p>函数形参是拷贝形式或<code>const</code>引用形式，就可以传入位字段。因为编译器会为这些位字段生成拷贝。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：const iterators 优于 iterators</title>
    <url>/2022/05/04/effective_cpp_iterator/</url>
    <content><![CDATA[<p>除非是需要修改容器元素的内容，否则在使用迭代器的时候，应该使用其<code>const</code>版本，也就是指向<code>const</code>类型元素的指针，以避免误操作。</p>
<span id="more"></span>

<h1 id="对于容器类，直接使用其成员函数"><a href="#对于容器类，直接使用其成员函数" class="headerlink" title="对于容器类，直接使用其成员函数"></a>对于容器类，直接使用其成员函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; val = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of vector are:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = val.<span class="built_in">cbegin</span>(); it != val.<span class="built_in">cend</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对于非容器类，使用标准库提供的非成员函数"><a href="#对于非容器类，使用标准库提供的非成员函数" class="headerlink" title="对于非容器类，使用标准库提供的非成员函数"></a>对于非容器类，使用标准库提供的非成员函数</h1><p>在 c++14 及以后的版本中，标准库才提供了<code>cbegin()、cend()、</code>这些函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of vector are:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = std::<span class="built_in">cbegin</span>(val); it != std::<span class="built_in">cend</span>(val); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要在 c++11 中使用，那就需要自定义函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief : 由于传入的是 const C&amp; 类型参数，模板推导返回的类型也会加上 const 限定符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cend</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::end(container))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">end</span>(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of vector are:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">cbegin</span>(val); it != <span class="built_in">cend</span>(val); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：正确使用 lambda</title>
    <url>/2022/05/12/effective_cpp_lambda/</url>
    <content><![CDATA[<p>lambda 使得 c++ 更有魅力，使用 lambda 可以创建一个可调用的对象，一般用于以下场合：</p>
<ol>
<li>快速创建一个简短的函数，仅在父函数中使用，避免繁琐的创建成员函数的过程。</li>
<li>为标准库的算法（<code>std::find_if,std::sort</code> 等），优雅的创建一个可调用对象。</li>
<li>快速为标准库创建删除器，比如<code>std::unique_ptr,std::shared_ptr</code>等</li>
</ol>
<span id="more"></span>

<h1 id="避免使用默认捕获"><a href="#避免使用默认捕获" class="headerlink" title="避免使用默认捕获"></a>避免使用默认捕获</h1><p>默认捕获会被编码者带来一定的误导，忽视一些错误捕获或无法捕获的场景。</p>
<blockquote>
<p>google 编码规范中，也 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#lambda">提到了这点</a>。</p>
</blockquote>
<h2 id="引用捕获要注意被捕获对象的作用域"><a href="#引用捕获要注意被捕获对象的作用域" class="headerlink" title="引用捕获要注意被捕获对象的作用域"></a>引用捕获要注意被捕获对象的作用域</h2><p>如果引用捕获对象的作用域是局部作用域，而 lambda 对象的使用超出了该作用域则会导致引用指向的对象无意义，最终会导致 undefined behavior。</p>
<p>比如设计一个容器，里面包含了函数对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> FilterContainer = std::vector&lt;std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(<span class="keyword">int</span>)&gt;&gt;;</span><br><span class="line"></span><br><span class="line">FilterContainer filters;</span><br></pre></td></tr></table></figure>

<p>然后在一个函数中，插入可调用对象到容器中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">  <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line">  <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>(                              </span><br><span class="line">    [&amp;](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;  </span><br><span class="line">  );                                                </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>由于<code>divisor</code>变量在退出函数后，其栈内存就被回收了，所以当该 lambda 被调用时，就是 undefined behavior。</p>
<p>为了避免这种情况，应该使用 passed by value 的形式形成闭包：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addDivisorFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> calc1 = <span class="built_in">computeSomeValue1</span>();</span><br><span class="line">  <span class="keyword">auto</span> calc2 = <span class="built_in">computeSomeValue2</span>();</span><br><span class="line">  <span class="keyword">auto</span> divisor = <span class="built_in">computeDivisor</span>(calc1, calc2);</span><br><span class="line">  filters.<span class="built_in">emplace_back</span>(                              </span><br><span class="line">    [=](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value % divisor == <span class="number">0</span>; &#125;  </span><br><span class="line">  );                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，如果捕获的参数是一个指针，也需要注意指针指向的内存被释放的情况。</p>
<p>使用默认捕获很容易让人忽视这类问题，而在捕获位置明确指出需要捕获的对象，则更容易提醒编码人员。</p>
<h2 id="捕获成员变量"><a href="#捕获成员变量" class="headerlink" title="捕获成员变量"></a>捕获成员变量</h2><p>需要理解的是：类中的成员变量的完整形式其实是：<code>this-&gt;member_variable</code></p>
<p>比如下面这段代码是会编译错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> func = [val_]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; val_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val_ = &#123;<span class="number">10</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为<code>val_</code>变量实际上是<code>this-&gt;val_</code>。</p>
<p>而使用默认捕获是可以编译通过的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> func = [=]() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; val_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val_ = &#123;<span class="number">10</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，这就等同于:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> obj_ptr = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">auto</span> func = [obj_ptr]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; obj_ptr-&gt;val_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就容易出现问题了，如果代码也是按照前面那一节将<code>lambda</code>对象放入容易，以后再来调用。<br>那么该对象完全可能在调用之前就被析构了，后来的操作就又是 undefined behavior。</p>
<p>最好的方式就是来捕获成员变量的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val_copy = val_;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = [val_copy]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; val_copy &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++ 14 还有更加简单的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接在捕获语句类生成拷贝</span></span><br><span class="line">    <span class="keyword">auto</span> func = [val_ = val_]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of val is &quot;</span> &lt;&lt; val_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态存储变量与捕获"><a href="#静态存储变量与捕获" class="headerlink" title="静态存储变量与捕获"></a>静态存储变量与捕获</h2><p>实际上，lambda 无法捕获静态存储变量而形成闭包：</p>
<blockquote>
<p>这里的静态存储变量包括：全局变量、在命名空间内的变量、<code>static</code>修饰的变量</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上这里加不加 = 都不影响，因为没有捕获到任何变量</span></span><br><span class="line">    <span class="keyword">auto</span> func = [=]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of v is &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The value of v is 3</span><br></pre></td></tr></table></figure>


<h1 id="使用初始捕获来完成移动对象的闭包"><a href="#使用初始捕获来完成移动对象的闭包" class="headerlink" title="使用初始捕获来完成移动对象的闭包"></a>使用初始捕获来完成移动对象的闭包</h1><p>如果有些对象（比如容器）以拷贝的方式形成闭包，其效率太低了。这种情况下应该以移动的方式来形成闭包。</p>
<blockquote>
<p>c++14 有现成的语法支持，称之为初始捕获（init capture）</p>
</blockquote>
<h2 id="基于-c-14-的初始捕获"><a href="#基于-c-14-的初始捕获" class="headerlink" title="基于 c++ 14 的初始捕获"></a>基于 c++ 14 的初始捕获</h2><p>所谓的初始捕获，其实简单来讲就是：使用局部变量来初始化 lambda 表达式闭包中的变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++ 14 支持将 vec 内容移动给 v 以形成闭包</span></span><br><span class="line">    <span class="keyword">auto</span> func = [v = std::<span class="built_in">move</span>(vec)]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The contenes of v are:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> val : v) &#123;</span><br><span class="line">            std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动后的 vec 则不包含内容了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec size &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于-c-11-的初始捕获"><a href="#基于-c-11-的初始捕获" class="headerlink" title="基于 c++ 11 的初始捕获"></a>基于 c++ 11 的初始捕获</h2><p>由于 c++ 11 没有语法支持，所以需要借助<code>std::bind</code>来完成这个需求：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(</span><br><span class="line">            [](<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;The contenes of v are:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> val : v) &#123;</span><br><span class="line">                    std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            std::<span class="built_in">move</span>(vec)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vec size &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lambda-与完美转发"><a href="#lambda-与完美转发" class="headerlink" title="lambda 与完美转发"></a>lambda 与完美转发</h1><p>c++14 中，lambda 的参数可以由<code>auto</code>推导，这就如同模板一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> x)&#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x)); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeCompilerGeneratedClassName</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                   </span></span><br><span class="line"><span class="function">  <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T x)</span> <span class="keyword">const</span>             </span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(x)); &#125;</span><br><span class="line">  …                                      </span><br><span class="line">&#125;;                                       </span><br></pre></td></tr></table></figure>

<p>但需要注意的是，如果 lambda 中调用了其他对象，且具有左值及右值对应的版本那么就需要使用完美转发：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)</span><br><span class="line">         &#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;???&gt;(x))); &#125;;</span><br></pre></td></tr></table></figure>

<p>但问题是，<code>std::forward</code>中并无法确定参数类型。</p>
<p>这个时候就可以使用<code>decltype</code>来推导类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span>&amp;&amp; x)</span><br><span class="line">         &#123; <span class="keyword">return</span> <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(x)&gt;(x))); &#125;;</span><br></pre></td></tr></table></figure>

<p>除此之外，c++14 的 lambda 还支持变参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f =</span><br><span class="line">  [](<span class="keyword">auto</span>&amp;&amp;... params)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">normalize</span>(std::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="lambda-优于-std-bind"><a href="#lambda-优于-std-bind" class="headerlink" title="lambda 优于 std::bind"></a>lambda 优于 std::bind</h1><p>lambad 综合上优于 <code>std::bind</code>，最主要的是其优异的可读性。</p>
<p>比如要编写一个声音报警程序，先声明以下类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间点</span></span><br><span class="line"><span class="keyword">using</span> Time = std::chrono::steady_clock::time_point;</span><br><span class="line"><span class="comment">// 报警的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Sound</span> &#123;</span> Beep, Siren, Whistle &#125;;</span><br><span class="line"><span class="comment">// 时间长度</span></span><br><span class="line"><span class="keyword">using</span> Duration = std::chrono::steady_clock::duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置报警的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Time t, Sound s, Duration d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后以 lambda 的方式来封装，产生一个 1 小时后响铃 30 秒的可调用对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setSoundL (&quot;L&quot; for &quot;lambda&quot;) is a function object allowing a</span></span><br><span class="line"><span class="comment">// sound to be specified for a 30-sec alarm to go off an hour</span></span><br><span class="line"><span class="comment">// after it&#x27;s set</span></span><br><span class="line"><span class="keyword">auto</span> setSoundL =                             </span><br><span class="line">  [](Sound s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// make std::chrono components available w/o qualification</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="built_in">hours</span>(<span class="number">1</span>),  <span class="comment">// alarm to go off</span></span><br><span class="line">             s,                               <span class="comment">// in an hour for</span></span><br><span class="line">             <span class="built_in">seconds</span>(<span class="number">30</span>));                    <span class="comment">// 30 seconds</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>基于 c++ 14 的话，还可以再次简化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> setSoundL =                             </span><br><span class="line">  [](Sound s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;         <span class="comment">// for C++14 suffixes</span></span><br><span class="line">    <span class="built_in">setAlarm</span>(steady_clock::<span class="built_in">now</span>() + <span class="number">1</span>h,     <span class="comment">// C++14, but</span></span><br><span class="line">             s,                            <span class="comment">// same meaning</span></span><br><span class="line">             <span class="number">30</span>s);                         <span class="comment">// as above</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>但使用<code>std::bind</code>来实现同样的可调用对象，则要麻烦得多，并且可读性很差：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;           <span class="comment">// as above</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;     <span class="comment">// needed for use of &quot;_1&quot;</span></span><br><span class="line"><span class="keyword">auto</span> setSoundB =                       <span class="comment">// &quot;B&quot; for &quot;bind&quot;</span></span><br><span class="line">  std::<span class="built_in">bind</span>(setAlarm,</span><br><span class="line">            <span class="comment">// 使用下面这种方式，那么获取到得则是绑定时得时间点，而不是调用时的时间点</span></span><br><span class="line">            <span class="comment">// steady_clock::now() + 1h,</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 应该如下，c++ 14 中，std::plus 中的类型可以忽略</span></span><br><span class="line">            std::<span class="built_in">bind</span>(std::plus&lt;&gt;(), steady_clock::<span class="built_in">now</span>(), <span class="number">1</span>h),</span><br><span class="line">            _1,</span><br><span class="line">            <span class="number">30</span>s);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：理解 std::move 和 std::forward</title>
    <url>/2022/05/05/effective_cpp_move_forward/</url>
    <content><![CDATA[<p>需要时刻牢记的是：函数的形参都是左值，即使它的类型是右值引用，它也是左值，因为它可以被取地址。</p>
<p>主要是区分什么是右值，满足以下二者之一即可：</p>
<ol>
<li>临时对象</li>
<li>无法位于赋值符号右边的对象</li>
</ol>
<span id="more"></span>

<h1 id="std-move和std-forward"><a href="#std-move和std-forward" class="headerlink" title="std::move和std::forward"></a><code>std::move</code>和<code>std::forward</code></h1><p><code>std::move</code>相当于无条件的将其参数转换为右值，而<code>std::forward</code>则是判定条件否则满足来进行转换。</p>
<blockquote>
<p>这就是说，这两个函数都是做的<code>cast</code>动作，并没有做其他的操作。</p>
</blockquote>
<p><code>std::move</code>的简易实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c++11 版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                         <span class="comment">// in namespace std</span></span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType =                       <span class="comment">// alias declaration;</span></span><br><span class="line">        <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c++14 版本</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                          </span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>move</code>函数将参数<code>param</code>使用<code>static_cast</code>强制转换为了<code>remove_reference&lt;T&gt;::type&amp;&amp;</code>，也就是参数的右值引用。</p>
<p>也就是说标准的<code>std::move</code>也仅仅是做转换作用，它并没有像它的名字那样实现移动的操作，而是向编译器指明，该对象是可以被移动的。</p>
<p>有了这个基础，就可以理解下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Hello</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;default constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hello</span>(<span class="keyword">const</span> Hello&amp; rhs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Hello</span>(Hello&amp;&amp; rhs) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move constructor!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认构造函数</span></span><br><span class="line">    Hello obj_a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用拷贝构造函数</span></span><br><span class="line">    <span class="function">Hello <span class="title">obj_b</span><span class="params">(obj_a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用移动构造函数</span></span><br><span class="line">    <span class="function">Hello <span class="title">obj_c</span><span class="params">(std::move(obj_a))</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解<code>std::move</code></h1><p>对于<code>std::string</code>，其有构造函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span> &#123;</span>            <span class="comment">// std::string is actually a </span></span><br><span class="line"><span class="keyword">public</span>:                   <span class="comment">// typedef for std::basic_string&lt;char&gt;</span></span><br><span class="line">…</span><br><span class="line">    <span class="built_in">string</span>(<span class="keyword">const</span> string&amp; rhs);    <span class="comment">// copy ctor</span></span><br><span class="line">    <span class="built_in">string</span>(string&amp;&amp; rhs);         <span class="comment">// move ctor</span></span><br><span class="line">…</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个是接收<code>const string</code>的左值引用的拷贝构造函数，另一个是<code>string</code>的右值引用移动构造函数，因为移动构造函数是要修改形参对象内存的，所以不能添加<code>const</code>限定。</p>
<p>下面假设有一个类的构造函数需要传入<code>string</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> std::string text)</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">    std::string value;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类的构造函数接受一个<code>const std::string</code>来完成对私有成员<code>value</code>的赋值。</p>
<p>下面假设我们希望使用移动语义来完成<code>value</code>的赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annotation</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Annotation</span><span class="params">(<span class="keyword">const</span> std::string text)</span></span></span><br><span class="line"><span class="function">        : value(std::move(text))  // <span class="string">&quot;move&quot;</span> text into value;</span> <span class="keyword">this</span> code</span><br><span class="line">        &#123; … &#125;                     <span class="comment">// doesn&#x27;t do what it seems to!</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::string value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但实际上，依然调用的是拷贝构造函数！</p>
<p>因为虽然使用了<code>std::move</code>将<code>text</code>确实转换成了右值引用，但是其<code>const</code>限定依然存在。既然有<code>const</code>存在，就无法使用<code>string</code>的移动构造函数，转而使用其拷贝构造函数！</p>
<p>所以，<code>std::move</code>只能说是将参数转换成了右值引用，至于是否真的执行了移动操作，要根据当前的上下文而定。</p>
<h1 id="理解std-forward"><a href="#理解std-forward" class="headerlink" title="理解std::forward"></a>理解<code>std::forward</code></h1><p>相对于<code>std::move</code>的无条件转换，<code>std::forward</code>则是根据情况来判定是否转换。</p>
<p><code>std::forward</code>主要是将函数模板参数转为特定的类型，给予不同的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; lvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is process function with const int&amp;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; rvalArg)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is process function with int&amp;&amp;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    <span class="built_in">func</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出为：</p>
<blockquote>
<p>This is process function with const int&amp;<br>This is process function with int&amp;&amp;</p>
</blockquote>
<p><code>std::forward</code>根据传入参数是左右引用还是右值引用来判定调用对应版本的重载函数。</p>
<p><code>std::forward</code>虽然看起来更加智能，但是其需要参考的条件也多：</p>
<ul>
<li>首先要指定转换的具体类型是什么</li>
<li>其次还要参数的类型是右值引用时，才会调用右值引用版本的函数</li>
</ul>
<p>但<code>std::move</code>好就好在简单粗暴，不管类型和传入参数，直接转换为右值引用。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：谨慎使用移动操作</title>
    <url>/2022/05/12/effective_cpp_no_move/</url>
    <content><![CDATA[<p>移动语义是 c++11 最重要的特性，但不是什么情况下都可以使用移动语义。<br>所以写代码的时候不能假设就有移动语义而忽视性能方面应该注意的问题。</p>
<blockquote>
<p>比如只有当一个类没有显示的定义拷贝、移动、析构函数时，编译器才会生成一个默认的移动构造、拷贝函数。</p>
<p>或者是一个类的成员变量类禁止了移动操作，那么也不会生成默认移动函数。</p>
</blockquote>
<span id="more"></span>

<h1 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a>std::array</h1><p><code>std::vector</code>，<code>std::deque</code>等这类容器，它们的内容实际上是存储于堆上，内部是由指针来指向内容所在的内存，所以是可以高效使用移动语义的。</p>
<p>将一个<code>std::vector</code>的内容拷贝到另一个<code>std::vector</code>，也就是将原指针的值拷贝到目的指针，且原指针的地址设为空。</p>
<blockquote>
<p>当然，之后的代码就不能再使用原指针了。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Widget&gt; vw1;</span><br><span class="line"><span class="comment">// put data into vw1</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// move vw1 into vw2. Runs in</span></span><br><span class="line"><span class="comment">// constant time. Only ptrs</span></span><br><span class="line"><span class="comment">// in vw1 and vw2 are modified</span></span><br><span class="line"><span class="keyword">auto</span> vw2 = std::<span class="built_in">move</span>(vw1);</span><br></pre></td></tr></table></figure>

<p>但<code>std::array</code>这个容器则与其他容器不同，它内部并没有指针来指向其内容。而是内容就直接存储于该类的对象种的。在<code>std::array</code>的<a href="https://en.cppreference.com/w/cpp/container/array">说明页面</a>也可以发现，它提供的仅有拷贝构造、拷贝赋值函数。</p>
<blockquote>
<p>既然有拷贝赋值函数了，那么编译器也就不会生成移动函数了。</p>
</blockquote>
<p>所以，即使给<code>std::array</code>使用了<code>std::move</code>也仅仅是调用的拷贝构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;Widget, 10000&gt; aw1;</span><br><span class="line"><span class="comment">// put data into aw1</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// move aw1 into aw2. Runs in</span></span><br><span class="line"><span class="comment">// linear time. All elements in</span></span><br><span class="line"><span class="comment">// aw1 are moved into aw2</span></span><br><span class="line"><span class="keyword">auto</span> aw2 = std::<span class="built_in">move</span>(aw1);</span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<p>先使用<code>std::vector</code>这不会触发<code>Hello</code>类的拷贝函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Hello</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Default construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Hello</span>(<span class="keyword">const</span> Hello&amp; obj) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Hello <span class="keyword">operator</span>=(<span class="keyword">const</span> Hello&amp; obj) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy assignment!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Hello</span>(Hello&amp;&amp; obj) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Hello <span class="keyword">operator</span>=(Hello&amp;&amp; obj) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move assignment!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Hello&gt; <span class="title">vw1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;construct vw2:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Hello&gt; <span class="title">vw2</span><span class="params">(std::move(vw1))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vw2 size = &quot;</span> &lt;&lt; vw2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">construct vw2:</span><br><span class="line">vw2 size = 10</span><br></pre></td></tr></table></figure>

<p>可以看到，仅仅是在最开始创建了对象，而接下来的移动操作并不会调用<code>Hello</code>类的拷贝、移动操作。因为直接是进行指针赋值了。</p>
<p>而如果使用<code>std::array</code>则不同了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Hello</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Default construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Hello</span>(<span class="keyword">const</span> Hello&amp; obj) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Hello <span class="keyword">operator</span>=(<span class="keyword">const</span> Hello&amp; obj) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Copy assignment!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Hello</span>(Hello&amp;&amp; obj) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move construct!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Hello <span class="keyword">operator</span>=(Hello&amp;&amp; obj) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Move assignment!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::array&lt;Hello, 5&gt; vw1 = &#123;<span class="built_in">Hello</span>(), <span class="built_in">Hello</span>(), <span class="built_in">Hello</span>(), <span class="built_in">Hello</span>(), <span class="built_in">Hello</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;construct vw2:\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::array&lt;Hello, 5&gt; <span class="title">vw2</span><span class="params">(std::move(vw1))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vw2 size = &quot;</span> &lt;&lt; vw2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">Default construct!</span><br><span class="line">construct vw2:</span><br><span class="line">Move construct!</span><br><span class="line">Move construct!</span><br><span class="line">Move construct!</span><br><span class="line">Move construct!</span><br><span class="line">Move construct!</span><br><span class="line">vw2 size = 5</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然使用了<code>std::move</code>，但由于<code>std::array</code>并没有移动函数，所以只能一个元素一个元素的拷贝。</p>
<blockquote>
<p><strong>但这里要注意，元素如果提供了移动操作，则会使用元素的移动函数。</strong></p>
</blockquote>
<p>相比<code>std::vector</code> 的 O(1) 时间复杂度，<code>std::array</code>就是 O(n) 的时间复杂度。</p>
<h1 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h1><p><code>std::string</code>对于短字符串会使用 SSO（small string optimization），也就是这些短字符串会直接存储在其对象中。</p>
<blockquote>
<p>长字符串才存储于堆中，因为要使用堆就会涉及到堆内存的申请，这也会影响性能。对于短字符串就不划算了。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以下这些情况都不能使用，或需要谨慎使用移动语义：</p>
<ul>
<li>当一个类不提供移动操作时，那么就会使用其拷贝操作</li>
<li>当移动操作性能不高于拷贝操作性能时：比如短字符串的<code>std::string</code></li>
<li>无法使用移动操作时：比如某些操作不能使用可能会抛出异常的移动函数</li>
<li>当被移动对象是左值时：有些情况下需要被移动对象是右值</li>
</ul>
<blockquote>
<p>比如左值接下来还会被使用等等</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：nullptr 优于 0 和 NULL</title>
    <url>/2022/05/02/effective_cpp_nullptr/</url>
    <content><![CDATA[<p>在 c 中，通常使用<code>NULL</code>表示一个空指针，但是在 cpp 中有更优的<code>nullptr</code>可供选择。</p>
<span id="more"></span>

<p>首先需要明白：</p>
<ol>
<li><code>0</code> 是一个<code>int</code>型的数，而不是指针类型</li>
<li><code>NULL</code>也是一个宏定义的<code>0</code><ul>
<li>在 c++11 及以后的版本中， <code>NULL</code>的宏定义为：<code>#define NULL nullptr</code></li>
</ul>
</li>
<li><code>nullptr</code>实际上是<code>std::nullptr_t</code>类型，它可以转换为任何指针类型，且不会有二义性</li>
</ol>
<h1 id="nullptr与二义性"><a href="#nullptr与二义性" class="headerlink" title="nullptr与二义性"></a><code>nullptr</code>与二义性</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void f(int i) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;int parameter &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void f(int *i) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;pointer paramter &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    f(0);</span><br><span class="line">    f(NULL);</span><br><span class="line">    f(nullptr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，在<code>msvc</code>编译环境中输出为：</p>
<blockquote>
<p>int parameter 0<br>int parameter 0<br>pointer paramter 00000000</p>
</blockquote>
<p>而在<code>g++</code>编译环境中，由于这种使用<code>NULL</code>的方式具有二义性，编译器干脆就报错：</p>
<blockquote>
<p>$ g++ main.cpp<br>main.cpp: In function ‘int main()’:<br>main.cpp:13:11: error: call of overloaded ‘f(NULL)’ is ambiguous<br>     f(NULL);<br>           ^<br>main.cpp:4:6: note: candidate: void f(int)<br> void f(int i){<br>      ^<br>main.cpp:7:6: note: candidate: void f(int*)<br> void f(int *i){<br>      ^</p>
</blockquote>
<p>所以，当明确要使用指针类型时，使用<code>nullptr</code>是最好的选择。</p>
<h1 id="nullptr与可读性"><a href="#nullptr与可读性" class="headerlink" title="nullptr与可读性"></a><code>nullptr</code>与可读性</h1><p>比如使用如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Record</span>();</span><br><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这样的代码，并不易于阅读，读代码的人并不能确定<code>result</code>一定是整型，或是指针。</p>
<p>但如果改为下面这样，那么<code>result</code>的类型就确认无疑是指针，这就增加了代码的可读性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">Record</span>();</span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="nullptr与正确性"><a href="#nullptr与正确性" class="headerlink" title="nullptr与正确性"></a><code>nullptr</code>与正确性</h1><p>由于<code>0</code>和<code>NULL</code>并不能转换为任意指针类型，所以在调用有些需要特定指针类型的函数时，编译器就会报错。</p>
<p>而<code>nullptr</code>却可以转为该类型，保证编译的正确执行。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：对象的初始化</title>
    <url>/2022/04/12/effective_cpp_obj_initialize/</url>
    <content><![CDATA[<p>要养成好的习惯：永远在使用对象之前先将它初始化。</p>
<ul>
<li>对于内置类型，在定义时就初始化</li>
<li>对于类类型，在构造函数初始值列表中按照<strong>声明顺序</strong>初始化<ul>
<li>类类型中的私有变量是内置类型时，也可以在声明时初始化，这样可以避免初始值列表过长。</li>
<li>如果期望类类型中的对象以默认构造函数初始化时，那也可以不用放在初始值列表中</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h1 id="初始化语法的迷惑"><a href="#初始化语法的迷惑" class="headerlink" title="初始化语法的迷惑"></a>初始化语法的迷惑</h1><h2 id="内置类型的初始化"><a href="#内置类型的初始化" class="headerlink" title="内置类型的初始化"></a>内置类型的初始化</h2><p>对于内置类型的初始化，有以下 4 种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//&#123;&#125; 和 = &#123;&#125; 的形式对于编译器来讲是同一种形式</span></span><br><span class="line">    <span class="comment">//所以可以简单把它们都称为列表初始化</span></span><br><span class="line">    <span class="keyword">int</span> k&#123;<span class="number">78</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> l = &#123;<span class="number">90</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of i is &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of j is &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of k is &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of l is &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> m = <span class="number">1.123456</span>;</span><br><span class="line">    <span class="comment">//不同类型转换，当存在丢失信息的风险，下面两种初始化最多只给出 warning</span></span><br><span class="line">    <span class="keyword">int</span> q = m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">w</span><span class="params">(m)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of q is &quot;</span> &lt;&lt; q &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of w is &quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不同类型转换，当存在丢失信息的风险，列表初始化就会编译器报错或给出 warning</span></span><br><span class="line">    <span class="keyword">int</span> e&#123;m&#125;;</span><br><span class="line">    <span class="keyword">int</span> r = &#123;m&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of e is &quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of r is &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>&#123;&#125;</code>和<code>=&#123;&#125;</code>对于编译器同义，那么初始化方式就是 3 种：</p>
<ul>
<li>赋值初始化</li>
<li>圆括号初始化</li>
<li>列表初始化</li>
</ul>
<blockquote>
<p>列表初始化如果出现<code>narrowing  conversions</code>，则编译器很可能报错！<br>比如 msvc 和 clang 都会报错，gcc 则会报 warning……</p>
</blockquote>
<h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>而对于对象初始化，这 3 种初始化方式差异就很大了，比如说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w1; 	<span class="comment">//使用默认构造函数，初始化对象</span></span><br><span class="line">Widget w2 = w1;<span class="comment">//使用拷贝构造函数，初始化对象</span></span><br><span class="line">w1 = w2;<span class="comment">//使用赋值重载方法（拷贝赋值）来赋值 w1</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//使用列表初始化，为容器内的对象设定初始值</span></span><br></pre></td></tr></table></figure>

<p>同样是对内置类型的初始化，在类声明中对内置类型使用圆括号初始化就会出错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j&#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//错误！</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">k</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="title">widget</span>;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还没完，在使用<code>std::atomic&lt;T&gt;</code>初始化对象时，赋值初始化也会出错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt; i&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">j</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//错误！</span></span><br><span class="line">    std::atomic&lt;<span class="keyword">int</span>&gt; k = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这就可以看出来：使用<strong>列表初始化</strong>来初始化内置类型是一个在各种环境下都正确的做法。</p>
<p>列表初始化对于对象来讲，也是相对安全的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;default construct -&gt; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用默认构造函数</span></span><br><span class="line">    <span class="function">Widget <span class="title">widget1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//这里实际上是声明了一个函数，参数为空，返回类型为 Widget ……</span></span><br><span class="line">    <span class="function">Widget <span class="title">widget2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//而使用列表初始化，就可以调用默认构造函数</span></span><br><span class="line">    Widget widget3&#123;&#125;;</span><br><span class="line">    Widget widget4&#123;<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="列表初始化的缺陷"><a href="#列表初始化的缺陷" class="headerlink" title="列表初始化的缺陷"></a>列表初始化的缺陷</h2><p>从上面的例子来看，列表初始化似乎是在初始化变量和对象时的完美解决方案，但实际上它也有一些限制……</p>
<h3 id="使用-auto-推导"><a href="#使用-auto-推导" class="headerlink" title="使用 auto 推导"></a>使用 auto 推导</h3><p>使用<code>auto</code>推导以列表初始化形式初始化的变量时，得到的是<code>std::initializer_list&lt;T&gt;</code>类型。</p>
<h3 id="对构造函数的调用"><a href="#对构造函数的调用" class="headerlink" title="对构造函数的调用"></a>对构造函数的调用</h3><h4 id="没有初始化列表构造函数时"><a href="#没有初始化列表构造函数时" class="headerlink" title="没有初始化列表构造函数时"></a>没有初始化列表构造函数时</h4><p>使用列表初始化方式初始化的对象，总是倾向于调用列表初始化形式的构造函数，<strong>而不会理会参数的匹配度！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 在没有列表初始化构造函数的情况下，使用列表初始化能够匹配到正确的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Widget <span class="title">widget1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Widget widget3&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Widget <span class="title">widget2</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    Widget widget4&#123;<span class="number">3</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有列表初始化函数时"><a href="#有列表初始化函数时" class="headerlink" title="有列表初始化函数时"></a>有列表初始化函数时</h4><p>当类有列表初始化构造函数后，情况就不同了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="keyword">double</span>&gt; val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;third construct :\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : val)&#123;</span><br><span class="line">            std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 在有列表初始化构造函数的情况下，使用列表初始化会强制调用列表初始化形式的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//调用第1个构造函数</span></span><br><span class="line">    <span class="function">Widget <span class="title">widget1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">//调用第3个构造函数</span></span><br><span class="line">    Widget widget3&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用第2个构造函数</span></span><br><span class="line">    <span class="function">Widget <span class="title">widget2</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//调用第3个构造函数</span></span><br><span class="line">    Widget widget4&#123;<span class="number">3</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>int</code>类型被转换成了<code>double</code>类型。</p>
<blockquote>
<p> 但如果<code>std::initializer_list&lt;T&gt;</code>中的元素为<code>int</code>时，编译器就会报错，因为损失了信息在列表初始化情况下编译器不予通过。</p>
</blockquote>
<p>即使对于拷贝构造和移动语义也是如此：</p>
<blockquote>
<p>使用 g++ 编译验证，但使用 msvc ，widget7{widget1} 会依然调用拷贝构造函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;<span class="keyword">double</span>&gt; val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;third construct :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : val)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; w) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy construct\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp;&amp; w) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move construct\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i &quot;</span> &lt;&lt; i_ &lt;&lt; <span class="string">&quot; j &quot;</span> &lt;&lt; j_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (i_ + j_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i_;</span><br><span class="line">    <span class="keyword">int</span> j_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 在有列表初始化构造函数的情况下，使用列表初始化会强制调用列表初始化形式的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget1:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget3:&quot;</span>;</span><br><span class="line">    Widget widget3&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget2:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget2</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget4:&quot;</span>;</span><br><span class="line">    Widget widget4&#123;<span class="number">3</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget5:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget5</span><span class="params">(widget1)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget6:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget6</span><span class="params">(std::move(widget2))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget7:&quot;</span>;</span><br><span class="line">    <span class="comment">//在有转换函数的情况下，先使用转换函数，然后调用初始化列表构造函数</span></span><br><span class="line">    Widget widget7&#123;widget1&#125;;</span><br><span class="line">    widget7.<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget8:&quot;</span>;</span><br><span class="line">    Widget widget8&#123;std::<span class="built_in">move</span>(widget2)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当类中有转换函数时，使用列表初始化传入另一个对象，就会调用列表初始化构造函数。</p>
<blockquote>
<p>但如果类中没有转换函数，还是会调用拷贝构造函数</p>
</blockquote>
<h4 id="初始值无法转换时"><a href="#初始值无法转换时" class="headerlink" title="初始值无法转换时"></a>初始值无法转换时</h4><p><strong>当初始值不能转换为初始化列表的元素值时，就会调用其他最为匹配的构造函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">int</span> j): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;std::string&gt; val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;third construct :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : val)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; w) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy construct\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i &quot;</span> &lt;&lt; i_ &lt;&lt; <span class="string">&quot; j &quot;</span> &lt;&lt; j_ &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;operator ()\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> (i_ + j_);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i_;</span><br><span class="line">    <span class="keyword">int</span> j_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 虽然有初始值列表构造函数，但类型无法转换，那么也会调用最匹配的构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget1:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget3:&quot;</span>;</span><br><span class="line">    Widget widget3&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget2:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget2</span><span class="params">(<span class="number">1</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget4:&quot;</span>;</span><br><span class="line">    Widget widget4&#123;<span class="number">3</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create widget1:first construct i: 1 j: 2</span><br><span class="line">create widget3:first construct i: 3 j: 4</span><br><span class="line">create widget2:second construct i: 1 j: 2</span><br><span class="line">create widget4:second construct i: 3 j: 4</span><br></pre></td></tr></table></figure>

<h4 id="当初始值列表为空时"><a href="#当初始值列表为空时" class="headerlink" title="当初始值列表为空时"></a>当初始值列表为空时</h4><p>当初始值列表为空时，就会调用默认构造函数。如果想要显示的调用初始值列表构造函数，那就需要使用圆括号或花括号把这个初始值列表再包含一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> j = <span class="number">0</span>): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;first construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j): <span class="built_in">i_</span>(i), <span class="built_in">j_</span>(j) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;second construct i: &quot;</span> &lt;&lt; i  &lt;&lt; <span class="string">&quot; j: &quot;</span>&lt;&lt; j &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(std::initializer_list&lt;std::string&gt; val) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;third construct :&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : val)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; w) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy construct\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::<span class="built_in">memcpy</span>(<span class="keyword">this</span>, &amp;w, <span class="built_in"><span class="keyword">sizeof</span></span>(w));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i_;</span><br><span class="line">    <span class="keyword">int</span> j_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget1:&quot;</span>;</span><br><span class="line">    Widget widget1; <span class="comment">//默认构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget2:&quot;</span>;</span><br><span class="line">    Widget widget2&#123;&#125;;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget3:&quot;</span>;</span><br><span class="line">    <span class="function">Widget <span class="title">widget3</span><span class="params">(&#123;&#125;)</span></span>;<span class="comment">//显示调用初始值列表构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;create widget4:&quot;</span>;</span><br><span class="line">    Widget widget4&#123;&#123;&#125;&#125;;<span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对-vector-初始化的理解"><a href="#对-vector-初始化的理解" class="headerlink" title="对 vector 初始化的理解"></a>对 vector 初始化的理解</h3><p>基于上面的理解，就能够明白<code>vector</code>初始化使用圆括号和使用初始值列表的意义了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;<span class="comment">//创建具有 5 个元素，且每个元素值为 10 的 vector</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">5</span>, <span class="number">100</span>&#125;;<span class="comment">//创建具有两个元素，且值依次为 5， 100 的 vector</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of v1 is &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v: v1) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The size of v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v: v2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="static-对象的初始化"><a href="#static-对象的初始化" class="headerlink" title="static 对象的初始化"></a><code>static</code> 对象的初始化</h1><p>除了上面所说的规则外，还有一个是<code>static</code>对象需要被注意，这包括：</p>
<ul>
<li>全局对象：non-local static</li>
<li>定义域<code>namespace</code>作用域内的对象：non-local static</li>
<li>在类内的对象：non-local static</li>
<li>在函数内的对象：local static</li>
<li>在文件作用域的对象：non-local static</li>
</ul>
<p>如果<code>non-local static</code>的对象，处于不同的文件中，那么他们的<a href="https://en.cppreference.com/w/cpp/language/initialization">初始化顺序是未定的！</a>。</p>
<p>相当于编译器生成了目标文件，在最后链接的过程中，并不能保证对象按照严格的顺序进行初始化。</p>
<p>所以就很可能会出现让人抓瞎的问题：</p>
<blockquote>
<p> 如果一个<code>non-local static</code>对象在使用另外一个<code>non-local static</code>对象，如果另外一个<code>non-local static</code>对象还未被初始化，那最终的行为就是未定义的。</p>
</blockquote>
<p>解决上面这个问题最简单的办法就是使用单例模式：</p>
<blockquote>
<p>如果希望存在这样一个<code>non-local static</code>对象，那么我们就将它做成单例模式，也就是只有单个对象的存在。</p>
<p>这样其他对象在使用它时，会调用<code>GetInstance()</code>这种方法来获取对象，而在函数中会必然保证该对象会被初始化。这样也就保证了初始化顺序。</p>
<p>如果该对象一直未被使用，那么也不会初始化该对象，相当于还节约了内存。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：管理资源</title>
    <url>/2022/04/17/effective_cpp_obj_resource/</url>
    <content><![CDATA[<p>这里的资源主要是：内存、文件描述符、互斥锁、数据库连接、socket 等，一旦不使用它们，都要归还给系统。</p>
<span id="more"></span>

<h1 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h1><p>首先在编写一个类的时候，就需要在它的析构函数中仔细整理它需要释放的资源。</p>
<p>而在使用对象时，需要使用 RAII 类来管理这些资源，比如智能指针。</p>
<p>编写 RAII 类时，除了管理原始资源外，还需要提供接口<code>get()</code>来获取原始资源。</p>
<p>因为一些 C API 是需要操作原始资源的。</p>
<h1 id="小心资源管理类中的拷贝行为"><a href="#小心资源管理类中的拷贝行为" class="headerlink" title="小心资源管理类中的拷贝行为"></a>小心资源管理类中的拷贝行为</h1><p>假设用一个类以 RAII 的方式来管理互斥量：</p>
<ul>
<li>在构造函数中获取锁</li>
<li>在析构函数中释放锁</li>
</ul>
<p>那么就这样定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutex_(pm) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123;</span><br><span class="line">        <span class="built_in">unlock</span>(mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Mutex* mutex_ = <span class="literal">nullptr</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后这样使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//传入锁的地址同时创建 RAII 对象，即可获得锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 退出区块后，调用 m1 析构函数释放锁</span></span><br></pre></td></tr></table></figure>

<p>但是如果对 RAII 对象进行了拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//传入锁的地址同时创建 RAII 对象，即可获得锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line">    <span class="comment">// 调用拷贝构造函数，如果拷贝构造函数里面也获取锁，便会造成死锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果拷贝构造里面没有获取锁，但是析构里面也会释放锁，就会出现重复释放</span></span><br></pre></td></tr></table></figure>

<p>对此的应对方法有以下几种：</p>
<h2 id="禁止拷贝"><a href="#禁止拷贝" class="headerlink" title="禁止拷贝"></a>禁止拷贝</h2><p>可以对拷贝构造和拷贝赋值函数使用<code>delete</code>关键字，以禁止拷贝操作的合理性。</p>
<h2 id="使用引用计数"><a href="#使用引用计数" class="headerlink" title="使用引用计数"></a>使用引用计数</h2><p>将需要被保护的资源使用<code>shared_ptr</code>管理起来，便可以基于引用计数来完成合理申请和释放。</p>
<blockquote>
<p>需要注意的是：<code>shared_ptr</code>的默认行为在计数为 0 时是删除其指定资源，而对于像互斥量这样的资源。<strong>我们希望的是释放锁，而不是删除锁。</strong></p>
<p>这种情况下，就需要为<code>shared_ptr</code>指定删除器。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 指定 shared_ptr 的删除器是 unlock 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutex_(pm, unlock) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutex_.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lock</span>() &#123;</span><br><span class="line">		<span class="comment">// 有了智能指针，析构函数就不需要主动释放了</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutex_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="复制底部资源"><a href="#复制底部资源" class="headerlink" title="复制底部资源"></a>复制底部资源</h2><p>对类管理的资源进行深拷贝，也可以避免这个问题。</p>
<p>比如对互斥量资源进行深拷贝，相当于又新建了一个互斥量。</p>
<h2 id="转移底部资源的拥有权"><a href="#转移底部资源的拥有权" class="headerlink" title="转移底部资源的拥有权"></a>转移底部资源的拥有权</h2><p>这就相当于使用了移动语义，以转移资源的所有权。</p>
<h1 id="使用-new-和-delete-时要采取相同形式"><a href="#使用-new-和-delete-时要采取相同形式" class="headerlink" title="使用 new 和 delete 时要采取相同形式"></a>使用 <code>new</code> 和 <code>delete</code> 时要采取相同形式</h1><p><code>new</code>和<code>delete</code>要成对使用，<code>new[]</code>和<code>delete[]</code>也是要一一对应成对使用。</p>
<blockquote>
<p>如果 new[] 对应 delete，那 delete 操作很可能因为不知道应该释放多少资源而导致内存泄漏。</p>
<p>反之，如果 new 对应 delete[]，那 delete 操作可能误认为会多次释放而释放了其他不属于自己的资源。</p>
</blockquote>
<h1 id="以独立语句将-newed-对象置入智能指针"><a href="#以独立语句将-newed-对象置入智能指针" class="headerlink" title="以独立语句将 newed 对象置入智能指针"></a>以独立语句将 newed 对象置入智能指针</h1><p>假设有一个函数接口是这样设计的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessWidget</span><span class="params">(std::shared_ptr&lt;Wdiget&gt; pw, Window win)</span></span>;</span><br></pre></td></tr></table></figure>

<p>然后进行调用时是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ProcessWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget), win);</span><br></pre></td></tr></table></figure>

<p>那么编译器在进行参数传递时，有可能会以以下顺序进行传递：</p>
<ul>
<li>申请内存，使用<code>new Widget</code></li>
<li>创建临时对象 <code>win</code></li>
<li>将第一步的地址传递给智能指针</li>
</ul>
<p>那么假设，在创建临时对象<code>win</code>是发生了异常而导致中断操作，那么第一步所申请的内存就没有被智能指针所接管。造成了<strong>很难排查的内存泄漏</strong>！</p>
<p>所以应该养成好的习惯：先创建智能指针，再进行调用：</p>
<blockquote>
<p>或者使用 <code>std::make_unique</code> 和 <code>std::make_shared 来替代</code> <code>new</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ProcessWidget</span>(pw, win);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：赋值重载的注意点</title>
    <url>/2022/04/15/effective_cpp_operator=/</url>
    <content><![CDATA[<p>复制重载涉及到拷贝赋值和移动赋值两种情况，有些点需要注意一下。</p>
<span id="more"></span>

<h1 id="让-operator-类重载返回-this-引用"><a href="#让-operator-类重载返回-this-引用" class="headerlink" title="让 operator=类重载返回 *this 引用"></a>让 <code>operator=</code>类重载返回 <code>*this</code> 引用</h1><p>为了满足连续赋值的需求，赋值重载方法需要返回对象。</p>
<p>而为了能够提高效率，返回它的引用是个好习惯。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// +=, -=, *= 这类函数重载都要满足连续赋值要求</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使参数类型不同，也需要满足连续赋值</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span> rhs) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="在-operator-中处理自我赋值"><a href="#在-operator-中处理自我赋值" class="headerlink" title="在 operator=中处理自我赋值"></a>在 <code>operator=</code>中处理自我赋值</h1><p>在实现拷贝赋值的过程中，需要处理自我赋值（自己给自己赋值）这种特殊情况。</p>
<blockquote>
<p>当存在别名这种情况下，自我赋值还是会比较容易发生的。</p>
</blockquote>
<p>比如，当向一个含有指针的类进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)&#123;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 如果没有上面判断，那么当自我赋值时，便会删除自己指向的内存</span></span><br><span class="line">            <span class="comment">// 接下来的操作结果便是未定义的</span></span><br><span class="line">            <span class="keyword">delete</span>[] str_;</span><br><span class="line"></span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="keyword">char</span>[str.len_];</span><br><span class="line">            std::<span class="built_in">memcpy</span>(str_, str.str_, str.len_);</span><br><span class="line">            len_ = str.len_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> len_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *str_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是上面的处理方式仍然有不足之处：</p>
<ul>
<li>如果<code>new</code>操作无法申请需求的内存而抛出异常，那么这个类的<code>str_</code>所指向的内存就会被保持被删除的状态，接下来的其他操作将会出现奇怪的行为。</li>
</ul>
<p>使用下面的方式便可以处理异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    	<span class="built_in">MyString</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">            <span class="keyword">int</span> str_len = std::<span class="built_in">strlen</span>(str);</span><br><span class="line">            <span class="keyword">if</span>(str_len == <span class="number">0</span>) &#123;</span><br><span class="line">                len_ = <span class="number">1</span>;</span><br><span class="line">                str_ = <span class="keyword">new</span> <span class="keyword">char</span>[len_];</span><br><span class="line">                str_[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                len_ = str_len + <span class="number">1</span>;</span><br><span class="line">                str_ = <span class="keyword">new</span> <span class="keyword">char</span>[len_];</span><br><span class="line">                std::<span class="built_in">memcpy</span>(str_, str, len_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">        MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">            <span class="comment">// 先使用一个副本指向当前指针指向的内存</span></span><br><span class="line">            <span class="keyword">char</span>* str_tmp = str_;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里使用构造函数</span></span><br><span class="line">            <span class="comment">// 如果此处 new 抛出异常，则不会对当前对象有任何影响</span></span><br><span class="line">            str_ = <span class="keyword">new</span> <span class="built_in">MyString</span>(str.str_);</span><br><span class="line">            <span class="comment">// 删除副本的内存</span></span><br><span class="line">            <span class="keyword">delete</span>[] str_tmp;</span><br><span class="line"></span><br><span class="line">            len_ = str.len_;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> len_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> *str_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，即避免了自我赋值的问题，也避免了抛出异常的问题。</p>
<blockquote>
<p>对于移动赋值，也需要考虑自我赋值的问题，但一般不会遇到抛出异常问题。因为移动赋值通常要声明为 noexcept 形式，已让 vector 这种容器使用。</p>
</blockquote>
<h1 id="注意要复制对象的每个成分"><a href="#注意要复制对象的每个成分" class="headerlink" title="注意要复制对象的每个成分"></a>注意要复制对象的每个成分</h1><ul>
<li>拷贝函数应该确保复制对象内的所有成员变量，以及<strong>所有父类的成分</strong></li>
<li>通常拷贝构造和拷贝赋值函数有一部分重复代码，这个时候增加一个私有的函数是个好办法</li>
</ul>
<p>对于第一点的示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">Customer</span>(<span class="keyword">const</span> Customer&amp; rhs): <span class="built_in">name</span>(rhs.name) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs) &#123;</span><br><span class="line">        name = rhs.name;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs), <span class="comment">// 调用基类的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">priority</span>(rhs.priority) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">PriorityCustomer&amp; <span class="title">PriorityCustomer</span><span class="params">(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span> </span>&#123;</span><br><span class="line">        Customer::<span class="keyword">operator</span>=(rhs); <span class="comment">//调用基类的拷贝赋值函数</span></span><br><span class="line">        priority = rhs.priority;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：不要创建通用引用的重载函数</title>
    <url>/2022/05/09/effective_cpp_overload_reference/</url>
    <content><![CDATA[<p>创建通用引用的重载函数，但很多时候还是会调用到通用引用函数，这会让人很迷惑。</p>
<span id="more"></span>

<h1 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h1><p>假设我们要实现一个函数，用于存入传递进来的<code>std::string</code>，普通版本如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::multiset&lt;std::string&gt; names;     <span class="comment">// global data structure</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">const</span> std::string&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now =                          <span class="comment">// get current time</span></span><br><span class="line">    std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);              <span class="comment">// make log entry</span></span><br><span class="line">  names.<span class="built_in">emplace</span>(name);                <span class="comment">// add name to global data</span></span><br><span class="line">&#125;                                     <span class="comment">// structure; </span></span><br></pre></td></tr></table></figure>

<p>在使用的时候如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">petName</span><span class="params">(<span class="string">&quot;Darla&quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">logAndAdd</span>(petName);                   <span class="comment">// pass lvalue std::string</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Persephone&quot;</span>)); <span class="comment">// pass rvalue std::string</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(<span class="string">&quot;Patty Dog&quot;</span>);               <span class="comment">// pass string literal</span></span><br></pre></td></tr></table></figure>

<p>第一种情况传入的是左值，且形参<code>name</code>也是左值，它以拷贝的方式加入全局变量<code>names</code>。</p>
<p>第二种情况创建了临时对象传递给<code>name</code>，形参<code>name</code>是左值，它以拷贝的方式加入全局变量<code>names</code>。但这种情况下，我们实际上是可以以移动的方式加入<code>names</code>的。</p>
<p>第三种情况隐式通过字面值字符串创建了临时对象给<code>name</code>，与第二种情况一样，它们也是可以以移动的方式加入<code>names</code>的。</p>
<p>所以以上第二、三种情况都可以被优化。</p>
<h1 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h1><p>当传入的参数是左值时，使用拷贝。当传入的参数是右值时，使用移动。那么基于通用引用的<code>std::forward</code>转换便是一个比较好的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">  names.<span class="built_in">emplace</span>(std::forward&lt;T&gt;(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用上面这个函数模板后，第一种情况依然以拷贝方式加入全局变量<code>names</code>。而第二、三种情况则是以移动的方式加入<code>names</code>。</p>
<h1 id="加入重载"><a href="#加入重载" class="headerlink" title="加入重载"></a>加入重载</h1><p>下面假设，用户可以查询索引的方式传入字符串，那么<code>logAndAdd</code>就需要一个重载版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">nameFromIdx</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;      <span class="comment">// return name corresponding to idx new overload</span></span><br><span class="line">                                       </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> now = std::chrono::system_clock::<span class="built_in">now</span>();</span><br><span class="line">  <span class="built_in">log</span>(now, <span class="string">&quot;logAndAdd&quot;</span>);</span><br><span class="line">  names.<span class="built_in">emplace</span>(<span class="built_in">nameFromIdx</span>(idx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么要调用该函数的方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">logAndAdd</span>(<span class="number">22</span>);                         <span class="comment">// calls int overload</span></span><br></pre></td></tr></table></figure>

<p>但如果传入一个变量，便会出错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> nameIdx;</span><br><span class="line">…                                      <span class="comment">// give nameIdx a value</span></span><br><span class="line"><span class="built_in">logAndAdd</span>(nameIdx);                    <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>这是因为，当传入的参数是<code>short</code>时，函数模板就将<code>T</code>推导成了<code>short</code>，虽然<code>int</code>版本的重载函数也可以接受<code>short</code>类型，但是函数模板的推导结果更为准确。最终<code>short</code>无法构造出<code>std::string</code>而导致报错。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：如果拷贝和移动的负担很小，那么考虑使用拷贝</title>
    <url>/2022/05/14/effective_cpp_pass_by_value/</url>
    <content><![CDATA[<p>为了兼顾性能和功能性，有些类会提供拷贝和移动两个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(<span class="keyword">const</span> std::string&amp; newName)</span>    <span class="comment">// take lvalue;</span></span></span><br><span class="line"><span class="function">  </span>&#123; names.<span class="built_in">push_back</span>(newName); &#125;               <span class="comment">// copy it</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(std::string&amp;&amp; newName)</span>         <span class="comment">// take rvalue;</span></span></span><br><span class="line"><span class="function">  </span>&#123; names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName)); &#125;    <span class="comment">// move it;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;std::string&gt; names;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>使用完美转发来实现一个简易版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                          <span class="comment">// take lvalues</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(T&amp;&amp; newName)</span>                     <span class="comment">// and rvalues;</span></span></span><br><span class="line"><span class="function">  </span>&#123;                                             <span class="comment">// copy lvalues,</span></span><br><span class="line">    names.<span class="built_in">push_back</span>(std::forward&lt;T&gt;(newName));  <span class="comment">// move rvalues;</span></span><br><span class="line">  &#125;                                             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但通用引用可以接收各种类型的参数，这在传入错误的参数时，编译器的报错信息会异常繁琐。其实还有更好的选择。</p>
<span id="more"></span>

<p>如果使用值传递：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addName</span><span class="params">(std::string newName)</span>           <span class="comment">// take lvalue or</span></span></span><br><span class="line"><span class="function">  </span>&#123; names.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(newName)); &#125;    <span class="comment">// rvalue; move it</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于 c++ 11，如果传入的参数是左值，则会进行一次拷贝构造。而如果传入的是右值，则进行的是移动构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">name</span><span class="params">(<span class="string">&quot;Bart&quot;</span>)</span></span>;</span><br><span class="line">w.<span class="built_in">addName</span>(name);                 <span class="comment">// call addName with lvalue</span></span><br><span class="line"></span><br><span class="line">w.<span class="built_in">addName</span>(name + <span class="string">&quot;Jenne&quot;</span>);       <span class="comment">// call addName with rvalue</span></span><br></pre></td></tr></table></figure>

<p>下面比较这 3 种方法的性能：</p>
<ul>
<li>拷贝构造和移动构造：传入左值时，会进行一次拷贝。传入右值时，会进行一次移动。</li>
<li>完美转发构造：完美转发会匹配对应的左值和右值函数，所以性能和方法 1 一样</li>
<li>值传递：传入左值时，一次拷贝加一次移动。传入右值时，两次移动<ul>
<li>首先是构造形参，传入左值时，会调用拷贝构造函数。传入右值时，会调用移动构造函数（<code>std::string</code>具有移动构造函数）。</li>
<li>然后是将形参移动到内部容器中</li>
</ul>
</li>
</ul>
<p>可以看到，方法 3 相比方法 1，2 多了一次移动操作，如果移动操作耗时很低，那么可以考虑使用方法 3。</p>
<p>因为方法 3 足够简单，阅读性也好。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：const,enum,inline 优于 define</title>
    <url>/2022/04/10/effective_cpp_prefer_const_to_define/</url>
    <content><![CDATA[<p>宏在 c++ 中要尽可能少的使用，在<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#preprocessor-macros">google c++ 编码规范中</a>也是建议使用宏要谨慎。</p>
<span id="more"></span>

<h1 id="宏的弊端"><a href="#宏的弊端" class="headerlink" title="宏的弊端"></a>宏的弊端</h1><h2 id="宏无法产生符号"><a href="#宏无法产生符号" class="headerlink" title="宏无法产生符号"></a>宏无法产生符号</h2><p>由于宏是在预编译过程中进行替换的，那么在随后生成的目标文件/可执行文件中，就不会包含有该宏的符号。这在某些调试的情况下，不那么方便。</p>
<p>比如下面的示例，先使用宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATION (1.653f)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> val = ASPECT_RATION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么在符号表中无法找到该符号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">~/lab/cpp$</span><span class="bash"> readelf -s a.out | grep <span class="string">&quot;ASPECT_RATION&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>下面使用 <code>const</code> 变量来替换宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> kAspectRation = <span class="number">1.653f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> val = kAspectRation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以找到符号表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">~/lab/cpp$</span><span class="bash"> readelf -s a.out | grep <span class="string">&quot;kAspectRation&quot;</span></span></span><br><span class="line">    37: 0000000000000838     4 OBJECT  LOCAL  DEFAULT   16 _ZL13kAspectRation</span><br></pre></td></tr></table></figure>

<h2 id="写宏时需要小心翼翼"><a href="#写宏时需要小心翼翼" class="headerlink" title="写宏时需要小心翼翼"></a>写宏时需要小心翼翼</h2><p>宏展开后的真实代码和我们以为的代码可能会不同，遇到这种问题还需要去查看预编译后的文件才能清楚。</p>
<p>所以写宏的时候需要小心翼翼，尤其是宏内容较复杂，有多个换行的情况下。这无疑是增加了程序员的负担。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The maximum is &quot;</span> &lt;&lt; <span class="built_in">MAX</span>(++a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如上面这个宏，除了要注意使用括号外，最终得到的结果也是非预期的。</p>
<blockquote>
<p>以为返回的是 11，结果返回了 12……</p>
</blockquote>
<h2 id="宏没有类内范围性"><a href="#宏没有类内范围性" class="headerlink" title="宏没有类内范围性"></a>宏没有类内范围性</h2><p>比如我们只想在类内使用该宏，但其实它的作用范围已经超出了宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> NUM_TURNS   (5)</span></span><br><span class="line">        <span class="keyword">int</span> scores_[NUM_TURNS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GamePlayer::GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(scores_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GamePlayer game_player;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of array is &quot;</span> &lt;&lt; game_player.<span class="built_in">GetArraySize</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;macro value &quot;</span> &lt;&lt; NUM_TURNS &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用常量替换-define"><a href="#使用常量替换-define" class="headerlink" title="使用常量替换 #define"></a>使用常量替换 <code>#define</code></h1><h2 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h2><p>通常使用常量来替换<code>#define</code>时，为了常量可以被多个文件所使用，需要将其放在头文件内。</p>
<p>对于想要定义常量字符串，有两种做法：</p>
<ul>
<li><p>定义指向常量字符串的常量指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kAuthorName = <span class="string">&quot;Scott Meyers&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>定义常量<code>string</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> std::string <span class="title">kAuthorName</span><span class="params">(<span class="string">&quot;Scott Meyers&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>定义常量<code>string</code>对象是更加合适的方法，因为不仅由于其不是指针而更好操作外，而且它还具有一系列成员函数，能满足更多的适用场合。</p>
<h2 id="类内的常量"><a href="#类内的常量" class="headerlink" title="类内的常量"></a>类内的常量</h2><p>当仅需要在类内定义一个常量时，则需要在类的内部使用<code>static const</code>来修饰它：</p>
<blockquote>
<p><code>static</code>修饰是为了在多个类中，仅占用一个变量的空间。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">// 如果不取 static 常量的地址，则无需提供定义</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> num_turns_ = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> scores_[num_turns_];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GamePlayer::GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(scores_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GamePlayer game_player;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of array is &quot;</span> &lt;&lt; game_player.<span class="built_in">GetArraySize</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方式是使用枚举来完成常量的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> &#123;</span>kNumTurns = <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> scores_[kNumTurns];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GamePlayer::GetArraySize</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">sizeof</span></span>(scores_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    GamePlayer game_player;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of array is &quot;</span> &lt;&lt; game_player.<span class="built_in">GetArraySize</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用内联函数替代宏函数"><a href="#使用内联函数替代宏函数" class="headerlink" title="使用内联函数替代宏函数"></a>使用内联函数替代宏函数</h1><p>使用<code>inline</code>函数则可以避免宏运行时无法预期的问题：</p>
<blockquote>
<p>其实用不用<code>inline</code>在绝大部分情况下都不影响。<br>所以简单粗暴的说应该是，使用函数来代替宏函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">Max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于调用的是函数，所以这里 a 只会被加一次，完全符合语义</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max is &quot;</span> &lt;&lt; <span class="built_in">Max</span>(++a, b) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;value of a is &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：区分通用引用和右值引用</title>
    <url>/2022/05/06/effective_cpp_reference/</url>
    <content><![CDATA[<p>声明一个右值引用，使用<code>T&amp;&amp;</code>这种格式，但是这玩意并不是表面上看到的那么简单。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>;             <span class="comment">// 右值引用</span></span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">Widget</span>();           <span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;                 <span class="comment">// 通用引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;     <span class="comment">// 右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;                  <span class="comment">// 通用引用</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h1 id="T-amp-amp-的意义"><a href="#T-amp-amp-的意义" class="headerlink" title="T&amp;&amp;的意义"></a><code>T&amp;&amp;</code>的意义</h1><p><code>T&amp;&amp;</code>实际上具有两种意义：</p>
<ul>
<li>一种意义是其代表的是右值引用，具有满足移动语义的可能性</li>
<li>一种意义是它既可以是右值引用，也可以是左值引用。它可以绑定多种类型<code>const</code>或非<code>const</code>，<code>volatile</code>或非<code>volatile</code>等等，所以也将其称为通用引用。</li>
</ul>
<h1 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h1><p>通用引用出现在两种场合。</p>
<p>一种是作为函数模板的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;             <span class="comment">// param is a universal reference</span></span><br></pre></td></tr></table></figure>

<p>一种是使用<code>auto</code>做推导时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;            <span class="comment">// var2 is a universal reference</span></span><br></pre></td></tr></table></figure>

<p>可以看到，通用引用都是出现在有推导的情况下，也就是说它们到底最终是左右还是右值引用，得要更具传入的参数或给其赋值的对象而决定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="built_in">f</span>(w);                  <span class="comment">// lvalue passed to f; param&#x27;s type is</span></span><br><span class="line">                       <span class="comment">// Widget&amp; (i.e., an lvalue reference)</span></span><br><span class="line"><span class="built_in">f</span>(std::<span class="built_in">move</span>(w));       <span class="comment">// rvalue passed to f; param&#x27;s type is</span></span><br><span class="line">                       <span class="comment">// Widget&amp;&amp; (i.e., an rvalue reference)</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>通用引用必须要严格遵从<code>T&amp;&amp;</code>的格式</strong>。</p>
<blockquote>
<p><code>auto</code>也是同理，遵从<code>auto&amp;&amp;</code>格式，也是通用引用。</p>
</blockquote>
<p>比如以下两种都是右值引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">// param is an rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>;         <span class="comment">// param is an rvalue reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;T&gt;&gt;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span>                                     </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//虽然 push_back 满足 T&amp;&amp;，但是其并没有推导过程</span></span><br><span class="line">  <span class="comment">//而是由对象创建时指明给类的（std::vector&lt;widget&gt; v;）</span></span><br><span class="line">  <span class="comment">//所以它还是一个右值引用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于<code>push_back</code>并没有推导过程，所以其不是通用引用，但是<code>emplace_back</code>因为有推导过程，所以它是通用引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;T&gt;&gt;  <span class="comment">// still from</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span>                                     <span class="comment">// C++</span></span><br><span class="line"><span class="keyword">public</span>:                                            <span class="comment">// Standards</span></span><br><span class="line">  <span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：理解引用折叠</title>
    <url>/2022/05/11/effective_cpp_reference_collapsing/</url>
    <content><![CDATA[<p>如果一个模板函数的形参是通用引用，那么：</p>
<ol>
<li>如果传入的实参是左值，那么推导出来的形参就是左值引用</li>
<li>如果传入的实参是右值，那么推导出来的形参就是<strong>不带引用的普通形参</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">widgetFactory</span><span class="params">()</span></span>;     <span class="comment">// function returning rvalue</span></span><br><span class="line">Widget w;                   <span class="comment">// a variable (an lvalue)</span></span><br><span class="line"><span class="built_in">func</span>(w);                    <span class="comment">// call func with lvalue; T deduced</span></span><br><span class="line">                            <span class="comment">// to be Widget&amp;</span></span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">widgetFactory</span>());      <span class="comment">// call func with rvalue; T deduced</span></span><br><span class="line">                            <span class="comment">// to be Widget</span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h1 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h1><p>但是为什么在里面加上<code>std::forward</code>却又可以区分出来左值引用和右值引用？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunc</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is lvalue!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunc</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is rvalue!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">SomeFunc</span>(std::forward&lt;T&gt;(param));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v1&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Func</span>(v1);</span><br><span class="line">    <span class="built_in">Func</span>(std::vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的推导逻辑，在编译器内部就叫做引用折叠（<code>reference collapsing</code>）,也就是两个引用化简为一个引用。</p>
<p>既然引用分为左值和右值引用，那么就会有 4 种组合：</p>
<ol>
<li>两个左值引用</li>
<li>一个左值引用，一个右值引用</li>
<li>一个右值引用，一个左值引用</li>
<li>两个右值引用</li>
</ol>
<p>其化简原则如下：</p>
<ul>
<li>只要其中一个是左值引用，那么结果就是左值引用</li>
<li>只有两个都是右值引用时，结果才是右值引用</li>
</ul>
<p>好了，现在来看<code>std::forward</code>的简易实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                                <span class="comment">// in</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span>                                <span class="comment">// namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">              remove_reference&lt;T&gt;::type&amp; param)</span>     <span class="comment">// std</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来推导传入左值的情况，当传入的是<code>v1</code>按照前面的规则，则<code>param</code>会被推导为<code>std::vector&lt;int&gt;&amp;</code>，那么对于<code>forward</code>就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt;&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span>                                </span></span></span><br><span class="line"><span class="params"><span class="function">              remove_reference&lt;std::vector&lt;<span class="keyword">int</span>&gt;&amp;&gt;::type&amp; param)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="keyword">int</span>&gt;&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么按照引用折叠的规则，最终返回的就是<code>std::vector&lt;int&gt;&amp;</code>。</p>
<p>而如果传入的是右值，那么<code>param</code>会被推导为<code>std::vector&lt;int&gt;</code>，对于<code>forward</code>就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span>                                </span></span></span><br><span class="line"><span class="params"><span class="function">              remove_reference&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;::type&amp; param)</span>     </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;std::vector&lt;<span class="keyword">int</span>&gt; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，不会发生引用折叠，那么就直接返回一个右值引用即可。</p>
<h1 id="引用折叠发生的场景"><a href="#引用折叠发生的场景" class="headerlink" title="引用折叠发生的场景"></a>引用折叠发生的场景</h1><p>引用折叠发生在以下 4 种场景种：</p>
<ol>
<li>模板推导过程种</li>
<li><code>auto</code>推导</li>
<li>使用<code>typedef</code></li>
<li>使用<code>decltype</code></li>
</ol>
<h2 id="auto推导"><a href="#auto推导" class="headerlink" title="auto推导"></a><code>auto</code>推导</h2><p><code>auto</code>推导和模板推导很类似：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;                   <span class="comment">// a variable (an lvalue)</span></span><br><span class="line"><span class="comment">// 首先 w 被 auto 推导为 Widget&amp;</span></span><br><span class="line"><span class="comment">// 然后展开就是 Widget&amp; &amp;&amp; w1 = w;</span></span><br><span class="line"><span class="comment">// 最终就是 Widget&amp; w1 = w;</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先临时变量被 auto 推导为 Widget</span></span><br><span class="line"><span class="comment">// 展开就是最终情况 Widget&amp;&amp; w2 = WidgetFactory();</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; w2 = <span class="built_in">WidgetFactory</span>();</span><br></pre></td></tr></table></figure>

<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a><code>typedef</code></h2><p>假设有一个模板类设计如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么传入的参数不同，则会得到相应的左右值引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&gt; w;</span><br><span class="line"><span class="comment">// 内部扩展为 typedef int&amp; &amp;&amp; RvalueRefToT;</span></span><br><span class="line"><span class="comment">// 那么最终就是 typedef int&amp; RvalueRefToT;</span></span><br><span class="line"></span><br><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&amp;&gt; w;</span><br><span class="line"><span class="comment">// 内部扩展为 typedef int&amp;&amp; &amp;&amp; RvalueRefToT;</span></span><br><span class="line"><span class="comment">// 那么最终就是 typedef int&amp;&amp; RvalueRefToT;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：作用域枚举优于非作用域枚举</title>
    <url>/2022/05/03/effective_cpp_scope_enum/</url>
    <content><![CDATA[<p>简单来讲就是对于枚举类型，也需要将其存放于命名空间中，以避免枚举中元素对外部标识符的污染。</p>
<span id="more"></span>

<h1 id="非作用域枚举对标识符的污染"><a href="#非作用域枚举对标识符的污染" class="headerlink" title="非作用域枚举对标识符的污染"></a>非作用域枚举对标识符的污染</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">  kWhite,</span><br><span class="line">  kBlack,</span><br><span class="line">  kRed,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kBlack = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如像上面这段代码，由于枚举中已经具有<code>kBlack</code>常量，导致我们想定义一个<code>kBlack</code>变量是编译不通过的。上面这个代码很简单，一般人也不会犯错。但是当代码量大起来的时候，在头文件中有这种枚举，那么就还是会比较容易出现这类冲突。</p>
<h1 id="使用作用域枚举解决标识符污染"><a href="#使用作用域枚举解决标识符污染" class="headerlink" title="使用作用域枚举解决标识符污染"></a>使用作用域枚举解决标识符污染</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">  kWhite,</span><br><span class="line">  kBlack,</span><br><span class="line">  kRed,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kBlack = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> kRed = Color::kRed;</span><br><span class="line">    <span class="keyword">auto</span> kWhite = Color::kWhite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，将枚举常量放入<code>Color</code>作用域中，就不会与外部标识符有冲突。</p>
<h1 id="作用域枚举是强类型"><a href="#作用域枚举是强类型" class="headerlink" title="作用域枚举是强类型"></a>作用域枚举是强类型</h1><p>使用非作用域枚举是可以与其它变量进行比较的（编译器会将其隐式转换为整型），但是使用作用域枚举与其他类型进行比较就会报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">  kWhite,</span><br><span class="line">  kBlack,</span><br><span class="line">  kRed,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kBlack = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> kRed = Color::kRed;</span><br><span class="line">    <span class="keyword">auto</span> kWhite = Color::kWhite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接使用 kWhite 与 5 进行比较是编译不过的，除非显示的进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(kWhite) &lt; <span class="number">5</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作用域枚举可以使用前置声明"><a href="#作用域枚举可以使用前置声明" class="headerlink" title="作用域枚举可以使用前置声明"></a>作用域枚举可以使用前置声明</h1><p>下面这段代码在 g++ 中编译不会通过，使用作用域枚举便可以编译通过：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span></span><br><span class="line">  kWhite,</span><br><span class="line">  kBlack,</span><br><span class="line">  kRed,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> Red = kRed;</span><br><span class="line">    <span class="keyword">auto</span> White = kWhite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于作用域枚举可以使用前置声明，那就可以在<code>cc</code>文件中定义该枚举，而在其它文件中使用前置声明即可。这样可以减短因枚举内容改变而需要重新编译的时间。</p>
<blockquote>
<p>由于编译器知道枚举的长度，所以在使用前置声明的函数中，可以直接创建一个枚举对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span>;</span>                   <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">continueProcessing</span><span class="params">(Status s)</span></span>;   <span class="comment">// use of fwd-declared enum</span></span><br></pre></td></tr></table></figure>

<p>默认的类型是<code>int</code>，用户也可以显示指定其存储类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Status</span>:</span> std::<span class="keyword">uint32_t</span>;</span><br></pre></td></tr></table></figure>

<h1 id="在需要使用索引的地方使用非作用域枚举"><a href="#在需要使用索引的地方使用非作用域枚举" class="headerlink" title="在需要使用索引的地方使用非作用域枚举"></a>在需要使用索引的地方使用非作用域枚举</h1><p>在需要使用索引的地方，使用枚举常量能够提高代码的可读性。</p>
<p>但由于作用域枚举不允许类型转换，那么这种情况下使用非作用域枚举是比较好的选择。</p>
<p>为了避免命名污染，那么使用一个名称空间将该非作用域枚举包裹一次即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> TupleIndex &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Element</span>&#123;</span></span><br><span class="line">      NAME,</span><br><span class="line">      ADDR,</span><br><span class="line">      AGE</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> UserInfo = std::tuple&lt;</span><br><span class="line">                    std::string, <span class="comment">// name</span></span><br><span class="line">                    std::string, <span class="comment">// addr</span></span><br><span class="line">                    std::<span class="keyword">size_t</span> <span class="comment">//age</span></span><br><span class="line">                    &gt;;</span><br><span class="line">    UserInfo may = &#123;<span class="string">&quot;May&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name &quot;</span> &lt;&lt; std::get&lt;TupleIndex::NAME&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot; ,addr &quot;</span> &lt;&lt; std::get&lt;TupleIndex::ADDR&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot; ,age &quot;</span> &lt;&lt; std::get&lt;TupleIndex::AGE&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用作用域枚举，就需要进行一次显示转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Element</span> &#123;</span></span><br><span class="line">  NAME,</span><br><span class="line">  ADDR,</span><br><span class="line">  AGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> UserInfo = std::tuple&lt;</span><br><span class="line">                    std::string, <span class="comment">// name</span></span><br><span class="line">                    std::string, <span class="comment">// addr</span></span><br><span class="line">                    std::<span class="keyword">size_t</span> <span class="comment">//age</span></span><br><span class="line">                    &gt;;</span><br><span class="line">    UserInfo may = &#123;<span class="string">&quot;May&quot;</span>, <span class="string">&quot;London&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name &quot;</span> &lt;&lt; std::get&lt;<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(Element::NAME)&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot; ,addr &quot;</span> &lt;&lt; std::get&lt;<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(Element::NAME)&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot; ,age &quot;</span> &lt;&lt; std::get&lt;<span class="keyword">static_cast</span>&lt;std::<span class="keyword">size_t</span>&gt;(Element::NAME)&gt;(may) &lt;&lt;</span><br><span class="line">                 <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这实在是太麻烦了！</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：智能指针</title>
    <url>/2022/04/17/effective_cpp_smart_pointers/</url>
    <content><![CDATA[<p>传统指针具有以下缺陷：</p>
<ol>
<li>单从一个指针的声明，无法判定它是指向一个对象还是指向一个包含该对象的数组</li>
<li>单从一个指针的声明，无法判定当不使用该指针时，是否需要释放它所指向对象所占用的资源</li>
<li>当需要释放指针所指向对象的资源时，并不能明确的知道是该使用<code>delete</code>，还是使用其它专有的释放函数</li>
<li>当需要使用<code>delete</code>释放资源时，到底是使用<code>delete</code>还是<code>delete[]</code>，这需要小心使用，否则会造成内存泄漏或未定义行为</li>
<li>当确定了释放机制时，也有可能写代码时一不小心，就造成了 double free</li>
<li>当释放一个资源时，有可能还有其它指针（Dangling pointers）指向该资源，从而导致很多很难查的 BUG</li>
</ol>
<p>使用智能指针变能够最大化的避免以上问题。</p>
<span id="more"></span>

<h1 id="当指针独占资源时，应该使用-unique-ptr"><a href="#当指针独占资源时，应该使用-unique-ptr" class="headerlink" title="当指针独占资源时，应该使用 unique_ptr"></a>当指针独占资源时，应该使用 unique_ptr</h1><h2 id="unique-ptr-的特点"><a href="#unique-ptr-的特点" class="headerlink" title="unique_ptr 的特点"></a><code>unique_ptr</code> 的特点</h2><ol>
<li><code>unique_ptr</code> 和原始指针的大小一样大，并且执行效率也高，可以满足一些对内存和运行性能有要求的场合。</li>
<li><code>unique_ptr</code>属于独占所指向的资源，因此不能将其赋值给另外的<code>unique_ptr</code>，而只能使用移动语义 </li>
</ol>
<h2 id="unique-ptr的使用场合"><a href="#unique-ptr的使用场合" class="headerlink" title="unique_ptr的使用场合"></a><code>unique_ptr</code>的使用场合</h2><h3 id="在工厂函数中使用"><a href="#在工厂函数中使用" class="headerlink" title="在工厂函数中使用"></a>在工厂函数中使用</h3><p>一般工厂函数都会返回一个<code>unique_ptr</code>，使用者可以没有心理负担的正常使用。</p>
<p>当该<code>unique_ptr</code>退出代码块后，便会自动调用析构函数来释放其所指向的资源。而不用担心中途的异常发生而非正常的跳出该代码块。</p>
<p>当某些资源不能使用正常的<code>delete</code>释放时，用户可以定义自己的<code>delete function</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;     <span class="comment">// custom deleter </span></span><br><span class="line">                  <span class="built_in">makeLogEntry</span>(pInvestment);      <span class="comment">// (a lambda expression)</span></span><br><span class="line">                  <span class="keyword">delete</span> pInvestment;             </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;                          <span class="comment">// revised</span></span><br><span class="line">std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;   <span class="comment">// return type</span></span><br><span class="line"><span class="built_in">makeInvestment</span>(Ts&amp;&amp;... params) &#123;</span><br><span class="line">  std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt; <span class="comment">// ptr to be returned</span></span><br><span class="line">    <span class="built_in">pInv</span>(<span class="literal">nullptr</span>, delInvmt);                       </span><br><span class="line">  <span class="keyword">if</span> ( <span class="comment">/* a Stock object should be created */</span> ) &#123;</span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* a Bond object should be created */</span> ) &#123;</span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="comment">/* a RealEstate object should be created */</span> ) &#123;</span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pInv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 c++14 中，则可以使用更加智能的推导方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">makeInvestment</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;              <span class="comment">// C++14</span></span><br><span class="line">  <span class="keyword">auto</span> delInvmt = [](Investment* pInvestment) &#123;    <span class="comment">// this is now inside make Investment</span></span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pInvestment);   </span><br><span class="line">                    <span class="keyword">delete</span> pInvestment;          </span><br><span class="line">                  &#125;;</span><br><span class="line">  std::unique_ptr&lt;Investment, <span class="keyword">decltype</span>(delInvmt)&gt;   <span class="comment">// as before</span></span><br><span class="line">    <span class="built_in">pInv</span>(<span class="literal">nullptr</span>, delInvmt);                         </span><br><span class="line">  <span class="keyword">if</span> ( … ) &#123;                                         <span class="comment">// as before</span></span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Stock</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( … ) &#123;                                    <span class="comment">// as before</span></span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Bond</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( … ) &#123;                                    <span class="comment">// as before</span></span><br><span class="line">    pInv.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">RealEstate</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pInv;                                      <span class="comment">// as before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>lambda</code>来定义删除函数的好处是：使用该种方式不会使得<code>unique_ptr</code>的体积增加，而使用普通函数的定义方式则会使得<code>unique_ptr</code>的体积增加。</p>
<p>工厂函数之所以返回的是<code>unique_ptr</code>，是因为这种返回方式可以不用关心调用者使用的是<code>shared_ptr</code>还是<code>unique_ptr</code>，这样更能适用于更加广泛的场合。</p>
<blockquote>
<p>返回的<code>unique_ptr</code>是临时对象，则编译器会尝试使用移动语义将该对象移动到被赋值变量中。</p>
</blockquote>
<h3 id="对数组使用"><a href="#对数组使用" class="headerlink" title="对数组使用"></a>对数组使用</h3><p>对数组使用的方式是<code>std::unique_ptr&lt;T[]&gt;</code>，一般使用这种方式都是在使用该指针指向 c 代码所提供的从堆中申请的内存地址。</p>
<p>在 c++ 中，使用<code>std::array</code>,<code>std::vector</code>总是优于使用原始的数组。</p>
<h1 id="使用-shared-ptr-来管理共享的堆资源"><a href="#使用-shared-ptr-来管理共享的堆资源" class="headerlink" title="使用 shared_ptr 来管理共享的堆资源"></a>使用 shared_ptr 来管理共享的堆资源</h1><p><code>shared_ptr</code>使用对资源的引用计数来决定是否释放资源：</p>
<ul>
<li>构造函数会使得对资源的引用计数加 1</li>
<li>而析构函数和赋值构造函数都会将<strong>对当前指向资源的引用计数减 1</strong><blockquote>
<p>赋值构造引用计数减 1，指的是：当前<code>shared_ptr</code>已经指向了一个对象，当它被另一个<code>shared_ptr</code>赋值时，那指向原来对象的<code>shared_ptr</code>关联计数就会减一，指向新对象的<code>shared_ptr</code>关联计数就会加一。</p>
</blockquote>
</li>
<li>当对资源的引用计数为 0 时，就会释放该资源</li>
</ul>
<h2 id="shared-ptr-的特点"><a href="#shared-ptr-的特点" class="headerlink" title="shared_ptr 的特点"></a><code>shared_ptr</code> 的特点</h2><p>既然<code>shared_ptr</code>使用引用计数来保存对资源的引用数，那么：</p>
<ul>
<li><code>shared_ptr</code>的大小是原始指针的两倍，因为包含资源指针和引用计数</li>
<li>引用计数也是动态申请的，这个后面会解释</li>
<li>引用计数的改变必须是原子的，以避免出现并发修改而导致的错误</li>
</ul>
<p>综上可以看出：<code>shared_ptr</code>的运行效率低于<code>unique_ptr</code>。</p>
<blockquote>
<p>但在使用移动语义对<code>shared_ptr</code>进行操作时，由于不需要修改引用计数，所以其操作效率也是比较高的。</p>
</blockquote>
<h2 id="自定义delete函数"><a href="#自定义delete函数" class="headerlink" title="自定义delete函数"></a>自定义<code>delete</code>函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>自定义<code>delete</code>函数时，<code>shared_ptr</code>在定义时和<code>unique_ptr</code>有些不同，应该说是<code>shared_ptr</code>更为优雅：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> loggingDel = [](Widget *pw) &#123;       <span class="comment">// custom deleter</span></span><br><span class="line">                    <span class="built_in">makeLogEntry</span>(pw);</span><br><span class="line">                    <span class="keyword">delete</span> pw;</span><br><span class="line">                  &#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;                        <span class="comment">// deleter type is part of ptr type</span></span></span><br><span class="line"><span class="function">  Widget, <span class="title">decltype</span><span class="params">(loggingDel)</span>           </span></span><br><span class="line"><span class="function">  &gt; <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, loggingDel)</span></span>;</span><br><span class="line">std::shared_ptr&lt;Widget&gt;                 <span class="comment">// deleter type is not part of ptr type</span></span><br><span class="line">  <span class="built_in">spw</span>(<span class="keyword">new</span> Widget, loggingDel);           </span><br></pre></td></tr></table></figure>

<h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><p><code>shared_ptr</code>即使使用了不同类型的<code>delete</code>函数，都可以放在同一个<code>vector</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> customDeleter1 = [](Widget *pw) &#123; … &#125;;    <span class="comment">// custom deleters,each with a different type</span></span><br><span class="line"><span class="keyword">auto</span> customDeleter2 = [](Widget *pw) &#123; … &#125;;     </span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw1</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter1)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw2</span><span class="params">(<span class="keyword">new</span> Widget, customDeleter2)</span></span>;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; vpw&#123; pw1, pw2 &#125;;</span><br></pre></td></tr></table></figure>

<p>因为<code>pw1</code>和<code>pw2</code>是属于同一个类型的，所以它们也可以赋值、所为参数传递等。但<code>unique_ptr</code>就不行，因为它们的定义形式不同，类型也就不一样。</p>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p><code>unique_ptr</code>在使用自定义<code>delete</code>函数后，其占用会增大。但是，<code>shared_ptr</code>的大小确不会改变。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Blanguage%5D/%5BWhat%5Dc_cpp--base/effective_modern/pic/item19/shared_ptr.jpg?raw=true"><br>如上图所示，这是因为<code>shared_ptr</code>中的成员变量一个是指向类型的指针，一个是指向 Control Block 的指针。</p>
<p>所以新增的内容都会位于 Control Block 的堆区，而不会影响<code>shared_ptr</code>的大小。</p>
<p>有以下几种情况会创建 Control Block ：</p>
<ol>
<li>使用<code>std::make_shared</code>总是会创建 control block</li>
<li>当使用独占指针（<code>std::unique_ptr</code>或<code>std::auto_ptr</code>）来创建一个<code>shared_ptr</code>时，因为独占指针不包含 control block</li>
<li>当使用原始指针来创建一个<code>shared_ptr</code>时</li>
</ol>
<p>尤其是第三点需要特别注意，也就是说：</p>
<blockquote>
<p>当将一个原始指针用于创建多个<code>shared_ptr</code>时，就会有多个 Control Block。</p>
<p>那就意味着有多个 Reference Count，那么就会导致同一个指针会被释放多次的问题。</p>
<p>所以最稳妥的方式是使用<code>make_shared</code>。</p>
</blockquote>
<p>比如像下面这样，<code>pw</code>就会被释放两次：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pw = <span class="keyword">new</span> Widget;                          <span class="comment">// pw is raw ptr</span></span><br><span class="line">…</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(pw, loggingDel)</span></span>;  <span class="comment">// create control  block for *pw</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(pw, loggingDel)</span></span>;  <span class="comment">// create 2nd control block for *pw!</span></span><br></pre></td></tr></table></figure>

<p>如果确实要使用原始指针，那么使用下面的方式才是正确的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw1</span><span class="params">(<span class="keyword">new</span> Widget,    <span class="comment">// direct use of new</span></span></span></span><br><span class="line"><span class="params"><span class="function">                             loggingDel)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(spw1)</span></span>;     <span class="comment">// spw2 uses same control block as spw1</span></span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr不能用于数组"><a href="#shared-ptr不能用于数组" class="headerlink" title="shared_ptr不能用于数组"></a><code>shared_ptr</code>不能用于数组</h2><p><code>shared_ptr</code>并没有像<code>unique_ptr</code>一样提供了<code>std::shared_ptr&lt;T[]&gt;</code>这样的功能函数，所以它不能作用于数组。</p>
<blockquote>
<p>使用 <code>std::array</code>,<code>std::vector</code>,<code>std::string</code>这类类才是正确的方式</p>
</blockquote>
<h1 id="使用-weak-ptr-来检查-shared-ptr-资源是否已经释放"><a href="#使用-weak-ptr-来检查-shared-ptr-资源是否已经释放" class="headerlink" title="使用 weak_ptr 来检查 shared_ptr 资源是否已经释放"></a>使用 weak_ptr 来检查 shared_ptr 资源是否已经释放</h1><h2 id="理解-weak-ptr"><a href="#理解-weak-ptr" class="headerlink" title="理解 weak_ptr"></a>理解 <code>weak_ptr</code></h2><p><code>std::weak_ptr</code>附属于<code>shared_ptr</code>，<code>weak_ptr</code>并不会影响资源引用计数的增加和减小，当最后一个<code>shared_ptr</code>被销毁时，资源便会被释放，就算现在依然存在<code>weak_ptr</code>。</p>
<p><code>weak_ptr</code>并不能够被解引用，它的目的主要是为了探测<code>shared_ptr</code>之间所指向的资源是否已经释放。</p>
<p>其应用场景一般是在当需要新建一个<code>shared_ptr</code>时或需要操作该资源时，首先使用<code>weak_ptr</code>来查看该资源是否已经释放，以避免未定义的行为。</p>
<p>要理解其使用场景，首先查看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> spi = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wpi</span><span class="params">(spi)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of spi is &quot;</span> &lt;&lt; *spi &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is wpi expired: &quot;</span> &lt;&lt; wpi.<span class="built_in">expired</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//资源已被释放</span></span><br><span class="line">    spi = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is wpi expired: &quot;</span> &lt;&lt; wpi.<span class="built_in">expired</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>shared_ptr</code>所指向的资源被释放时，<code>weak_ptr</code>的<code>expired()</code>方法将返回<code>true</code>。</p>
<h2 id="多线程下的-weak-ptr"><a href="#多线程下的-weak-ptr" class="headerlink" title="多线程下的 weak_ptr"></a>多线程下的 <code>weak_ptr</code></h2><p>但如果是在多线程的应用场景，就有可能出现临界区问题：</p>
<ul>
<li>线程 T1 通过<code>expired()</code>返回<code>false</code>判定资源还没有被释放，于是决定新建一个<code>shared_ptr</code></li>
<li>在线程 T1 执行完<code>expired()</code>后，线程 T2 抢占了 T1 运行，T2 中指向同一资源的最后一个<code>shared_ptr</code>被销毁，该资源被释放</li>
<li>T1 重新运行，该<code>shared_ptr</code>指向一段未知的堆区域，接下来对该<code>shared_ptr</code>操作结果都是未知的</li>
</ul>
<p>所以，加锁是必须的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> spi = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wpi</span><span class="params">(spi)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of spi is &quot;</span> &lt;&lt; *spi &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 lock() 方法返回 shared_ptr，如果资源已经被释放了，则返回 nullptr</span></span><br><span class="line">    <span class="keyword">auto</span> spi2 = wpi.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span>(spi2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of spi2 is &quot;</span> &lt;&lt; *spi2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//资源已被释放</span></span><br><span class="line">    spi = <span class="literal">nullptr</span>;</span><br><span class="line">    spi2 = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> spi3 = wpi.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span>(spi3 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The value of spi3 is &quot;</span> &lt;&lt; *spi3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The resource is not existent!\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>一个应用场景便是在观察者模式中，发送者会含有许多观察者的基类指针。如果这些观察者都是在堆上申请，且有可能被其他代码所释放掉，那么使用<code>weak_ptr</code>是一个比较优雅的办法。</p>
<blockquote>
<p>一旦 <code>lock()</code>方法返回为<code>nullptr</code>，则代表该观察者已经被销毁，则就不应该再向它发送消息了。</p>
</blockquote>
<h1 id="make-shared-和-make-unique-优于使用-new"><a href="#make-shared-和-make-unique-优于使用-new" class="headerlink" title="make_shared 和 make_unique 优于使用 new"></a>make_shared 和 make_unique 优于使用 new</h1><p><code>std::make_shared</code> 是 c++11 的一部分，但是<code>std::make_unique</code>是在 c++14 才被加入标准的。如果要在 c++ 11 中使用，可以自己定义一个简易版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Ts&amp;&amp;... params)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::unique_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Ts&gt;(params)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个版本无法指向原始数组，也无法定制删除函数</p>
</blockquote>
<h2 id="为什么要使用make函数"><a href="#为什么要使用make函数" class="headerlink" title="为什么要使用make函数"></a>为什么要使用<code>make</code>函数</h2><h3 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">upw1</span><span class="params">(std::make_unique&lt;Widget&gt;())</span></span>;      <span class="comment">// with make func</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget&gt; <span class="title">upw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// without make func</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">spw1</span><span class="params">(std::make_shared&lt;Widget&gt;())</span></span>;      <span class="comment">// with make func</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw2</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;   <span class="comment">// without make func</span></span><br></pre></td></tr></table></figure>

<p>从上面这段代码可以看出，使用<code>make</code>函数，便可以使用<code>auto</code>来推导对象的类型。</p>
<p>而使用<code>new</code>来创建对象的话，就需要显示的写明对象的类型，这在以后修改类型时，就有点麻烦。</p>
<h3 id="保证安全性"><a href="#保证安全性" class="headerlink" title="保证安全性"></a>保证安全性</h3><p>比如有如下函数定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>并且使用<code>new</code>来传入对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::shared_ptr&lt;Widget&gt;(<span class="keyword">new</span> Widget),  <span class="comment">// potential resource leak!</span></span><br><span class="line">              <span class="built_in">computePriority</span>());                    </span><br></pre></td></tr></table></figure>

<p>这种情况下就有可能造成内存泄漏。</p>
<p><code>shared_ptr</code>的创建一定要在<code>new</code>之后，以获取<code>new</code>的地址进行管理，那么正常的流程应该是：</p>
<ol>
<li><code>new</code>先创建一个 Widget 对象</li>
<li>调用<code>shared_ptr</code>的构造函数，获取 Widget 对象的地址进行管理</li>
<li>执行 computePriority() 函数</li>
</ol>
<p>但如果编译器进行了优化，就有可能会执行下面这个顺序：</p>
<ol>
<li><code>new</code>先创建一个 Widget 对象</li>
<li>执行 computePriority() 函数</li>
<li>调用<code>shared_ptr</code>的构造函数，获取 Widget 对象的地址进行管理</li>
</ol>
<p>假设在执行第二步时，computePriority() 抛出了一个异常，那么第三步就无法执行，第一步申请的内存无法释放就造成了内存泄漏。</p>
<p>使用<code>make</code>函数便可以避免此问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::make_shared&lt;Widget&gt;(),   <span class="comment">// no potential resource leak</span></span><br><span class="line">              <span class="built_in">computePriority</span>());           </span><br></pre></td></tr></table></figure>

<p>因为使用<code>make</code>函数就将步骤变成了两步，这样无论谁先执行，都能保证不会造成内存泄漏。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>对于<code>shared_ptr</code>要管理一段资源，除了要申请该资源的内存还要申请对应的 control block。</p>
<p>如果使用<code>new</code>来创建对象资源，那么申请资源就要分为两步：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>make</code>函数，那就将两个步骤合并为一个步骤，提高了效率：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> spw = std::make_shared&lt;Widget&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="make函数的缺陷"><a href="#make函数的缺陷" class="headerlink" title="make函数的缺陷"></a><code>make</code>函数的缺陷</h2><h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a><code>delete</code>函数</h3><p>使用<code>make</code>函数时，并不能定义<code>delete</code>函数，这种情况下只能使用<code>new</code>来完成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> widgetDeleter = [](Widget* pw) &#123; … &#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;Widget, <span class="title">decltype</span><span class="params">(widgetDeleter)</span>&gt;</span></span><br><span class="line"><span class="function">  <span class="title">upw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, widgetDeleter)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所以，在之前的安全性讨论中，如果需要新建<code>delete</code>方法，那么就需要将对象的创建分为单独的一行来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">spw</span><span class="params">(<span class="keyword">new</span> Widget, cusDel)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(spw, <span class="built_in">computePriority</span>()); </span><br></pre></td></tr></table></figure>

<h3 id="初始化的限制"><a href="#初始化的限制" class="headerlink" title="初始化的限制"></a>初始化的限制</h3><p>使用<code>make</code>函数调用的是括号初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> upv = std::make_unique&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码都是创建有 10 个元素，每个元素值为 20 的 vector。</p>
<p>如果想使用列表初始化，除了使用<code>new</code>以外，还可以使用<code>auto</code>进行推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create std::initializer_list</span></span><br><span class="line"><span class="keyword">auto</span> initList = &#123; <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">// create std::vector using std::initializer_list ctor</span></span><br><span class="line"><span class="keyword">auto</span> spv = std::make_shared&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt;(initList);</span><br></pre></td></tr></table></figure>

<h3 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h3><p>有些类会定义自己的申请和释放方法，但是这些方法往往自会计算自身对象的大小而忽略了 control block 的大小，这种情况下也不能用<code>make</code>函数。</p>
<h3 id="占用很大的申请"><a href="#占用很大的申请" class="headerlink" title="占用很大的申请"></a>占用很大的申请</h3><p>前面讲过，使用<code>weak_ptr</code>来判定<code>shared_ptr</code>所管理的资源是否已经释放。</p>
<p>但实际上，是在 control block 中也有一个 weak count 来表明<code>weak_ptr</code>，所以只有当<code>weak_ptr</code>被销毁时，相关内存资源才算真的被释放完了。</p>
<p>由于<code>make</code>函数申请资源内存和 control block 是一个整体，那么在有<code>weak_ptr</code>的情况下，即使<code>shared_ptr</code>已经被完全销毁了，但是其资源的内存及 control block 的内存都既然存在，直到<code>weak_ptr</code>被销毁。</p>
<p>如果<code>make</code>函数申请的内存很大，那么在一些应用场景下就有可能出现其它代码申请不到内存的情况。</p>
<p>如果使用<code>new</code>就不会有这个问题，因为对象资源和 control block 的内存不是一个整块被申请的，所以当<code>shared_ptr</code>被完全销毁了，对象的资源也会被释放掉。仅需要保留 control block 给<code>weak_ptr</code>使用即可。</p>
<h1 id="正确的使用-Pimpl"><a href="#正确的使用-Pimpl" class="headerlink" title="正确的使用 Pimpl"></a>正确的使用 Pimpl</h1><p>Pimpl 简单来讲是指在类的头文件，以指针的形式包含其它类（委托），然后在实现文件中包含类成员的头文件和内存的申请释放。</p>
<p>这样做的目的是减少编译时间，避免类成员发生改变后，该类头文件也受影响，尽量减少受影响的范围。</p>
<h2 id="最简单粗暴的方式"><a href="#最简单粗暴的方式" class="headerlink" title="最简单粗暴的方式"></a>最简单粗暴的方式</h2><p>直接在头文件中包含成员头文件，那么当成员的声明被修改后，当前头文件也需要重新展开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                     <span class="comment">// in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::vector&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">  Gadget g1, g2, g3;               <span class="comment">// Gadget is some user defined type</span></span><br><span class="line">&#125;;                                  </span><br></pre></td></tr></table></figure>

<p>上面这段代码，其实<code>std::string</code>和<code>std::vector</code>都不会被改变，可以这样使用。</p>
<p>但是由于<code>Gadget</code>类是用户自定义的，那么被修改的可能性就很大了。</p>
<h2 id="使用指针包含成员变量"><a href="#使用指针包含成员变量" class="headerlink" title="使用指针包含成员变量"></a>使用指针包含成员变量</h2><p>以委托的方式包含成员，可以避免头文件的编译依赖问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                 <span class="comment">// still in header &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  ~<span class="built_in">Widget</span>();                   <span class="comment">// dtor is needed—see below</span></span><br><span class="line">  …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span>                 <span class="comment">// declare implementation struct and pointer to it</span></span><br><span class="line">  Impl *pImpl;                 </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span>            <span class="comment">// in impl. file &quot;widget.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;          <span class="comment">// definition of Widget::Impl</span></span><br><span class="line">  std::string name;            <span class="comment">// with data members formerly</span></span><br><span class="line">  std::vector&lt;<span class="keyword">double</span>&gt; data;    <span class="comment">// in Widget</span></span><br><span class="line">  Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::<span class="built_in">Widget</span>()               <span class="comment">// allocate data members for this Widget object</span></span><br><span class="line">: <span class="built_in">pImpl</span>(<span class="keyword">new</span> Impl)               </span><br><span class="line">&#123;&#125;</span><br><span class="line">Widget::~<span class="built_in">Widget</span>()              <span class="comment">// destroy data members for this object</span></span><br><span class="line">&#123; <span class="keyword">delete</span> pImpl; &#125;               </span><br></pre></td></tr></table></figure>

<h2 id="使用unique-ptr"><a href="#使用unique-ptr" class="headerlink" title="使用unique_ptr"></a>使用<code>unique_ptr</code></h2><p>前面使用原始指针的方式一点也不优雅，所以使用智能指针才是明智的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                      <span class="comment">// in &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span> </span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pImpl;      <span class="comment">// use smart pointer</span></span><br><span class="line">&#125;;                                  <span class="comment">// instead of raw pointer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span>                 <span class="comment">// in &quot;widget.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;               <span class="comment">// as before</span></span><br><span class="line">  std::string name;</span><br><span class="line">  std::vector&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">  Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::<span class="built_in">Widget</span>()                    <span class="comment">// create std::unique_ptr</span></span><br><span class="line">: <span class="built_in">pImpl</span>(std::make_unique&lt;Impl&gt;()) </span><br><span class="line">&#123;&#125; </span><br></pre></td></tr></table></figure>

<h3 id="编译期的问题"><a href="#编译期的问题" class="headerlink" title="编译期的问题"></a>编译期的问题</h3><p>但若仅仅是上面这样，编译时便会遇到问题，编译器会报错<code>delete</code>一个非完整的类型。</p>
<p>这是因为前面的类并没有显示定义析构函数，而编译器会生成默认的<strong>内联析构函数</strong>，并且在析构函数中做类型检查。但是类型<code>Impl</code>在头文件中并不完整，所以就会导致编译错误。</p>
<p>正确的做法是显示的定义一个空的析构函数，该函数在 cpp 文件中的位置要位于<code>Widget::Impl</code>定义之后即可。</p>
<p>同样的，如果使用了移动构造函数，那也会遭遇同样的错误，所以也需要显示的定义。</p>
<h3 id="拷贝构造与拷贝赋值函数"><a href="#拷贝构造与拷贝赋值函数" class="headerlink" title="拷贝构造与拷贝赋值函数"></a>拷贝构造与拷贝赋值函数</h3><p>由于头文件中包含委托，默认的拷贝构造和拷贝赋值函数并不能满足要求，这就需要用户显示定义拷贝构造函数来完成正确的内存拷贝。</p>
<p>综上所述，代码应该如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                            <span class="comment">//&quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  ~<span class="built_in">Widget</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);                   <span class="comment">// declarations only</span></span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(Widget&amp;&amp; rhs);        </span><br><span class="line"></span><br><span class="line">  <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);              <span class="comment">// declarations only</span></span><br><span class="line">  Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:                                  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span></span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">…                                        <span class="comment">// in &quot;widget.cpp&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;     </span><br><span class="line">  std::string name;                      <span class="comment">// Widget::Impl</span></span><br><span class="line">  std::vector&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">  Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::<span class="built_in">Widget</span>()                     </span><br><span class="line">: <span class="built_in">pImpl</span>(std::make_unique&lt;Impl&gt;())</span><br><span class="line">&#123;&#125;</span><br><span class="line">Widget::~<span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;              <span class="comment">// definitions</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget&amp;&amp; rhs) = <span class="keyword">default</span>;   </span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs)              <span class="comment">// copy ctor</span></span><br><span class="line">: <span class="built_in">pImpl</span>(std::make_unique&lt;Impl&gt;(*rhs.pImpl))</span><br><span class="line">&#123;&#125;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;   <span class="comment">// copy operator=</span></span><br><span class="line"></span><br><span class="line">  *pImpl = *rhs.pImpl;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用shared-ptr"><a href="#使用shared-ptr" class="headerlink" title="使用shared_ptr"></a>使用<code>shared_ptr</code></h2><p>如果将<code>unique_ptr</code>替换为<code>shared_ptr</code>便没有上述这些问题，也就是说代码可以非常简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                      <span class="comment">// in &quot;widget.h&quot;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>();</span><br><span class="line">  …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Impl</span>;</span> </span><br><span class="line">  std::shared_ptr&lt;Impl&gt; pImpl;      <span class="comment">// use smart pointer instead of raw pointer</span></span><br><span class="line">&#125;;                                  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span>                 <span class="comment">// in &quot;widget.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gadget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Widget</span>:</span>:Impl &#123;               <span class="comment">// as before</span></span><br><span class="line">  std::string name;</span><br><span class="line">  std::vector&lt;<span class="keyword">double</span>&gt; data;</span><br><span class="line">  Gadget g1, g2, g3;</span><br><span class="line">&#125;;</span><br><span class="line">Widget::<span class="built_in">Widget</span>()                    <span class="comment">// create std::shared_ptr</span></span><br><span class="line">: <span class="built_in">pImpl</span>(std::make_shared&lt;Impl&gt;())   </span><br><span class="line">&#123;&#125; </span><br></pre></td></tr></table></figure>

<p>这是由于二者所使用的删除器是不同的：</p>
<ul>
<li><code>unique_ptr</code>使用的指向具体类型的删除器，好处是生成的数据结构小并且运行效率高。但在编译器生成特殊函数时，就需要知道完整的类型定义。</li>
<li><code>shared_ptr</code>却没有使用指向具体类型的删除器，虽然生成的数据结构大且运行效率相对低。但在编译器生成特殊函数时，不需要知道完整的类型定义，也就可以使用编译器的默认函数。</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：类型推导</title>
    <url>/2022/04/29/effective_cpp_type_deduction/</url>
    <content><![CDATA[<p>理解 cpp 是如何进行类型推导的，这样在使用时才不会踩太多坑……</p>
<span id="more"></span>

<h1 id="模板类型推导"><a href="#模板类型推导" class="headerlink" title="模板类型推导"></a>模板类型推导</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>一个普通的函数模板就像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">GetSum</span><span class="params">(<span class="keyword">const</span> T* buf, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  T sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">    sum += buf[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint16_t</span> u16_buf[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32_buf[] = &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> float_buf[] = &#123;<span class="number">1.123</span>, <span class="number">2.234</span>, <span class="number">3.345</span>, <span class="number">4.456</span>&#125;;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The sum of u16 buffer is &quot;</span> &lt;&lt; <span class="built_in">GetSum</span>(u16_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(u16_buf) / <span class="built_in"><span class="keyword">sizeof</span></span>(u16_buf[<span class="number">0</span>])) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The sum of u32 buffer is &quot;</span> &lt;&lt; <span class="built_in">GetSum</span>(u32_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(u32_buf) / <span class="built_in"><span class="keyword">sizeof</span></span>(u32_buf[<span class="number">0</span>])) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The sum of float buffer is &quot;</span> &lt;&lt; <span class="built_in">GetSum</span>(float_buf, <span class="built_in"><span class="keyword">sizeof</span></span>(float_buf) / <span class="built_in"><span class="keyword">sizeof</span></span>(float_buf[<span class="number">0</span>])) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的输出为：</p>
<blockquote>
<p> The sum of u16 buffer is 15<br> The sum of u32 buffer is 40<br> The sum of float buffer is 11.158</p>
</blockquote>
<p>使用函数模板来代替函数重载，这是一种简单而优雅的做法。</p>
<p>从表面上来看，似乎编译器是自然而然的就可以根据实参的类型推导出类型<code>T</code>，然而实际上类型<code>T</code>和形参所使用的<code>T</code>是不同的。</p>
<blockquote>
<p>就拿上面的 GetSum 函数模板举例，被推导的类型实际上有：</p>
<ol>
<li>模板类型 T</li>
<li>函数形参 const T*</li>
</ol>
</blockquote>
<p>最终，真正决定<code>T</code>的类型，是由实参和形参类型共同所决定的，具有以下 3 种情况：</p>
<ol>
<li>形参是一个指针或引用类型，但并不是通用引用</li>
<li>形参是一个通用引用</li>
<li>形参既不是指针也不是引用</li>
</ol>
<h2 id="形参是一个指针或引用类型，但并不是通用引用"><a href="#形参是一个指针或引用类型，但并不是通用引用" class="headerlink" title="形参是一个指针或引用类型，但并不是通用引用"></a>形参是一个指针或引用类型，但并不是通用引用</h2><p>这种情况下的推导步骤如下：</p>
<ul>
<li>如果实参是一个引用（无论是左值还是右值引用）或指针，那么就忽略引用或指针的部分</li>
<li>然后再根据实参剩余部分和形参共同决定类型<code>T</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一种函数模板形参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有以下 3 种实参</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; rx = x;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">//T 类型为 int，形参类型为 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">//T 类型为 const int，形参类型为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">//T 类型为 const int，形参类型为 const int&amp;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到，实参<code>rx</code>的引用被去掉了，最终类型<code>T</code>和<code>cx</code>是一致的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第二种函数模板形参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有以下 3 种实参</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; rx = x;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(x);   <span class="comment">//T 类型为 int，形参类型为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);  <span class="comment">//T 类型为 int，形参类型为 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);  <span class="comment">//T 类型为 int，形参类型为 const int&amp;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这一次的类型<code>T</code>统一为<code>int</code>型。</p>
<ul>
<li>由于第一种情况下，形参并没有使用<code>const</code>限定符，而实参使用了<code>const</code>限定符，那么用户的期望是希望<code>T</code>是无法被改变的类型，所以<code>T</code>被推导成了 const int。</li>
<li>但是第二种情况下，形参已经使用了<code>const</code>限定符，那么实参是否有<code>const</code>已经不重要了，这种情况下就可以使用更为宽松的<code>int</code>类型。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第三种函数模板形参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有以下 2 种实参</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(&amp;x);   <span class="comment">//T 类型为 int，形参类型为 int*</span></span><br><span class="line"><span class="built_in">f</span>(px);  <span class="comment">//T 类型为 const int，形参类型为 const int*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第四种函数模板形参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T* param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具有以下 2 种实参</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(&amp;x);  <span class="comment">//T 类型为 int，形参类型为 const int*</span></span><br><span class="line"><span class="built_in">f</span>(px);  <span class="comment">//T 类型为 int，形参类型为 const int*</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到，使用指针的情况也是和引用类似的。</p>
<h2 id="形参是一个通用引用"><a href="#形参是一个通用引用" class="headerlink" title="形参是一个通用引用"></a>形参是一个通用引用</h2><ul>
<li>如果实参是一个左值，那么类型 T 和形参都会被推导成左值引用<ul>
<li>即使形参是右值引用，也会被推导成左值引用</li>
</ul>
</li>
<li>如果实参是一个右值，那么就会使用 1.2 节所述规则来进行推导<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设如下的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实参如下</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//x 是左值，T 类型就是 int&amp;，形参类型也是 int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(cx);<span class="comment">//cx 是左值，T 类型就是 const int&amp;，形参类型也是 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(rx);<span class="comment">//rx 是左值，T 类型就是 const int&amp;，形参类型也是 const int&amp;</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);<span class="comment">//27 是右值，T 类型就是 int，形参类型是 int&amp;&amp;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="形参既不是指针也不是引用"><a href="#形参既不是指针也不是引用" class="headerlink" title="形参既不是指针也不是引用"></a>形参既不是指针也不是引用</h2><ul>
<li>如果实参是一个引用，忽略掉引用部分</li>
<li>忽略掉引用后，如果实参部分是 <code>const</code> 或 <code>volatile</code>，也忽略掉 <code>const</code> 或<code>volatitle</code>。</li>
</ul>
<blockquote>
<p>其中的逻辑在于，函数模板此时的形参是 <code>passed by value</code>的形式。<br>那么即使实参是 <code>const</code>或<code>volatile</code>修饰，它的被拷贝副本就可以不用是<code>const</code>或<code>volatile</code>修饰了。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如如下的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实参如下</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rx = x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> ptr = <span class="string">&quot;Fun with pointers&quot;</span>;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">// 类型 T 和 形参均为 int 型</span></span><br><span class="line"><span class="built_in">f</span>(cx); <span class="comment">// 类型 T 和 形参均为 int 型</span></span><br><span class="line"><span class="built_in">f</span>(rx); <span class="comment">// 类型 T 和 形参均为 int 型</span></span><br><span class="line"><span class="built_in">f</span>(ptr); <span class="comment">//类型 T 和 形参均为 const char * 型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虽然<code>cx</code>和<code>rx</code>都是<code>const</code>类型，但由于函数模板是普通形参，无论实参如何，形参都是对实参的拷贝。所以形参都是<code>int</code>类型。</li>
<li>而<code>ptr</code>是指向<code>const char *</code>型的<code>const</code>指针，所以<code>ptr</code>本身的<code>const</code>被 passed by value，但该<code>ptr</code>所指向的对象依然应该是<code>const char *</code>。</li>
</ul>
<h2 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h2><p>需要注意的是：对于模版参数而言，数组参数和指针参数不是一个东西</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如如下的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实参如下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;J.P. Briggs&quot;</span>;</span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">//类型 T 和 形参均为 const char * 型</span></span><br></pre></td></tr></table></figure>
<p>上面这种情况下，name 和上一个情况的 ptr 是一样的，但如果函数模版形参是引用的话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假如如下的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实参如下</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;<span class="comment">//name 的长度是 13 字节</span></span><br><span class="line"><span class="comment">//对应的推导结果就是</span></span><br><span class="line"><span class="built_in">f</span>(name); <span class="comment">//类型 T 为 const char [13], 形参为 const char(&amp;)[13]</span></span><br></pre></td></tr></table></figure>
<p>可以看到此时形参就被推导成为了对固定长度数组的引用</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>另一个需要注意的就是函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);<span class="comment">// 类型 T 和形参均为 void(*)(int, double);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f2</span>(someFunc);<span class="comment">// 类型 T 为 void()(int, double)，形参为 void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>

<h1 id="理解-auto-类型的推导"><a href="#理解-auto-类型的推导" class="headerlink" title="理解 auto 类型的推导"></a>理解 auto 类型的推导</h1><h2 id="auto-推导与模版推导的相同之处"><a href="#auto-推导与模版推导的相同之处" class="headerlink" title="auto 推导与模版推导的相同之处"></a>auto 推导与模版推导的相同之处</h2><p>有了前面的基础，就可以比较容易的理解 <code>auto</code> 推导的逻辑。</p>
<p>其实 <code>auto</code> 推导和模版推导几乎一致：</p>
<ul>
<li>模版中使用实参和形参决定 <code>T</code> 和 形参</li>
<li>而 <code>auto</code> 就类似于 <code>T</code>，其他附加限定符就类似于形参，赋值号右边的就相当于实参</li>
</ul>
<p>比如如下示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对 auto 的使用</span></span><br><span class="line"><span class="keyword">auto</span> x = <span class="number">27</span>; <span class="comment">//auto 为 int，x 为 int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cx = x;<span class="comment">//auto 为 int，cx 为 const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;rx = x;<span class="comment">//auto 为 int，rx 为 const int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; uref1 = x;<span class="comment">// auto 和 uref1 均为 int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; uref2 = cx;<span class="comment">// auto 和 uref2 均为 const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; uref3 = <span class="number">27</span>;<span class="comment">//auto 为 int，uref3 为 int &amp;&amp;</span></span><br><span class="line"><span class="comment">//分别对应于函数模版</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_x</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_x</span>(<span class="number">27</span>);<span class="comment">//T 和 param 均为 int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_cx</span><span class="params">(<span class="keyword">const</span> T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_cx</span>(x);<span class="comment">//T 为 int，param 为 const int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_for_rx</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func_for_rx</span>(x);<span class="comment">// T 为 int，param 为 const int &amp;</span></span><br></pre></td></tr></table></figure>

<p>同样的，<code>auto</code> 推导也具有 3 种情况：</p>
<ul>
<li>限定符是指针或引用，但不是通用引用</li>
<li>限定符是通用引用</li>
<li>限定符既不是指针也不是引用</li>
</ul>
<p>同样的，对于数组和函数指针也有例外：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;R. N. Briggs&quot;</span>;<span class="comment">//name 的长度为 13 字节</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> arr1 = name;<span class="comment">//auto 和 arr1 均为 const char *</span></span><br><span class="line"><span class="keyword">auto</span> &amp;arr2 = name;<span class="comment">//auto 为 const char()[13]，arr2 为 const char (&amp;)[13]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> func1 = someFunc;<span class="comment">//auto 和 func1 均为 void (*)(int, double)</span></span><br><span class="line"><span class="keyword">auto</span> &amp;func2 = someFunc;<span class="comment">//auto 为 void()(int, double),fun1 为 void(&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>
<h2 id="auto-的独特之处"><a href="#auto-的独特之处" class="headerlink" title="auto 的独特之处"></a>auto 的独特之处</h2><p>c11 初始化一个变量有以下 4 种语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = <span class="number">27</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x3 = &#123;<span class="number">27</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x4&#123;<span class="number">27</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>以上 4 种语法得到的都是一个<code>int</code>型变量，其值为 27。但如果使用 <code>auto</code>，情况就有些不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = <span class="number">27</span>; <span class="comment">// x1 是 int</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">x2</span><span class="params">(<span class="number">27</span>)</span></span>;<span class="comment">// x2 是 int</span></span><br><span class="line"><span class="keyword">auto</span> x3 = &#123;<span class="number">27</span>&#125;;<span class="comment">//x3 是 std::initializer_list&lt;int&gt; 类型并包含一个元素，其值为 27</span></span><br><span class="line"><span class="keyword">auto</span> x4&#123;<span class="number">27</span>&#125;;<span class="comment">//x4 是 std::initializer_list&lt;int&gt; 类型并包含一个元素，其值为 27</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当使用初始值列表而推导得到的变量类型也是初始值列表。</p>
<p>实际上使用初始值列表推导有两个步骤：</p>
<ul>
<li>因为右值是初始值列表，所以首次推导为 std::initializer_list<T> 类型</li>
<li>然后是根据初始值列表中的值，再次推导 T 的类型</li>
</ul>
<p>基于以上认识，下面这些情况下推导就会出错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误！</span></span><br><span class="line"><span class="comment">//虽然第一步推导出了 std::initializer_list&lt;T&gt;</span></span><br><span class="line"><span class="comment">//但是第二步却由于列表中的值类型不同，而导致推导失败</span></span><br><span class="line"><span class="keyword">auto</span> x5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x = &#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;;<span class="comment">//x 为 std::initializer_list&lt;int&gt; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误！</span></span><br><span class="line"><span class="comment">//函数模版却没有 auto 那么智能</span></span><br><span class="line"><span class="built_in">f</span>(&#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(std::initializer_list&lt;T&gt; initList)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="comment">//f1 仅仅需要一步推导即可得出 T 为 int</span></span><br><span class="line"><span class="built_in">f1</span>(&#123;<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>在 c++ 14 中，函数可以使用 auto 作为返回，但是这种情况下就无法正确的推导初始化列表了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createInitList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//错误，无法推导</span></span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="理解-decltype"><a href="#理解-decltype" class="headerlink" title="理解 decltype"></a>理解 decltype</h1><h2 id="decltype-规则"><a href="#decltype-规则" class="headerlink" title="decltype 规则"></a><code>decltype</code> 规则</h2><ul>
<li><code>decltype</code> 对于变量和表达式的推导，总是忠实的反应其类型</li>
<li>对于<strong>左值表达式</strong>，由于其可被赋值，所以推导的类型总是 T&amp;</li>
<li>c++14 支持 <code>decltype(auto)</code>，使得 <code>auto</code> 以 <code>decltype</code> 的规则进行推导</li>
</ul>
<h2 id="使用-decltype-的场合"><a href="#使用-decltype-的场合" class="headerlink" title="使用 decltype 的场合"></a>使用 <code>decltype</code> 的场合</h2><h3 id="c-11"><a href="#c-11" class="headerlink" title="c++ 11"></a>c++ 11</h3><p>在 c++11 中，<code>decltype</code> 经常使用的场景是用于模板函数：当输入的参数类型不一样，得到的函数返回类型也不一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AuthAndAccess</span><span class="params">(Container&amp; c, Index i)</span></span></span><br><span class="line"><span class="function">-&gt; <span class="title">decltype</span><span class="params">(c[i])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AuthenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的模板函数，要返回 c[i] 类型，但是由于 c 和 i 的类型并无法提前知晓，那么这里使用 decltype 是合理的方式。</p>
<h3 id="c-14"><a href="#c-14" class="headerlink" title="c++ 14"></a>c++ 14</h3><p>对于 c++14 而言，从语法上来讲是可以忽略上面的尾置返回类型的，使用 auto 来推导返回的类型，但是这可能会出错：当需要将函数的返回作为左值时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//由于 auto 推导规则是会省略引用，所以此函数的返回类型最终为 int，而不是 int &amp;</span></span><br><span class="line"><span class="built_in">AuthAndAccess</span>(d, <span class="number">5</span>) = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>为了能够在 c++14 中返回引用，也需要使用 <code>decltype</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container, <span class="keyword">typename</span> Index&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">AuthAndAccess</span><span class="params">(Container&amp; c, Index i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">AuthenticateUser</span>();</span><br><span class="line">    <span class="keyword">return</span> c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>decltype</code> 与 <code>auto</code> 合用，可以使得以 <code>decltype</code> 的形式进行推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w;</span><br><span class="line"><span class="keyword">const</span> Widget&amp; cw = w;</span><br><span class="line"><span class="comment">//my_widget 的类型是 Widget</span></span><br><span class="line"><span class="keyword">auto</span> my_widget = cw;</span><br><span class="line"><span class="comment">//my_widget2 的类型是 const Widget&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) my_widget2 = cw;</span><br></pre></td></tr></table></figure>

<h2 id="使用-decltype-的注意事项"><a href="#使用-decltype-的注意事项" class="headerlink" title="使用 decltype 的注意事项"></a>使用 <code>decltype</code> 的注意事项</h2><ul>
<li>当直接推导变量名时，得到的是变量名对应的类型</li>
<li>当变量名由括号所包含时，得到的是变量名对应类型的引用</li>
</ul>
<p>这种特性使得在函数返回时，很有趣：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">F1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//decltype(x) 得到 int</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">F2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//decltype(x) 得到 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> (x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查看推导的类型"><a href="#查看推导的类型" class="headerlink" title="查看推导的类型"></a>查看推导的类型</h1><p>在理解了基本的推导原则后，为了查看及验证推导的类型，使用<strong>编译时获取</strong>和<strong>基于 boost 库获取</strong>是最为靠谱的方案。</p>
<h2 id="在编辑器中获取"><a href="#在编辑器中获取" class="headerlink" title="在编辑器中获取"></a>在编辑器中获取</h2><p>在大多数 IDE 中的编辑器，如果代码没有语法错误，那么将鼠标指向被推导的变量，就会出现该变量的提示。</p>
<p><strong>但是，在一些稍微复杂的场合，这些提示往往是不准确的。</strong></p>
<h2 id="在编译过程中获取"><a href="#在编译过程中获取" class="headerlink" title="在编译过程中获取"></a>在编译过程中获取</h2><p>通过故意使得编译出错，从而使编译展示该类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeDisplay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	TypeDisplay&lt;<span class="keyword">decltype</span>(x)&gt; type1;</span><br><span class="line">	TypeDisplay&lt;<span class="keyword">decltype</span>((x))&gt; type2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译过程中便会有如下类似错误：</p>
<blockquote>
<p>[Error] aggregate ‘TypeDisplay<int> type1’ has incomplete type and cannot be defined</p>
<p>[Error] aggregate ‘TypeDisplay&lt;int&amp;&gt; type2’ has incomplete type and cannot be defined</p>
</blockquote>
<p>对于稍微复杂一点的场景也可以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeDisplay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>&#123;</span><br><span class="line">	TypeDisplay&lt;T&gt; type1;</span><br><span class="line">	TypeDisplay&lt;<span class="keyword">decltype</span>(param)&gt; type2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; createVec;</span><br><span class="line">	</span><br><span class="line">	createVec.push_back(<span class="number">2.0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">auto</span> vw = createVec;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!vw.empty()) &#123;</span><br><span class="line">		f(&amp;vw[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误输出如下：</p>
<blockquote>
<p>[Error] ‘TypeDisplay&lt;const float*&gt; type1’ has incomplete type</p>
<p>[Error] ‘TypeDisplay&lt;const float* const&amp;&gt; type2’ has incomplete type</p>
</blockquote>
<h2 id="在运行过程中获取"><a href="#在运行过程中获取" class="headerlink" title="在运行过程中获取"></a>在运行过程中获取</h2><p>使用 <code>typeid</code> 很多时候并不能准确的推导类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>(x)).name() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="keyword">decltype</span>((x))).name() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码用 gcc 编译后的输出是：</p>
<blockquote>
<p>Hello world<br>i<br>i</p>
</blockquote>
<p>i 代表 <code>int</code> 类型，但是第二种情况实际上应该是 <code>int &amp;</code>。</p>
<p>在运行时的环境中，只有 <code>boost</code> 库提供的方法能够准确的显示被推导的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::cout;</span><br><span class="line">  <span class="keyword">using</span> boost::typeindex::type_id_with_cvr;</span><br><span class="line">  <span class="comment">// show T</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T =     &quot;</span></span><br><span class="line">       &lt;&lt; type_id_with_cvr&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">       &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  <span class="comment">// show param&#x27;s type</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;param = &quot;</span></span><br><span class="line">       &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">       &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective  C++ ：尽可能使用 const</title>
    <url>/2022/04/10/effective_cpp_use_const/</url>
    <content><![CDATA[<p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#const">谷歌 c++ 编码规范</a>也比较推崇尽量使用<code>const</code>。</p>
<span id="more"></span>

<h1 id="const对指针的修饰"><a href="#const对指针的修饰" class="headerlink" title="const对指针的修饰"></a><code>const</code>对指针的修饰</h1><p><code>const</code>对指针的修饰就看它与星号的位置关系：</p>
<ul>
<li>如果<code>const</code>在星号左边，则被指对象是常量：<code>const int* p = &amp;val</code></li>
<li>如果<code>const</code>在星号右边，则指针自身是常量：<code>int* const p = &amp;val</code></li>
<li>如果<code>const</code>在星号左右都有，则被指对象和指针都是常量：<code>const int* const p = &amp;val</code></li>
</ul>
<p>在使用迭代器时，如果不希望改变容器元素的内容，那么就应该使用<code>const_iterator</code>。</p>
<blockquote>
<p>如果使用<code>const</code>修饰<code>iterator</code>，则得到的是<code>T* const</code>指针，也就是指针自身是常量，但被指对象可以被改变。</p>
</blockquote>
<p>当函数要返回一个指针或引用时，需要考虑是否允许用户可以修改此返回值，如果不允许修改，则需要加上<code>const</code>限定。</p>
<h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a><code>const</code>成员函数</h1><p>当成员函数不会修改成员变量时，应该为其加上<code>const</code>限定：</p>
<ul>
<li>一来可以让接口更为明确</li>
<li>二来可以操作<code>const</code>对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;non const!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;const!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Hello hello;</span><br><span class="line"></span><br><span class="line">    hello.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Hello chello;</span><br><span class="line">	<span class="comment">// 假如没有 const 版本的 print，则此行代码无法通过编译</span></span><br><span class="line">    chello.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要理解的是</strong>：<code>const</code>仅限定该成员函数不会改变成员变量，但被该成员变量指向的内存还是有可能被改变：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CTextBlock</span>(<span class="keyword">const</span> <span class="keyword">char</span>* val) &#123;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (!val) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = std::<span class="built_in">strlen</span>(val) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ptext_ = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">        std::<span class="built_in">memcpy</span>(ptext_, val, std::<span class="built_in">strlen</span>(val));</span><br><span class="line">        ptext_[len - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">CTextBlock</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptext_) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] ptext_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptext_[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Text</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ptext_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* ptext_ &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of obj are : &quot;</span> &lt;&lt; cctb.<span class="built_in">Text</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// ptext 指向的内存被改变了</span></span><br><span class="line">    *pc = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of obj after modified are : &quot;</span> &lt;&lt; cctb.<span class="built_in">Text</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当一个类需要实现<code>const</code>和<code>non-const</code>两个版本函数时，为了避免代码重复，应该使<code>non-const</code>版本调用<code>const</code>版本。</p>
<blockquote>
<p>为<code>non-const</code>添加<code>const</code>限定，使用<code>static_cast</code>即可，这是安全的。</p>
<p>而要去除<code>const</code>显示，使用<code>const_cast</code>，使用前需要谨慎。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;const hello world!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;cast to const\n&quot;</span>;</span><br><span class="line">            <span class="comment">// 将对象 cast 为 const 型，然后就会调用到 const 限定的 print</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Hello&gt;(*<span class="keyword">this</span>).<span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Hello chello;</span><br><span class="line"></span><br><span class="line">    chello.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Hello hello;</span><br><span class="line"></span><br><span class="line">    hello.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="const-成员函数与线程安全"><a href="#const-成员函数与线程安全" class="headerlink" title="const 成员函数与线程安全"></a>const 成员函数与线程安全</h1><p><code>const</code>成员函数在正常情况下，不能对该对象的私有成员变量进行更改，那该函数执行的就是只读操作。</p>
<p>那么多线程调用该成员函数是可以的，例外的是对<code>mutable</code>修饰的变量进行更改。</p>
<p>为了避免<code>const</code>成员函数的<code>mutalbe</code>变量在多线程情况下的数据竞争，需要使用互斥锁、原子锁等方式保证临界区的互斥。</p>
<blockquote>
<p>当有多个原子锁且有一定顺序时，应该使用互斥锁将它们做成一个整体。</p>
</blockquote>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：对右值引用使用 std::move，对通用引用使用 std::forward</title>
    <url>/2022/05/06/effective_cpp_use_move_forward/</url>
    <content><![CDATA[<p>当形参被声明为右值引用时，意味着传入的实参需要是右值引用，并且该参数是可移动的。既然目的如此明确，那么使用<code>std::move</code>是正确的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Widget</span>(Widget&amp;&amp; rhs)               <span class="comment">// rhs is rvalue reference</span></span><br><span class="line">  : <span class="built_in">name</span>(std::<span class="built_in">move</span>(rhs.name)),</span><br><span class="line">    <span class="built_in">p</span>(std::<span class="built_in">move</span>(rhs.p))</span><br><span class="line">    &#123; … &#125;</span><br><span class="line">  …</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">  std::shared_ptr&lt;SomeDataStructure&gt; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但如果形参被声明为通用引用时，则意味着实参有可能是右值引用，该参数有可能可被移动。那么对应的使用<code>std::forward</code>是正确的选择：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span>               <span class="comment">// newName is</span></span></span><br><span class="line"><span class="function">  </span>&#123; name = std::forward&lt;T&gt;(newName); &#125;    <span class="comment">// universal reference</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="如果将std-move应用于通用引用会怎样？"><a href="#如果将std-move应用于通用引用会怎样？" class="headerlink" title="如果将std::move应用于通用引用会怎样？"></a>如果将<code>std::move</code>应用于通用引用会怎样？</h1><p>如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">setName</span><span class="params">(T&amp;&amp; newName)</span>         <span class="comment">// universal reference</span></span></span><br><span class="line"><span class="function">  </span>&#123; name = std::<span class="built_in">move</span>(newName); &#125;    <span class="comment">// compiles, but is</span></span><br><span class="line">                                   <span class="comment">// bad, bad, bad!</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = &#123;<span class="string">&quot;hello,world\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of str before move : &quot;</span> &lt;&lt; str;</span><br><span class="line"></span><br><span class="line">    Widget widget&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    widget.<span class="built_in">setName</span>(str);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The contents of str after move : &quot;</span> &lt;&lt; str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出为：</p>
<blockquote>
<p>The contents of str before move : hello,world<br>The contents of str after move : </p>
</blockquote>
<p>作为<code>widget</code>的使用者，其本意是将<code>str</code>的内容拷贝一份给<code>widget</code>，但是由于使用了<code>std::move</code>进行无条件转换。最终<code>str</code>指向的内容被移动到了<code>widget</code>的私有成员<code>name</code>中。</p>
<p>但作为使用者还以为<code>str</code>中依然是原来的内容，如果继续操作<code>str</code>便会遇到未定义的错误！</p>
<h1 id="对返回值使用std-move或std-forward"><a href="#对返回值使用std-move或std-forward" class="headerlink" title="对返回值使用std::move或std::forward"></a>对返回值使用<code>std::move</code>或<code>std::forward</code></h1><h2 id="好心办坏事"><a href="#好心办坏事" class="headerlink" title="好心办坏事"></a>好心办坏事</h2><p>当<strong>同时</strong>满足以下两个条件时，c++ 会应用返回值优化策略（return value optimization，RVO）：</p>
<ol>
<li>局部变量的类型和函数的返回类型一致</li>
<li>当前局部变量就是被返回的变量</li>
</ol>
<p>那么编译器会尝试使用移动语义，以提高返回变量的效率。</p>
<p>假设在满足 RVO 的前提下，用户主动使用<code>std::move</code>转换返回的变量会怎么样？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Widget w;</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(w);     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>其实这是会起反作用的，因为使用<code>std::move</code>转换后，返回的类型便是<code>Widget</code>的右值引用了，这反而影响了编译器的判断（不满足条件 2）而最终使用拷贝的方式返回。</p>
<blockquote>
<p>相当于用户手动的实现了移动操作，而绕过了编译器的自主优化。</p>
</blockquote>
<h2 id="正确的使用场景"><a href="#正确的使用场景" class="headerlink" title="正确的使用场景"></a>正确的使用场景</h2><p>那么哪种情况下比较适合主动使用<code>std::move</code>或<code>std::forward</code>呢？</p>
<p>也就是返回的变量不满足上面两个条件时，可以主动使用移动语义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Matrix                                        <span class="comment">// by-value return</span></span><br><span class="line"><span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  lhs += rhs;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(lhs);                      <span class="comment">// move lhs into</span></span><br><span class="line">&#125;                                             <span class="comment">// return value</span></span><br></pre></td></tr></table></figure>

<p>上面这个<code>+</code>重载函数是以值的方式返回，参数<code>lhs</code>是一个通用引用。</p>
<p>这种情况下使用<code>std::move</code>转换一下，编译器便会尝试使用移动语义来提高效率：</p>
<ul>
<li>如果<code>Matrix</code>类支持移动操作，那么就会调用移动操作。</li>
<li>如果<code>Matrix</code>类不支持移动操作，那么就会使用拷贝操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;         </span><br><span class="line">Fraction                           <span class="comment">// by-value return</span></span><br><span class="line"><span class="built_in">reduceAndCopy</span>(T&amp;&amp; frac)            <span class="comment">// universal reference param</span></span><br><span class="line">&#123;</span><br><span class="line">  frac.<span class="built_in">reduce</span>();</span><br><span class="line">  <span class="keyword">return</span> std::forward&lt;T&gt;(frac);    <span class="comment">// move rvalue into return</span></span><br><span class="line">&#125;                                  <span class="comment">// value, copy lvalue</span></span><br></pre></td></tr></table></figure>

<p>当参数<code>frac</code>是左值时，那么就使用拷贝操作。</p>
<p>当参数<code>frac</code>是右值时，则将其转换为右值引用，并尝试使用移动操作。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：using 优于 typedef</title>
    <url>/2022/05/03/effective_cpp_using/</url>
    <content><![CDATA[<p>在 c 中，<code>typedef</code>是我经常使用的别名语法。但在 cpp 中，<code>using</code>才是更好的选择。</p>
<span id="more"></span>

<h1 id="可读性比较"><a href="#可读性比较" class="headerlink" title="可读性比较"></a>可读性比较</h1><p>在 cpp 中为了避免命名污染，通常会在使用一个对象、方法时都要输入其完整的命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt; val;</span><br></pre></td></tr></table></figure>

<p>上面第二种写法实在是累，就算使用复制粘贴的方式，以后如果要修改，改起来也非常麻烦。</p>
<p>这种情况下可以使用 <code>typedef</code> 或<code>using</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line">  std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;</span><br><span class="line">  UPtrMapSS;</span><br><span class="line"><span class="keyword">using</span> UPtrMapSS =</span><br><span class="line">  std::unique_ptr&lt;std::unordered_map&lt;std::string, std::string&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>上面这两种方式看不出孰优孰劣，但如果在函数指针的情况下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FP is a synonym for a pointer to a function taking an int and</span></span><br><span class="line"><span class="comment">// a const std::string&amp; and returning nothing</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">const</span> std::string&amp;)</span></span>;      <span class="comment">// typedef</span></span><br><span class="line"><span class="comment">// same meaning as above</span></span><br><span class="line"><span class="keyword">using</span> FP = <span class="built_in"><span class="keyword">void</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">const</span> std::string&amp;);     <span class="comment">// alias</span></span><br><span class="line">                                                  <span class="comment">// declaration</span></span><br></pre></td></tr></table></figure>

<p>很明显，使用<code>using</code>的可读性比<code>typedef</code>要好得多。</p>
<p>下面再看别名一个模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 using</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                           <span class="comment">// MyAllocList&lt;T&gt;</span></span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;  <span class="comment">// is synonym for</span></span><br><span class="line">                                               <span class="comment">// std::list&lt;T,</span></span><br><span class="line">                                               <span class="comment">//   MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt; lw;                        <span class="comment">// client code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  MyAllocList&lt;T&gt; list;                         <span class="comment">// no &quot;typename&quot;,</span></span><br><span class="line">  …                                            <span class="comment">// no &quot;::type&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 typedef</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;                     <span class="comment">// MyAllocList&lt;T&gt;::type</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList</span> &#123;</span>                     <span class="comment">// is synonym for</span></span><br><span class="line">  <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; <span class="comment">// std::list&lt;T,</span></span><br><span class="line">&#125;;                                       <span class="comment">//   MyAlloc&lt;T&gt;&gt;</span></span><br><span class="line">MyAllocList&lt;Widget&gt;::type lw;            <span class="comment">// client code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>                         <span class="comment">// Widget&lt;T&gt; contains</span></span><br><span class="line"><span class="keyword">private</span>:                               <span class="comment">// a MyAllocList&lt;T&gt;</span></span><br><span class="line">  <span class="keyword">typename</span> MyAllocList&lt;T&gt;::type list;  <span class="comment">// as a data member</span></span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以说是高下立判了，并且在使用<code>typedef</code>的情况下，还有可能使得编译结果不是自己所预期的……</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><code>typedef</code>对模板的支持度不够，很多时候会导致编译错误，而<code>using</code>则不会。</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective C++ ：为多态基类声明 virtual 析构函数</title>
    <url>/2022/04/14/effective_cpp_virtual/</url>
    <content><![CDATA[<p>为保证多态析构的正确性，需要为<strong>基类</strong>的虚构函数加上<code>virtual</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">BasicClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass destructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BasicClass &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">DerivedClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;DerivedClass destructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BasicClass</span>* <span class="title">p_class</span> =</span> <span class="keyword">new</span> <span class="built_in">DerivedClass</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果  BasicClass 的析构函数没有 virtual 关键字</span></span><br><span class="line">	<span class="comment">// 那么执行 delete 后只会执行 BasicClass 的析构函数</span></span><br><span class="line">	<span class="comment">// 也就是说，只释放了基类内存，而派生类的内存没有被释放掉</span></span><br><span class="line">    <span class="keyword">delete</span> p_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>但这并不意味着每一个类的析构函数都需要为其加上<code>virtual</code>修饰，因为一旦加上，这个类所携带的信息就还得需要虚指针，虚指针指向对应的虚表。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">BasicClass</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass destructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicClass2</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">BasicClass2</span>() &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;BasicClass2 destructor!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BasicClass basic_class;</span><br><span class="line">    BasicClass2 basic_class2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof BasicClass is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(basic_class) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof BasicClass2 is &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(basic_class2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sizeof BasicClass is 16</span><br><span class="line">sizeof BasicClass2 is 4</span><br><span class="line">BasicClass2 destructor!</span><br><span class="line">BasicClass destructor!</span><br></pre></td></tr></table></figure>

<p>所以：</p>
<ul>
<li>如果一个类不希望作为基类，那它需要使用<code>final</code>关键字来限定避免被继承。自然它也就不需要为析构函数加上<code>virtual</code>修饰了。</li>
<li>如果一个类作为基类，需要应用多态的特性，就需要加上<code>virtual</code>修饰了。</li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
        <category>effective</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>ERPC 接口内存的申请和释放</title>
    <url>/2022/01/17/framework_erpc_allocate_free/</url>
    <content><![CDATA[<p>在 ERPC 的 IDL 说明文档中，对于接口内存的申请和释放是这样描述的：</p>
<blockquote>
<ul>
<li><strong>On the client side:</strong> All memory space has to be allocated and provided by the user code. The shim code only reads from or writes into this memory space.</li>
<li><strong>On the server side:</strong> All memory space is allocated and provided by the shim code. The user code only reads from or writes into this memory space.</li>
</ul>
</blockquote>
<p>为了避免在实际使用中产生内存泄漏，还是需要实际查看代码来理解。</p>
<p>其实这里分两种情况：</p>
<ol>
<li>以指针作为返回参数</li>
<li>以指针作为形参</li>
</ol>
<span id="more"></span>

<p>这一部分的具体实现，需要查看生成的 server 和 client 端的代码来理解，还是以 <a href="http://kcmetercec.top/2021/12/18/framework_erpc_demo/">ERPC 使用体验</a> 的生成代码来看，其 API 为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么这里就主要观察 <strong>binary_t</strong> 这种内置类型。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>服务端生成的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_binary_t_struct</span><span class="params">(erpc::Codec * codec, <span class="keyword">binary_t</span> * data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> * data_local;</span><br><span class="line">    codec-&gt;<span class="built_in">readBinary</span>(&amp;data-&gt;dataLength, &amp;data_local);</span><br><span class="line">    data-&gt;data = (<span class="keyword">uint8_t</span> *) <span class="built_in">erpc_malloc</span>(data-&gt;dataLength * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        codec-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_MemoryError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data-&gt;data, data_local, data-&gt;dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_binary_t_struct</span><span class="params">(<span class="keyword">binary_t</span> * data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(data-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">DEMO_service::DemoHello_shim</span><span class="params">(Codec * codec, MessageBufferFactory *messageFactory, <span class="keyword">uint32_t</span> sequence)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span> *val = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 申请形参的内存</span></span><br><span class="line">    val = (<span class="keyword">binary_t</span> *) <span class="built_in">erpc_malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">binary_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        codec-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_MemoryError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">binary_t</span> * result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// startReadMessage() was already called before this shim was invoked.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">read_binary_t_struct</span>(codec, val);</span><br><span class="line"></span><br><span class="line">    err = codec-&gt;<span class="built_in">getStatus</span>();</span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Invoke the actual served function.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ERPC_NESTED_CALLS_DETECTION</span></span><br><span class="line">        nestingDetection = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 执行 API</span></span><br><span class="line">        result = <span class="built_in">DemoHello</span>(val);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ERPC_NESTED_CALLS_DETECTION</span></span><br><span class="line">        nestingDetection = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// preparing MessageBuffer for serializing data</span></span><br><span class="line">        err = messageFactory-&gt;<span class="built_in">prepareServerBufferForSend</span>(codec-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == kErpcStatus_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// preparing codec for serializing data</span></span><br><span class="line">        codec-&gt;<span class="built_in">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Build response message.</span></span><br><span class="line">        codec-&gt;<span class="built_in">startWriteMessage</span>(kReplyMessage, kDEMO_service_id, kDEMO_DemoHello_id, sequence);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write_binary_t_struct</span>(codec, result);</span><br><span class="line"></span><br><span class="line">        err = codec-&gt;<span class="built_in">getStatus</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放形参内存中 data 所指向的内存</span></span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free_binary_t_struct</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放形参本身的内存</span></span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放返回值内存中 data 所指向的内存</span></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free_binary_t_struct</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放返回值本身的内存</span></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出来：</p>
<ol>
<li>服务端会自动申请形参的内存，以及形参内部数据指针的内存</li>
<li>服务端会自动释放形参相关的所有内存</li>
<li>服务端会自动释放返回值相关的所有内存</li>
</ol>
<p>那么对于服务端的用户实现的代码，就需要：</p>
<ol>
<li>对于形参</li>
</ol>
<ul>
<li>如果服务端形参是读指针，那么只需要直接读取即可</li>
<li>如果服务端形参是写指针，那么用户需要申请其内部<code>data</code>指针所指向的内存</li>
</ul>
<ol start="2">
<li>对于返回</li>
</ol>
<ul>
<li>用户需要完成对<code>binary_t</code>以及其内部<code>data</code>指针所指向的内存的申请</li>
</ul>
<p>所以在<code>server</code>端用户代码就是这样写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client message: &quot;</span> &lt;&lt; (<span class="keyword">char</span>*)val-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = std::<span class="built_in">strlen</span>(ret) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)std::<span class="built_in">malloc</span>(len);</span><br><span class="line">    std::<span class="built_in">strncpy</span>(buf, ret, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span>* message = <span class="keyword">new</span> <span class="keyword">binary_t</span>&#123;(<span class="keyword">uint8_t</span>*)buf, (<span class="keyword">uint32_t</span>)(len - <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>DemoHello</code>函数执行完毕后，申请的这两段内存是会被自动释放掉的。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端其自动生成代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_binary_t_struct</span><span class="params">(erpc::Codec * codec, <span class="keyword">binary_t</span> * data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> * data_local;</span><br><span class="line">    codec-&gt;<span class="built_in">readBinary</span>(&amp;data-&gt;dataLength, &amp;data_local);</span><br><span class="line">    data-&gt;data = (<span class="keyword">uint8_t</span> *) <span class="built_in">erpc_malloc</span>(data-&gt;dataLength * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        codec-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_MemoryError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(data-&gt;data, data_local, data-&gt;dataLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO interface DemoHello function client shim.</span></span><br><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span> * result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        <span class="comment">// 申请读取内存</span></span><br><span class="line">        result = (<span class="keyword">binary_t</span> *) <span class="built_in">erpc_malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">binary_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            codec-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_MemoryError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里会申请读取数据内存</span></span><br><span class="line">        <span class="built_in">read_binary_t_struct</span>(codec, result);</span><br><span class="line"></span><br><span class="line">        err = codec-&gt;<span class="built_in">getStatus</span>();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispose of the request.</span></span><br><span class="line">    g_client-&gt;<span class="built_in">releaseRequest</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke error handler callback function</span></span><br><span class="line">    g_client-&gt;<span class="built_in">callErrorHandler</span>(err, kDEMO_DemoHello_id);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ERPC_PRE_POST_ACTION</span></span><br><span class="line">    pre_post_action_cb postCB = g_client-&gt;<span class="built_in">getPostCB</span>();</span><br><span class="line">    <span class="keyword">if</span> (postCB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">postCB</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，客户端代码是会自动完成对<code>binary_t</code>以及其内部<code>data</code>指针所指向的内存的申请。</p>
<p>所以：</p>
<ol>
<li>客户端在接收到数据并处理后，<strong>需要主动释放器返回指针的内存</strong>！</li>
</ol>
<p>所以，客户端的代码也是这样写的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    <span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60901</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 初始化消息缓存</span></span><br><span class="line">    <span class="keyword">auto</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 加入消息</span></span><br><span class="line">    <span class="built_in">erpc_client_init</span>(transport, message_buffer_factory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> message = <span class="string">&quot;Hello, this is client!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">binary_t</span> cmd&#123;(<span class="keyword">uint8_t</span>*)message, (<span class="keyword">uint32_t</span>)(std::<span class="built_in">strlen</span>(message))&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span> *ret = <span class="built_in">DemoHello</span>(&amp;cmd);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Get message of server: &quot;</span> &lt;&lt; ret-&gt;data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(ret-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">erpc_transport_tcp_close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>以上是 ERPC 针对<code>binary_t</code>而言，它会主动释放其内部的<code>data</code>缓存，因为这是它内置类型。</p>
<p>而如果是用户自定义的结构体指针中还包含其他数据指针，就需要小心管理了。</p>
<p>所以为了避免这种情况：</p>
<ol>
<li>简单数据类型，使用结构体进行传递</li>
<li>复杂的数据，通过<code>binary_t</code>进行传递</li>
</ol>
]]></content>
      <categories>
        <category>framework</category>
        <category>ERPC</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>ERPC 同时运行一个服务端和客户端</title>
    <url>/2021/12/20/framework_erpc_cs_together/</url>
    <content><![CDATA[<p>在使用 EPRC 进行 TCP 通信的过程中，如果需要同时运行一个客户端和服务端就会出现异常。</p>
<p>这是因为其提供的 <code>erpc_setup_tcp.cpp</code> 只能初始化一个实例，那就需要对其进行理解并修改。</p>
<span id="more"></span>

<h1 id="EPRC-能否支持在运行服务端的时候运行客户端？"><a href="#EPRC-能否支持在运行服务端的时候运行客户端？" class="headerlink" title="EPRC 能否支持在运行服务端的时候运行客户端？"></a>EPRC 能否支持在运行服务端的时候运行客户端？</h1><p>从理论上来讲，服务端和客户端都维护自己对应的端口，读写数据都走自己的端口即可，互不相干。</p>
<p>从 ERPC 的 API 可以看到，服务端和客户端创建的代码是不一样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief This function initializes client.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] transport Initiated transport.</span></span><br><span class="line"><span class="comment"> * @param[in] message_buffer_factory Initiated message buffer factory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function initializes client with all components necessary for serve client request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erpc_client_init</span><span class="params">(<span class="keyword">erpc_transport_t</span> transport, <span class="keyword">erpc_mbf_t</span> message_buffer_factory)</span></span>;</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief This function initializes server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function initializes server with all components necessary for running server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Server object type.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">erpc_server_t</span> <span class="title">erpc_server_init</span><span class="params">(<span class="keyword">erpc_transport_t</span> transport, <span class="keyword">erpc_mbf_t</span> message_buffer_factory)</span></span>;</span><br></pre></td></tr></table></figure>

<p>那么应该是可以将二者区分开来应用的。</p>
<h1 id="erpc-setup-tcp-cpp-的更改"><a href="#erpc-setup-tcp-cpp-的更改" class="headerlink" title="erpc_setup_tcp.cpp 的更改"></a><code>erpc_setup_tcp.cpp</code> 的更改</h1><p>在 <code>erpc_setup_tcp.cpp</code> 中，其使用 <code>s_transport</code> 来对 TCP 对象进行创建，但是模板类中的私有成员对象仅能存储一个对象元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief Storage for the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An array of uint64 is used to get 8-byte alignment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">uint64_t</span> m_storage[(<span class="built_in"><span class="keyword">sizeof</span></span>(T) + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint64_t</span>) - <span class="number">1</span>) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">uint64_t</span>)];</span><br></pre></td></tr></table></figure>

<p>如果我们要同时使用一个服务端和客户端，就需要调用 <code>erpc_transport_tcp_init</code> 函数两次以创建两个对象，所以这里就需要对其进行更改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2020 (c) Sierra Wireless</span></span><br><span class="line"><span class="comment"> * Copyright 2021 ACRIOS Systems s.r.o.</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_manually_constructed.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_tcp_transport.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_transport_setup.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> erpc;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Variables</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ManuallyConstructed&lt;TCPTransport&gt; s_transport[<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 新增加标记来避免多次调用该函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> initialized[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_transport_t</span> <span class="title">erpc_transport_tcp_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">uint16_t</span> port, <span class="keyword">bool</span> isServer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_transport_t</span> transport;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can only initialize once</span></span><br><span class="line">    <span class="keyword">if</span> (initialized[isServer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 isServer 的值来区分是客户端还是服务端</span></span><br><span class="line">    s_transport[isServer].<span class="built_in">construct</span>(host, port, isServer);</span><br><span class="line">    <span class="keyword">if</span> (kErpcStatus_Success == s_transport[isServer]-&gt;<span class="built_in">open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        transport = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">erpc_transport_t</span>&gt;(s_transport[isServer].<span class="built_in">get</span>());</span><br><span class="line">        initialized[isServer] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transport = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transport;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erpc_transport_tcp_close</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialized[<span class="literal">false</span>]) &#123;</span><br><span class="line">        s_transport[<span class="literal">false</span>].<span class="built_in">get</span>()-&gt;<span class="built_in">close</span>(<span class="literal">true</span>);</span><br><span class="line">        initialized[<span class="literal">false</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initialized[<span class="literal">true</span>]) &#123;</span><br><span class="line">        s_transport[<span class="literal">true</span>].<span class="built_in">get</span>()-&gt;<span class="built_in">close</span>(<span class="literal">true</span>);</span><br><span class="line">        initialized[<span class="literal">true</span>] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="修改及验证"><a href="#修改及验证" class="headerlink" title="修改及验证"></a>修改及验证</h1><p>其实我们只需要在 <a href="http://kcmetercec.top/2021/12/18/framework_erpc_demo/">上一篇 demo</a> 的基础之上，再增加一个服务端，来接收原来服务端的数据即可验证。</p>
<h2 id="新服务端的-IDL-文件"><a href="#新服务端的-IDL-文件" class="headerlink" title="新服务端的 IDL 文件"></a>新服务端的 IDL 文件</h2><p>新服务端的 IDL 文件 <code>erpcserver.erpc</code> 依然很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义工程的名字，后面生成的文件就会以这个名字作为前缀</span></span><br><span class="line">program erpcserver</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line">interface SERVER &#123;</span><br><span class="line">    <span class="comment">// 这里表示可调用函数 ServerHello 输入类型是 int32，无输出类型</span></span><br><span class="line">    <span class="function">oneway <span class="title">ServerHello</span><span class="params">(int32 val)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后再按照之前的方式生成文件即可。</p>
<h2 id="test-erpcdemo-server-cpp"><a href="#test-erpcdemo-server-cpp" class="headerlink" title="test_erpcdemo_server.cpp"></a><code>test_erpcdemo_server.cpp</code></h2><p>原服务端也需要增加初始化客户端的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file: test_erpcdemo_server.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_client_setup.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_server_setup.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_transport_setup.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpcdemo_server.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpcserver.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* ret = <span class="string">&quot;Hello, this is server!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client message: &quot;</span> &lt;&lt; (<span class="keyword">char</span>*)val-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = std::<span class="built_in">strlen</span>(ret) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)std::<span class="built_in">malloc</span>(len);</span><br><span class="line">    std::<span class="built_in">strncpy</span>(buf, ret, len - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">binary_t</span>* message = <span class="keyword">new</span> <span class="keyword">binary_t</span>&#123;(<span class="keyword">uint8_t</span>*)buf, (<span class="keyword">uint32_t</span>)(len - <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给另一个服务端发数据</span></span><br><span class="line">    <span class="built_in">ServerHello</span>(<span class="number">-123456</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    <span class="keyword">auto</span> transport1 = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60902</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 初始化消息缓存</span></span><br><span class="line">    <span class="keyword">auto</span> message_buffer_factory1 = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 加入消息</span></span><br><span class="line">    <span class="built_in">erpc_client_init</span>(transport1, message_buffer_factory1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建服务端</span></span><br><span class="line">    <span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60901</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 建立消息缓存</span></span><br><span class="line">    <span class="keyword">erpc_mbf_t</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 初始化服务端对象</span></span><br><span class="line">    <span class="built_in">erpc_server_init</span>(transport, message_buffer_factory);</span><br><span class="line">    <span class="comment">// 将当前服务端加入事件检测机制</span></span><br><span class="line">    <span class="built_in">erpc_add_service_to_server</span>(<span class="built_in">create_DEMO_service</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server is running!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="built_in">erpc_server_run</span>(); </span><br><span class="line">    <span class="comment">// 当客户端退出后，服务端也主动退出</span></span><br><span class="line">    <span class="built_in">erpc_transport_tcp_close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="test-erpcserver-server-cpp"><a href="#test-erpcserver-server-cpp" class="headerlink" title="test_erpcserver_server.cpp"></a><code>test_erpcserver_server.cpp</code></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file: test_erpcserver_server.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_server_setup.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_transport_setup.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpcserver_server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerHello</span><span class="params">(<span class="keyword">int32_t</span> val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;I get value from client: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务端</span></span><br><span class="line">    <span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60902</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 建立消息缓存</span></span><br><span class="line">    <span class="keyword">erpc_mbf_t</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 初始化服务端对象</span></span><br><span class="line">    <span class="built_in">erpc_server_init</span>(transport, message_buffer_factory);</span><br><span class="line">    <span class="comment">// 将当前服务端加入事件检测机制</span></span><br><span class="line">    <span class="built_in">erpc_add_service_to_server</span>(<span class="built_in">create_SERVER_service</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server2 is running!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="built_in">erpc_server_run</span>(); </span><br><span class="line">    <span class="comment">// 当客户端退出后，服务端也主动退出</span></span><br><span class="line">    <span class="built_in">erpc_transport_tcp_close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NESTED-CALLS-DETECTION"><a href="#NESTED-CALLS-DETECTION" class="headerlink" title="NESTED_CALLS_DETECTION"></a>NESTED_CALLS_DETECTION</h2><p><code>NESTED_CALLS_DETECTION</code> 宏是用于检测在服务端的函数被调用期间，是否又进行了其他接口函数的调用。这个宏默认是使能的。</p>
<blockquote>
<p>服务端生成的自动代码中，会先后设置变量 <code>nestingDetection</code> 的值为 <code>true</code> 和 <code>false</code>，以检测这期间是否有嵌套调用。</p>
</blockquote>
<p>而如果我们修改当前代码到客户端和服务端同时使用时，便会给这个宏带来误导，导致客户端的调用函数可能会返回失败 <code>kErpcStatus_NestedCallFailure</code>。</p>
<p>所以这里要在文件 <code>erpc_config.h</code> 中关闭该宏。</p>
<h2 id="修改-Makefile"><a href="#修改-Makefile" class="headerlink" title="修改 Makefile"></a>修改 Makefile</h2><p>原服务端既是客户端也是服务端，且我们也新增了代码，所以需要修改如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">INCLUDE = /usr/local/<span class="keyword">include</span>/erpc</span><br><span class="line">LIBRARY = /usr/local/lib</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	g++  test_erpcdemo_client.cpp erpcdemo_client.cpp erpc_setup_tcp.cpp -I$&#123;INCLUDE&#125; -L$&#123;LIBRARY&#125; -lerpc -lpthread -o client</span><br><span class="line">	g++  test_erpcdemo_server.cpp erpcdemo_server.cpp erpcserver_client.cpp erpc_setup_tcp.cpp -I$&#123;INCLUDE&#125; -L$&#123;LIBRARY&#125; -lerpc -lpthread -o server</span><br><span class="line">	g++  test_erpcserver_server.cpp erpcserver_server.cpp erpc_setup_tcp.cpp -I$&#123;INCLUDE&#125; -L$&#123;LIBRARY&#125; -lerpc -lpthread -o server2</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>可以看到已经正常运行了：</p>
<p>新服务端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./server2</span></span><br><span class="line">server2 is running!</span><br><span class="line">I get value from client: -123456</span><br></pre></td></tr></table></figure>

<p>原服务端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./server</span></span><br><span class="line">server is running!</span><br><span class="line">client message: Hello, this is client!</span><br></pre></td></tr></table></figure>

<p>原客户端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./client</span></span><br><span class="line">Get message of server: Hello, this is server!</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在 ERPC 源码中存在着不少静态全局变量，这是代码中的 Bad smell，这些对象应该是能够被动态的创建和销毁的。</p>
]]></content>
      <categories>
        <category>framework</category>
        <category>ERPC</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>ERPC 使用体验</title>
    <url>/2021/12/18/framework_erpc_demo/</url>
    <content><![CDATA[<p>在没有使用 <a href="https://zh.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E9%81%8E%E7%A8%8B%E8%AA%BF%E7%94%A8">RPC</a> 之前，那就需要程序员自己来完成两个进程（芯片）之间的通信。无论是对于发射端还是接收端，其逻辑都类似如下：</p>
<ol>
<li>发送端根据制定的传输格式传输二进制流</li>
<li>接收端根据接收到的二进制流，以状态机的方式依次分解二进制流的内容</li>
<li>最终将解析出来的命令和数据与对应的处理程序进行关联调用</li>
</ol>
<p>人为实现这个过程比较繁琐：</p>
<ol>
<li>发射端和接收端可能会存在大小端的问题，这需要单独处理</li>
<li>如果代码架构不好，那么换一个底层通信协议便会导致又需要重新实现一次这个过程</li>
<li>长期维护起来比较麻烦，尤其是存在多个进程（芯片）之间通信时</li>
<li>发射端和接收端存在同步和异步调用关系，人为实现较为麻烦</li>
</ol>
<p>而有了 RPC 框架，便可以以函数调用的方式来实现多个进程（芯片）之间的通信，通信细节对于程序员来讲就是透明的。程序员便可以专注于上层业务逻辑，提高开发效率。</p>
<p>相比较于代码量庞大的 <a href="https://grpc.io/">grpc</a>，<a href="https://github.com/EmbeddedRPC/erpc">ERPC</a> 更适合于嵌入式通信的应用场景，我们先来体验一下它。</p>
<span id="more"></span>

<h1 id="获取代码并打补丁"><a href="#获取代码并打补丁" class="headerlink" title="获取代码并打补丁"></a>获取代码并打补丁</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>EPRC 的工具需要一些依赖库才可以工作，所以需要先安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y flex bison libboost-dev libboost-system-dev libboost-filesystem-dev</span><br></pre></td></tr></table></figure>

<h2 id="获取代码"><a href="#获取代码" class="headerlink" title="获取代码"></a>获取代码</h2><p>ERPC 主要分为 <code>Master</code> 和 <code>develop</code> 两个分支，在 clone 代码以后，首先需要切换到 <code>Master</code> 分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/EmbeddedRPC/erpc.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> erpc/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br></pre></td></tr></table></figure>

<h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><p>虽然这 <code>Master</code> 分支是最新的 1.8.1 版本，但由于其存在重复定义 BUG，所以需要修复该问题。按照这个 <a href="https://github.com/EmbeddedRPC/erpc/pull/180/files/71d0063d1c13562df961df39331020624c516bfd">Pull request</a> 进行修复即可。</p>
<h1 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h1><p>编译和安装步骤倒是轻车熟路了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j8</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure>

<p>安装完成后，安装路径位于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Installing headers in /usr/local/include/erpc</span><br><span class="line">Installing liberpc.a in /usr/local/lib</span><br><span class="line">Installing erpcgen in /usr/local/bin</span><br><span class="line">Installing erpcsniffer in /usr/local/bin</span><br></pre></td></tr></table></figure>

<h1 id="编写-demo"><a href="#编写-demo" class="headerlink" title="编写 demo"></a>编写 demo</h1><h2 id="定义-IDL-文件"><a href="#定义-IDL-文件" class="headerlink" title="定义 IDL 文件"></a>定义 IDL 文件</h2><p>IDL 文件用于定义客户端和服务端通信的接口，下面建立一个简单的文件 <code>erpcdemo.erpc</code> ：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义工程的名字，后面生成的文件就会以这个名字作为前缀</span></span><br><span class="line">program erpcdemo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line">interface DEMO &#123;</span><br><span class="line">    <span class="comment">// 这里表示可调用函数 DemoHello 输入类型是 binary，输出类型也是 binary</span></span><br><span class="line">    <span class="built_in">DemoHello</span>(binary val) -&gt; binary</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来便是生成对应的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> erpcgen erpcdemo.erpc</span></span><br></pre></td></tr></table></figure>

<p>便会生成下面 4 个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">erpcdemo.h</span><br><span class="line">erpcdemo_client.cpp</span><br><span class="line">erpcdemo_server.cpp</span><br><span class="line">erpcdemo_server.h</span><br></pre></td></tr></table></figure>

<p>对于客户端而言，需要包含<code>erpcdemo.h</code>，<code>erpcdemo_client.cpp</code>文件。</p>
<p>对于服务端而言，需要包含<code>erpcdemo_server.cpp</code>，<code>erpcdemo_server.h</code>文件。</p>
<h2 id="提供-TCP-通信实例"><a href="#提供-TCP-通信实例" class="headerlink" title="提供 TCP 通信实例"></a>提供 TCP 通信实例</h2><p>由于 ERPC 默认编译方式并没有把创建 TCP 实例的代码包含进库中，所以我们需要将 <code>erpc_c/setup/erpc_setup_tcp.cpp</code> 复制到当前测试文件夹下。</p>
<h2 id="实现服务端"><a href="#实现服务端" class="headerlink" title="实现服务端"></a>实现服务端</h2><p>服务端用于创建连接并实现接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file: test_erpcdemo_server.cpp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_server_setup.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_transport_setup.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpcdemo_server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* ret = <span class="string">&quot;Hello, this is server!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;client message: &quot;</span> &lt;&lt; (<span class="keyword">char</span>*)val-&gt;data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = std::<span class="built_in">strlen</span>(ret) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)std::<span class="built_in">malloc</span>(len);</span><br><span class="line">    std::<span class="built_in">strncpy</span>(buf, ret, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span>* message = <span class="keyword">new</span> <span class="keyword">binary_t</span>&#123;(<span class="keyword">uint8_t</span>*)buf, (<span class="keyword">uint32_t</span>)(len - <span class="number">1</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建服务端</span></span><br><span class="line">    <span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60901</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 建立消息缓存</span></span><br><span class="line">    <span class="keyword">erpc_mbf_t</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 初始化服务端对象</span></span><br><span class="line">    <span class="built_in">erpc_server_init</span>(transport, message_buffer_factory);</span><br><span class="line">    <span class="comment">// 将当前服务端加入事件检测机制</span></span><br><span class="line">    <span class="built_in">erpc_add_service_to_server</span>(<span class="built_in">create_DEMO_service</span>());</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;server is running!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="built_in">erpc_server_run</span>();</span><br><span class="line">    <span class="comment">// 当客户端退出后，服务端也主动退出</span></span><br><span class="line">    <span class="built_in">erpc_transport_tcp_close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现客户端"><a href="#实现客户端" class="headerlink" title="实现客户端"></a>实现客户端</h2><p>客户端就是与服务端连接，并调用接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file: test_erpcdemo_client.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_client_setup.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_port.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;erpc_transport_setup.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpcdemo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    <span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60901</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 初始化消息缓存</span></span><br><span class="line">    <span class="keyword">auto</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line">    <span class="comment">// 加入消息</span></span><br><span class="line">    <span class="built_in">erpc_client_init</span>(transport, message_buffer_factory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> message = <span class="string">&quot;Hello, this is client!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">binary_t</span> cmd&#123;(<span class="keyword">uint8_t</span>*)message, (<span class="keyword">uint32_t</span>)(std::<span class="built_in">strlen</span>(message))&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">binary_t</span> *ret = <span class="built_in">DemoHello</span>(&amp;cmd);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Get message of server: &quot;</span> &lt;&lt; ret-&gt;data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(ret-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="built_in">erpc_free</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">erpc_transport_tcp_close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写-Makefile"><a href="#编写-Makefile" class="headerlink" title="编写 Makefile"></a>编写 Makefile</h2><p>Makefile 比较简单，如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">INCLUDE = /usr/local/<span class="keyword">include</span>/erpc</span><br><span class="line">LIBRARY = /usr/local/lib</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        g++  test_erpcdemo_client.cpp erpcdemo_client.cpp erpc_setup_tcp.cpp -I$&#123;INCLUDE&#125; -L$&#123;LIBRARY&#125; -lerpc -lpthread -o client</span><br><span class="line">        g++  test_erpcdemo_server.cpp erpcdemo_server.cpp erpc_setup_tcp.cpp -I$&#123;INCLUDE&#125; -L$&#123;LIBRARY&#125; -lerpc -lpthread -o server</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>服务端输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server is running!</span><br><span class="line">client message: Hello, this is client!</span><br></pre></td></tr></table></figure>

<p>客户端输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Get message of server: Hello, this is server!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>framework</category>
        <category>ERPC</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>IMX8MM 使用 ERPC 结合 rpmsg 完成 A53 和 M4 的通信</title>
    <url>/2021/12/21/framework_erpc_imx8mm_rpmsg/</url>
    <content><![CDATA[<p>NXP 官方提供了 M4 和 A53 通信的 demo，但是仅仅是演示作用：</p>
<ul>
<li>M4 端仅使用 rpmsg 与 A53 进行通信，没有 ERPC 封装</li>
<li>A53 端将 rpmsg 操作暴露成了一个 tty 设备，仅适合 <code>echo</code> 演示，不适合编写代码完成通信</li>
<li>需要在 rpmsg 的基础上进行 ERPC 封装</li>
</ul>
<p>那么完成的步骤就是：</p>
<ol>
<li>完成用户态代码实现与 M4 进行 rpmsg 通信</li>
<li>对 rpmsg 进行 ERPC 封装</li>
</ol>
<span id="more"></span>

<h1 id="rpmsg-char-驱动"><a href="#rpmsg-char-驱动" class="headerlink" title="rpmsg_char 驱动"></a><code>rpmsg_char</code> 驱动</h1><p>内核文件 <code>drivers/rpmsg/rpmsg_char.c</code> 驱动，可以将 rpmsg 相关操作暴露在用户空间的 <code>/dev/rpmsg_ctrlX</code> 路径中。</p>
<p>用户可以操作 <code>/dev/rpmsg_ctrlX</code> 文件，以创建对应通信端口。</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>kernel 主线的代码对 <code>rpmsg_char</code> 的支持不够完善，所以我们需要先应用<a href="https://lwn.net/Articles/743115/">这个补丁</a>，以完成对通信端口动态的创建。</p>
<h2 id="使能"><a href="#使能" class="headerlink" title="使能"></a>使能</h2><p>在 menuconfig 路径 <code>Device Drivers -&gt; Rpmsg drivers</code> 确认 <code>RPMSG device interface</code>使能。</p>
<blockquote>
<p>使能后，<code>Enable Virtio RPMSG char device driver support</code> 也会默认使能。</p>
</blockquote>
<p>启动新编译的内核后，便可以看到 rpmsg 的控制设备 <code>/dev/rpmsg_ctrl0</code>。</p>
<h1 id="编写用户态代码"><a href="#编写用户态代码" class="headerlink" title="编写用户态代码"></a>编写用户态代码</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>对应的头文件位于 <code>include/uapi/linux/rpmsg.h</code>，根据该头文件及其代码可以看出应用流程为：</p>
<ol>
<li>首先使用 <code>ioctl()</code> 操作 <code>/dev/rpmsg_ctrl0</code> 设备，发送命令 <code>RPMSG_CREATE_EPT_IOCTL</code> 来创建一个端口。</li>
<li>操作端口 <code>/dev/rpmsgX</code> ，使用 <code>read()</code>,<code>write()</code> 系统调用完成对端口的读写操作</li>
<li>对端口 <code>/dev/rpmsgX</code>，使用 <code>ioctl()</code>，发送命令 <code>RPMSG_DESTROY_EPT_IOCTL</code> 来销毁该端口</li>
</ol>
<p>在创建端口设备时，需要填充结构体 <code>rpmsg_endpoint_info</code>:<br> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct rpmsg_endpoint_info - endpoint info representation</span></span><br><span class="line"><span class="comment"> * @name: name of service</span></span><br><span class="line"><span class="comment"> * @src: local address</span></span><br><span class="line"><span class="comment"> * @dst: destination address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rpmsg_endpoint_info</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> src;</span><br><span class="line">    <span class="keyword">uint32_t</span> dst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这里面填充的值，需要根据 M4 端创建的服务端而定。</p>
<p>在使用 NXP 所提供的 <code>imx_rpmsg_tty.c</code> 驱动中，其输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">imx_rpmsg_tty virtio0.rpmsg-virtual-tty-channel-1.-1.30: new channel: 0x400 -&gt; 0x1e!</span><br></pre></td></tr></table></figure>
<p>也就是说，其对应：</p>
<ul>
<li>name：<code>rpmsg-virtual-tty-channel-1</code></li>
<li>src：<code>0x400</code></li>
<li>dst：<code>0x1e</code></li>
</ul>
<h2 id="编写及测试"><a href="#编写及测试" class="headerlink" title="编写及测试"></a>编写及测试</h2><p>有了上面的基础，那就可以写一个简单的测试程序了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * file: rpmsg_test.c</span></span><br><span class="line"><span class="comment"> * author: kcmetercec (kcmeter.cec@gmail.com)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rpmsg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_CONTROL_NAME		<span class="meta-string">&quot;/dev/rpmsg_ctrl0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_EP_NAME			<span class="meta-string">&quot;/dev/rpmsg0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUF_SIZE	(128)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;send command&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> control_device_fd = <span class="built_in">open</span>(DEVICE_CONTROL_NAME, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (control_device_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t open control device: &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rpmsg_endpoint_info</span> <span class="title">ep_info</span> =</span> &#123;</span><br><span class="line">		.name = <span class="string">&quot;rpmsg-virtual-tty-channel-1&quot;</span>,</span><br><span class="line">		.src = <span class="number">0x400</span>,</span><br><span class="line">		.dst = <span class="number">0x1e</span>,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(control_device_fd, RPMSG_CREATE_EPT_IOCTL, &amp;ep_info)) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t create endpoint:&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ep_fd = <span class="built_in">open</span>(DEVICE_EP_NAME, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (ep_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t open endpoint device: &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> write_size = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">ssize_t</span> ret = <span class="built_in">write</span>(ep_fd, argv[<span class="number">1</span>], write_size);</span><br><span class="line">	<span class="keyword">if</span> (ret != write_size) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;write failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> read_buf[READ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">read</span>(ep_fd, read_buf, READ_BUF_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;read failed:&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read end of file.\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		read_buf[READ_BUF_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read from m4: %s\n&quot;</span>, read_buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(ep_fd, RPMSG_DESTROY_EPT_IOCTL)) &#123;</span><br><span class="line">		<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t destroy endpoint:&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">close</span>(ep_fd);</span><br><span class="line">	<span class="built_in">close</span>(control_device_fd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上简单的代码，便可以完成与 M4 的回环测试了。</p>
<h1 id="EPRC-封装"><a href="#EPRC-封装" class="headerlink" title="EPRC 封装"></a>EPRC 封装</h1><p>在 M4 和 A53 通信的过程中，M4 是作为服务端（remote）而存在的，而 A53 是作为客户端（master）而存在的。</p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>查看当前 ERPC 的代码，其已经具备了 <code>erpc_transport_rpmsg_lite_rtos_remote_init()</code> 函数，其创建的实例是 <code>RPMsgRTOSTransport</code> 类。</p>
<p><code>RPMsgRTOSTransport</code> 类已经实现了直接使用 <code>rpmsg_lite</code> 库的创建、读、写函数，所以对于 M4 而言，只需要将 ERPC 库移植到其代码中即可。</p>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>客户端则是使用 <code>rpmsg_char</code> 接口完成的数据读写，所以这里需要我们自己实现一个 transport 类以及对应的 setup 函数。</p>
<h3 id="编译无法通过的坑"><a href="#编译无法通过的坑" class="headerlink" title="编译无法通过的坑"></a>编译无法通过的坑</h3><p>在将 ERPC 源码移植到 M4 工程中时，会有如下类似警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MIMX8MM6_cm4.h:6371:51: error: &#x27;reinterpret_cast&lt;CCM_Type*&gt;(808976384)&#x27; is not a constant expression</span><br></pre></td></tr></table></figure>
<p>这个警告造成的原因是有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CCM_BASE (0x30380000u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CCM ((CCM_Type*)CCM_BASE)</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">clock_root_control</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kCLOCK_RootM4 = (<span class="keyword">uint32_t</span>)(&amp;(CCM)-&gt;ROOT[<span class="number">1</span>].TARGET_ROOT),</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">clock_root_control_t</span>;</span><br></pre></td></tr></table></figure>
<p>注意看，<strong>这是一个枚举类型</strong>。</p>
<p>C++ 标准规定，枚举类型的值必须是常量表达式，而 <code>CCM</code> 宏的实现方式由 c++ 编译器解释就是使用 <code>reinterpret_cast</code> 对指针进行从新解释。那就是说它不是一个常量表达式，这就会造成编译时报错。</p>
<p>所以，为了解决这个报错，就需要将这行代码替换为常量表达式。</p>
<p>这个代码的意义就是为了获取 <code>CCM</code> 空间下 <code>ROOT[1].TARGET_ROOT</code> 处所在的地址，地址以整型表示。</p>
<p>而 C/C++ 提供了宏 <code>offsetof</code> 来以常量的方式计算地址偏移：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member)</span></span><br></pre></td></tr></table></figure>
<p>那么上面的枚举就可以修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">kCLOCK_RootM4 = (<span class="keyword">uint32_t</span>)(CCM_BASE + <span class="built_in">offsetof</span>(CCM_Type, ROOT[<span class="number">1</span>].TARGET_ROOT)),</span><br></pre></td></tr></table></figure>

<h3 id="transport-类"><a href="#transport-类" class="headerlink" title="transport 类"></a>transport 类</h3><p>根据前面的测试代码，再继承自 <code>Transport</code> 类，很容易就能写出 <code>transport</code> 类。</p>
<p>头文件：<code>erpc_rpmsg_char_transport.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.</span></span><br><span class="line"><span class="comment"> * Copyright 2016-2020 NXP</span></span><br><span class="line"><span class="comment"> * Copyright 2021 kcmetercec (kcmeter.cec@gmail.com)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _EMBEDDED_RPC__RPMSG_CHAR_TRANSPORT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _EMBEDDED_RPC__RPMSG_CHAR_TRANSPORT_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rpmsg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_transport.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup rpmsg_char_transport</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> * @file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Classes</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> erpc &#123;</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief Client side of rpmsg transport.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @ingroup rpmsg_char_transport</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RPMsgCharTransport</span> :</span> <span class="keyword">public</span> Transport</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief Constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This function initializes object attributes.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param[in] name Specify the name of the remote device.</span></span><br><span class="line"><span class="comment">     * @param[in] src Specify the local address.</span></span><br><span class="line"><span class="comment">     * @param[in] dst Specify the destination address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">RPMsgCharTransport</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> src, <span class="keyword">uint32_t</span> dst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief RPMsgCharTransport destructor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RPMsgCharTransport</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief This function will connect client to the server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @retval #kErpcStatus_Success When client connected successfully.</span></span><br><span class="line"><span class="comment">     * @retval #kErpcStatus_ConnectionFailure Connecting to the specified host failed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">connect</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief This function disconnects client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @retval #kErpcStatus_Success Always return this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">disconnect</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief Store incoming message to message buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In block while no message come.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param[in] message Message buffer, to which will be stored incoming message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @retval kErpcStatus_ReceiveFailed Failed to receive message buffer.</span></span><br><span class="line"><span class="comment">     * @retval kErpcStatus_Success Successfully received all data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">receive</span><span class="params">(MessageBuffer *message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*!</span></span><br><span class="line"><span class="comment">     * @brief Function to send prepared message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param[in] message Pass message buffer to send.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @retval kErpcStatus_SendFailed Failed to send message buffer.</span></span><br><span class="line"><span class="comment">     * @retval kErpcStatus_Success Successfully sent all data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">erpc_status_t</span> <span class="title">send</span><span class="params">(MessageBuffer *message)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rpmsg_endpoint_info</span> <span class="title">m_ep_info</span>;</span></span><br><span class="line">    <span class="keyword">int</span> m_control_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m_ep_fd = <span class="number">0</span>;</span><br><span class="line">    std::array&lt;<span class="keyword">char</span>, 256&gt; m_read_buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace erpc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! @&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _EMBEDDED_RPC__RPMSG_CHAR_TRANSPORT_H_</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源文件：<code>erpc_rpmsg_char_transport.cc</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2015, Freescale Semiconductor, Inc.</span></span><br><span class="line"><span class="comment"> * Copyright 2016 NXP</span></span><br><span class="line"><span class="comment"> * Copyright 2021 kcmetercec (kcmeter.cec@gmail.com)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_rpmsg_char_transport.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> erpc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_CONTROL_NAME		<span class="meta-string">&quot;/dev/rpmsg_ctrl0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_EP_NAME			<span class="meta-string">&quot;/dev/rpmsg0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line">RPMsgCharTransport::<span class="built_in">RPMsgCharTransport</span>(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> src, <span class="keyword">uint32_t</span> dst)</span><br><span class="line">:<span class="built_in">Transport</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::<span class="built_in">memcpy</span>(m_ep_info.name, name, std::<span class="built_in">strlen</span>(name));</span><br><span class="line">    m_ep_info.name[<span class="number">31</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_ep_info.src = src;</span><br><span class="line">    m_ep_info.dst = dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RPMsgCharTransport::~<span class="built_in">RPMsgCharTransport</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">RPMsgCharTransport::connect</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_control_fd = <span class="built_in">open</span>(DEVICE_CONTROL_NAME, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (m_control_fd == <span class="number">-1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t open control device: &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> kErpcStatus_ConnectionFailure;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">ioctl</span>(m_control_fd, RPMSG_CREATE_EPT_IOCTL, &amp;m_ep_info)) </span><br><span class="line">    &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t create endpoint:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">disconnect</span>();</span><br><span class="line">		<span class="keyword">return</span> kErpcStatus_ConnectionFailure;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_ep_fd = <span class="built_in">open</span>(DEVICE_EP_NAME, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (m_ep_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t open endpoint device: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">disconnect</span>();</span><br><span class="line">		<span class="keyword">return</span> kErpcStatus_ConnectionFailure;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> 	kErpcStatus_Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">RPMsgCharTransport::disconnect</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ep_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ioctl</span>(m_ep_fd, RPMSG_DESTROY_EPT_IOCTL)) </span><br><span class="line">        &#123;</span><br><span class="line">		    std::<span class="built_in">perror</span>(<span class="string">&quot;Can&#x27;t destroy endpoint:&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="built_in">close</span>(m_ep_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_control_fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(m_control_fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_ep_fd = <span class="number">0</span>;</span><br><span class="line">    m_control_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> 	kErpcStatus_Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">RPMsgCharTransport::receive</span><span class="params">(MessageBuffer *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="built_in">read</span>(m_ep_fd, m_read_buf.<span class="built_in">data</span>(), m_read_buf.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;read failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kErpcStatus_ReceiveFailed;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;read end of file:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kErpcStatus_ReceiveFailed;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">		message-&gt;<span class="built_in">set</span>(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(m_read_buf.<span class="built_in">data</span>()), ret);</span><br><span class="line">        message-&gt;<span class="built_in">setUsed</span>(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kErpcStatus_Success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_status_t</span> <span class="title">RPMsgCharTransport::send</span><span class="params">(MessageBuffer *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span>* buf = message-&gt;<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">uint32_t</span> length = message-&gt;<span class="built_in">getLength</span>();</span><br><span class="line">    <span class="keyword">uint32_t</span> used = message-&gt;<span class="built_in">getUsed</span>();</span><br><span class="line"></span><br><span class="line">    message-&gt;<span class="built_in">set</span>(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> ret = <span class="built_in">write</span>(m_ep_fd, buf, used);</span><br><span class="line">	<span class="keyword">if</span> (ret != used) </span><br><span class="line">    &#123;</span><br><span class="line">		std::<span class="built_in">perror</span>(<span class="string">&quot;write failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        message-&gt;<span class="built_in">set</span>(buf, length);</span><br><span class="line">        message-&gt;<span class="built_in">setUsed</span>(used);</span><br><span class="line">		<span class="keyword">return</span> kErpcStatus_SendFailed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kErpcStatus_Success; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="setup-函数"><a href="#setup-函数" class="headerlink" title="setup 函数"></a>setup 函数</h3><p>setup 函数就是创建连接即可，然后在 <code>erpc_transport_setup.h</code> 中声明该函数即可。</p>
<p>源文件：<code>erpc_setup_rpmsg_char.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2014-2016, Freescale Semiconductor, Inc.</span></span><br><span class="line"><span class="comment"> * Copyright 2016-2020 NXP</span></span><br><span class="line"><span class="comment"> * Copyright 2021 kcmetercec (kcmeter.cec@gmail.com)</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SPDX-License-Identifier: BSD-3-Clause</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_manually_constructed.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_rpmsg_char_transport.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erpc_transport_setup.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> erpc;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Variables</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ManuallyConstructed&lt;RPMsgCharTransport&gt; s_transport;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">erpc_transport_t</span> <span class="title">erpc_transport_rpmsg_char_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> src, <span class="keyword">uint32_t</span> dst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_transport_t</span> transport;</span><br><span class="line"></span><br><span class="line">    s_transport.<span class="built_in">construct</span>(name, src, dst);</span><br><span class="line">    <span class="keyword">if</span> (s_transport-&gt;<span class="built_in">connect</span>() == kErpcStatus_Success)</span><br><span class="line">    &#123;</span><br><span class="line">        transport = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">erpc_transport_t</span>&gt;(s_transport.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transport = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> transport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>将 A53 端代码交叉编译并验证，一切工作如预期。😊</p>
]]></content>
      <categories>
        <category>framework</category>
        <category>ERPC</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>ERPC 的执行效率</title>
    <url>/2022/01/24/framework_erpc_performance/</url>
    <content><![CDATA[<p>ERPC 将传统数据流的分析及处理的实现封装了起来，那么它的执行效率如何？</p>
<p>这里仅仅关注 ERPC 在收发方面的实现，而不深入整体架构。</p>
<p>依然是以<a href="http://kcmetercec.top/2021/12/18/framework_erpc_demo/">之前的 demo</a>代码来分析，按照客户端和服务端的收发来顺藤摸瓜。</p>
<span id="more"></span>

<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><h2 id="客户端的创建"><a href="#客户端的创建" class="headerlink" title="客户端的创建"></a>客户端的创建</h2><p>客户端创建的简单流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> transport = <span class="built_in">erpc_transport_tcp_init</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">60901</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">auto</span> message_buffer_factory = <span class="built_in">erpc_mbf_dynamic_init</span>();</span><br><span class="line"><span class="built_in">erpc_client_init</span>(transport, message_buffer_factory);</span><br></pre></td></tr></table></figure>

<h3 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h3><p><code>transport</code>就是一个底层数据收发的具体实现。</p>
<p>在<code>erpc_transport_tcp_init</code>中，就是通过一个模板类来完成<code>transport</code>对象的创建及操作。</p>
<blockquote>
<p>这里创建的是 TCP 对象，以及使用它来连接服务端。</p>
</blockquote>
<p>查看<code>TCPTransport</code>类的实现，可以看到其继承关系如下图：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BFramework%5D/%5Berpc%5D/pic/tcptransport_impl.jpg?raw=true"><code>Transport</code>是最顶层的基类，需要派生类来完成数据的收发操作。</p>
<p>而 <code>FramedTransport</code>则是完成了数据收发操作的框架实现，那么它的派生类的实现就会更加的简单，仅需要完成最基本的数据读写即可。</p>
<blockquote>
<p>这便是<code>模板方法（Template Method）</code>的设计思想。</p>
</blockquote>
<p>查看<code>FramedTransport</code>的收发步骤如下：</p>
<ol>
<li>接受的步骤<ul>
<li>使用<code>underlyingReceive</code>读取消息头，头中包含消息的长度以及 crc 校验值</li>
<li>根据头中的消息长度，再次使用<code>underlyingReceive</code>读取消息内容</li>
<li>对消息类型进行 crc 校验，看与头中的描述是否符合</li>
</ul>
</li>
<li>发送的步骤<ul>
<li>根据当前的消息，生成消息头，这里就填充了消息长度和 crc 校验值</li>
<li>依次发送消息头，和消息内容</li>
</ul>
</li>
</ol>
<p>有了前面的框架，查看<code>TCPTransport</code>的收发步骤，就是简单的<code>read,write</code>操作了。</p>
<p>到这里，可以大胆假设，ERPC 框架会使用<code>Transport</code>基类指针，完成数据的收发。</p>
<h3 id="message-buffer"><a href="#message-buffer" class="headerlink" title="message buffer"></a>message buffer</h3><p><code>erpc_mbf_dynamic_init()</code>创建了一个用于存储消息的内存。</p>
<p><code>MessageBuffer</code>类，则是对该申请的动态内存进行管理：</p>
<ul>
<li>内存的地址</li>
<li>内存的容量</li>
<li>内存使用量</li>
<li>当前内存使用的指针</li>
</ul>
<p>也可以大胆假设，ERPC 框架会对消息缓存进行多次读写，最后再调用底层<code>transport</code>实现。</p>
<blockquote>
<p>因为这样的效率最高，相当于将 IO 缓存先准备好，然后再合并发送一样。 避免了频繁的系统 API 调用。</p>
</blockquote>
<h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><p><code>erpc_client_init()</code>完成了客户端对象的创建。</p>
<p>可以看到，它将前面创建的<code>transport</code>和<code>message buffer</code>都传递给了客户端，其大致步骤如下：</p>
<ol>
<li>为<code>transport</code>对象设定对应的<code>crc</code>算法，默认是<code>crc16</code>。</li>
<li>将<code>transport</code>和<code>message buffer</code>都传递给客户端</li>
<li>将<code>codec</code>的实例传递给客户端</li>
</ol>
<p>这里的<code>Codec</code>类就是对<code>message buffer</code>操作的上层类，它将复杂的参数分解为了基本的数据然后依次写入<code>message buffer</code>中。</p>
<h2 id="客户端的收发"><a href="#客户端的收发" class="headerlink" title="客户端的收发"></a>客户端的收发</h2><p>接下来便是对<code>DemoHello</code>函数的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> message = <span class="string">&quot;Hello, this is client!\n&quot;</span>;</span><br><span class="line"><span class="keyword">binary_t</span> cmd&#123;(<span class="keyword">uint8_t</span>*)message, (<span class="keyword">uint32_t</span>)(std::<span class="built_in">strlen</span>(message))&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">binary_t</span> *ret = <span class="built_in">DemoHello</span>(&amp;cmd);</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Get message of server: &quot;</span> &lt;&lt; ret-&gt;data &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret-&gt;data) &#123;</span><br><span class="line">    <span class="built_in">erpc_free</span>(ret-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    <span class="built_in">erpc_free</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就来看生成的<code>shim</code>代码是如何实现的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DEMO interface DemoHello function client shim.</span></span><br><span class="line"><span class="function"><span class="keyword">binary_t</span> * <span class="title">DemoHello</span><span class="params">(<span class="keyword">const</span> <span class="keyword">binary_t</span> * val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">erpc_status_t</span> err = kErpcStatus_Success;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">binary_t</span> * result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get a new request.</span></span><br><span class="line">    RequestContext request = g_client-&gt;<span class="built_in">createRequest</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encode the request.</span></span><br><span class="line">    Codec * codec = request.<span class="built_in">getCodec</span>();</span><br><span class="line"></span><br><span class="line">    codec-&gt;<span class="built_in">startWriteMessage</span>(kInvocationMessage, kDEMO_service_id, kDEMO_DemoHello_id, request.<span class="built_in">getSequence</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write_binary_t_struct</span>(codec, val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send message to server</span></span><br><span class="line">    <span class="comment">// Codec status is checked inside this function.</span></span><br><span class="line">    g_client-&gt;<span class="built_in">performRequest</span>(request);</span><br><span class="line"></span><br><span class="line">    result = (<span class="keyword">binary_t</span> *) <span class="built_in">erpc_malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">binary_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        codec-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_MemoryError);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">read_binary_t_struct</span>(codec, result);</span><br><span class="line"></span><br><span class="line">    err = codec-&gt;<span class="built_in">getStatus</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispose of the request.</span></span><br><span class="line">    g_client-&gt;<span class="built_in">releaseRequest</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke error handler callback function</span></span><br><span class="line">    g_client-&gt;<span class="built_in">callErrorHandler</span>(err, kDEMO_DemoHello_id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createRequest"><a href="#createRequest" class="headerlink" title="createRequest"></a>createRequest</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RequestContext request = g_client-&gt;<span class="built_in">createRequest</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>这里的<code>g_client</code>就是指向前面客户端对象的指针。</p>
<blockquote>
<p>从这里也可以看出，目前的代码不支持创建多个 client</p>
</blockquote>
<p>这个函数做了两件事：</p>
<ol>
<li>创建了一个 <code>codec</code> 和 <code>message buffer</code>，并将二者绑定起来</li>
<li>创建一个<code>RequestContext</code>对象，主要用于返回创建的<code>codec</code>以及当前传输的序列号</li>
</ol>
<p>这就是说，这是为传输申请的基本操作的内存，为后面做准备。</p>
<h3 id="startWriteMessage"><a href="#startWriteMessage" class="headerlink" title="startWriteMessage"></a>startWriteMessage</h3><p><code>startWriteMessage</code>是将当前的消息类型、服务器 ID、请求 ID、发送序列号填充到了发送缓存中。</p>
<p>这就是 ERPC 的<strong>消息内容包头</strong>。</p>
<h3 id="write-binary-t-struct"><a href="#write-binary-t-struct" class="headerlink" title="write_binary_t_struct"></a>write_binary_t_struct</h3><p>这里就是写入这个函数参数的内容了，由于<code>binary_t</code>是 ERPC 的内置类型，所以<code>codec</code>便提供了对应的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BasicCodec::writeBinary</span><span class="params">(<span class="keyword">uint32_t</span> length, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Write the blob length as a u32.</span></span><br><span class="line">    <span class="built_in">write</span>(length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">writeData</span>(value, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performRequest"><a href="#performRequest" class="headerlink" title="performRequest"></a>performRequest</h3><p>前面是对发送缓存做好了准备，那么下面就是执行具体的操作。</p>
<p>这里就包含了数据的读写，首先是数据的写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Send invocation request to server.</span></span><br><span class="line"><span class="keyword">if</span> (request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">isStatusOk</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    err = m_transport-&gt;<span class="built_in">send</span>(request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">    request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">updateStatus</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果不其然，这里最终使用到了<code>transport</code>的发送方法。</p>
<blockquote>
<p>通过虚指针指向<code>FramedTransport</code>的虚表，那么就调用对应的发送实现。进一步调用了<code>TCPTransport</code>的实现。</p>
</blockquote>
<p>可以看到，当前的发送格式就是：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BFramework%5D/%5Berpc%5D/pic/tcp_frame_format.jpg?raw=true">写完数据以后，再判断是否有返回，如果有返回则读取其内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!request.<span class="built_in">isOneway</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">isStatusOk</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Receive reply.</span></span><br><span class="line">        err = m_transport-&gt;<span class="built_in">receive</span>(request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">getBuffer</span>());</span><br><span class="line">        request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">updateStatus</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the reply.</span></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">isStatusOk</span>() == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">verifyReply</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在接受完数据后，还要对数据进行校验。</p>
<p>而校验的方法，就是对消息头进行校验：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Extract the reply header.</span></span><br><span class="line">request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">startReadMessage</span>(&amp;msgType, &amp;service, &amp;requestNumber, &amp;sequence);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">isStatusOk</span>() == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Verify that this is a reply to the request we just sent.</span></span><br><span class="line">    <span class="keyword">if</span> ((msgType != kReplyMessage) || (sequence != request.<span class="built_in">getSequence</span>()))</span><br><span class="line">    &#123;</span><br><span class="line">        request.<span class="built_in">getCodec</span>()-&gt;<span class="built_in">updateStatus</span>(kErpcStatus_ExpectedReply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是对消息类型和序列号进行比对。</p>
<h3 id="read-binary-t-struct"><a href="#read-binary-t-struct" class="headerlink" title="read_binary_t_struct"></a>read_binary_t_struct</h3><p><code>read_binary_t_struct</code>就是从消息缓存中读出内容。</p>
<h3 id="releaseRequest"><a href="#releaseRequest" class="headerlink" title="releaseRequest"></a>releaseRequest</h3><p>这里就是将前面申请的消息缓存和<code>codec</code>进行释放。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>观察服务端的实现，其实与客户端都是大同小异：</p>
<ol>
<li>创建服务端的<code>transport</code>，<code>message buffer</code></li>
<li>创建服务端并关联之前创建的对象</li>
<li>服务端调用<code>transport</code>的读方法，获取数据</li>
<li>根据获取消息的服务器ID得到服务器对象</li>
<li>根据方法ID得到对应的调用方法</li>
<li>根据方法的返回再次创建一个返回消息</li>
<li>调用<code>transport</code>的发送方法将数据发送出去</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>传统的通过消息类型来调用对应处理函数的方式，在 ERPC 中则是通过方法 ID 来实现匹配。</li>
<li>在发送消息先，都是先将内容在缓存中写好，才会调用底层的发送函数以提高效率。</li>
<li>唯一对性能有较大影响的，就是对整个消息包的 crc 校验。</li>
</ol>
<p>可以看到，根据不同情况可以将校验用其他简单的类来代替，便可以实现高效的通信。</p>
<p>总的来说，ERPC 是一个比较高效的通信框架。可以提高芯片间、多核、多进程间通信的开发效率。<br>如果没有因此而出现性能瓶颈，是完全没有必要来修改其核心代码的！</p>
]]></content>
      <categories>
        <category>framework</category>
        <category>ERPC</category>
      </categories>
      <tags>
        <tag>framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Kconfig 基本使用</title>
    <url>/2023/08/19/kernel_make_kconfig_hello/</url>
    <content><![CDATA[<p>u-boot 或者 Linux 在进行配置内核时，其调用步骤如下:</p>
<ol>
<li><code>make ARCH=&lt;arch&gt; &lt;xxx_defconfig&gt; menuconfig</code> <ul>
<li>ARCH : 指定要配置的构架</li>
<li><xxx_defconfig> : 指定默认的参考配置,比如arm默认配置位于 <code>arch/arm/configs/</code> <ul>
<li>一般都可以参考这些配置，不然内核的配置项太多了。比如 <code>make ARCH=arm s3c2410_defconfig menuconfig</code></li>
</ul>
</li>
</ul>
</li>
<li>配置工具都会提取 <code>./Kconfig</code> 文件,此文件 <code>source</code> 读取 <code>arch/$&#123;ARCH&#125;/Kconfig</code></li>
<li><code>arch/$&#123;ARCH&#125;/Kconfig</code> 再source其他文件夹下的 <code>Kconfig</code> ,层层调用来完成整个界面的映射.配置界面的显示,也是对应层层显示的.</li>
<li>在完成配置后，在内核根目录下会生成文件 .config(新配置) 和 .config.old(之前配置)，用户根据查看这两个文件可以以一个全局视野查看内核配置以及相对上次修改的配置</li>
</ol>
<p>经过上面的配置，然后分别编译内核文件和模块文件:</p>
<ol>
<li><code>make ARCH=&lt;arch&gt; CROSS_COMPILE=&lt;arm-gcc&gt; zImage</code> :编译内核文件(比如 <code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage</code>)<ul>
<li>编译完成后，在内核根目录会有未压缩的 <code>vmlinux</code> 和符号表 <code>System.map</code>,以及在 <code>arch/xxx/boot/</code> 目录下会有已经压缩的zImage</li>
</ul>
</li>
<li><code>make ARCH=&lt;arch&gt; CROSS_COMPILE=&lt;arm-gcc&gt; modules</code> : 编译内核模块<ul>
<li>内核模块对应的存在于其源码的路径中</li>
<li>为了便捷的将编译的模块安装在文件系统，一般还会执行 <code>make modules_install</code> ，默认会安装在目标文件系统的 <code>/lib/modules/$(KERNELRELEASE)</code></li>
</ul>
</li>
</ol>
<span id="more"></span>

<h1 id="菜单入口"><a href="#菜单入口" class="headerlink" title="菜单入口"></a>菜单入口</h1><p>最基本的一个配置如下:r4</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config MODVERSIONS</span><br><span class="line">       bool &quot;Set version information on all module symbols&quot;</span><br><span class="line">       depends on MODULES</span><br><span class="line">       help</span><br><span class="line">            Usually, modules have to be recompiled whenever you switch to a new kernel....</span><br></pre></td></tr></table></figure>

<p>每一行都由一个关键字做起始,后面可以跟多个参数。 </p>
<p>“config”代表一个新的配置选项，后面的缩进行则是这个配置的属性。</p>
<p>属性可以是配置类型，输入提示，依赖，帮助信息，默认值等等。<br>多个”config” 后面可以跟相同的名字,但必须保证它们的输入提示是一样的，并且类型也不能起冲突。</p>
<p>config 后的名称 <code>MODVERSIONS</code> 在编译过程中其实是 <code>CONFIG_MODVERSIONS</code>。</p>
<h1 id="菜单属性"><a href="#菜单属性" class="headerlink" title="菜单属性"></a>菜单属性</h1><p>一个菜单可以具有多个属性,但不是每个属性都可以同时使用。</p>
<h2 id="type-类型"><a href="#type-类型" class="headerlink" title="type (类型)"></a>type (类型)</h2><p>使用: <code>bool &quot;string&quot;</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>bool</td>
<td>y / n</td>
</tr>
<tr>
<td>tristate</td>
<td>y / n / m</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>hex</td>
<td>0x**</td>
</tr>
<tr>
<td>int</td>
<td>**</td>
</tr>
</tbody></table>
<p>此类型的值也就是 <code>CONFIG_MODVERSIONS</code> 的值， <code>tristate</code> 和 <code>string</code> 是基本类型，其他类型都是由它们演化出来的。</p>
<p>type 类型后跟的字符串是一个输入提示字符.。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bool &quot;Networking support&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line"></span><br><span class="line">bool</span><br><span class="line">prompt &quot;Networking support&quot;</span><br></pre></td></tr></table></figure>

<h2 id="input-prompt-输入提示"><a href="#input-prompt-输入提示" class="headerlink" title="input prompt (输入提示)"></a>input prompt (输入提示)</h2><p>使用: <code>prompt &quot;string&quot; [if &lt;expr&gt;]</code></p>
<p>每个菜单只能有 <strong>一个</strong> 提示信息, <code>if</code> 用于在依赖项使能的情况下,才显示这条提示.</p>
<h2 id="default-默认值"><a href="#default-默认值" class="headerlink" title="default (默认值)"></a>default (默认值)</h2><p>使用: <code>default &lt;expr&gt; [if &lt;expr&gt;]</code></p>
<p>每个菜单可以有多个默认值,但真正起作用的只有第一个, <code>if</code> 用于在依赖项使能的情况下,才使用这个默认值.</p>
<h2 id="type-default-默认类型及默认值"><a href="#type-default-默认类型及默认值" class="headerlink" title="type + default (默认类型及默认值)"></a>type + default (默认类型及默认值)</h2><p>使用: <code>def_bool / def_tristate &lt;expr&gt; [ if &lt;expr&gt; ]</code></p>
<p>这是一种简单的写法, <code>if</code> 用于在依赖项使能的情况下,才使用这个值</p>
<h2 id="dependencies-依赖"><a href="#dependencies-依赖" class="headerlink" title="dependencies (依赖)"></a>dependencies (依赖)</h2><p>使用: <code>depends on &lt;expr&gt;</code></p>
<p>表示只有依赖的菜单使能了,这个菜单才会显示.当有多个依赖时, 使用 <code>&amp;&amp;</code> 连接.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bool &quot;foo&quot; if BAR</span><br><span class="line">default y if BAR</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等价于</span></span><br><span class="line"></span><br><span class="line">depends on BAR</span><br><span class="line">bool &quot;foo&quot;</span><br><span class="line">default y</span><br></pre></td></tr></table></figure>

<p>在 depends on 中,当 A 依赖于 B ,则 A 的值有如下几种情况.</p>
<table>
<thead>
<tr>
<th>B 的值</th>
<th>A 的 值</th>
</tr>
</thead>
<tbody><tr>
<td>Y</td>
<td>Y / M / N</td>
</tr>
<tr>
<td>M</td>
<td>M / N</td>
</tr>
<tr>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h2 id="reverse-dependencies-反向依赖"><a href="#reverse-dependencies-反向依赖" class="headerlink" title="reverse dependencies (反向依赖)"></a>reverse dependencies (反向依赖)</h2><p>使用: <code>select &lt;symbol&gt; [if &lt;expr&gt;]</code></p>
<p>相比于 <code>depends on</code>，反向依赖规定菜单值的下限。</p>
<p>在 select 中,当 A 反向依赖于B ,则 B 的值有以下几种情况</p>
<table>
<thead>
<tr>
<th>A 的值</th>
<th>B 的值</th>
</tr>
</thead>
<tbody><tr>
<td>N</td>
<td>N / M / Y</td>
</tr>
<tr>
<td>M</td>
<td>M / Y</td>
</tr>
<tr>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<p>当 select 有多个值时，则下限值是这些值中的最大值。</p>
<h2 id="weak-reverse-dependencies-反向弱依赖"><a href="#weak-reverse-dependencies-反向弱依赖" class="headerlink" title="weak reverse dependencies: (反向弱依赖)"></a>weak reverse dependencies: (反向弱依赖)</h2><p>使用: <code>imply &lt;symbol&gt; [if &lt;expr&gt;]</code></p>
<p>imply 使得 symbol 在任何时候都可以设置为 N.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config FOO</span><br><span class="line">       tristate</span><br><span class="line">       imply BAZ</span><br><span class="line"></span><br><span class="line">config BAZ</span><br><span class="line">       tristate</span><br><span class="line">       depends on BAR</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>FOO</th>
<th>BAR</th>
<th>BAZ 的默认值</th>
<th>BAZ 可以设定的值</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>y</td>
<td>n</td>
<td>N / M / Y</td>
</tr>
<tr>
<td>m</td>
<td>y</td>
<td>m</td>
<td>N / M / Y</td>
</tr>
<tr>
<td>y</td>
<td>y</td>
<td>y</td>
<td>Y / N</td>
</tr>
<tr>
<td>y</td>
<td>n</td>
<td>*</td>
<td>N</td>
</tr>
</tbody></table>
<p>当一个驱动可以应用于多个组件时，可以关闭其中一个或多个，而不用关闭驱动。</p>
<h2 id="limiting-menu-display-菜单限制信息"><a href="#limiting-menu-display-菜单限制信息" class="headerlink" title="limiting menu display (菜单限制信息)"></a>limiting menu display (菜单限制信息)</h2><p>使用: <code>visible if &lt;expr&gt;</code></p>
<p>此属性只能在菜单块中使用,当 expr 为 true 则此菜单块显示,否则隐藏</p>
<h2 id="numerical-ranges-数字输入范围"><a href="#numerical-ranges-数字输入范围" class="headerlink" title="numerical ranges (数字输入范围)"></a>numerical ranges (数字输入范围)</h2><p>使用: <code>range &lt;symbol&gt; &lt;symbol&gt; [if &lt;expr&gt;]</code></p>
<p>用于限制 int 或 hex 的输入范围</p>
<h2 id="help-text-帮助信息"><a href="#help-text-帮助信息" class="headerlink" title="help text (帮助信息)"></a>help text (帮助信息)</h2><p>使用: <code>help 或者 ---help---</code></p>
<h2 id="misc-options-其他依赖属性"><a href="#misc-options-其他依赖属性" class="headerlink" title="misc options (其他依赖属性)"></a>misc options (其他依赖属性)</h2><p>使用: <code>option &lt;symbol&gt; [=&lt;value&gt;]</code></p>
<ul>
<li>defconfig_list : 默认值列表</li>
<li>modules : </li>
<li>env=<value> : 设置环境变量的值</li>
<li>allnoconfig_y : </li>
</ul>
<h1 id="依赖关系表达式"><a href="#依赖关系表达式" class="headerlink" title="依赖关系表达式"></a>依赖关系表达式</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::= &lt;symbol&gt;                       (1)</span><br><span class="line">           &lt;symbol&gt; ’=‘ &lt;symbol&gt;          (2)</span><br><span class="line">           &lt;symbol&gt; ’!=‘ &lt;symbol&gt;         (3)</span><br><span class="line">           ’(‘&lt;expr&gt;’)’                   (4)</span><br><span class="line">           ‘!‘&lt;expr&gt;                      (5)</span><br><span class="line">           &lt;expr&gt; ’&amp;&amp;‘ &lt;expr&gt;             (6)</span><br><span class="line">           &lt;expr&gt; ’||‘ &lt;expr&gt;             (7)</span><br></pre></td></tr></table></figure>

<ol>
<li>将 symbol 值赋值给 expr ,bool 和 tristate 类型直接赋值,其他类型值为 n.</li>
<li>如果两个 symbol 的值相等, 则返回 y ,否则为 n</li>
<li>如果两个 symbol 的值不等, 则符号 y, 否则为 n</li>
<li>返回表达式的值</li>
<li>返回非 expr 的结果</li>
<li>返回两个 expr 与运算</li>
<li>返回两个 expr 或运算</li>
</ol>
<p>表达式的值可以为 n, m和 y。当表达式的值为 m 或 y 时，菜单可见。</p>
<p>symbol 有两种类型，一种是常数型，一种是非常数型。</p>
<p>非常数型由 config 关键字定义，由 字母，数字，下划线组成。常数 symbol 总是用単引号或者双引号括起来，内部可以使用转义字符。</p>
<h1 id="菜单结构"><a href="#菜单结构" class="headerlink" title="菜单结构"></a>菜单结构</h1><p>一个 Kconfig 文件的两头包含 menu 和 endmenu,这样就形成了一个菜单块.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu &quot;Network device support&quot;</span><br><span class="line">     depends on NET</span><br><span class="line"></span><br><span class="line">config NETDEVICES</span><br><span class="line"></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>如上所示, 在 menu 和 endmenu 之间的菜单都会成为 <code>Network device support</code> 的子菜单,只有 NET 打开时,这个菜单块才可见。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>配置文件就是由很多小的菜单项组合而成的,每一行都由一个关键字做起始。</p>
<ul>
<li>config</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config &lt;symbol&gt;</span><br><span class="line">&lt;config options&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>menuconfig</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menuconfig &lt;symbol&gt;</span><br><span class="line">&lt;config options&gt;</span><br></pre></td></tr></table></figure>

<p>menuconfig 表示它下面的选项都是它的子选项.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(1);</span><br><span class="line">menuconfig M</span><br><span class="line">if M</span><br><span class="line">   config C1</span><br><span class="line">   config C2</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">(2):</span><br><span class="line">menuconfig M</span><br><span class="line">config C1</span><br><span class="line">       depends on M</span><br><span class="line">config C2</span><br><span class="line">       depends on M</span><br></pre></td></tr></table></figure>

<ul>
<li>choice/endchoice</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">choice [symbol]</span><br><span class="line">&lt;choice options&gt;</span><br><span class="line">&lt;choice block&gt;</span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>

<p>用 choice 来生成一个可选的列表,当一个硬件有多种驱动时,这种方法比较适用。</p>
<ul>
<li>comment</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">comment &lt;prompt&gt;</span><br><span class="line">&lt;comment options&gt;</span><br></pre></td></tr></table></figure>

<p>在图形界面中显示一定的注释.</p>
<ul>
<li>if/endif</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if &lt;expr&gt;</span><br><span class="line">&lt;if block&gt;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>当 expr 为真时, block 中的选项才显示.</p>
<ul>
<li>source</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source &lt;prompt&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">+end_example</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mainmenu</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mainmenu &lt;prompt&gt;</span><br></pre></td></tr></table></figure>

<p>显示在配置界面的最上方,如同标题一样.</p>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="限制某些选项只能备编译为模块"><a href="#限制某些选项只能备编译为模块" class="headerlink" title="限制某些选项只能备编译为模块"></a>限制某些选项只能备编译为模块</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config FOO</span><br><span class="line">       depends on BAR &amp;&amp; m</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>make</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试之 initcall_debug</title>
    <url>/2023/08/04/kernel_initcall_debug/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>初步认识 initcall_debug 的实现机制。</p>
<span id="more"></span>

<h1 id="u-boot-对-chosen-的修改"><a href="#u-boot-对-chosen-的修改" class="headerlink" title="u-boot 对 chosen 的修改"></a>u-boot 对 chosen 的修改</h1><p>当 u-boot 使能设备树功能，且环境变量中具有 <code>bootargs</code> 时，u-boot 就会主动将设备树中的<code>bootargs</code>参数修改为自己环境变量的值。</p>
<p>一般现在都是使用设备树中的参数，所以需要将该环境变量从 u-boot 中删除，避免造成误导。</p>
<blockquote>
<p>u-boot 中的默认环境变量配置位于路径 <code>include/configs/</code>中</p>
</blockquote>
<p>关于 u-boot 修改的代码路径如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> /cmd/bootz.c: do_bootz()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /boot/bootm.c: do_bootm_states()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /boot/bootm_os.c: bootm_os_get_boot_func()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /arch/arm/lib/bootm.c: do_bootm_linux()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /arch/arm/lib/bootm.c: boot_prep_linux()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /boot/image-borad.c: image_setup_linux()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /boot/image-fdt.c: image_setup_libfdt()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /common/fdt_support.c: fdt_chosen()</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdt_chosen</span><span class="params">(<span class="keyword">void</span> *fdt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">abuf</span> <span class="title">buf</span> =</span> &#123;&#125;;</span><br><span class="line">	<span class="keyword">int</span>   nodeoffset;</span><br><span class="line">	<span class="keyword">int</span>   err;</span><br><span class="line">	<span class="keyword">char</span>  *str;		<span class="comment">/* used to set string properties */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对设备树进行检查</span></span><br><span class="line">	err = fdt_check_header(fdt);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找或创建 chose 节点</span></span><br><span class="line">	nodeoffset = fdt_find_or_add_subnode(fdt, <span class="number">0</span>, <span class="string">&quot;chosen&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (nodeoffset &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> nodeoffset;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_BOARD_RNG_SEED) &amp;&amp; !board_rng_seed(&amp;buf)) &#123;</span><br><span class="line">		err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;rng-seed&quot;</span>,</span><br><span class="line">				  abuf_data(&amp;buf), abuf_size(&amp;buf));</span><br><span class="line">		abuf_uninit(&amp;buf);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set rng-seed %s.\n&quot;</span>,</span><br><span class="line">			       fdt_strerror(err));</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 bootargs 环境变量</span></span><br><span class="line">	str = board_fdt_chosen_bootargs();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有该环境变量，则使用环境变量的 bootargs 替代 chosen 节点中的值</span></span><br><span class="line">	<span class="keyword">if</span> (str) &#123;</span><br><span class="line">		err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;bootargs&quot;</span>, str,</span><br><span class="line">				  <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,</span><br><span class="line">			       fdt_strerror(err));</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加 u-boot 的版本号</span></span><br><span class="line">	err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;u-boot,version&quot;</span>, PLAIN_VERSION,</span><br><span class="line">			  <span class="built_in">strlen</span>(PLAIN_VERSION) + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set u-boot,version %s.\n&quot;</span>,</span><br><span class="line">		       fdt_strerror(err));</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="kernel-获取参数的代码调用路径"><a href="#kernel-获取参数的代码调用路径" class="headerlink" title="kernel 获取参数的代码调用路径"></a>kernel 获取参数的代码调用路径</h1><p>以 <code>arm32</code> 为例，其调用路径为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">-&gt;</span><span class="bash"> /init/main.c: start_kernel()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /arch/arm/kernel/setup.c: setup_arch()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /arch/arm/kernel/devtree.c: setup_machine_fdt()</span></span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> /drivers/of/fdt.c: early_init_dt_scan_nodes()</span></span><br></pre></td></tr></table></figure>




<h1 id="传入参数的存储位置"><a href="#传入参数的存储位置" class="headerlink" title="传入参数的存储位置"></a>传入参数的存储位置</h1><p>设备树的参数最终存储于数组 <code>boot_command_line</code> ，而对应的命令参数则存在于设备树的 <code>/chosen</code> 中。</p>
<blockquote>
<p>如果 <code>/chosen</code> 不存在则会搜寻节点 <code>/chosen@0</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> __initdata boot_command_line[COMMAND_LINE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init <span class="title">early_init_dt_scan_chosen</span><span class="params">(<span class="keyword">char</span> *cmdline)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l, node;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *rng_seed;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *fdt = initial_boot_params;</span><br><span class="line"></span><br><span class="line">	node = fdt_path_offset(fdt, <span class="string">&quot;/chosen&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (node &lt; <span class="number">0</span>)</span><br><span class="line">		node = fdt_path_offset(fdt, <span class="string">&quot;/chosen@0&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (node &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="comment">/* Handle the cmdline config options even if no /chosen node */</span></span><br><span class="line">		<span class="keyword">goto</span> handle_cmdline;</span><br><span class="line"></span><br><span class="line">	chosen_node_offset = node;</span><br><span class="line"></span><br><span class="line">	early_init_dt_check_for_initrd(node);</span><br><span class="line">	early_init_dt_check_for_elfcorehdr(node);</span><br><span class="line"></span><br><span class="line">	rng_seed = of_get_flat_dt_prop(node, <span class="string">&quot;rng-seed&quot;</span>, &amp;l);</span><br><span class="line">	<span class="keyword">if</span> (rng_seed &amp;&amp; l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		add_bootloader_randomness(rng_seed, l);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* try to clear seed so it won&#x27;t be found. */</span></span><br><span class="line">		fdt_nop_property(initial_boot_params, node, <span class="string">&quot;rng-seed&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* update CRC check value */</span></span><br><span class="line">		of_fdt_crc32 = crc32_be(~<span class="number">0</span>, initial_boot_params,</span><br><span class="line">				fdt_totalsize(initial_boot_params));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retrieve command line */</span></span><br><span class="line">	p = of_get_flat_dt_prop(node, <span class="string">&quot;bootargs&quot;</span>, &amp;l);</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; l &gt; <span class="number">0</span>)</span><br><span class="line">		strscpy(cmdline, p, min(l, COMMAND_LINE_SIZE));</span><br><span class="line"></span><br><span class="line">handle_cmdline:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CONFIG_CMDLINE is meant to be a default in case nothing else</span></span><br><span class="line"><span class="comment">	 * managed to set the command line, unless CONFIG_CMDLINE_FORCE</span></span><br><span class="line"><span class="comment">	 * is set in which case we override whatever was found earlier.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMDLINE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_CMDLINE_EXTEND)</span></span><br><span class="line">	strlcat(cmdline, <span class="string">&quot; &quot;</span>, COMMAND_LINE_SIZE);</span><br><span class="line">	strlcat(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_CMDLINE_FORCE)</span></span><br><span class="line">	strscpy(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="comment">/* No arguments from boot loader, use kernel&#x27;s  cmdl*/</span></span><br><span class="line">	<span class="keyword">if</span> (!((<span class="keyword">char</span> *)cmdline)[<span class="number">0</span>])</span><br><span class="line">		strscpy(cmdline, CONFIG_CMDLINE, COMMAND_LINE_SIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_CMDLINE */</span></span></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;Command line is: %s\n&quot;</span>, (<span class="keyword">char</span> *)cmdline);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">early_init_dt_scan_nodes</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize &#123;size,address&#125;-cells info */</span></span><br><span class="line">	early_init_dt_scan_root();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retrieve various information from the /chosen node */</span></span><br><span class="line">	rc = early_init_dt_scan_chosen(boot_command_line);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		pr_warn(<span class="string">&quot;No chosen node found, continuing without\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup memory, calling early_init_dt_add_memory_arch */</span></span><br><span class="line">	early_init_dt_scan_memory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Handle linux,usable-memory-range property */</span></span><br><span class="line">	early_init_dt_check_for_usable_mem_range();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="截取-initcall-debug-设置"><a href="#截取-initcall-debug-设置" class="headerlink" title="截取 initcall_debug 设置"></a>截取 initcall_debug 设置</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在文档 <code>Documentation/admin-guide/kernel-parameters.txt</code> 中说明了 <code>initcall_debug</code> 命令参数的作用:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">initcall_debug	[KNL] Trace initcalls as they are executed.  Useful</span><br><span class="line">		for working out where the kernel is dying during</span><br><span class="line">		startup.</span><br></pre></td></tr></table></figure>

<p>简单来说就是可以展示初始化函数的执行。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在 <code>init/main.c</code> 中定义了标志位， <code>initcall_debug</code> :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> initcall_debug;</span><br><span class="line">core_param(initcall_debug, initcall_debug, <span class="keyword">bool</span>, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure>

<p>将上面的宏 <code>core_param</code> 展开为如下代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> &#123;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">mod</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="keyword">const</span> u16 perm;</span><br><span class="line">	s8 level;</span><br><span class="line">	u8 flags;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">void</span> *arg;</span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kparam_string</span> *<span class="title">str</span>;</span></span><br><span class="line">		<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kparam_array</span> *<span class="title">arr</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 bool 类型的操作</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param_ops</span> <span class="title">param_ops_bool</span> =</span> &#123;</span><br><span class="line">	.flags = KERNEL_PARAM_OPS_FL_NOARG,</span><br><span class="line">	.<span class="built_in">set</span> = param_set_bool,</span><br><span class="line">	.get = param_get_bool,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(param_ops_bool);</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处指定了命令行的字符串</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> __param_str_initcall_debug[] = <span class="string">&quot;initcall_debug&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> __<span class="title">moduleparam_const</span> __<span class="title">param_initcall_debug</span>	</span></span><br><span class="line"><span class="class">__<span class="title">used</span> __<span class="title">section</span>(&quot;__<span class="title">param</span>&quot;)					</span></span><br><span class="line"><span class="class">__<span class="title">aligned</span>(__<span class="title">alignof__</span>(<span class="keyword">struct</span> <span class="title">kernel_param</span>))			</span></span><br><span class="line"><span class="class">=</span> </span><br><span class="line">&#123; </span><br><span class="line">	__param_str_initcall_debug, 		<span class="comment">// 名称 </span></span><br><span class="line">	THIS_MODULE, 						<span class="comment">// 所属模块</span></span><br><span class="line">	&amp;param_ops_bool,					<span class="comment">// 操作方法</span></span><br><span class="line">	VERIFY_OCTAL_PERMISSIONS(<span class="number">0644</span>), 	<span class="comment">// 权限</span></span><br><span class="line">	<span class="number">-1</span>, </span><br><span class="line">	<span class="number">0</span>, </span><br><span class="line">	&#123; &amp;initcall_debug &#125; 				<span class="comment">// 对象的地址</span></span><br><span class="line">&#125;;	</span><br></pre></td></tr></table></figure>

<p>根据以上代码可以推断出:</p>
<ul>
<li>可以查看 <code>/sys/module/kernel/parameters/initcall_debug</code> 值的方式以判定此参数是否已经被设置</li>
<li>代码中一定有某处通过操作 <code>__param</code> 段来获取内核 <code>param</code> 的各项设置</li>
</ul>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>注意到此变量以及其对应的链接脚本:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> __<span class="title">start___param</span>[], __<span class="title">stop___param</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Built-in module parameters. */</span>				\</span><br><span class="line">__param : AT(ADDR(__param) - LOAD_OFFSET) &#123;			\</span><br><span class="line">	__start___param = .;					\</span><br><span class="line">	KEEP(*(__param))					\</span><br><span class="line">	__stop___param = .;					\</span><br><span class="line">&#125;		</span><br></pre></td></tr></table></figure>

<p>就可以知道，一定有代码来从 <code>__start___param</code> 到 <code>__stop___param</code> 中取出 <code>kernel_param</code> 依次解析变量。</p>
<p>这就又回到了 <code>start_kernel</code> 函数中的一段:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, saved_command_line);</span><br><span class="line"><span class="comment">/* parameters may set static keys */</span></span><br><span class="line">jump_label_init();</span><br><span class="line">parse_early_param();</span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">			  static_command_line, __start___param,</span><br><span class="line">			  __stop___param - __start___param,</span><br><span class="line">			  <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, &amp;unknown_bootoption);</span><br><span class="line">print_unknown_bootoptions();</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以看出，通过启动时的 “Kernel command line:” 字符串也可以查看命令设置</li>
</ul>
<p>也一定会有代码，将这些变量加入到 sysfs 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * param_sysfs_builtin - add sysfs parameters for built-in modules</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Add module_parameters to sysfs for &quot;modules&quot; built into the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &quot;module&quot; name (KBUILD_MODNAME) is stored before a dot, the</span></span><br><span class="line"><span class="comment"> * &quot;parameter&quot; name is stored behind a dot in kernel_param-&gt;name. So,</span></span><br><span class="line"><span class="comment"> * extract the &quot;module&quot; name for all built-in kernel_param-eters,</span></span><br><span class="line"><span class="comment"> * and for all who have the same, call kernel_add_sysfs_param.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">param_sysfs_builtin</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kernel_param</span> *<span class="title">kp</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> name_len;</span><br><span class="line">	<span class="keyword">char</span> modname[MODULE_NAME_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (kp = __start___param; kp &lt; __stop___param; kp++) &#123;</span><br><span class="line">		<span class="keyword">char</span> *dot;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (kp-&gt;perm == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		dot = <span class="built_in">strchr</span>(kp-&gt;name, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span> (!dot) &#123;</span><br><span class="line">			<span class="comment">/* This happens for core_param() */</span></span><br><span class="line">			<span class="built_in">strcpy</span>(modname, <span class="string">&quot;kernel&quot;</span>);</span><br><span class="line">			name_len = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			name_len = dot - kp-&gt;name + <span class="number">1</span>;</span><br><span class="line">			strlcpy(modname, kp-&gt;name, name_len);</span><br><span class="line">		&#125;</span><br><span class="line">		kernel_add_sysfs_param(modname, kp, name_len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-initcall-debug"><a href="#使用-initcall-debug" class="headerlink" title="使用 initcall_debug"></a>使用 initcall_debug</h1><p>在进行初始化执行之前会有对变量 <code>initcall_debug</code> 的判断:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __init_or_module <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trace_initcall_start_cb</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ktime_t</span> *calltime = data;</span><br><span class="line"></span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;calling  %pS @ %i\n&quot;</span>, fn, task_pid_nr(current));</span><br><span class="line">	*calltime = ktime_get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __init_or_module <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trace_initcall_finish_cb</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">initcall_t</span> fn, <span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">ktime_t</span> rettime, *calltime = data;</span><br><span class="line"></span><br><span class="line">	rettime = ktime_get();</span><br><span class="line">	printk(KERN_DEBUG <span class="string">&quot;initcall %pS returned %d after %lld usecs\n&quot;</span>,</span><br><span class="line">		 fn, ret, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)ktime_us_delta(rettime, *calltime));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">do_trace_initcall_start</span><span class="params">(<span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!initcall_debug)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	trace_initcall_start_cb(&amp;initcall_calltime, fn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">do_trace_initcall_finish</span><span class="params">(<span class="keyword">initcall_t</span> fn, <span class="keyword">int</span> ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!initcall_debug)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	trace_initcall_finish_cb(&amp;initcall_calltime, fn, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __init_or_module <span class="title">do_one_initcall</span><span class="params">(<span class="keyword">initcall_t</span> fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = preempt_count();</span><br><span class="line">	<span class="keyword">char</span> msgbuf[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initcall_blacklisted(fn))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	do_trace_initcall_start(fn);</span><br><span class="line">	ret = fn();</span><br><span class="line">	do_trace_initcall_finish(fn, ret);</span><br><span class="line"></span><br><span class="line">	msgbuf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (preempt_count() != count) &#123;</span><br><span class="line">		<span class="built_in">sprintf</span>(msgbuf, <span class="string">&quot;preemption imbalance &quot;</span>);</span><br><span class="line">		preempt_count_set(count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (irqs_disabled()) &#123;</span><br><span class="line">		strlcat(msgbuf, <span class="string">&quot;disabled interrupts &quot;</span>, <span class="keyword">sizeof</span>(msgbuf));</span><br><span class="line">		local_irq_enable();</span><br><span class="line">	&#125;</span><br><span class="line">	WARN(msgbuf[<span class="number">0</span>], <span class="string">&quot;initcall %pS returned with %s\n&quot;</span>, fn, msgbuf);</span><br><span class="line"></span><br><span class="line">	add_latent_entropy();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>initcall_debug</code> 为 <code>true</code> 时则会打印函数名以及其执行的时间。</p>
<p>需要注意的是: <strong>此处使用的printk 的等级是 KERN_DEBUG,所以为了能够打印信息通常是 “loglevel=8 initcall_debug” 结合使用!</strong></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 字符设备基础</title>
    <url>/2023/09/10/linux_driver_char_device_hello/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>整理字符设备的基础操作。</p>
<span id="more"></span>

<h1 id="cdev-include-linux-cdev-h"><a href="#cdev-include-linux-cdev-h" class="headerlink" title="cdev(include/linux/cdev.h)"></a>cdev(include/linux/cdev.h)</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>linux 使用 cdev 来表示一个字符设备：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span> dev;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 cdev 并复制 ops 成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *, <span class="keyword">const</span> struct file_operations *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态申请一个cdev</span></span><br><span class="line"><span class="function">struct cdev *<span class="title">cdev_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向系统添加一个cdev，完成注册</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *, <span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向系统删除一个cdev</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_del</span><span class="params">(struct cdev *)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h2><p>设备号由 12 位主设备号和 20 位次设备号组成:</p>
<ul>
<li>主设备代表某一类设备，次设备号代表某个具体设备</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS    20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK    ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 将已知设备号向系统申请</span></span><br><span class="line"><span class="comment">* @note 在使用 cdev_add 之前需要申请设备号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 由系统分配一个设备号</span></span><br><span class="line"><span class="comment">* @note 在使用 cdev_add 之前需要申请设备号, 推荐使用此函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *, <span class="keyword">unsigned</span>, <span class="keyword">unsigned</span>, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放设备号</span></span><br><span class="line"><span class="comment">//在使用cdev_del之后需要释放设备号</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span>, <span class="keyword">unsigned</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文件操作接口"><a href="#文件操作接口" class="headerlink" title="文件操作接口"></a>文件操作接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="comment">// 修改文件的当前读写位置，并将新位置返回</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">    <span class="comment">// 设备相关控制命令的实现</span></span><br><span class="line">    <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_supported_flags;</span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">    <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">    <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">    <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>抽象字符设备的操作接口为文件操作接口。</p>
<h1 id="驱动组成框架"><a href="#驱动组成框架" class="headerlink" title="驱动组成框架"></a>驱动组成框架</h1><p>实际情况下，并不会直接用下面这个模块的方式来编写，而是基于驱动框架来编写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief : 此结构体表示设备需要用到的私有数据，和面向对象中的对象概念一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">dev_obj</span>;</span></span><br><span class="line">    <span class="keyword">dev_t</span>       dev_no;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;<span class="keyword">xxx_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//申请该设备的私有数据</span></span><br><span class="line">    <span class="keyword">xxx_dev_t</span> *new_dev = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">xxx_dev_t</span>), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(new_dev == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化cdev</span></span><br><span class="line">    cdev_init(&amp;new_dev-&gt;dev_obj, &amp;xxx_fops);</span><br><span class="line">    <span class="comment">//申请设备号</span></span><br><span class="line">    alloc_chrdev_region(&amp;new_dev-&gt;dev_no, <span class="number">0</span>, <span class="number">1</span>, DEV_NAME);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//注册设备</span></span><br><span class="line">    ret = cdev_add(&amp;new_dev-&gt;dev_obj, new_dev-&gt;dev_no, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">xxx_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注销设备</span></span><br><span class="line">    cdev_dev(&amp;new_dev-&gt;dev_obj);</span><br><span class="line">    <span class="comment">//释放占用的设备号</span></span><br><span class="line">    unregister_chrdev_region(new_dev-&gt;dev_no, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ioctl-命令"><a href="#ioctl-命令" class="headerlink" title="ioctl() 命令"></a>ioctl() 命令</h2><p>Linux 中 ioctl() 命令码的组成方式为:</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>数据尺寸</th>
<th>设备类型</th>
<th>序列号</th>
</tr>
</thead>
<tbody><tr>
<td>2位</td>
<td>14位</td>
<td>8位</td>
<td>8位</td>
</tr>
</tbody></table>
<p>命令码的设备类型字段为一个”幻数”，取值范围为 0~0xff，文档中的 <code>ioctl-number.txt</code> 给出了一些推荐的和已经被使用的幻数，幻数的目的是为了避免 <strong>命令码污染</strong>。</p>
<ul>
<li>命令码方向的值: <code>_IOC_NONE</code>(无数据传输),<code>_IOC_READ</code>(读),<code>IOC_WRITE</code>(写),<code>_IOC_READ|IOC_WRITE</code>(双向), <strong>数据方向是从应用程序角度来看的</strong>。</li>
</ul>
<p>在实际使用中,一般使用宏: <code>_IO(type,nr)</code>, <code>_IOR(type,nr,size)</code>, <code>_IOW(type,nr,size)</code>, <code>_IOWR(type, nr, size)</code> 来直接生成命令码。</p>
<p>对应在内核中进行解码的宏有：<code>_IOC_DIR(nr)</code>，<code>_IOC_TYPE(nr)</code>，<code>_IOC_NR(nr)</code>，<code>_IOC_SIZE(nr)</code></p>
<p>由于数据尺寸占用 14 位，那么参数的最大大小为 <code>16kB - 1</code> 字节。</p>
<h1 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h1><p>由于用户空间不能直接访问内核空间的内存,因此需要使用函数 <code>copy_from_user(), copy_to_user()</code> 来完成数据 <strong>复制</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回不能被复制的字节数,如果完全复制成功则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_from_user</span><span class="params">(<span class="keyword">void</span> *to, <span class="keyword">const</span> <span class="keyword">void</span> __user *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">copy_to_user</span><span class="params">(<span class="keyword">void</span> __user *to, <span class="keyword">const</span> <span class="keyword">void</span> *from, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//复制简单类型,比如 char,int,long等使用 put_user 和 get_user</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">...</span><br><span class="line">get_user(val, (<span class="keyword">int</span> *)arg);</span><br><span class="line">..</span><br><span class="line">put_user(val, (<span class="keyword">int</span> *)arg);</span><br></pre></td></tr></table></figure>

<p>以上函数都在内部进行了缓冲区合法性检查.</p>
<p><strong>注意:</strong></p>
<p>在内核空间与用户空间的界面处,内核检查用户空间的合法性显得尤为重要, <strong>Linux 内核的许多安全漏洞都是因为遗漏了这一检查造成的</strong>。</p>
<p>侵入者可以伪造一片内核空间的缓冲区地址传入系统调用接口,让内核对这个evil指针指向的内核空间填充数据.参考:<a href="http://www.cvedetails.com/">CVE列表</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 将一块缓存定义为一个字符设备</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBALMEM_SIZE          (0x1000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_CLEAR               (0x01)</span></span><br><span class="line"><span class="comment">//! 主设备号，表明一种驱动类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GLOBALMEM_MAJOR         (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEV_NAME                <span class="meta-string">&quot;globalmem&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NUM              (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> globalmem_major = GLOBALMEM_MAJOR;</span><br><span class="line">module_param(globalmem_major, <span class="keyword">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> mem[GLOBALMEM_MAJOR];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> r_wait;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> w_wait;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> current_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">globalmem_devp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">globalmem_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="comment">//!将当前进程加入等待队列</span></span><br><span class="line">    add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! 可读数据</span></span><br><span class="line">    <span class="keyword">while</span>(dev-&gt;current_len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! 如果是以非阻塞方式访问，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(filp-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;wait for read!\n&quot;</span>);</span><br><span class="line">        <span class="comment">//! 如果以阻塞访问，则将当前进程挂起</span></span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="comment">//! 释放互斥量，然写函数可以工作</span></span><br><span class="line">        mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">        <span class="comment">//! 进程切换</span></span><br><span class="line">        schedule();</span><br><span class="line">        <span class="comment">//! 如果是其他信号唤醒了进程，也直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(signal_pending(current))</span><br><span class="line">        &#123;</span><br><span class="line">                ret = -ERESTARTSYS;</span><br><span class="line">                <span class="keyword">goto</span> out2;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; dev-&gt;current_len)</span><br><span class="line">    &#123;</span><br><span class="line">        count = dev-&gt;current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(buf, dev-&gt;mem , count))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//! 将剩余的数据放在队列首部</span></span><br><span class="line">        <span class="built_in">memcpy</span>(dev-&gt;mem, dev-&gt;mem + count, dev-&gt;current_len - count);</span><br><span class="line">        dev-&gt;current_len -= count;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;read %u byte(s) from %lu\n&quot;</span>, count, p);</span><br><span class="line">        <span class="comment">//! 唤醒写进程</span></span><br><span class="line">        wake_up_interruptible(&amp;dev-&gt;w_wait);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;wakeup write!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">out2:</span><br><span class="line">    <span class="comment">//! 移除等待队列</span></span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);</span><br><span class="line">    <span class="comment">//! 设置状态为正常</span></span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">globalmem_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span>*ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> p = *ppos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line">    DECLARE_WAITQUEUE(wait, current);</span><br><span class="line">    mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">    add_wait_queue(&amp;dev-&gt;w_wait, &amp;wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dev-&gt;current_len &gt;= GLOBALMEM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(filp-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;wait for write!\n&quot;</span>);</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span>(signal_pending(current))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">goto</span> out2;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p &gt;= GLOBALMEM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &gt; GLOBALMEM_SIZE - dev-&gt;current_len)</span><br><span class="line">    &#123;</span><br><span class="line">        count = GLOBALMEM_SIZE - dev-&gt;current_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(dev-&gt;mem + dev-&gt;current_len, buf, count))</span><br><span class="line">    &#123;</span><br><span class="line">        ret = -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dev-&gt;current_len += count;</span><br><span class="line">        *ppos += count;</span><br><span class="line">        ret = count;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;written %u byte(s) current_len %lu\n&quot;</span>, count, dev-&gt;current_len);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;wakeup read&quot;</span>);</span><br><span class="line">        wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">out2:</span><br><span class="line">    remove_wait_queue(&amp;dev-&gt;w_wait, &amp;wait);</span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">loff_t</span> <span class="title">globalmem_llseek</span><span class="params">(struct file *filp, <span class="keyword">loff_t</span> offset, <span class="keyword">int</span> orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">loff_t</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(orig)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(offset &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret= -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)offset &gt; GLOBALMEM_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filp-&gt;f_pos = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)offset;</span><br><span class="line">            ret = filp-&gt;f_pos;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((filp-&gt;f_pos + offset) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            filp-&gt;f_pos += offset;</span><br><span class="line">            ret = filp-&gt;f_pos;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">globalmem_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(cmd)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> MEM_CLEAR:</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">            <span class="built_in">memset</span>(dev-&gt;mem, <span class="number">0</span>, GLOBALMEM_SIZE);</span><br><span class="line">            mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">            printk(KERN_INFO <span class="string">&quot;globalmem is set to zero\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalmem_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">globalmem_dev</span> *<span class="title">dev</span> =</span> container_of(inode-&gt;i_cdev, struct globalmem_dev, cdev);</span><br><span class="line">    filp-&gt;private_data = dev;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">globalmem_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">globalmem_fops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .llseek = globalmem_llseek,</span><br><span class="line">    .read =globalmem_read,</span><br><span class="line">    .write = globalmem_write,</span><br><span class="line">    .unlocked_ioctl = globalmem_ioctl,</span><br><span class="line">    .open = globalmem_open,</span><br><span class="line">    .release = globalmem_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">globalmem_setup_cdev</span><span class="params">(struct globalmem_dev *dev, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! 通过主设备号与次设备号生成 设备号</span></span><br><span class="line">    <span class="keyword">int</span> err, devno = MKDEV(globalmem_major, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! 将fops与cdev建立连接</span></span><br><span class="line">    cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops);</span><br><span class="line">    dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line">    <span class="comment">//! 向系统注册字符设备</span></span><br><span class="line">    err = cdev_add(&amp;dev-&gt;cdev, devno, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err)</span><br><span class="line">    &#123;</span><br><span class="line">            printk(KERN_NOTICE <span class="string">&quot;Error %d adding globalmem %d\n&quot;</span>, err, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">globalmem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">dev_t</span> devno = MKDEV(globalmem_major, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(globalmem_major)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//! 向系统指定设备号</span></span><br><span class="line">            ret = register_chrdev_region(devno, DEVICE_NUM, DEV_NAME);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//! 向系统申请设备号</span></span><br><span class="line">            ret = alloc_chrdev_region(&amp;devno, <span class="number">0</span>, DEVICE_NUM, DEV_NAME);</span><br><span class="line">            <span class="comment">//! 获取设备号</span></span><br><span class="line">            globalmem_major = MAJOR(devno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//! 申请设备空间</span></span><br><span class="line">        globalmem_devp = kzalloc(<span class="keyword">sizeof</span>(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span>(globalmem_devp == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> fail_malloc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//! 注册设备</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; DEVICE_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mutex_init(&amp;(globalmem_devp + i)-&gt;mutex);</span><br><span class="line">            globalmem_setup_cdev(globalmem_devp + i, i);</span><br><span class="line">            init_waitqueue_head(&amp;(globalmem_devp + i)-&gt;r_wait);</span><br><span class="line">            init_waitqueue_head(&amp;(globalmem_devp + i)-&gt;w_wait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_malloc:</span><br><span class="line">        <span class="comment">//! 释放申请的设备号</span></span><br><span class="line">        unregister_chrdev_region(devno, DEVICE_NUM);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">module_init(globalmem_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">globalmem_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//! 卸载设备</span></span><br><span class="line">    <span class="keyword">int</span> i  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i &lt; DEVICE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">            cdev_del(&amp;(globalmem_devp + i)-&gt;cdev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//! 释放申请的设备号</span></span><br><span class="line">    unregister_chrdev_region(MKDEV(globalmem_major, <span class="number">0</span>), DEVICE_NUM);</span><br><span class="line">    <span class="comment">//! 释放空间</span></span><br><span class="line">    kfree(globalmem_devp);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(globalmem_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kcmetercec &lt;kcmeter.cec@gmail.com&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//! 如果没有许可证声明，加载模块时会收到内核被污染警告(Kernel Tainted)</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">// GPL, GPL v2, GPL and additional rights, Dual BSD/GPL, Dual MPL/GPL</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple example char device &quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;a simplest module&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;ver1.0&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>char</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个旋转编码器的驱动？</title>
    <url>/2022/10/02/linux_driver_chip_rotary_encoder/</url>
    <content><![CDATA[<ul>
<li>kernel 版本：v5.4</li>
<li>参考文档： /Documentation/input/devices/rotary-encoder.rst</li>
</ul>
<p>分析 Linux kernel 中编码器驱动的实现，从而应用到单片机上。</p>
<blockquote>
<p>此处所指的旋转编码器，是用手拧的那种编码器。</p>
</blockquote>
<span id="more"></span>

<h1 id="波形与判断"><a href="#波形与判断" class="headerlink" title="波形与判断"></a>波形与判断</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--chip/rotary_encoder/pic/inc_encoder.jpg?raw=true"><br>驱动文档上指出了编码器的一个完整周期的正转的波形输出，可以理解为 A 超前 B 90°，当反转时就是 A 滞后 B 90°。</p>
<h2 id="简易判断方法"><a href="#简易判断方法" class="headerlink" title="简易判断方法"></a>简易判断方法</h2><p>以前做单片机的时候，用的是简易判断方法：</p>
<ol>
<li>配置 AB 管脚为输入模式，且仅 A 为上升沿触发中断</li>
<li>当进入中断后进行一段时间的循环判断(这个时间要先根据示波器观察编码器周期长短来确定)<ul>
<li>判断逻辑为：只要在这段时间 A 电平为低则退出处理函数，判断为误触发</li>
</ul>
</li>
<li>在中断中读取 AB 的电平，当 A 和 B 都为高时代表正转，当 A 为高 B 为低时代表反转</li>
</ol>
<p>以上这种判断方式有以下缺陷：</p>
<ol>
<li>由于在中断中还需要一段循环判断，导致占用中断时间过长，系统吞吐量会下降</li>
<li>判断逻辑只判断了半个周期，并没有判断一个完整的周期，所以误触发的概率相对较大</li>
<li>延时的时间根据编码器而不同，无法通用</li>
</ol>
<h2 id="驱动中的判断逻辑"><a href="#驱动中的判断逻辑" class="headerlink" title="驱动中的判断逻辑"></a>驱动中的判断逻辑</h2><p>驱动则是利用了 A 和 B 的边沿触发中断，且判断了整个周期。</p>
<p>根据 AB 波形时序可以得出其组合值为：</p>
<ul>
<li>正转：0b10(0x2) -&gt; 0b11(0x3) -&gt; 0b01(0x1) -&gt; 0b00(0x0)</li>
<li>反转：0b01(0x1) -&gt; 0b11(0x3) -&gt; 0b10(0x2) -&gt; 0b00(0x0) </li>
</ul>
<p>驱动的逻辑为：</p>
<ul>
<li>将 AB 脚都配置为双边沿触发</li>
<li>进入中断以后驱动先后读取 AB 的值，A 放在第1位与 B 的值或。</li>
<li>根据上面的正反转做成状态机，当进入到状态 0b00 时确认已完成一个周期，即可向上层反应方向</li>
</ul>
<blockquote>
<p>有个疑问：这里为什么没有消抖处理，是默认硬件上以并电容的方式处理的吗？</p>
</blockquote>
<p>具体流程看代码（位于<code>/drivers/input/misc/rotary_encoder.c</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rotary_encoder_get_state</span><span class="params">(struct rotary_encoder *encoder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; encoder-&gt;gpios-&gt;ndescs; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = gpiod_get_value_cansleep(encoder-&gt;gpios-&gt;desc[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* convert from gray encoding to normal */</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;encoding == ROTENC_GRAY &amp;&amp; ret &amp; <span class="number">1</span>)</span><br><span class="line">            val = !val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 IO 口逻辑电平组合为数值</span></span><br><span class="line">        ret = ret &lt;&lt; <span class="number">1</span> | val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret &amp; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotary_encoder_report_event</span><span class="params">(struct rotary_encoder *encoder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (encoder-&gt;relative_axis) &#123;</span><br><span class="line">        <span class="comment">// 如果是增量式编码器，则直接返回方向</span></span><br><span class="line">        input_report_rel(encoder-&gt;input,</span><br><span class="line">                 encoder-&gt;axis, encoder-&gt;dir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是绝对式编码器，则计算绝对位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> pos = encoder-&gt;pos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;dir &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* turning counter-clockwise */</span></span><br><span class="line">            <span class="keyword">if</span> (encoder-&gt;rollover)</span><br><span class="line">                pos += encoder-&gt;steps;</span><br><span class="line">            <span class="keyword">if</span> (pos)</span><br><span class="line">                pos--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* turning clockwise */</span></span><br><span class="line">            <span class="keyword">if</span> (encoder-&gt;rollover || pos &lt; encoder-&gt;steps)</span><br><span class="line">                pos++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;rollover)</span><br><span class="line">            pos %= encoder-&gt;steps;</span><br><span class="line"></span><br><span class="line">        encoder-&gt;pos = pos;</span><br><span class="line">        input_report_abs(encoder-&gt;input, encoder-&gt;axis, encoder-&gt;pos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_sync(encoder-&gt;input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">rotary_encoder_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rotary_encoder</span> *<span class="title">encoder</span> =</span> dev_id;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;encoder-&gt;access_mutex);</span><br><span class="line"></span><br><span class="line">    state = rotary_encoder_get_state(encoder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x0</span>:</span><br><span class="line">        <span class="comment">// 如果进入 0x0 状态且之前已进入过 0x2 状态，则发送结果</span></span><br><span class="line">        <span class="comment">// 如果先进入 0x2 然后立马进入 0x0，则是反转</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;armed) &#123;</span><br><span class="line">            rotary_encoder_report_event(encoder);</span><br><span class="line">            encoder-&gt;armed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x3</span>:</span><br><span class="line">        <span class="comment">// 如果先进入 0x2 再进入 0x3，则是正转</span></span><br><span class="line">        <span class="comment">// 如果先进入 0x2 再进入 0x1，则是反转</span></span><br><span class="line">        <span class="keyword">if</span> (encoder-&gt;armed)</span><br><span class="line">            encoder-&gt;dir = <span class="number">2</span> - state;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x2</span>:</span><br><span class="line">        encoder-&gt;armed = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;encoder-&gt;access_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码逻辑就可以看出，主要是根据进入 0x2 状态之后再进入的状态来判断正反转。</p>
<h1 id="驱动的使用"><a href="#驱动的使用" class="headerlink" title="驱动的使用"></a>驱动的使用</h1><h2 id="使用前的确认"><a href="#使用前的确认" class="headerlink" title="使用前的确认"></a>使用前的确认</h2><p>  在使用此驱动前需要确保：</p>
<ol>
<li>GPIO驱动已经正确加载</li>
<li>GPIO相关中断控制器能正常工作且能接收双边沿触发</li>
</ol>
<h2 id="配置设备树"><a href="#配置设备树" class="headerlink" title="配置设备树"></a>配置设备树</h2><p>参考文档 <code>Documentation/devicetree/bindings/input/rotary-encoder.txt</code> 可以知道其典型设备树为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rotary@0 &#123;</span><br><span class="line">    compatible = &quot;rotary-encoder&quot;;</span><br><span class="line">    gpios = &lt;&amp;gpio 19 1&gt;, &lt;&amp;gpio 20 0&gt;; /* GPIO19 is inverted */</span><br><span class="line">    linux,axis = &lt;0&gt;; /* REL_X */</span><br><span class="line">    rotary-encoder,encoding = &quot;gray&quot;;</span><br><span class="line">    rotary-encoder,relative-axis;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加入编译选项"><a href="#加入编译选项" class="headerlink" title="加入编译选项"></a>加入编译选项</h2><p>位于 <code>Device Dervers-&gt;Input device support-&gt;Generic input layer -&gt; Miscellaneous devices ::Rotary encoders connected to GPIO pins</code></p>
<h2 id="用户空间使用"><a href="#用户空间使用" class="headerlink" title="用户空间使用"></a>用户空间使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fd, rd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open (<span class="string">&quot;/dev/input/event0&quot;</span>, O_RDONLY|O_NONBLOCK)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Can not open device!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)&amp;ev, <span class="number">0</span>, <span class="keyword">sizeof</span>(ev));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((rd = read(fd, (<span class="keyword">void</span>*)&amp;ev, <span class="keyword">sizeof</span>(ev))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;value: %d\n&quot;</span>, ev.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面程序验证可以发现event只返回 1，-1 两个方向，而无法判断出速度。<br>而关于速度的判断，可以通过状态机的方式在应用代码中实现(在一定时间内判断单一方向上数据增加的个数来区分速度)。</p>
<ul>
<li>在用户空间通过 poll 来查询编码器输入，并计数</li>
<li>在每次 poll <strong>第一次触发</strong> 开始后，通过信号量唤醒另一个线程计算在一段时间内的计数值</li>
</ul>
<p><strong>需要注意的是</strong>： 编码器输出一般会并一个电容，一般在 1nF～10nF，具体的取值以示波器观察波形是否失真为准。</p>
<h1 id="实际应用的调整"><a href="#实际应用的调整" class="headerlink" title="实际应用的调整"></a>实际应用的调整</h1><p>如果编码器是无源的，那触发引脚则需要接入上拉电阻，那么这个时候周期时序就会发生变化：</p>
<ul>
<li>正转：0b01(0x1) -&gt; 0b00(0x0) -&gt; 0b10(0x2) -&gt; 0b11(0x3)</li>
<li>反转：0b10(0x2) -&gt; 0b00(0x0) -&gt; 0b01(0x1) -&gt; 0b11(0x3)</li>
</ul>
<p>这种情况下，就需要：</p>
<ol>
<li>以 0x3 作为最后的发送条件，而 0x0 作为<code>armed</code>标记触发点</li>
<li>如果进入 0x0 后进入 0x2，则为正转。如果进入 0x0 后进入 0x1，则为反转</li>
</ol>
<p>总之都是对周期状态进行正反判断，同样的半周期和四分之一周期都可以用类似的方式（状态机）来完成判断。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>chip</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>认识设备树</title>
    <url>/2023/07/09/linux_driver_device_tree_hello/</url>
    <content><![CDATA[<p>设备树平时用得很多，但总感觉对它缺乏一个系统性的认识。</p>
<p>偶然间刷到了 bootlin 的 <a href="https://www.youtube.com/watch?v=Nz6aBffv-Ek">视频</a> 那就再来过一次。</p>
<span id="more"></span>

<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/type_hw.jpg?raw=true"><br>以上是一个典型的嵌入式系统所具备的控制器及外设，如何简易的告诉给 Linux？设备树便是一个很好的配置文件格式。</p>
<p>需要明白的是，并不是所有的硬件信息都需要写入设备树中。因为有些硬件具备了设备发现机制，比如 USB、PCIE 这种当设备插入后会启动枚举机制来获取设备信息，然后与对应的驱动联系起来。</p>
<p>有些不具备发现机制的（比如 I2C、SPI）则需要在设备树中注明与之相连接的外设。</p>
<p>所以在设备树中一般需要包含的信息从内到外有：</p>
<ul>
<li>当前 SOC 有多少核心</li>
<li>在内存总线上可以访问的控制器，该控制器对应的物理地址、中断号</li>
<li>当前 SOC 所具备的外围与那个控制器连接，它具备的地址等</li>
</ul>
<p>使用设备树的流程为：</p>
<ol>
<li>由开发人员编写设备树源码<code>.dts</code>文件</li>
<li>由设备树编译器<code>dtc</code>将 <code>.dts</code> 文件编译为 <code>.dtb</code> 文件</li>
<li>对于 U-Boot、Barebox 而言，可以将 <code>.dtb</code>文件链接到可执行文件中。对于 Linux 而言通常由 boot loader 告知。</li>
</ol>
<blockquote>
<p>比如对于 U-Boot 而言：bootz <kernel-addr> - <dtb-addr></p>
</blockquote>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/base_syntax.jpg?raw=true"><br>以上便是一个基本的设备树语法，理解起来还是比较直观。</p>
<blockquote>
<p>dtc 只进行语法检查，不会进行语义检查！</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example.jpg?raw=true"><br>如上图的右侧所示，硬件描述为：</p>
<ul>
<li>该 SOC 具有两个 Cortex A9 内核</li>
<li>与该内核通信总线上具备有 USB 控制器、中断控制器、I2C 控制器、DDR 控制器</li>
<li>I2C 总线上被挂载了 EEPROM 设备，DDR 控制器外接了 DDR 内存芯片</li>
</ul>
<p>上图左侧的根设备树也很清楚的描述了以上硬件：</p>
<ul>
<li>cpus 节点描述内核</li>
<li>memory 节点描述内存</li>
<li>chosen 节点描述要发送给系统的配置命令</li>
<li>soc 节点描述通信总线上的控制器</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example_cpus.jpg?raw=true"><br>上图便是描述 cpus 节点的详细信息，此处便描述了内核类型，以及内核数量。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example_memory.jpg?raw=true"><br>上图分别描述了：</p>
<ul>
<li>memory 节点描述内存从物理地址 0x00 开始，具备大小为 512MB 。</li>
<li>chosen 节点描述启动参数为空，标准输出为 serial0，波特率 115200，8 位且无停止位</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example_soc_interrupt.jpg?raw=true"><br>上图描述了中断控制器的两段物理地址及其可被访问的范围。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example_soc_i2c.jpg?raw=true"><br>上图描述了 I2C 控制器的：</p>
<ul>
<li>物理地址、其可以被访问的范围、中断号以及时钟源和时钟频率</li>
<li>该总线上还挂载了 24c02 这种 EEPROM，该 EEPROM 的地址为 0x52</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/simplified_example_soc_usb.jpg?raw=true"><br>上图描述了 USB 控制器的：</p>
<ul>
<li>物理地址、其可被访问的范围、中断号以及时钟源</li>
<li>与该 USB 控制器连接的 PHY 的 phandle</li>
</ul>
<h2 id="设备树的组织方式"><a href="#设备树的组织方式" class="headerlink" title="设备树的组织方式"></a>设备树的组织方式</h2><p>设备树可以被分为多个文件：</p>
<ul>
<li><code>.dtsi</code> 文件一般是当前该 SOC 的通用设备树配置，描述了该 SOC 的内核以及控制器。所以它一般会被其他的 <code>.dts</code> 文件所包含。</li>
<li><code>.dts</code> 文件通常是会以 phandle 的方式来扩展对 <code>.dtsi</code> 文件的描述，以完整的描述控制器的参数和外接设备</li>
</ul>
<p><code>.dts</code> 可以包含 <code>.dtsi</code> 和 <code>.h</code> 文件，通过 <code>#include</code> 语法来实现（就和 c 语言一样的）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示 DTS 的版本</span></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;zynqmp.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;zynqmp-clk-ccf.dtsi&quot;</span></span></span><br><span class="line"><span class="comment">// 包含源码头文件，以便于引用宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/input/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/gpio/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/pinctrl/pinctrl-zynqmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/phy/phy.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/inheritance_example.jpg?raw=true"><br>以上表示了<code>.dts</code> 文件对 <code>.dtsi</code>文件的增加和改写，最终在 <code>.dtb</code>文件中会合并为最终的信息。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/inheritance_labels_example.jpg?raw=true"><br>如上图所示，<code>.dts</code> 文件增加或改写 <code>.dtsi</code> 文件有两种方式：</p>
<ol>
<li>直接描述层级以及节点的名称和地址，在里面加上需要增加或改动的属性及值</li>
<li>通过 phandle 的方式来引用节点</li>
</ol>
<blockquote>
<p>方法 2 明显优于方法 1</p>
</blockquote>
<h1 id="构建设备树"><a href="#构建设备树" class="headerlink" title="构建设备树"></a>构建设备树</h1><p>对于 ARM/ARM64 而言，<code>.dts</code> 的存在路径为：<code>arch/&lt;ARCH&gt;/boot/dts/</code> 或者 <code>arch/&lt;ARCH&gt;/boot/dts/&lt;vendor&gt;/</code> 目录下。</p>
<p>该目录下的 Makefile 就描述了对应要编译的 <code>.dts</code> 文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dtb-$(CONFIG_ARCH_ZYNQMP) += avnet-ultra96-rev1.dtb</span><br><span class="line">dtb-$(CONFIG_ARCH_ZYNQMP) += zynqmp-zc1232-revA.dtb</span><br><span class="line">dtb-$(CONFIG_ARCH_ZYNQMP) += zynqmp-zc1254-revA.dtb</span><br><span class="line">dtb-$(CONFIG_ARCH_ZYNQMP) += zynqmp-zc1275-revA.dtb</span><br></pre></td></tr></table></figure>
<p>在编译内核或 U-Boot 的时候，如果执行 <code>make</code> 命令就会顺带的编译对应的设备树。</p>
<p>当然也可以单独编译设备树：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">make dtbs</span><br></pre></td></tr></table></figure>

<p>除了构建设备树外，还可以使用以下方式对设备树进行语义检查：</p>
<ul>
<li><code>make dt_bindings_check</code> ：检查 YAML 绑定是否合理</li>
<li><code>make dtbs_check</code> ：对 YAML 绑定进行验证</li>
</ul>
<h1 id="调试设备树"><a href="#调试设备树" class="headerlink" title="调试设备树"></a>调试设备树</h1><p>当 linux 启动后，可以在路径 <code>/sys/firmware/devicetree/base</code> 中浏览设备树的层级以及内容。</p>
<p>这种方式就可以检查设备树的配置是否与设定的一致。</p>
<blockquote>
<p>如果在目标板上还有 <code>dtc</code> 工具，那可以通过 <code>dtc -I fs /sys/firmware/devicetree/base</code> 来以 txt 的方式解析设备树。</p>
</blockquote>
<p>除此之外，在内核启动之前，U-Boot 可以通过 <code>fdt</code> 命令 <code>fdt set</code>,<code>fdt mknode</code>,<code>fdt rm</code> 来完成对设备树的编辑。</p>
<p>一般要新增一个设备时，首先需要在 <code>Document/devicetree/bindings</code> 目录下查看对应的说明，这样可以少走很多弯路。</p>
<p>该文档中的描述有两种风格，传统风格和 YAML 风格：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/device_old_style.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/device_yaml_style.jpg?raw=true"></p>
<h1 id="设备树-overlays"><a href="#设备树-overlays" class="headerlink" title="设备树 overlays"></a>设备树 overlays</h1><p>当硬件的外设灵活变化时，还可以通过对设备树打补丁的方式来完成设备树的更新，以提高灵活性。</p>
<p>也就是将各种不同的组合以相加的方式替代了相乘的方式，以减小设备树文件的数量。</p>
<p>比如下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/plugin/;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Pi3 uses a GPIO expander to drive the LEDs which can only be accessed</span></span><br><span class="line"><span class="comment">   from the VPU. There is a special driver for this with a separate DT node,</span></span><br><span class="line"><span class="comment">   which has the unfortunate consequence of breaking the act_led_gpio and</span></span><br><span class="line"><span class="comment">   act_led_activelow dtparams.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This overlay changes the GPIO controller back to the standard one and</span></span><br><span class="line"><span class="comment">   restores the dtparams.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">/&#123;</span><br><span class="line">	compatible = <span class="string">&quot;brcm,bcm2835&quot;</span>;</span><br><span class="line"></span><br><span class="line">	fragment@<span class="number">0</span> &#123;</span><br><span class="line">		target = &lt;&amp;act_led&gt;;</span><br><span class="line">		frag0: __overlay__ &#123;</span><br><span class="line">			gpios = &lt;&amp;gpio <span class="number">0</span> <span class="number">0</span>&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	__overrides__ &#123;</span><br><span class="line">		gpio = &lt;&amp;frag0&gt;,<span class="string">&quot;gpios:4&quot;</span>;</span><br><span class="line">		activelow = &lt;&amp;frag0&gt;,<span class="string">&quot;gpios:8&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="设备树的设计理念"><a href="#设备树的设计理念" class="headerlink" title="设备树的设计理念"></a>设备树的设计理念</h1><ol>
<li>完整的描述硬件，而不是具体该如何使用硬件</li>
<li>设备树应该与系统无关，无论是裸机还是操作系统都可以使用同一份设备树（操作系统的升级也不应该需要修改设备树）</li>
<li>描述硬件的组成，而不是描述硬件的内部结构</li>
</ol>
<h1 id="设备树中的属性"><a href="#设备树中的属性" class="headerlink" title="设备树中的属性"></a>设备树中的属性</h1><h2 id="compatible"><a href="#compatible" class="headerlink" title="compatible"></a>compatible</h2><p><code>compatible</code> 用于将设备和驱动进行匹配，其通常是以 <code>vendor, model</code> 的方式来表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">compatible = <span class="string">&quot;arm,armv8-timer&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;actions,s900-uart&quot;</span>, <span class="string">&quot;actions,owl-uart&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>该值就与驱动中的 <code>of_device_id</code> 相匹配：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%9E%84%E6%9E%B6/device_tree/pic/matching_driver.jpg?raw=true"></p>
<h2 id="通用属性"><a href="#通用属性" class="headerlink" title="通用属性"></a>通用属性</h2><ul>
<li><p>reg</p>
<ul>
<li>对于内存映射的设备，用于描述其基地址以及该设备可被访问的范围</li>
<li>对于 I2C 类设备，用于表示该设备的地址</li>
<li>对于 SPI 类设备，用于表示该设备的片选地址</li>
</ul>
</li>
<li><p>interrupts,interrupt-parent,interrupts-extended : 描述中断号，以及与其关联的中断控制器</p>
</li>
<li><p>clocks : 描述该设备所使用的对应的时钟控制器</p>
</li>
<li><p>dmas : 描述该设备使用的 DMA 控制器以及其 DMA 通道号</p>
</li>
<li><p>status: <code>status: okay</code> 描述该设备被使能，如果是其他值则该设备被 disable</p>
</li>
<li><p>pinctrl-x: 描述该设备需要的 GPIO</p>
</li>
</ul>
<h2 id="值与范围"><a href="#值与范围" class="headerlink" title="值与范围"></a>值与范围</h2><p>属性的值可以使用 10 进制、16 进制来表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    <span class="comment">/* This property has 1 cell */</span></span><br><span class="line">    foo = &lt;<span class="number">0xdeadbeef</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上描述的是 32 位的值，对于 64 位的值使用两个 32 位的值来表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    <span class="comment">/* This property has 2 cells */</span></span><br><span class="line">    foo = &lt;<span class="number">0xdeadbeef</span> <span class="number">0xbadcafe</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>规定值与范围的，是通过 <code>#address-cells</code> 和 <code>#size-cells</code> 来设定的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">    <span class="comment">// 以下属性使用一个 cell 表示地址，一个 cell 表示范围</span></span><br><span class="line">    <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">    i2c@f1001000 &#123;</span><br><span class="line">        reg = &lt;<span class="number">0xf1001000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        <span class="comment">// 以下的属性使用一个 cell 表示地址且没有范围</span></span><br><span class="line">        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;</span>;</span></span><br><span class="line">        eeprom@<span class="number">52</span> &#123;</span><br><span class="line">            reg = &lt;<span class="number">0x52</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同理，<code>#interrupts-cells</code> 表示用多少 cell 表示设备使用的中断号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    intc: interrupt-controller@f1002000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;foo,bar-intc&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0xf1002000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="comment">// 该中断控制器需要两个 cell 来描述设备与它的连接关系</span></span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    i2c@f1001000 &#123;</span><br><span class="line">        interrupt-parent = &lt;&amp;intc&gt;;</span><br><span class="line">        <span class="comment">/* Must have two cells */</span></span><br><span class="line">        interrupts = &lt;<span class="number">12</span> <span class="number">24</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了上面的理解，那么<code>#clock-cells</code>，<code>#gpio-cells</code>，<code>#phy-cells</code>都可以以此类推：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    clkc: clock@f1003000 &#123;</span><br><span class="line">    compatible = <span class="string">&quot;foo,bar-clock&quot;</span>;</span><br><span class="line">    reg = &lt;<span class="number">0xf1003000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    <span class="meta">#clock-cells = <span class="meta-string">&lt;3&gt;</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    i2c@f1001000 &#123;</span><br><span class="line">    <span class="comment">/* Must have three cells */</span></span><br><span class="line">    clocks = &lt;&amp;clkc <span class="number">12</span> <span class="number">24</span> <span class="number">32</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="names"><a href="#names" class="headerlink" title="-names"></a>-names</h2><p>可以通过 <code>&lt;prop&gt;-names</code>将当前属性与名字匹配，更易于理解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">interrupts = &lt;<span class="number">0</span> <span class="number">59</span> <span class="number">0</span>&gt;, &lt;<span class="number">0</span> <span class="number">70</span> <span class="number">0</span>&gt;;</span><br><span class="line">interrupt-names = <span class="string">&quot;macirq&quot;</span>, <span class="string">&quot;macpmt&quot;</span>;</span><br><span class="line">clocks = &lt;&amp;car <span class="number">39</span>&gt;, &lt;&amp;car <span class="number">45</span>&gt;, &lt;&amp;car <span class="number">86</span>&gt;, &lt;&amp;car <span class="number">87</span>&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;gnssm_rgmii&quot;</span>, <span class="string">&quot;gnssm_gmac&quot;</span>, <span class="string">&quot;rgmii&quot;</span>, <span class="string">&quot;gmac&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么在驱动中就可以这么使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">platform_get_irq_byname</span>(pdev, <span class="string">&quot;macirq&quot;</span>);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>devicetree</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IIO(Industrial I/O Subsystem) 基本使用</title>
    <url>/2023/09/02/linux_driver_iio_overview/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>参考网站: <a href="https://wiki.analog.com/software/linux/docs/iio/iio">Analog</a>，<a href="https://bootlin.com/blog/the-backbone-of-a-linux-industrial-i-o-driver/">the-backbone-of-a-linux-industrial-i-o-driver</a></p>
<p>参考文档: <code>Documentation/iio/</code>     <code>Documentation/ABI/testing/sysfs-bus-iio*</code></p>
<p>参考代码: <code>drivers/iio/**</code></p>
<span id="more"></span>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>IIO 子系统主要包含一些传感器，AD，DA 等器件的操作。<br>此系统的目的是为了填补hwmon 和 input 子系统之间的空隙。</p>
<p>一般此子系统下的设备是通过 SPI 或者 I2C 通信。</p>
<ul>
<li>hwmon(硬件监视) : 主要用于低速的设备监视</li>
<li>input(输入子系统): 主要专注于与用户交互的设备(比如: 按键, 鼠标, 触摸等)</li>
</ul>
<p>此子系统为这类设备提供了统一的函数接口和数据结构, 这些的具体实现位置是 <code>drivers/iio/industrialio-xxx.c</code>。</p>
<p>包含以下种类:</p>
<ul>
<li>ADC 以及 DAC</li>
<li>加速度计</li>
<li>陀螺仪</li>
<li>惯性测量仪</li>
<li>电容-数字转换器</li>
<li>气压计</li>
<li>颜色，光，距离传感器</li>
<li>温度传感器</li>
<li>磁力计</li>
<li>直接数字合成器(DDS)</li>
<li>锁相环(PLL)</li>
<li>可变/可编程增益放大器(VGA, PGA)</li>
<li>FPGA外设</li>
<li>由DMA传输的高速串口或并口</li>
</ul>
<p>包含以下功能:</p>
<ul>
<li>设备的注册及处理操作.</li>
<li>可以通过 <code>sysfs</code> 来访问设备</li>
<li>事件机制: 将设备的一些事件发送给用户空间。</li>
<li>支持硬件环形队列</li>
<li>ring buffer 存储事件，可以查看 buffer 填充状态</li>
</ul>
<p>这些设备都有一些共同点：</p>
<ul>
<li>在采集数据前，需要先对采集进行配置</li>
<li>部分设备还具备采集的触发机制</li>
<li>采集到的数据通过统一的机制发送给用户空间</li>
</ul>
<h3 id="ring-buffer"><a href="#ring-buffer" class="headerlink" title="ring buffer"></a>ring buffer</h3><p>环形队列缓存，也就是先进先出缓存，从尾部写入，从头部读出。iio 使用 <code>kfifo</code> 来实现，以应对生产者消费者模型。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--IIO/overview/IIO_ringBuffer.jpg?raw=true"></p>
<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>可以认为是一些标识，以向用户表示一些状态发生了。</p>
<h3 id="trigger"><a href="#trigger" class="headerlink" title="trigger"></a>trigger</h3><p>一个引导信号，只要此信号产生后便会导致另一些处理程序的运行(类似于中断)，比如产生一个事件标志。</p>
<p>有如下几种 trigger：</p>
<ul>
<li>数据已准备好</li>
<li>GPIO触发<ul>
<li>iio中使用 <code>iio-trig-gpio</code> 来完成此支持</li>
</ul>
</li>
<li>内部周期性触发<ul>
<li>iio中使用 <code>iio-trig-rtc</code> 来完成此支持</li>
</ul>
</li>
<li>用户空间读取特定文件的触发<ul>
<li>iio中使用 <code>iio-trig-sysfs</code> 来完成此支持</li>
</ul>
</li>
</ul>
<p>IIO中使用 trigger 来填充ring buffer。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>一个通道，代表一种信号(数据)。比如气压计具有测量气压和温度的功能，则它具有一个气压通道和一个温度通道。</p>
<h2 id="构架"><a href="#构架" class="headerlink" title="构架"></a>构架</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--IIO/overview/IIO_overview.jpg?raw=true"><br>根据设备驱动思想以及上面的说明可以知道需要以下软件的支持才能使用此子系统:</p>
<ul>
<li>总线控制器驱动及设备树</li>
<li>芯片驱动(总线客户端驱动)及设备树</li>
<li>IIO子系统的接口填充</li>
</ul>
<p>一般来讲，<code>BUS Driver</code> 的驱动都有芯片厂商提供，用户需要：</p>
<ul>
<li>在设备树中对应总线方式增加设备节点</li>
<li>实现设备驱动</li>
<li>在设备驱动中使用 iio 提供的接口将配置映射到字符设备和 <code>sysfs</code> 中</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>在驱动正常的情况下，子系统会将设备映射到 :</p>
<ol>
<li><code>sysfs</code> 下，用于配置设备以及读取原始数据。</li>
<li>字符设备，用于访问内核缓存事件等</li>
</ol>
<h2 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h2><p>路径位于: <code>/sys/bus/iio/devices/iio:deviceX</code> ，其目录下具有以下文件:</p>
<ul>
<li>name: 设备号</li>
<li>dev: 设备节点(major:minor)</li>
<li>device configuration attributes (sampling_frequency_avaliables)</li>
<li>data channel access attributes(in_resistance_raw)</li>
<li>buffer/，events/，trigger/，scan_elements/</li>
</ul>
<p>通过读取 <code>iio:deviceX</code> 中的对应文件，其实会对应调用设备的回调函数</p>
<p>(比如读取 “xxx_raw” 文件, 会调用 read_raw 函数).</p>
<h2 id="character-device"><a href="#character-device" class="headerlink" title="character device"></a>character device</h2><p>路径位于: <code>/dev/iio:deviceX</code></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="驱动编写步骤"><a href="#驱动编写步骤" class="headerlink" title="驱动编写步骤"></a>驱动编写步骤</h2><p>驱动的编写步骤为:</p>
<ol>
<li><p>根据设备所属的通信总线，实现其总线驱动，以及对应的设备树节点。</p>
</li>
<li><p>创建 <code>struct iio_dev</code> 结构（通过 <code>devm_iio_device_alloc</code>申请），并填充其内容</p>
<ul>
<li><p>设备名称</p>
</li>
<li><p>私有数据填充</p>
</li>
<li><p>设备 <code>iio_info</code> 结构体填充</p>
</li>
<li><p>设备 <code>channel</code> 结构体填充</p>
</li>
<li><p>设备所支持的模式</p>
</li>
<li><p>如果设备只有特定的通道能用，则需要初始化<code>available_scan_masks</code>，在实际工作中，当前正在获取的通道会在<code>active_scan_mask</code>中表示</p>
</li>
<li><p>初始化设备的每个通道的类型，比如（<code>IIO_VOLTAGE</code>，<code>IIO_TEMPERATURE</code>）</p>
</li>
</ul>
</li>
<li><p>使用 <code>devm_iio_device_register</code> 将此设备注册至IIO框架.</p>
</li>
<li><p>完成对应的卸载功能函数</p>
</li>
</ol>
<h2 id="iio-dev"><a href="#iio-dev" class="headerlink" title="iio_dev"></a>iio_dev</h2><p><code>iio_dev</code> 是最主要的结构体，用于设备驱动，主要提供一些信息和操作函数:</p>
<ul>
<li>该设备有多少通道可用</li>
<li>此设置支持哪些操作模式</li>
<li>此驱动支持的一些回调函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief struct iio_dev - industrial I/O device</span></span><br><span class="line"><span class="comment"> * @param modes: 此设备支持的模式</span></span><br><span class="line"><span class="comment"> * @param dev: 设备结构体，说明 iio_dev 继承自 struct device</span></span><br><span class="line"><span class="comment"> * @param buffer: 当前设备的数据缓存</span></span><br><span class="line"><span class="comment"> * @param scan_bytes: 被捕获的字节数</span></span><br><span class="line"><span class="comment"> * @param mlock: 用于互斥操作的锁</span></span><br><span class="line"><span class="comment"> * @param available_scan_masks: 允许的通道 mask</span></span><br><span class="line"><span class="comment"> * @param masklength: mask长度</span></span><br><span class="line"><span class="comment"> * @param active_scan_mask: 缓存所需要的mask</span></span><br><span class="line"><span class="comment"> * @param scan_timestamp: 缓存与时间戳</span></span><br><span class="line"><span class="comment"> * @param trig: 当前设备的触发设置</span></span><br><span class="line"><span class="comment"> * @param pollfunc: 触发被接收到后, 用于运行的功能</span></span><br><span class="line"><span class="comment"> * @param pollfunc_event: 当事件触发被接收到后, 运行</span></span><br><span class="line"><span class="comment"> * @param channels: 对通道的定义</span></span><br><span class="line"><span class="comment"> * @param num_channels: 定义的通道数</span></span><br><span class="line"><span class="comment"> * @param name: 设备的名称</span></span><br><span class="line"><span class="comment"> * @param label : 标识设备的唯一名称</span></span><br><span class="line"><span class="comment"> * @param info: 驱动的回调和固定信息</span></span><br><span class="line"><span class="comment"> * @param setup_ops: 在缓存使能和关闭时的回调</span></span><br><span class="line"><span class="comment"> * @param priv: 每个驱动的私有数据结构的指针，通过 iio_priv 获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>                modes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>            <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span>        *<span class="title">buffer</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                scan_bytes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            <span class="title">mlock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>        *available_scan_masks;</span><br><span class="line">    <span class="keyword">unsigned</span>            masklength;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>        *active_scan_mask;</span><br><span class="line">    <span class="keyword">bool</span>                scan_timestamp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span>        *<span class="title">trig</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>        *<span class="title">pollfunc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>        *<span class="title">pollfunc_event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">const</span>    *<span class="title">channels</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                num_channels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *label;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span>        *<span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span>    *<span class="title">setup_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>                *priv;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief chardev interface for an event lines</span></span><br><span class="line"><span class="comment"> * @param wait : 阻塞读取队列</span></span><br><span class="line"><span class="comment"> * @param det_events: 已经检测到的事件链表</span></span><br><span class="line"><span class="comment"> * @param dev_attr_list: 属性链表</span></span><br><span class="line"><span class="comment"> * @param flags:相应的文件操作标记</span></span><br><span class="line"><span class="comment"> * @param group: 属性组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_event_interface</span>&#123;</span></span><br><span class="line">        <span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">        DECLARE_KFIFO(det_events, struct iio_event_data, <span class="number">16</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dev_attr_list</span>;</span></span><br><span class="line">        unsigend <span class="keyword">long</span> flags;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> <span class="title">group</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">read_lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备的通道"><a href="#设备的通道" class="headerlink" title="设备的通道"></a>设备的通道</h2><p>通道的描述用 <code>channel</code> 结构体来完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 定义一个通道</span></span><br><span class="line"><span class="comment">   * @param info_mask_separate : 对于当前通道，在 sysfs 中的展现信息 </span></span><br><span class="line"><span class="comment">   * @param scan_type : 指定当前通道的数据类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span>    <span class="title">type</span>;</span></span><br><span class="line">    <span class="keyword">int</span>            channel;</span><br><span class="line">    <span class="keyword">int</span>            channel2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        address;</span><br><span class="line">    <span class="keyword">int</span>            scan_index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span>    sign;</span><br><span class="line">        u8    realbits;</span><br><span class="line">        u8    storagebits;</span><br><span class="line">        u8    shift;</span><br><span class="line">        u8    repeat;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">iio_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    &#125; scan_type;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_separate;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_separate_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_type;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_type_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_dir;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_dir_available;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_all;</span><br><span class="line">    <span class="keyword">long</span>            info_mask_shared_by_all_available;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_spec</span> *<span class="title">event_spec</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        num_event_specs;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec_ext_info</span> *<span class="title">ext_info</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *extend_name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *datasheet_name;</span><br><span class="line">    <span class="keyword">unsigned</span>        modified:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        indexed:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        output:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>        differential:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里初始化了 ms5611 的气压和温度通道</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">ms5611_channels</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .type = IIO_PRESSURE,</span><br><span class="line">        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_SCALE) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),</span><br><span class="line">        .scan_index = <span class="number">0</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">            .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            .realbits = <span class="number">32</span>,</span><br><span class="line">            .storagebits = <span class="number">32</span>,</span><br><span class="line">            .endianness = IIO_CPU,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .type = IIO_TEMP,</span><br><span class="line">        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_SCALE) |</span><br><span class="line">            BIT(IIO_CHAN_INFO_OVERSAMPLING_RATIO),</span><br><span class="line">        .scan_index = <span class="number">1</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">            .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">            .realbits = <span class="number">32</span>,</span><br><span class="line">            .storagebits = <span class="number">32</span>,</span><br><span class="line">            .endianness = IIO_CPU,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    IIO_CHAN_SOFT_TIMESTAMP(<span class="number">2</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当具有多个通道的时候, 有两种方式来生成不同的通道:</p>
<ul>
<li>设置 <code>.modified</code> 值为1, 对应的设置 <code>.channel2</code> 来区分不同的通道.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">light_channels</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_INTENSITY,</span><br><span class="line">                .modified = <span class="number">1</span>,</span><br><span class="line">                .channel2 = IIO_MOD_LIGHT_IR,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_INTENSITY,</span><br><span class="line">                .modified = <span class="number">1</span>,</span><br><span class="line">                .channel2 = IIO_MOD_LIGHT_BOTH,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_LIGHT,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span><br><span class="line">                .info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),</span><br><span class="line">        &#125;.</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用上面的配置,得到的 <code>sysfs</code> 文件为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/bus/iio/device/iio:deviceX/in_intensity_ir_raw </span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/in_intensity_both_raw</span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/in_illuminance_input </span><br><span class="line"></span><br><span class="line">/sys/bus/iio/device/iio:deviceX/sampling_frequency </span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <code>.indexed</code> 值为1, 对应的设置 <code>.channel</code> 来区分不同的通道</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">light_channels</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_VOLTAGE,</span><br><span class="line">                .indexed = <span class="number">1</span>,</span><br><span class="line">                .channel = <span class="number">0</span>,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .type = IIO_VOLTAGE,</span><br><span class="line">                .indexed = <span class="number">1</span>,</span><br><span class="line">                .channel = <span class="number">1</span>,</span><br><span class="line">                .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用上面的配置, 得到的 <code>sysfs</code> 文件为:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/sys/bus/iio/devices/iio:deviceX/in_voltage0_raw,</span><br><span class="line"></span><br><span class="line">/sys/bus/iio/devices/iio:deviceX/in_voltage1_raw,</span><br></pre></td></tr></table></figure>

<h2 id="缩放因子"><a href="#缩放因子" class="headerlink" title="缩放因子"></a>缩放因子</h2><p>当在<code>sysfs</code>中读取 raw 或 scale 的值时，内核回调函数<code>int (*read_raw)(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask)</code>将会被调用。</p>
<p>对于<code>info_mask_separate</code>是<code>IIO_CHAN_INFO_RAW</code>的通道，就会直接返回原始数据。而对于<code>IIO_CHAN_INFO_SCALE</code>的通道，会返回原始数据和缩放因子。</p>
<p>IIO 驱动的内核则会除以该缩放因子，得到最终的值返回给用户空间。</p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>采样的值可以简单粗暴的通过读<code>/sys/bus/devices/iio:device/in_&lt;type&gt;&lt;index&gt;_raw</code>，对应到驱动的<code>read_raw()</code>回调来完成。这种读取就是单次的读数据。</p>
<p>也可以通过触发的方式，来获取数据。</p>
<h2 id="设备缓存"><a href="#设备缓存" class="headerlink" title="设备缓存"></a>设备缓存</h2><p>当使用缓存时, 会在 <code>sysfs</code> 下建立文件夹 <code>/sys/bus/iio/device/iio:deviceX/buffer/</code> , 此目录下具有文件:</p>
<ul>
<li>length : 缓存的大小</li>
<li>enable : 使能 buffer 捕捉事件</li>
</ul>
<p>一个通道读取原始数据以后, 放在缓存中, 称为 <code>scan element</code>, 此属性在 <code>iio_chan_spec</code> 的 <code>scan_type</code> 中设置.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">accel_channels</span>[]=</span></span><br><span class="line">&#123;</span><br><span class="line">        .type = IIO_ACCEL,</span><br><span class="line">        .modified = <span class="number">1</span>,</span><br><span class="line">        .channel2 = IIO_MOD_X,</span><br><span class="line">        <span class="comment">/// 指定此通道的优先级,越低优先级越高, 为 -1 代表不支持放入buffer</span></span><br><span class="line">        .scan_index = <span class="number">0</span>,</span><br><span class="line">        .scan_type = &#123;</span><br><span class="line">                .sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">                .realbits = <span class="number">13</span>,</span><br><span class="line">                .storgebits = <span class="number">16</span>,</span><br><span class="line">                .shift = <span class="number">4</span>,</span><br><span class="line">                .endianness = IIO_LE,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置 <code>scan element</code> 的对应文件位于 <code>sys/bus/iio/device/iio:deviceX/scan_elements/</code>, 具有以下文件:</p>
<ul>
<li>enable : 用于使能一个通道, 此值不为 0 时则存入捕获的结果</li>
<li>type : 用于表述数据的类型,格式为 <code>[be/le]:[s/u]bits/storagebitsRepeat[&gt;&gt;shift]</code>.<ul>
<li>be -&gt; 大端模式, le -&gt; 小端模式</li>
<li>s -&gt; 有符号型, u -&gt; 无符号型</li>
<li>bits -&gt; 有效数据位数</li>
<li>storagebits -&gt; 一个数据以多少位来表示</li>
<li>repeat -&gt; 指定数据重复次数</li>
<li>shift -&gt; 数据 <strong>需要偏移的位数以得到正确的数据</strong>.</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief buffer 用于存储接收到的数据, 用户通过 /dev/iio:deviceX 来读取即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span>                         length;</span><br><span class="line">        <span class="keyword">int</span>                         bytes_per_datum;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      *<span class="title">scan_el_attrs</span>;</span></span><br><span class="line">        <span class="keyword">long</span>                        *scan_mask;</span><br><span class="line">        <span class="keyword">bool</span>                        scan_timestamp;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_access_funcs</span> *<span class="title">access</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">scan_el_dev_attr_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      <span class="title">buffer_group</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>      <span class="title">scan_el_group</span>;</span></span><br><span class="line">        <span class="keyword">wait_queue_head_t</span>           pollq;</span><br><span class="line">        <span class="keyword">bool</span>                        stufftoread;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>      *<span class="title">attrs</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">demux_list</span>;</span></span><br><span class="line">        <span class="keyword">void</span>                        *demux_bounce;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>            <span class="title">buffer_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>                 <span class="title">ref</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>                waitermark;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备触发"><a href="#设备触发" class="headerlink" title="设备触发"></a>设备触发</h2><p>通过触发来存储数据，比用轮询的方式更加科学。</p>
<p>触发对应的 <code>sysfs</code> 文件夹有两个位置:</p>
<ul>
<li><code>/sys/bus/iio/devices/triggerY</code> : 当 IIO 触发使用了注册函数后, 此文件夹便建立了, 具有以下两个属性文件。<ul>
<li>name –&gt; 触发的名称</li>
<li>sampling_frequency –&gt; 基于定时器的触发， 具有扫瞄频率</li>
</ul>
</li>
<li><code>/sys/bus/iio/devices/iio:deviceX/trigger/</code> : 当一个设备支持触发时, 此文件夹便出现。为了将设备与触发连接起来， 在 <code>current_trigger</code> 文件中写入触发名称即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span>    *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>            *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>            *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>            <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">alloc_list</span>;</span></span><br><span class="line">    <span class="keyword">atomic_t</span>            use_count;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>            <span class="title">subirq_chip</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                subirq_base;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_subirq</span> <span class="title">subirqs</span>[<span class="title">CONFIG_IIO_CONSUMERS_PER_TRIGGER</span>];</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pool[BITS_TO_LONGS(CONFIG_IIO_CONSUMERS_PER_TRIGGER)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            <span class="title">pool_lock</span>;</span></span><br><span class="line">    <span class="keyword">bool</span>                attached_own_device;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>        <span class="title">reenable_work</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span> <span class="title">zpa2326_trigger_ops</span> =</span> &#123;</span><br><span class="line">    .set_trigger_state = zpa2326_set_trigger_state,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zpa2326_init_managed_trigger</span><span class="params">(struct device          *parent,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct iio_dev         *indio_dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct zpa2326_private *<span class="keyword">private</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">int</span>                     irq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> *<span class="title">trigger</span>;</span></span><br><span class="line">    <span class="keyword">int</span>                 ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (irq &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    trigger = devm_iio_trigger_alloc(parent, <span class="string">&quot;%s-dev%d&quot;</span>,</span><br><span class="line">                     indio_dev-&gt;name,</span><br><span class="line">                     iio_device_id(indio_dev));</span><br><span class="line">    <span class="keyword">if</span> (!trigger)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic setup. */</span></span><br><span class="line">    trigger-&gt;ops = &amp;zpa2326_trigger_ops;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>-&gt;trigger = trigger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Register to triggers space. */</span></span><br><span class="line">    ret = devm_iio_trigger_register(parent, trigger);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        dev_err(parent, <span class="string">&quot;failed to register hardware trigger (%d)&quot;</span>,</span><br><span class="line">            ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="触发与缓存连接"><a href="#触发与缓存连接" class="headerlink" title="触发与缓存连接"></a>触发与缓存连接</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note 用于在 buffer 在使能和失能前后的操作</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> <span class="title">zpa2326_buffer_setup_ops</span> =</span> &#123;</span><br><span class="line">	.preenable   = zpa2326_preenable_buffer,</span><br><span class="line">	.postenable  = zpa2326_postenable_buffer,</span><br><span class="line">	.postdisable = zpa2326_postdisable_buffer</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note 用于中断的底半处理, 用于将设备的数据存入缓存, 并且还有此数据的时间标记</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">zpa2326_trigger_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span>         *<span class="title">indio_dev</span> =</span> ((struct iio_poll_func *)</span><br><span class="line">					     data)-&gt;indio_dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zpa2326_private</span> *<span class="title">priv</span> =</span> iio_priv(indio_dev);</span><br><span class="line">	<span class="keyword">bool</span>                    cont;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We have been dispatched, meaning we are in triggered buffer mode.</span></span><br><span class="line"><span class="comment">	 * Using our own internal trigger implies we are currently in continuous</span></span><br><span class="line"><span class="comment">	 * hardware sampling mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cont = iio_trigger_using_own(indio_dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cont) &#123;</span><br><span class="line">		<span class="comment">/* On demand sampling : start a one shot cycle. */</span></span><br><span class="line">		<span class="keyword">if</span> (zpa2326_start_oneshot(indio_dev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Wait for sampling cycle to complete. */</span></span><br><span class="line">		<span class="keyword">if</span> (priv-&gt;irq &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* No interrupt available: poll for completion. */</span></span><br><span class="line">			<span class="keyword">if</span> (zpa2326_poll_oneshot_completion(indio_dev))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Only timestamp sample once it is ready. */</span></span><br><span class="line">			priv-&gt;timestamp = iio_get_time_ns(indio_dev);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* Interrupt handlers will timestamp for us. */</span></span><br><span class="line">			<span class="keyword">if</span> (zpa2326_wait_oneshot_completion(indio_dev, priv))</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Enqueue to IIO buffer / userspace. */</span></span><br><span class="line">	zpa2326_fill_sample_buffer(indio_dev, priv);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!cont)</span><br><span class="line">		<span class="comment">/* Don&#x27;t switch to low power if sampling continuously. */</span></span><br><span class="line">		zpa2326_sleep(indio_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Inform attached trigger we are done. */</span></span><br><span class="line">	iio_trigger_notify_done(indio_dev-&gt;trig);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*setup triggered buffer, usually in probe function */</span></span><br><span class="line">err = devm_iio_triggered_buffer_setup(parent, indio_dev, <span class="literal">NULL</span>,</span><br><span class="line">					      zpa2326_trigger_handler,</span><br><span class="line">					      &amp;zpa2326_buffer_setup_ops)</span><br></pre></td></tr></table></figure>

<h2 id="设备的具体操作"><a href="#设备的具体操作" class="headerlink" title="设备的具体操作"></a>设备的具体操作</h2><p>设备的操作便是接收一个触发信号, 然后调用自己定义的回调函数, 回调函数通过 <code>iio_info</code> 来提供给框架.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 关于设备的信息</span></span><br><span class="line"><span class="comment"> ,* @param read_raw: 从设备获取一个值, mask 用于指明读取那个数值, 函数返回值的类型</span></span><br><span class="line"><span class="comment"> ,* @param read_raw_multi: 读取一些值</span></span><br><span class="line"><span class="comment"> ,* @param write_raw: 写一个值</span></span><br><span class="line"><span class="comment"> ,* @param write_raw_get_fmt: 查询可以写入的格式</span></span><br><span class="line"><span class="comment"> ,* @param read_event_config: 查看是否事件已经使能</span></span><br><span class="line"><span class="comment"> ,* @param write_event_config: 设置事件使能</span></span><br><span class="line"><span class="comment"> ,* @param read_event_value: 读取一个事件的配置</span></span><br><span class="line"><span class="comment"> ,* @param write_event_value: 写入一个事件的配置</span></span><br><span class="line"><span class="comment"> ,* @param validate_trigger: 确认有触发产生</span></span><br><span class="line"><span class="comment"> ,* @param update_scan_mode: 配置设备和扫描缓存</span></span><br><span class="line"><span class="comment"> ,* @param debugfs_reg_access: 读写设备的寄存器值</span></span><br><span class="line"><span class="comment"> ,* @param of_xlate: 获取对应通道的索引</span></span><br><span class="line"><span class="comment"> ,* @param </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span>                   *<span class="title">driver_module</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>          *<span class="title">event_attrs</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>    *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*read_raw)(struct iio_dev *indio_dev,</span><br><span class="line">                        struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                        <span class="keyword">int</span> *val,</span><br><span class="line">                        <span class="keyword">int</span> *val2,</span><br><span class="line">                        <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span> (*read_raw_multi)(struct iio_dev *indio_dev,</span><br><span class="line">                              struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                              <span class="keyword">int</span> max_len,</span><br><span class="line">                              <span class="keyword">int</span> *vals,</span><br><span class="line">                              <span class="keyword">int</span> *val_len,</span><br><span class="line">                              <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*write_raw)(struct iio_dev *indio_dev,</span><br><span class="line">                        struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                        <span class="keyword">int</span> val,</span><br><span class="line">                        <span class="keyword">int</span> val2,</span><br><span class="line">                        <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*write_raw_get_fmt)(struct iio_dev *indio_dev,</span><br><span class="line">                                struct iio_chan_spec <span class="keyword">const</span> *chan,</span><br><span class="line">                                <span class="keyword">long</span> mask);</span><br><span class="line">        <span class="keyword">int</span>(*read_event_config)(struct iio_dev *indio_dev,</span><br><span class="line">                                <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                <span class="keyword">enum</span> iio_event_direction dir);</span><br><span class="line">        <span class="keyword">int</span>(*write_event_config)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">int</span> state);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>(*read_event_value)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_info info,</span><br><span class="line">                               <span class="keyword">int</span> *val, <span class="keyword">int</span> *val2);</span><br><span class="line">        <span class="keyword">int</span>(*write_event_value)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">const</span> struct iio_chan_spec *chan,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">                                 <span class="keyword">enum</span> iio_event_info info,</span><br><span class="line">                               <span class="keyword">int</span> *val, <span class="keyword">int</span> *val2);</span><br><span class="line">        <span class="keyword">int</span>(*validate_trigger)(struct iio_dev *indio_dev,</span><br><span class="line">                               struct iio_trigger *trig);</span><br><span class="line">        <span class="keyword">int</span>(*update_scan_mode)(struct iio_dev *indio_dev,</span><br><span class="line">                               <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> *scan_mask);</span><br><span class="line">        <span class="keyword">int</span>(*debugfs_reg_access)(struct iio_dev *indio_dev,</span><br><span class="line">                                 <span class="keyword">unsigned</span> reg, <span class="keyword">unsigned</span> writeval,</span><br><span class="line">                                 <span class="keyword">unsigned</span> *readval);</span><br><span class="line">        <span class="keyword">int</span>(*of_xlate)(struct iio_dev *indio_dev,</span><br><span class="line">                       <span class="keyword">const</span> struct of_phandle_args *iiospec);</span><br><span class="line">        <span class="keyword">int</span>(*hwfifo_set_watermark)(struct iio_dev *indio_dev, <span class="keyword">unsigned</span> val);</span><br><span class="line">        <span class="keyword">int</span> (*hwfifo_flush_to_buffer)(struct iio_dev *indio_dev, <span class="keyword">unsigned</span> count);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> sturct iio_info ms5611_info = </span><br><span class="line">&#123;</span><br><span class="line">    .read_raw = &amp;ms5611_read_raw,</span><br><span class="line">    .driver_module = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="设备模式"><a href="#设备模式" class="headerlink" title="设备模式"></a>设备模式</h2><p>在 <code>linux/iio/iio.h</code> 中列出了设备所支持的模式:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">+BEGIN_SRC c</span></span><br><span class="line">//设备可用于软件触发</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_DIRECT_MODE          0X01</span></span><br><span class="line">//设备可用于硬件触发</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_TRIGGERED     0X02</span></span><br><span class="line">//设备使用软件缓存</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_SOFTWARE      0X04</span></span><br><span class="line">//设备使用硬件缓存</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_BUFFER_HARDWARE      0X08</span></span><br><span class="line">//设备使用事件触发机制</span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_EVENT_TEIGGERED      0X10</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define INDIO_ALL_BUFFER_MODES \</span></span><br><span class="line"><span class="bash">        (INDIO_BUFFER_TRIGGERED | INDIO_BUFFER_HARDWARE | INDIO_BUFFER_SOFTWARE)</span></span><br></pre></td></tr></table></figure>

<h2 id="申请一个设备"><a href="#申请一个设备" class="headerlink" title="申请一个设备"></a>申请一个设备</h2><p>申请设备时,就需要申请一个 <code>iio_dev</code> 结构并存放其私有数据, 用于代表此设备,然后调用注册函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 申请并管理IIO申请的设备内存(可以在驱动退出时自动卸载)</span></span><br><span class="line"><span class="comment"> ,* @param sizeof_priv: 私有数据的大小</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_dev *<span class="title">devm_iio_device_alloc</span><span class="params">(struct device *dev, <span class="keyword">int</span> sizeof_priv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 注册设备到IIO子系统中</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">devm_iio_device_register</span><span class="params">(struct device *dev, struct iio_dev *indio_dev)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 示例</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ms5611_i2c_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ms5611_state</span> *<span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span></span><br><span class="line"></span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line">    indio_dev = devm_iio_device_alloc(&amp;client-&gt;dev, <span class="keyword">sizeof</span>(*st));</span><br><span class="line">    <span class="keyword">if</span>(!indio_dev)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    st = iio_priv(indio_dev);</span><br><span class="line">    st-&gt;reset = ms5611_i2c_reset;</span><br><span class="line">    st-&gt;read_prom_word = ms5611_i2c_read_prom_word;</span><br><span class="line">    .....</span><br><span class="line">    st-&gt;client = client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ms5611_probe(indio_dev, &amp;client-&gt;dev, id-&gt;driver_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ms5611_probe</span><span class="params">(struct iio_dev *indio_dev, struct device *dev, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ms5611_state</span> *<span class="title">st</span> =</span> iio_priv(indio_dev);</span><br><span class="line"></span><br><span class="line">        st-&gt;chip_info = &amp;chip_info_tbl[type];</span><br><span class="line">        indio_dev-&gt;dev.parent = dev;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">        indio_dev-&gt;modes = INDIO_DIRECT_MODE;</span><br><span class="line">        indio_dev-&gt;channels = &amp;ms5611_channels;</span><br><span class="line">        indio_dev-&gt;num_channels = ARRAY_SIZE(ms5611_channels);</span><br><span class="line">        indio_dev-&gt;info = &amp;ms5611_info;</span><br><span class="line"></span><br><span class="line">        ret = ms5611_init(indio_dev);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="keyword">return</span> devm_iio_device_register(dev, indio_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>iio</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个简单的内核模块？</title>
    <url>/2023/03/24/linux_driver_module_hello/</url>
    <content><![CDATA[<p>这里仅仅是一个简单的说明，比较全面的说明可以查看开源书籍 <a href="https://sysprog21.github.io/lkmpg/">lkmpg</a>。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux内核使用模块(Module)的方法使得需要的功能可以动态的方式被加载到内核中，它具有如下优点：</p>
<ul>
<li>模块本身不被编译入内核镜像，可以灵活的控制内核大小</li>
<li>模块被加载后，和内核其他部分一样，也是通过函数的方式调用(宏内核)<ul>
<li>但如果模块编写有误，也有可能导致内核奔溃</li>
</ul>
</li>
</ul>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="加载及卸载"><a href="#加载及卸载" class="headerlink" title="加载及卸载"></a>加载及卸载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">加载模块</span></span><br><span class="line">sudo insmod name.ko</span><br><span class="line"><span class="meta">#</span><span class="bash">以依赖的方式加载模块，这种方式默认模块位于 /lib/modules/&lt;kernel&gt; 目录下</span></span><br><span class="line">sudo modprobe name.ko </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">卸载模块</span></span><br><span class="line">sudo rmmod name</span><br><span class="line"><span class="meta">#</span><span class="bash">以依赖的方式卸载模块</span></span><br><span class="line">sudo modprobe -r name.ko </span><br></pre></td></tr></table></figure>

<p>需要注意的是：当模块在卸载时，如果模块申请的资源没有被完全释放，那么下次再加载此模块时将有可能会出现各种错误。</p>
<h3 id="Required-key-not-available"><a href="#Required-key-not-available" class="headerlink" title="Required key not available"></a>Required key not available</h3><p>在Linux内核4.4.0-20 之后(ubuntu16.04)，默认打开了安全启动模式，也就是禁止第三方的模块加载。</p>
<p>所以需要关闭此安全启动模式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">简单粗暴的进入bios，然后关闭安全启动模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################</span></span></span><br><span class="line">sudo apt install mokutil</span><br><span class="line"><span class="meta">#</span><span class="bash">执行完此步骤后会输入一个8~16位密码</span></span><br><span class="line">sudo mokutil --disable-validation</span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line"><span class="meta">#</span><span class="bash">根据提示关闭安装启动模式(启动时可能不是输入密码，而是要你按照屏幕提示输入字符，和验证码一样)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">再次重启</span></span><br></pre></td></tr></table></figure>

<h2 id="模块查看"><a href="#模块查看" class="headerlink" title="模块查看"></a>模块查看</h2><ul>
<li>使用 <code>lsmod</code> 命令可以获得系统中已加载的所有模块以及模块间的依赖关系。<ul>
<li>此命令实际上是读取 <code>/proc/modules</code> 文件中的内容显示的</li>
</ul>
</li>
<li>内核被加载后，也存在于 <code>/sys/module/&lt;module_name&gt;</code> 文件夹下。<ul>
<li><code>refcnt</code> 代表模块被引用的次数</li>
<li><code>sections</code> 表示了模块的段信息，在进行GDB调试时，需要获取这些信息</li>
<li><code>parameters</code> 中包含了模块中定义的参数变量，可以<code>cat</code>出其值</li>
</ul>
</li>
<li>使用 <code>modinfo &lt;module_name&gt;.ko</code> 可以查看模块信息</li>
</ul>
<h1 id="实例模版"><a href="#实例模版" class="headerlink" title="实例模版"></a>实例模版</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * this is a example of kernel module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief 通过编译会在当前目录生成example.ko</span></span><br><span class="line"><span class="comment"> * ### 加载模块</span></span><br><span class="line"><span class="comment"> * 1. 加载模块时使用命令   insmod ./example.ko(加载模块位于 /sys/module/ 目录 ，并且会创建一个和模块名一样的目录，目录下具有模块对应的信息)</span></span><br><span class="line"><span class="comment"> * 2. 也可以使用&quot;modprobe&quot;命令加载，此命令会同时加载其该模块所依赖的模块, 模块之间的依赖关系位于 /lib/modules/&lt;kernel-version&gt;/modules.dep 文件中</span></span><br><span class="line"><span class="comment"> * 3. 在本模块代码中,可以使用&quot;request_module(module_name)&quot;动态加载其他模块</span></span><br><span class="line"><span class="comment"> * 4. 查看内核输出的文件: /var/log/kern.log</span></span><br><span class="line"><span class="comment"> * ### 卸载模块</span></span><br><span class="line"><span class="comment"> * 1. 卸载模块时使用命令   rmmod  example</span></span><br><span class="line"><span class="comment"> * 2. 相应的使用 &quot;modprobe -r filename&quot;命令卸载，会同时卸载其依赖的模块</span></span><br><span class="line"><span class="comment"> * ### 模块信息</span></span><br><span class="line"><span class="comment"> * 1. 查看已经加载的模块使用命令 lsmod(此命令实际上是分析文件 /proc/modules )</span></span><br><span class="line"><span class="comment"> * 2. 查看单个模块的信息使用 &quot;modinfo &lt;模块名&gt;&quot;命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief 使用&quot;module_param(参数名, 参数类型, 参数访问权限)&quot;定义一个外部可访问的参数</span></span><br><span class="line"><span class="comment"> * 在模块加载的时候可以为参数设定值&quot; insmod ./example.ko module_name=&#x27;world&#x27;&quot;(*参数赋值前后不能有空格*，多个参数使用空格分隔)</span></span><br><span class="line"><span class="comment"> * 或者在bootloader中在&quot;bootargs&quot;设置&quot;模块名.参数名 = 值&quot;</span></span><br><span class="line"><span class="comment"> * 也可以在设备树中设定</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数类型: byte, short, ushort, int, uint, long, ulong, charp, bool, invbool</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 也可以定义数组&quot;module_param_array(数组名, 数组类型, 长度, 访问权限)&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 模块参数可以在&quot;/sys/module/example/parameters&quot;下查看</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *module_name = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">module_param(module_name, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">1000</span>;</span><br><span class="line">module_param(num, <span class="keyword">int</span>, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 使用&quot;__initdata&quot;标记的变量，内核在初始化完模块后，便释放该变量所占用的内存</span></span><br><span class="line"><span class="comment">//! 同理，只有卸载阶段才使用的变量，可以使用标记&quot;__exitdata&quot;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> hello_data __initdata = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief 使用EXPORT_SYMBOL_GPL(符号名) 导出符号被外部模块使用(符号表位于/proc/kallsyms)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_integar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(add_integar);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_integar</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(sub_integar);</span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * 如果直接编译进内核，此函数放在区段&quot;.init.text&quot;区段</span></span><br><span class="line"><span class="comment"> * 其地址放在 &quot;.initcall.init&quot; 用于初始化调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note: 在初始化后这两个段的内存将会被释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;\n********************\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[Hello world] module initialized! val = &lt;%d&gt;\n&quot;</span>, hello_data);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;module name = %s\n&quot;</span>, module_name);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;module num = %d\n&quot;</span>, num);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;********************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! 初始化成功返回0,失败返回负值(位于&lt;linux/errno.h&gt;),这些值可以被perror()使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @brief 当此模块被编译被内建模块时，此函数将被省略</span></span><br><span class="line"><span class="comment"> * 注意：使用此函数，需要清理掉模块所申请的内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;\n********************\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;[Hello world] module exit!\n&quot;</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;********************\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kcmetercec &lt;kcmeter.cec@gmail.com&gt;&quot;</span>);</span><br><span class="line"><span class="comment">//! 如果没有许可证声明，加载模块时会收到内核被污染警告(Kernel Tainted)</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);<span class="comment">// GPL, GPL v2, GPL and additional rights, Dual BSD/GPL, Dual MPL/GPL</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple example module&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;a simplest module&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;ver1.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="编译-Makefile"><a href="#编译-Makefile" class="headerlink" title="编译(Makefile)"></a>编译(Makefile)</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KVERS = <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line"></span><br><span class="line">obj-m += example.o</span><br><span class="line"><span class="comment">#如果模块包含多个文件 (file1.c,file2.c) 则使用</span></span><br><span class="line"><span class="comment">#obj-m := modulename.o</span></span><br><span class="line"><span class="comment">#modulename-objs := file1.o file2.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用可以得到包含调试信息的模块</span></span><br><span class="line"><span class="comment">#EXTRA_CFLAGS=-g -O0</span></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line"><span class="comment"># -C 后指定了内核的源码目录</span></span><br><span class="line"><span class="comment"># 对于交叉编译，那么就需要首先修改 CC 变量指定编译器，然后再指定源码目录</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(KVERS)</span>/build M=<span class="variable">$(CURDIR)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(KVERS)</span>/build M=<span class="variable">$(CURDIR)</span> clean</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统基本实现</title>
    <url>/2024/09/13/linux_fs_detail/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<p>继续深入理解文件系统的实现。</p>
<span id="more"></span>

<h1 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h1><p>根据前面的了解，可以知道当新建一个文件时，需要修改以下部分：</p>
<ul>
<li>从inode bitmap 中找到空闲位</li>
<li>从block bitmap 中找到空闲位</li>
<li>填充此新文件的数据内容到block中</li>
<li>填充此新文件的inode内容到inode table中</li>
<li>在包含此文件的目录的block中增加新文件的条目<ul>
<li>如果已经超过了一个block，则还需要申请新block并填充</li>
</ul>
</li>
<li>更新目录的inode内容</li>
<li>更新superblock的inode和block记录信息</li>
</ul>
<p>以上这么多步操作显然就不是原子性的，如果在操作过程中系统崩溃或者硬件掉电，都会造成元数据和数据不一致的问题。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">这里其实还有会安全性的问题，因为文件系统在删除一个文件时，</span><br><span class="line">为了提高处理速度一般是不会去真的删除block中的内容的，一般是直接删除其元数据即可。</span><br><span class="line"></span><br><span class="line">那么当为一个文件增加一个block时，如果在写完元数据后真正的block还没有被写入时发生了掉电，</span><br><span class="line">那么下次启动时，这个文件下一个block的内容其实是上次被删除文件的内容!</span><br></pre></td></tr></table></figure>

<h2 id="实例模拟掉电过程"><a href="#实例模拟掉电过程" class="headerlink" title="实例模拟掉电过程"></a>实例模拟掉电过程</h2><h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个虚拟硬盘</span></span><br><span class="line">dd if=/dev/zero of=image bs=4096 count=1024</span><br><span class="line"><span class="meta">#</span><span class="bash">格式化</span></span><br><span class="line">mkfs.ext4 -b 4096 image</span><br></pre></td></tr></table></figure>

<h3 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看super block 的具体描述</span></span><br><span class="line">dumpe2fs image</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">First inode:              11</span></span><br><span class="line"><span class="meta">#</span><span class="bash">...</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Block bitmap at 2 (+2), Inode bitmap at 18 (+18)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Inode table at 34-65 (+34)</span></span><br></pre></td></tr></table></figure>

<p>由上面输出可以看到其 inode bitmap 起始块为18，block bitmap 起始块为2，inode table 起始块为34</p>
<ul>
<li>查看bitmap内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-C 以16进制显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-n 32 只显示前32个数</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure>

<p>可以看到其输出的 bitmap，前面的 <code>ff 07</code> 正好是11位，和前面的 <code>First inode: 11</code> 遥相呼应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000  ff 07 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure>

<h3 id="增加文件再次查看元数据"><a href="#增加文件再次查看元数据" class="headerlink" title="增加文件再次查看元数据"></a>增加文件再次查看元数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir hello</span><br><span class="line"><span class="meta">#</span><span class="bash">文件模拟的硬盘需要 <span class="string">&quot;-o loop&quot;</span> 命令</span></span><br><span class="line">mount -o loop image hello</span><br><span class="line"><span class="meta">#</span><span class="bash">新建文件</span></span><br><span class="line">cd hello</span><br><span class="line">echo &quot;hello&quot; &gt; world</span><br><span class="line"><span class="meta">#</span><span class="bash">再次查看inode bitmap</span></span><br><span class="line">cd ../</span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure>

<p>查看其输出，发现第12位被置位了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00000000  ff 0f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure>

<h3 id="破坏inode-bitmap"><a href="#破坏inode-bitmap" class="headerlink" title="破坏inode bitmap"></a>破坏inode bitmap</h3><p>下面再来将其12位清零，以造成数据不一致的错误。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先卸载挂载</span></span><br><span class="line">umount hello</span><br><span class="line">vim image</span><br><span class="line"><span class="meta">#</span><span class="bash">转为16进制显示</span></span><br><span class="line"><span class="meta">#</span><span class="bash">:%!xxd</span></span><br><span class="line"><span class="meta">#</span><span class="bash">计算其inode bitmap起始地址为 0x12000</span></span><br><span class="line"><span class="meta">#</span><span class="bash">修改对应 0f 为 07</span></span><br><span class="line"><span class="meta">#</span><span class="bash">保存后还原为二进制</span></span><br><span class="line"><span class="meta">#</span><span class="bash">:%!xxd -r</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br></pre></td></tr></table></figure>

<p>通过以上操作可以发现其12位已经被清零了，并且此时使用 <code>fsck.ext4 image</code> 并无法检查出此错误。</p>
<p>重新 <code>mount</code> 依然可以看到文件的inode还是12（因为此记录依然保存在文件夹的block中）。</p>
<p>但如果此时再新建一个文件，便会报错 <code>Input/output erro</code> ,此时通过 <code>dmesg</code> 可以看到错误提示。</p>
<p>再次使用 <code>fsck.ext4 image</code> 即可检查出问题并修复</p>
<h3 id="破坏block-bitmap"><a href="#破坏block-bitmap" class="headerlink" title="破坏block bitmap"></a>破坏block bitmap</h3><p>再次使用 <code>dumpe2fs image</code> 查看其super block:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Group 0: (Blocks 0-1023) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0xf4d9, unused inodes 1012</span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-1</span><br><span class="line">  Block bitmap at 2 (+2), Inode bitmap at 18 (+18)</span><br><span class="line">  Inode table at 34-65 (+34)</span><br><span class="line">  981 free blocks, 1012 free inodes, 2 directories, 1012 unused inodes</span><br><span class="line">  Free blocks: 8-17, 20-33, 67-1023</span><br><span class="line">  Free inodes: 13-1024</span><br></pre></td></tr></table></figure>

<p>通过其free blocks 输出，猜测其block bitmap 的前9字节应该是(小端模式16进制): ff 00 0c 00 fc ff ff ff 07</p>
<p>然后通过 <code>dd if=image bs=4096 skip=2 | hexdump -C -n 32</code> 来查看输出，果然如此。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">00000000  ff 00 0c 00 fc ff ff ff  07 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000020</span><br></pre></td></tr></table></figure>

<p>新建文件然后查看其block bitmap:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -o loop image hello/</span><br><span class="line">echo &quot;haha&quot; &gt; hello/123</span><br><span class="line">dd if=image bs=4096 skip=2 | hexdump -C -n 32</span><br><span class="line"><span class="meta">#</span><span class="bash">00000000  ff 00 0c 00 <span class="built_in">fc</span> ff ff ff  0f 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000020</span></span><br><span class="line">dd if=image bs=4096 skip=18 | hexdump -C -n 32</span><br><span class="line"><span class="meta">#</span><span class="bash">00000000  ff 1f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span></span><br><span class="line"><span class="meta">#</span><span class="bash">00000020</span></span><br></pre></td></tr></table></figure>

<p>然后按照之前类似步骤将 block bitmap的 <code>0f</code> 修改为 <code>07</code> , 如果此时再来新建文件却并不会报错。<br>然后通过 <code>fsck.ext4 image</code> 可以检测block bitmap错误，但同时新建文件的内容则为空。</p>
<h3 id="fsck-缺点"><a href="#fsck-缺点" class="headerlink" title="fsck 缺点"></a>fsck 缺点</h3><p>fsck 由于是进行全部元数据的对比扫描所以及执行速度比较慢，转而的替代方案则是日志文件系统。</p>
<h2 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由上面的掉电过程可以知道：在操作文件系统的任何时刻掉电都会造成数据不一致的问题，<br>而如果在检查文件系统时通过遍历的方法显然是低效的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了提高操作效率，我们完全可以将文件系统的操作过程来做一次记录，那么下次就可以直接检查最后一次记录的完整性：</p>
<ul>
<li>如果记录完整则代表上层操作已操作完毕</li>
<li>如果不完整则根据最后一次记录的进度，要么将此次操作撤销，要么主动完成此次操作。</li>
</ul>
<p>transaction(事务): 保证数据操作一致性</p>
<p>日志文件系统就以 transaction 为基础，来记录对文件系统的操作，其日志分4个阶段：</p>
<ol>
<li>journal write: 将要对文件系统的操作步骤写入 transaction </li>
<li>journal commit: 将此 transaction 写入存储日志内容的block中</li>
<li>checkpoint: 此步才是真正来执行文件系统的操作</li>
<li>Free： 此步若完成，则更新日志的 superblock以表示完成，并释放 transaction 在block中的空间</li>
</ol>
<p>分析以上步骤：</p>
<ul>
<li>假设在 jounral write 或 jounral commit 步骤掉电了，那么对日志来说用户什么都没有做</li>
<li>假设在 checkpoint 步骤中掉电了，那么日志已经记录了此操作，但用户真正操作还没有完成，那将由日志来主动完成。</li>
</ul>
<p>所以对文件系统的一致性就简化为两种状态：</p>
<ul>
<li>要么什么都没有做</li>
<li>要么没有做完，那么从新做一次</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的日志系统的transaction是要保存文件系统操作的每个步骤，那在对block的操作中所消耗的空间和时间都比较大，<br>为了能够提高效率，可以仅需要对其元数据做 transaction 即可。</p>
<p>进而演化出了 Metadata 日志阶段：</p>
<ol>
<li>Data write : 写文件数据到block<ul>
<li>此部分有几个选项 data=writeback,data=ordered<ul>
<li>writeback: 不用等待此步骤完成，而是并行的开始后面的步骤</li>
<li>ordered: 需要等待此步骤完成才能进行后面的步骤</li>
</ul>
</li>
</ul>
</li>
<li>Journal metadata write: 将要操作的文件的元数据过程写入到transaction</li>
<li>Journal commit: 将此transaction 写入存储日志内容的block中</li>
<li>checkpoint metadata: 真正执行文件的元数据操作</li>
<li>Free: 更新日志superblock 并释放transaction 在block中的空间</li>
</ol>
<p>分析以上步骤：</p>
<ul>
<li>当以 ordered 形式操作，如果在commit以以前的步骤掉电了则就等于什么都没有做</li>
<li>当以writeback形式操作，则可能出现 metadata已经checkpoint，但block还未写完的现象</li>
</ul>
<p>在实际格式化磁盘时，就可以给文件系统选项以让日志工作在什么模式：</p>
<ul>
<li><code>data=journal</code> : 传统日志方式，所有操作都做日志</li>
<li><code>data=ordered</code> : 等待block写完</li>
<li><code>data=writeback</code> : 并行写block和日志</li>
</ul>
<h2 id="COW-读拷贝更新-文件系统"><a href="#COW-读拷贝更新-文件系统" class="headerlink" title="COW(读拷贝更新)文件系统"></a>COW(读拷贝更新)文件系统</h2><p>COW的基本思路是：在更改磁盘时，先对要更改的对象创造一个副本，然后去修改这个副本。<br>当副本操作完成后，将副本与之前的节点链接起来为一个新树，最后再将superblock 指向新树的树顶。</p>
<p>由于 <strong>最后的superblock指针的操作</strong> 是原子性的，所以这种文件系统也只有两种状态：</p>
<ol>
<li>在指针操作之前断电，那相当于什么都没有发生，依然使用之前的树</li>
<li>在指针操作后断电，所有操作也都完成了，使用新树</li>
</ol>
<p>这种操作系统就不需要日志系统了。</p>
<p>Btrfs就是使用这种技术的文件系统：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_detail/Btrfs.jpg?raw=true"></p>
<h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><ul>
<li>格式化并挂载</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//申请的磁盘空间不能太小，否则会出现警告 &quot;no space to alloc data/metadata chunk&quot;</span><br><span class="line">dd if=/dev/zero of=image bs=4096 count=102400</span><br><span class="line">mkfs.btrfs image</span><br><span class="line">mkdir hello</span><br><span class="line">mount -o loop image hello</span><br></pre></td></tr></table></figure>

<ul>
<li>创建当前文件系统的快照和子卷<ul>
<li>快照相当于对当前文件系统做了一个备份。</li>
<li>子卷相当于做了一个小分区</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hello</span><br><span class="line">echo &quot;Hello world&quot; &gt; hello</span><br><span class="line"><span class="meta">#</span><span class="bash">为当前文件创建一个名为 snapshot1 的快照</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此时snapshot1 中的内容和当前目录一样，但其实是指针指向了同一个树，并没有复制内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当文件系统根目录修改时，它会为止使用COW技术来生成一个新的树。</span></span><br><span class="line">btrfs subvolume snapshot . snapshot1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个名为 sub1 的子卷</span></span><br><span class="line">btrfs subvolume create sub1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看文件系统子卷信息</span></span><br><span class="line">btrfs subvolume list .</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">ID 256 gen 9 top level 5 path snapshot1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ID 257 gen 13 top level 5 path sub1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>直接挂载子卷的内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ../</span><br><span class="line">umount hello</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">根据前面的ID号来mount子卷</span></span><br><span class="line">mount image -o subvolid=257 hello</span><br></pre></td></tr></table></figure>

<h1 id="文件系统inode和block互查"><a href="#文件系统inode和block互查" class="headerlink" title="文件系统inode和block互查"></a>文件系统inode和block互查</h1><h2 id="通过文件查看其inode内容"><a href="#通过文件查看其inode内容" class="headerlink" title="通过文件查看其inode内容"></a>通过文件查看其inode内容</h2><ul>
<li>使用命令 <code>stat &lt;file_name&gt;</code> 来查看简易版的inode</li>
<li>使用命令 <code>debugfs</code> 来查看文件详细的inode内容：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file_path 绝对文件路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device_partition 设备分区路径</span></span><br><span class="line">debugfs -R &#x27;stat &lt;file_path&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure>

<p>比如在之前的 <code>simplefs</code> 中查看 <code>simple.c</code> 的 inode : </p>
<ul>
<li>debugfs -R ‘stat /home/baohua/github/simplefs-master/simple.c’ /dev/sda1</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">inode号        档案类型         权限</span></span><br><span class="line">Inode: 441161   Type: regular    Mode:  0664   Flags: 0x80000</span><br><span class="line">Generation: 2565248354    Version: 0x00000000:00000001</span><br><span class="line"><span class="meta">#</span><span class="bash">user id      group id        文件内容大小</span></span><br><span class="line">User:  1000   Group:  1000   Size: 27049</span><br><span class="line">File ACL: 0    Directory ACL: 0</span><br><span class="line"><span class="meta">#</span><span class="bash">链接数</span></span><br><span class="line">Links: 1   Blockcount: 56</span><br><span class="line">Fragment:  Address: 0    Number: 0    Size: 0</span><br><span class="line"><span class="meta">#</span><span class="bash">使用 <span class="built_in">stat</span> &lt;file_name&gt; 来显示文件所有相关时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash">最后改变文件属性的时间</span></span><br><span class="line"> ctime: 0x5afce24b:a4380e4c -- Thu May 17 10:00:43 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">最后访问时间</span></span><br><span class="line"> atime: 0x5afce251:0dda0cac -- Thu May 17 10:00:49 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">最后修改文件内容的时间，命令 ls -al 默认显示此时间</span></span><br><span class="line"> mtime: 0x5afce24b:a3be0bec -- Thu May 17 10:00:43 2018</span><br><span class="line"><span class="meta">#</span><span class="bash">创建时间</span></span><br><span class="line">crtime: 0x5afce24b:a3be0bec -- Thu May 17 10:00:43 2018</span><br><span class="line">Size of extra inode fields: 28</span><br><span class="line">EXTENTS:#block 位置</span><br><span class="line">(0-6):1537640-1537646</span><br></pre></td></tr></table></figure>

<h2 id="根据-block-查看其inode"><a href="#根据-block-查看其inode" class="headerlink" title="根据 block 查看其inode"></a>根据 block 查看其inode</h2><p>同样通过 <code>debugfs</code> 可以反算出inode号:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">debugfs -R &#x27;icheck &lt;block_num&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure>

<p>继续上面的例子(block号取其中任意一个都可以算出其inode)：</p>
<ul>
<li>debugfs -R ‘icheck 1537640’ /dev/sda1<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">debugfs 1.42.9 (4-Feb-2014)</span><br><span class="line">Block    Inode number</span><br><span class="line">1537640    441161</span><br></pre></td></tr></table></figure></li>
</ul>
<p>继续通过 inode 得出其文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">debugfs -R &#x27;ncheck &lt;inode_num&gt;&#x27; &lt;device_partition&gt;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">debugfs 1.42.9 (4-Feb-2014)</span><br><span class="line">Inode    Pathname</span><br><span class="line">441161    /home/baohua/github/simplefs-master/simple.c</span><br></pre></td></tr></table></figure>

<h2 id="低级方式查看block中的内容"><a href="#低级方式查看block中的内容" class="headerlink" title="低级方式查看block中的内容"></a>低级方式查看block中的内容</h2><p>使用 <code>blkcat</code> 来直接读取block中的内容:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blkcat &lt;device_partition&gt; &lt;block_num&gt;</span><br></pre></td></tr></table></figure>

<p>依然以 <code>simple.c</code> 的block <code>1537640</code> 来读取其一部分代码:</p>
<ul>
<li>blkcat /dev/sda1 1537640</li>
</ul>
<p>还可以使用 <code>dd</code> 命令来以扇区为偏移读取block的内容：</p>
<ul>
<li>首先使用 <code>fdisk -l /dev/sda1</code> 来查看磁盘的扇区<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Disk /dev/sda1: 16.6 GB, 16641949696 bytes</span><br><span class="line">255 heads, 63 sectors/track, 2023 cylinders, total 32503808 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x00000000</span><br></pre></td></tr></table></figure>

可以看出其扇区为512字节，当前文件系统的block为4096字节，那么一个block由8个扇区组成。</li>
</ul>
<p>然后可以使用 dd 来查看block的一个扇区:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/sda1 of=sector skip=$((1537640*8)) bs=512c count=1</span><br></pre></td></tr></table></figure>

<p>然后就可以在文件 <code>sector</code> 中查看其一个扇区的内容了。</p>
<p>当要从磁盘最开始查找的话，还需要计算 <code>/dev/sda1</code> 分区的起始扇区，这可以通过 <code>fdisk /dev/sda</code> 使用 <code>p</code> 查看</p>
<p>比如查看当前偏移是2048个扇区，那么命令就可以修改为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/sda1 of=sector skip=$((1537640*8 + 2048)) bs=512c count=1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>fs</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统基本操作</title>
    <url>/2024/09/10/linux_fs_hello/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="编程接口"><a href="#编程接口" class="headerlink" title="编程接口"></a>编程接口</h1><p>此节只列出 Linux 和 c 库操作接口，具体的详细信息还是要找 <code>man</code> 。</p>
<ul>
<li>其实在实际应用中，还是尽量使用标准的 c/c++ 库便于以后移植。</li>
</ul>
<p>需要注意的是：标准的ISOC库的I/O操作默认是带有缓存的，也就是填充一定的缓存后才会去调用系统接口。<br>而如果直接使用POSIX标准的系统接口，相当于上层没有做缓存，但实际上 <strong>内核为了尽量批量化的操作I/O，其内部也会做缓存。</strong></p>
<h2 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h2><h3 id="文件的创建"><a href="#文件的创建" class="headerlink" title="文件的创建"></a>文件的创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 设置文件在创建时需要去掉的权限</span></span><br><span class="line"><span class="comment">  * @note : 此设置仅影响此进程的umask，不会影响 shell 默认的 umask</span></span><br><span class="line"><span class="comment">  * 使用shell命令 umask </span></span><br><span class="line"><span class="comment">  * 可以查看 shell 设置输出依次为: &lt;special bits&gt;&lt;user&gt;&lt;group&gt;&lt;other&gt; </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">umask</span><span class="params">(<span class="keyword">int</span> newmask)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief 创建文件并设置权限</span></span><br><span class="line"><span class="comment">  * @note 权限与 umask 相与决定最终的权限</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 此函数使用较少，一般使用 open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>mode value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>S_IRUSR</td>
<td>用户可读</td>
</tr>
<tr>
<td>S_IWUSR</td>
<td>用户可写</td>
</tr>
<tr>
<td>S_IXUSR</td>
<td>用户可执行</td>
</tr>
<tr>
<td>S_IRWXU</td>
<td>用户可读、写、执行</td>
</tr>
<tr>
<td>S_IRGRP</td>
<td>组可读</td>
</tr>
<tr>
<td>S_IWGRP</td>
<td>组可写</td>
</tr>
<tr>
<td>S_IXGRP</td>
<td>组可执行</td>
</tr>
<tr>
<td>S_IRWXG</td>
<td>组可读、写、执行</td>
</tr>
<tr>
<td>S_IROTH</td>
<td>其他人可读</td>
</tr>
<tr>
<td>S_IWOTH</td>
<td>其他人可写</td>
</tr>
<tr>
<td>S_IXOTH</td>
<td>其他人可执行</td>
</tr>
<tr>
<td>S_IRWXO</td>
<td>其他人可读、写、执行</td>
</tr>
<tr>
<td>S_ISUID</td>
<td>设置用户执行ID</td>
</tr>
<tr>
<td>S_ISGID</td>
<td>设置组执行ID</td>
</tr>
</tbody></table>
<h3 id="创建及打开"><a href="#创建及打开" class="headerlink" title="创建及打开"></a>创建及打开</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode )</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以flags指定的方式打开 pathname 指定的文件</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> * 1. 当 flags 为 O_CREAT 时，需要指定其 mode</span></span><br><span class="line"><span class="comment"> * 2. 当pathname为相对路径时，可以使用 openat 为其指定一个 dirfd，以此dir为相对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, ...<span class="comment">/*mode_t mode*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>flags value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>只读方式打开</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写方式打开</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>读写方式打开</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>追加方式打开</td>
</tr>
<tr>
<td>O_CREAT</td>
<td>创建</td>
</tr>
<tr>
<td>O_EXCL</td>
<td>如果使用了O_CREATE且文件存在，就会发生错误</td>
</tr>
<tr>
<td>O_NOBLOCK</td>
<td>以非阻塞的方式打开</td>
</tr>
<tr>
<td>O_TRUNC</td>
<td>如果文件存在则删除其内容</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<ul>
<li>在POSIX标准中的标准输入、输出、错误对应的宏依次为 <code>STDIN_FILENO,STDOUT_FILENO,STDERR_FILENO</code> 位于头文件 <code>&lt;unistd.h&gt;</code> 中</li>
</ul>
<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>进行 read 和 write 大量数据读写时，需要考虑单次读写的字节数，取文件系统的block大小(比如4096字节)，能在尽量减小系统调用的同时保证较高的写入效率。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">( <span class="keyword">void</span>          *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">              FILE          *stream )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">( <span class="keyword">const</span> <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">               FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以 whence 为起始移动 offset 字节</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> * 1. 获取当前文件位置使用 currpos = lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"> * 当返回负数代表此文件对象不能做移动操作，比如FIFO，SOCKET</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>whence value</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SEEK_SET</td>
<td>文件开头</td>
</tr>
<tr>
<td>SEEK_CUR</td>
<td>当前位置</td>
</tr>
<tr>
<td>SEEK_END</td>
<td>文件尾</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">( FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> origin )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="截断文件"><a href="#截断文件" class="headerlink" title="截断文件"></a>截断文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief : 从文件末尾到文件头的顺序截断length字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *stream )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><ul>
<li>新建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * ### 文件操作</span></span><br><span class="line"><span class="comment"> * 1. 创建</span></span><br><span class="line"><span class="comment"> * &gt; int create(const char *filename, mode_t mode);</span></span><br><span class="line"><span class="comment"> * &gt; mode 与 umask (mode &amp; umask)共同决定文件的最终权限</span></span><br><span class="line"><span class="comment"> * &gt; int umask(int newmask);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; FILE *fopen(const char *path, const char *mode);</span></span><br><span class="line"><span class="comment"> * &gt; mode --&gt; &quot;r&quot;/&quot;rb&quot;/&quot;w&quot;/&quot;wb&quot;/&quot;a&quot;/&quot;ab&quot;/&quot;r+&quot;/&quot;r+b&quot;/&quot;rb+&quot;/&quot;w+&quot;/&quot;w+b&quot;/&quot;wb+&quot;/&quot;a+&quot;/&quot;a+b&quot;/&quot;ab+&quot;</span></span><br><span class="line"><span class="comment"> * 2. 打开</span></span><br><span class="line"><span class="comment"> * &gt; int open(const char *pathname, int flags);</span></span><br><span class="line"><span class="comment"> * &gt; int open(const char *pathname, int flags, mode_t mode);</span></span><br><span class="line"><span class="comment"> * &gt; flag --&gt; O_RDONLY / O_WRONLY / O_RDWR / O_APPEND / O_CREAT / O_EXEC / O_NOBLOCK / O_TRUNC;</span></span><br><span class="line"><span class="comment"> * &gt; mode --&gt; S_IRUSR / S_IWUSR/ S_IXUSR / S_IRWXU / S_IRGRP / S_IWGRP / S_IXGRP / S_IRWXGRP / S_IROTH / S_IWOTH / S_IXOTH / S_IRWXO / S_ISUID / S_ISGID;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 读写</span></span><br><span class="line"><span class="comment"> * &gt; int read(int fd, const void *buf, size_t length);</span></span><br><span class="line"><span class="comment"> * &gt; int write(int fd, const void *buf, size_t length);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fgetc(FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fputc(int c, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; char *fgets(char *s, int n, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fputs(const char *s, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; int fprintf(FILE *stream, const char *format, ...);</span></span><br><span class="line"><span class="comment"> * &gt; int fscanf(FILE *stream, const char *format, ...);</span></span><br><span class="line"><span class="comment"> * &gt; size_t fread(void *ptr, size_t size, size_t n, FILE *stream);</span></span><br><span class="line"><span class="comment"> * &gt; size_t fwrite(const void *ptr, size_t size, size_t n, FILE *stream);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 定位</span></span><br><span class="line"><span class="comment"> * &gt; int lseek(int fd, offset_t offset, int whence);</span></span><br><span class="line"><span class="comment"> * &gt; whence --&gt; SEEK_SET / SEEK_CUR / SEEK_END;</span></span><br><span class="line"><span class="comment"> * &gt; 得到文件长度 lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fgetpos(FILE *stream, fpos_t *pos);</span></span><br><span class="line"><span class="comment"> * &gt; int fsetpos(FILE *stream, const fpos_t *pos);</span></span><br><span class="line"><span class="comment"> * &gt; int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 关闭</span></span><br><span class="line"><span class="comment"> * &gt; int close(int fd);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &gt; int fclose(FILE *stream);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH      (100)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> fd, len;</span><br><span class="line">      <span class="keyword">char</span> str[LENGTH];</span><br><span class="line">      FILE *p_fd;</span><br><span class="line"></span><br><span class="line">      fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);</span><br><span class="line">      <span class="keyword">if</span>(fd)</span><br><span class="line">      &#123;</span><br><span class="line">            write(fd, <span class="string">&quot;Hello world&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Hello world&quot;</span>));</span><br><span class="line">            close(fd);</span><br><span class="line">      &#125;</span><br><span class="line">      p_fd = fopen(<span class="string">&quot;hello_lib.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(p_fd)</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="built_in">fputs</span>(<span class="string">&quot;Hello world! ^_^ \n&quot;</span>, p_fd);</span><br><span class="line">            fclose(p_fd);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">      len = read(fd, str, LENGTH);</span><br><span class="line">      str[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">      close(fd);</span><br><span class="line"></span><br><span class="line">      p_fd = fopen(<span class="string">&quot;hello_lib.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      fgets(str, LENGTH, p_fd);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">      fclose(p_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个进程打开同一个文件"><a href="#多个进程打开同一个文件" class="headerlink" title="多个进程打开同一个文件"></a>多个进程打开同一个文件</h2><p>多个进程打开同一个文件时，每个进程的 <code>task_struct</code> 都会包含此文件的资源描述，但是最终它们都是指向同一个 <code>inode</code> 。</p>
<ul>
<li>每个文件资源描述都包含对该文件的操作状态，位置偏移等信息</li>
<li>当进行 <code>lseek</code> 这种操作时，如果没有造成文件的扩大，其实是直接操作的资源描述结构体，而没有去操作inode。</li>
</ul>
<h3 id="互斥操作"><a href="#互斥操作" class="headerlink" title="互斥操作"></a>互斥操作</h3><p>如果有多个进程在操作同一个文件，则很有可能会造成竞态，有以下方式来避免此问题的发生：</p>
<ul>
<li>pread , pwrite</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief : 在文件为起始的 offset 字节处开始读或者写</span></span><br><span class="line"><span class="comment"> * @note :</span></span><br><span class="line"><span class="comment"> * 1. 这两个函数的操作是原子性的</span></span><br><span class="line"><span class="comment"> * 2. 此函数并不会改变对应进程本身所保存的 offset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文件索引的复制"><a href="#文件索引的复制" class="headerlink" title="文件索引的复制"></a>文件索引的复制</h2><p>使用以下函数可以完成文件索引的复制(也就是两个不同的索引指向同一个文件描述资源，它们具有联动的偏移位置)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="主动写回数据到硬盘"><a href="#主动写回数据到硬盘" class="headerlink" title="主动写回数据到硬盘"></a>主动写回数据到硬盘</h2><p>一般的文件读写数据都会被存在 page cache 中，待内核在合适的时间写入硬盘，为了强制同步，可以使用下面函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以阻塞的方式等待某个文件同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 以阻塞的方式同步文件数据，文件的元数据不一定会同步</span></span><br><span class="line"><span class="comment"> * @note : 只有一些重要的修改才会同步元数据，比如文件大小改变了</span></span><br><span class="line"><span class="comment"> * 但文件的方式文件改变了，是不会同步元数据的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给内核发送同步消息，并不会等待内核操作完成</span></span><br><span class="line"><span class="comment"> * @note shell 中的 sync 命令 也是调用的此函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文件运行时控制"><a href="#文件运行时控制" class="headerlink" title="文件运行时控制"></a>文件运行时控制</h2><p>当一个文件已经打开，要修改它的一些属性时，可以使用函数 <code>fcntl</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数具有以下用途：</p>
<ol>
<li>生成一个文件描述符的副本</li>
<li>获取或设置文件描述符标记</li>
<li>获取或设置文件状态</li>
<li>获取或设置文件拥有者关系</li>
<li>获取或设置文件锁</li>
</ol>
<p><strong>需要注意的是：</strong> 当要修改某个文件状态时，应该像操作寄存器位那样通过 <code>读-修改-写</code> 的方式操作（也就是先读取当前设置值，然后写入新设置的那一位，再回写回去）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./test&quot;</span>, O_CREAT | O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open file failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((status = fcntl(fd, F_GETFL, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not get file status:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> close_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(status &amp; O_ACCMODE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read only\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write only\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> O_RDWR:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read write\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can not get file mode!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_APPEND)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;append\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_NONBLOCK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;nonblocking\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(status &amp; O_SYNC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;synchronous writes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close_out:</span><br><span class="line">    close(fd);</span><br><span class="line">    remove(<span class="string">&quot;./test&quot;</span>);</span><br><span class="line">quick_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外的一个控制函数便是 <code>ioctl</code> ，这个在驱动的操作中经常使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="文件的权限与属性"><a href="#文件的权限与属性" class="headerlink" title="文件的权限与属性"></a>文件的权限与属性</h2><h3 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h3><p>平时使用最多的 shell 命令 <code>ls -al</code> 就是提取的文件属性来显示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* file type */</span></span><br><span class="line">    <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">    <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">    <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="keyword">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">      precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">      For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取文件的属性并存储于结构 stat 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//如果文件是符号链接，那么获取被链接文件的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//获取已打开文件的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="comment">//如果文件是符号链接，那么获取该符号链接的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据用户指定的 dirfd 和提供的路径 pathname 来获取文件属性，</span></span><br><span class="line"><span class="comment">//flags 用于控制是否读取符号链接本身</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 也可以使用下面的函数修改时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimes</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lutimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct timeval tv[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>如下代码所示，使用 lstat 来判断文件类型:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: ./a.out &lt;file_path&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lstat(argv[<span class="number">1</span>], &amp;file_stat) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not get file status:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The file type is : &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;regular file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;directory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISCHR(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;character device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISBLK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISFIFO(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FIFO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISLNK(file_stat.st_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;symbolic link&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;unknown!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">quick_out:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作文件的权限"><a href="#操作文件的权限" class="headerlink" title="操作文件的权限"></a>操作文件的权限</h3><p>与操作文件相关的 ID 具有下面几类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>真实用户ID和真实组ID</td>
<td>表示当前是哪个用户位于哪个组正在访问此文件</td>
</tr>
<tr>
<td>有效用户ID，有效组ID和补充组ID</td>
<td>表示该文件允许的用户和组(在没有suid,sgid的情况下，此值与真实用户和真实组ID是一个值)</td>
</tr>
<tr>
<td>suid</td>
<td>当文件user的可执行权限打开并设置了suid后，其他用户可以以该文件所有者的权限来运行此文件</td>
</tr>
<tr>
<td>sgid</td>
<td>当文件group的可执行权限打开并设置了sgid后，其他用户可以以该文件组成员的权限来运行此文件</td>
</tr>
</tbody></table>
<ul>
<li>对于权限方面还有一个(sticky bit):当文件other的可执行权限打开并设置了sticky后，用户都可以在此文件夹下新建文件和文件夹(类似于共享文件夹)<ul>
<li>但用户不能删除其他用户所新建的文件或文件夹</li>
</ul>
</li>
<li>对于普通权限 <code>rwx</code> 不得不提的是：<ul>
<li>要进入基本的目录，至少要具有 <code>x</code> 权限，要读取目录内容列表信息，至少要具有 <code>rx</code> 权限。</li>
<li>对一个文件是否具有新建或删除的权限，要看用户对此目录是否具有 <code>rw</code> 权限。<ul>
<li>这与文件自身的权限无关， <strong>自身权限只关联其内容的操作权限</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以使用下面的函数来判断当前进程是否有权限访问某个文件:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改文件权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//改变用户id和组id</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>  每增加一个硬链接，文件的链接数量加1，以表示有多少个文件引用到同一个inode.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>  每取消一个硬链接，文件的链接数量减1，当一个文件的链接数量减至0 <strong>并且没有进程打开此文件时</strong> ，文件既被删除。</p>
<ul>
<li>当有进程打开了文件，那么当进程退出或关闭文件时，内核检查引用计数为0，才删除文件。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">//移除文件时，与 unlink 一致，移除文件夹时，与 rmdir 一致</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><ul>
<li>创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取符号链接本身内容(可以看到其block内容为其引用文件路径)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat2</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="文件系统与设备驱动-include-linux-fs-h"><a href="#文件系统与设备驱动-include-linux-fs-h" class="headerlink" title="文件系统与设备驱动(include/linux/fs.h)"></a>文件系统与设备驱动(include/linux/fs.h)</h1><p>在设备驱动中，会关心 file 和 inode 这两个结构体。</p>
<ul>
<li>每打开一个文件，在内核空间中就有与之关联的 file 结构体<ul>
<li>设备驱动通过此结构体判断用户操作模式(比如是阻塞还是非阻塞等)<ul>
<li>判断阻塞还是非阻塞使用 <code>f_flags</code> </li>
</ul>
</li>
<li><code>private_data</code> 保存该设备驱动申请的数据地址</li>
</ul>
</li>
<li>inode 则包含了一个文件的详细信息，比如权限、生成时间、访问时间、最后修改时间等</li>
</ul>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>    <span class="title">f_llist</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">f_rcuhead</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_iocb_flags;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>        <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>    <span class="comment">/* cached value */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span> <span class="comment">// 和文件关联的操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Protects f_ep, f_flags.</span></span><br><span class="line"><span class="comment">     * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        f_lock;</span><br><span class="line">    <span class="keyword">atomic_long_t</span>        f_count;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>         f_flags; <span class="comment">// 文件标志，如 O_RDONLY、O_NONBLOCK </span></span><br><span class="line">    <span class="keyword">fmode_t</span>            f_mode;<span class="comment">// 文件读/写模式，FMODE_READ 和 FMODE_WRITE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">f_pos_lock</span>;</span></span><br><span class="line">    <span class="keyword">loff_t</span>            f_pos; <span class="comment">// 当前读写的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>    <span class="title">f_owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">    u64            f_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>            *f_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">    <span class="keyword">void</span>            *private_data; <span class="comment">// 文件私有数据</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    *<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span></span><br><span class="line">    <span class="keyword">errseq_t</span>        f_wb_err;</span><br><span class="line">    <span class="keyword">errseq_t</span>        f_sb_err; <span class="comment">/* for syncfs */</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));    <span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>

<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> * of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">umode_t</span>            i_mode; <span class="comment">// inode 权限</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        i_opflags;</span><br><span class="line">    <span class="keyword">kuid_t</span>            i_uid; <span class="comment">// inode 拥有者 id</span></span><br><span class="line">    <span class="keyword">kgid_t</span>            i_gid; <span class="comment">// inode 所属群组 id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="keyword">void</span>            *i_security;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_ino;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">dev_t</span>            i_rdev; <span class="comment">// 若是设备文件，此字段记录设备的设备号</span></span><br><span class="line">    <span class="keyword">loff_t</span>            i_size; <span class="comment">// inode 所代表的文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_atime</span>;</span> <span class="comment">// 最近一次的存取时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_mtime</span>;</span> <span class="comment">// 最近一次的修改时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_ctime</span>;</span> <span class="comment">// inode 的产生时间</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        i_lock;    <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>          i_bytes;</span><br><span class="line">    u8            i_blkbits;</span><br><span class="line">    u8            i_write_hint;</span><br><span class="line">    <span class="keyword">blkcnt_t</span>        i_blocks; <span class="comment">// inode 所使用的 block 数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="keyword">seqcount_t</span>        i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>    <span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        dirtied_when;    <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        dirtied_time_when;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_io_list</span>;</span>    <span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>    *<span class="title">i_wb</span>;</span>        <span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">    <span class="keyword">int</span>            i_wb_frn_winner;</span><br><span class="line">    u16            i_wb_frn_avg_time;</span><br><span class="line">    u16            i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>        <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>    <span class="comment">/* backing dev writeback list */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">i_dentry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>        <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">atomic64_t</span>        i_version;</span><br><span class="line">    <span class="keyword">atomic64_t</span>        i_sequence; <span class="comment">/* see futex */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_count;</span><br><span class="line">    <span class="keyword">atomic_t</span>        i_dio_count;</span><br><span class="line">    <span class="keyword">atomic_t</span>        i_writecount;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>    <span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="keyword">void</span> (*free_inode)(struct inode *);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>    *<span class="title">i_flctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>    *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>        *<span class="title">i_cdev</span>;</span> <span class="comment">// 若是字符设备，为其对应的 cdev 结构体指针</span></span><br><span class="line">        <span class="keyword">char</span>            *i_link;</span><br><span class="line">        <span class="keyword">unsigned</span>        i_dir_seq;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32            i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32            i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>    *<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>    *<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span>    *<span class="title">i_verity_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>            *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>i_rdev</code> 表示设备编号，由高12位主设备号和低20位次设备号组成，使用下面的函数获取主次设备号<ul>
<li>主设备号代表同一类设备，次设备号表示使用该设备的实例对象</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORBITS    20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINORMASK    ((1U &lt;&lt; MINORBITS) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)    (((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">iminor</span><span class="params">(<span class="keyword">const</span> struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MINOR(inode-&gt;i_rdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">imajor</span><span class="params">(<span class="keyword">const</span> struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAJOR(inode-&gt;i_rdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以在 <code>/proc/devices</code> 中得到注册设备的主设备号和设备名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/devices</span><br></pre></td></tr></table></figure>

<ul>
<li>可以在 <code>/dev/</code> 下得到注册设备的主次设备号</li>
</ul>
<h1 id="udev-用户空间设备管理"><a href="#udev-用户空间设备管理" class="headerlink" title="udev 用户空间设备管理"></a>udev 用户空间设备管理</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Linux设计中强调的一个基本观点是机制和策略分离。</span><br><span class="line">机制是做某样事情的固定步骤、方法，而策略是每一个步骤所采取的不同方式。</span><br><span class="line">机制是固定的，而每个步骤采用的策略是不固定的。机制是稳定的，而策略是灵活的。</span><br><span class="line">因此，在Linux内核中，不应该实现策略。</span><br></pre></td></tr></table></figure>

<p>udev完全在用户态工作，利用设备加入或移出时内核所发送的热拔插事件(Hotplug Event)来工作。<br>在热拔插时，设备的详细信息会由内核通过netlink套接字发送出来，发出的事件叫uevent。<br>udev的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用从内核收到的信息来进行创建设备文件节点等工作。</p>
<p>udev的工作过程：</p>
<ol>
<li>当内核检测到系统中出现了新设备后，内核会通过netlink套接字发送uevent</li>
<li>udev获取内核发送的信息，进行规则的匹配。匹配的事物包括SUBSYSTEM、ACTION、attribute，内核提供的名称(通过KERNEL=)以及其他的环境变量</li>
</ol>
<p>使用下面的代码就可以接收 netlink 消息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_nl</span> <span class="title">nls</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;nls, <span class="number">0</span>, <span class="keyword">sizeof</span>(nls));</span><br><span class="line"></span><br><span class="line">    nls.nl_family = AF_NETLINK;</span><br><span class="line">    nls.nl_pid = getpid();</span><br><span class="line">    nls.nl_groups = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pfd.events = POLLIN;</span><br><span class="line">    pfd.fd = socket(PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);</span><br><span class="line">    assert(pfd.fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(pfd.fd, (<span class="keyword">void</span> *)&amp;nls, <span class="keyword">sizeof</span>(nls));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (poll(&amp;pfd, <span class="number">1</span>, <span class="number">-1</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(pfd.fd, buf, <span class="keyword">sizeof</span>(buf), MSG_DONTWAIT);</span><br><span class="line">        assert(len != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf + i);</span><br><span class="line">            i += <span class="built_in">strlen</span>(buf + i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要让内核主动发出一次 uevent，则可以对 <code>/sys/module</code> 中的模块主动写 <code>add</code> 命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo add &gt; /sys/module/psmouse/uevent</span><br></pre></td></tr></table></figure>

<p>会输出类似以下的消息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add@/module/psmouse</span><br><span class="line">ACTION=add</span><br><span class="line">DEVPATH=/module/psmouse</span><br><span class="line">SUBSYSTEM=module</span><br><span class="line">SYNTH_UUID=0</span><br><span class="line">SEQNUM=739</span><br></pre></td></tr></table></figure>

<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs是内核设备模型的一个全局概览，此目录下的多个顶层文件是站在不同的角度来查看设备模型的：</p>
<ul>
<li><code>bus</code> 是以总线的视角来看待。<ul>
<li>首先，总线有很多种类型，所以在bus目录下会有多个代表不同总线类型的文件</li>
<li>其次，每种总线相对应的就包含设备和驱动，所以就会有 <code>devices,drivers</code> 文件夹<ul>
<li>设备下的文件是 <code>/sys/devices</code> 中文件的符号链接</li>
</ul>
</li>
</ul>
</li>
<li><code>devices</code> 是以设备的视角看待<ul>
<li>首先，设备是以层级的方式拓扑的，所以目录也是以此层级进行排列的</li>
<li>其次，当设备与驱动匹配以后，对应设备目录就会有 <code>driver</code> 目录</li>
</ul>
</li>
<li><code>class</code> 是以设备种类的视角看待设备<ul>
<li>此目录下都是以种类区分各种设备</li>
<li>设备下的文件是 <code>/sys/devices</code> 中文件的符号链接</li>
</ul>
</li>
<li><code>block</code> 是单独列出块设备文件</li>
<li><code>dev</code> 是块设备和字符设备文件</li>
</ul>
<p>在代码实现中，分别使用 <code>bus_type,device_driver,device</code> 来描述总线、驱动和设备:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *dev_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>        *<span class="title">dev_root</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">bus_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">drv_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    <span class="keyword">int</span> (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*remove)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*online)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*num_vf)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*dma_configure)(struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*dma_cleanup)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iommu_ops</span> *<span class="title">iommu_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">subsys_private</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> need_parent_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>        *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>        *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *mod_name;    <span class="comment">/* used for built-in modules */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> suppress_bind_attrs;    <span class="comment">/* disables bind/unbind via sysfs */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">probe_type</span> <span class="title">probe_type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span>    *<span class="title">of_match_table</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">acpi_device_id</span>    *<span class="title">acpi_match_table</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*probe) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*sync_state)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*remove) (struct device *dev);</span><br><span class="line">    <span class="keyword">void</span> (*shutdown) (struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*suspend) (struct device *dev, <span class="keyword">pm_message_t</span> state);</span><br><span class="line">    <span class="keyword">int</span> (*resume) (struct device *dev);</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">dev_groups</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_ops</span> *<span class="title">pm</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*coredump) (struct device *dev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">driver_private</span> *<span class="title">p</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>        *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>    *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *init_name; <span class="comment">/* initial name of the device */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>    *<span class="title">bus</span>;</span>        <span class="comment">/* type of bus device is on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>    <span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">                       device */</span></span><br><span class="line">    <span class="keyword">void</span>        *platform_data;    <span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">                       core doesn&#x27;t touch it */</span></span><br><span class="line">    <span class="keyword">void</span>        *driver_data;    <span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">                       dev_set_drvdata/dev_get_drvdata */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>device_driver 和 device 都依附于总线，所以都包含了 <code>bus_type</code> 指针。而 device 又由 driver 驱动，所以它还包含了 <code>device_driver</code> 指针。</p>
<p>设备和驱动都是分开被注册的，总线的<code>match</code>函数来进行对应的匹配，匹配成功后驱动的<code>probe()</code>函数就会被调用。</p>
<p>总线、设备和驱动都会映射在 <code>sysfs</code> 中，其中的目录来源于 <code>bus_type,device_driver,device</code> ，而目录中的文件来源于 <code>attribute</code> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;</span><br><span class="line">    <span class="keyword">umode_t</span>            mode;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">    <span class="keyword">bool</span>            ignore_lockdep:<span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>    *<span class="title">key</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>    <span class="title">skey</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct bus_type *bus, <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct bus_type *bus, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>    <span class="title">attr</span>;</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            <span class="keyword">char</span> *buf);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以上结构，内核提供了快捷的操作宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_PREALLOC(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        __ATTR_PREALLOC(_name, _mode, _show, _store)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_ADMIN_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RW_MODE(_name, 0600)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_ADMIN_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_RO_MODE(_name, 0400)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_WO(_name) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR_WO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ULONG_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_ulong, device_store_ulong), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_INT_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_BOOL_ATTR(_name, _mode, _var) \</span></span><br><span class="line"><span class="meta">    struct dev_ext_attribute dev_attr_##_name = \</span></span><br><span class="line"><span class="meta">        &#123; __ATTR(_name, _mode, device_show_bool, device_store_bool), &amp;(_var) &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name =        \</span></span><br><span class="line"><span class="meta">        __ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_RW(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_RO(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUS_ATTR_WO(_name) \</span></span><br><span class="line"><span class="meta">    struct bus_attribute bus_attr_##_name = __ATTR_WO(_name)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>userspace</category>
        <category>fs</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统结构概览</title>
    <url>/2024/09/08/linux_fs_overview/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<p>复习网站： <a href="http://linux.vbird.org/linux_basic/0230filesystem.php#">鸟哥私房菜</a></p>
<p>重温文件系统(ext)的相关操作并做整理，不然我这尿记性要不了多久又会忘。。。</p>
<span id="more"></span>

<h1 id="文件系统的组成"><a href="#文件系统的组成" class="headerlink" title="文件系统的组成"></a>文件系统的组成</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在Linux中，一个磁盘可以分为多个区，每个区可以格式化为不同的文件系统，<br>最终通过虚拟文件系统VFS将这些抽象给上层统一的函数接口操作。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/vfs_overview.jpg?raw=true"></p>
<ul>
<li>在驱动中，无论是字符设备、块设备、还是其他文件系统，与VFS所接口的都是填充 <code>struct file_operations</code> 结构体</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/vfs_fileoperations.jpg?raw=true"><br>一个ext文件系统的组成部分如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/fs_struct_overview.jpg?raw=true"></p>
<h3 id="Boot-Sector"><a href="#Boot-Sector" class="headerlink" title="Boot Sector"></a>Boot Sector</h3><p>此部分通过MBR跳转过来，用于显示关于此部分系统的启动界面以及引导系统启动，以达到多重启动的目的。 <a href="https://en.wikipedia.org/wiki/Boot_sector">wiki上有很详细的解释</a></p>
<h3 id="Block-Group"><a href="#Block-Group" class="headerlink" title="Block Group"></a>Block Group</h3><p>Block Group 用于将文件系统分为几个块，便于管理。</p>
<h3 id="Superblock"><a href="#Superblock" class="headerlink" title="Superblock"></a>Superblock</h3><p>此部分描述整个文件系统信息，是此分区文件系统的全部概览。 </p>
<p><strong>一个文件系统只能有一个Superblock,其他BlockGroup中可能会具有Superblock的备份，用于备用恢复。</strong></p>
<h3 id="文件系统描述"><a href="#文件系统描述" class="headerlink" title="文件系统描述"></a>文件系统描述</h3><p>此部分是描述当前block group的相关信息。</p>
<h3 id="区块对照表-block-bitmap"><a href="#区块对照表-block-bitmap" class="headerlink" title="区块对照表(block bitmap)"></a>区块对照表(block bitmap)</h3><p>此表用于查询文件系统中的block的使用情况，以反应出block的全局概览。</p>
<h3 id="inode对照表-inode-bitmap"><a href="#inode对照表-inode-bitmap" class="headerlink" title="inode对照表(inode bitmap)"></a>inode对照表(inode bitmap)</h3><p>此表用于查询文件系统中的inode的使用情况，以反应出inode的全局概览。</p>
<h3 id="inode-table"><a href="#inode-table" class="headerlink" title="inode table"></a>inode table</h3><p>用于存储该部分的inode的具体内容，一个文件对应一个inode。</p>
<p>inode用于描述文件权限、群组关系、容量、时间、链接的block等等相关信息，它不包含文件的实际内容。</p>
<p>inode中存储了包含文件内容的block索引，系统可以根据此索引预读文件内容，如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/inode_block_overview.jpg?raw=true"><br>一个inode的大小是有限制的，如果一个文件很大，就会需要很多的block。<br>那么一个inode就无法存储这么多地址，所以文件系统使用一部分block来存储inode，如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/inode_save_block.jpg?raw=true"><br>ext2/3 的inode可以直接寻址的block为12个，间接寻址、双间接寻址、三间接寻址各一个。</p>
<ul>
<li>一个block的地址为4字节，当block为4k时那么它就可以存储1024个block地址</li>
<li>所以一个直接寻址的总共block大小为 <code>12 * 4k = 48k (block_size * num)</code></li>
<li>间接寻址 :<code>1024 * 4k = 4M  [(block_size / 4) ^ 1] * block_size</code></li>
<li>双间接寻址: <code>1024 * 1024 * 4k = 4GB  [(block_size / 4) ^ 2] * block_size</code></li>
<li>三间接寻址为: <code>1024 * 1024 * 1024 * 4k = 4TB [(block_size / 4) ^ 3] * block_size</code></li>
</ul>
<p>ext4在此基础上做了优化:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">本来的ext2/3中inode以1个4字节对应一个block，如果一个文件占用了1000个block，</span><br><span class="line">那对应的inode中需要分配block来对应存储这1000个block的索引。</span><br><span class="line"></span><br><span class="line">但如果这1000个block地址是连续的，那就没有必要一一存储，可以在inode中存储一个结构体</span><br><span class="line">以表示block索引的起始地址和结束地址。这样就大大减少了inode的存储空间。</span><br><span class="line"></span><br><span class="line">也就是说同样大小的文件，ext4中对应inode此文件的inode占用空间更小，</span><br><span class="line">那么ext4中的inode能表示的文件大小范围也更大。</span><br></pre></td></tr></table></figure>

<h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>data block 用于存储文件的实际内容，在格式化的时候一个block的大小就规定好了，此为最小的存储单位。<br>也就是说当一个文件内容不足一个block也会占用一个block。</p>
<h2 id="superblock-查看与理解"><a href="#superblock-查看与理解" class="headerlink" title="superblock 查看与理解"></a>superblock 查看与理解</h2><ul>
<li>首先使用命令 <code>sudo blkid</code> 查看当前已经被格式化过的且已挂载的分区以及对应的文件系统</li>
<li>然后使用命令 <code>sudo dumpe2fs -h &lt;partition&gt;</code> 用于查看文件系统的全局概览。<ul>
<li>当不加 h 选项时还会输出 block group 的信息。<br>通过下面这个输出就可以看出一个 superblock 中可以看到的文件系统信息：</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">文件系统名称</span></span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">上一次的挂载点</span></span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          db4b4bdb-ebff-4928-b154-786622f8438f</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line"><span class="meta">#</span><span class="bash">文件系统特征</span></span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line"><span class="meta">#</span><span class="bash">默认挂载选项</span></span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line"><span class="meta">#</span><span class="bash">文件系统状态</span></span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line"><span class="meta">#</span><span class="bash">总共的inode数量</span></span><br><span class="line">Inode count:              8126464</span><br><span class="line"><span class="meta">#</span><span class="bash">总共的block数量</span></span><br><span class="line">Block count:              32505600</span><br><span class="line"><span class="meta">#</span><span class="bash">保留的block数量</span></span><br><span class="line">Reserved block count:     1625280</span><br><span class="line"><span class="meta">#</span><span class="bash">还剩余多少blocks和inodes可用</span></span><br><span class="line">Free blocks:              28442724</span><br><span class="line">Free inodes:              7560146</span><br><span class="line"><span class="meta">#</span><span class="bash">第一个block的起始索引</span></span><br><span class="line">First block:              0</span><br><span class="line"><span class="meta">#</span><span class="bash">block 大小</span></span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Reserved GDT blocks:      1016</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group的block数量</span></span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group的inode数量</span></span><br><span class="line">Inodes per group:         8192</span><br><span class="line"><span class="meta">#</span><span class="bash">每个group可用多少个block来表示inode</span></span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line"><span class="meta">#</span><span class="bash">时间信息</span></span><br><span class="line">Filesystem created:       Tue Apr 18 22:27:06 2017</span><br><span class="line">Last mount time:          Thu Apr 26 09:20:42 2018</span><br><span class="line">Last write time:          Thu Apr 26 09:20:38 2018</span><br><span class="line">Mount count:              280</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Tue Apr 18 22:27:06 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          137 GB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line"><span class="meta">#</span><span class="bash">inode大小</span></span><br><span class="line">Inode size:               256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line"><span class="meta">#</span><span class="bash">日志系统的inode号码</span></span><br><span class="line">Journal inode:            8</span><br><span class="line">First orphan inode:       3538974</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      7deaec65-123c-4de8-aab7-9ca8dd458823</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke</span><br><span class="line"><span class="meta">#</span><span class="bash">文件日志可用大小</span></span><br><span class="line">Journal size:             128M</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x00042c45</span><br><span class="line">Journal start:            16552</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">第一个group的block索引范围</span></span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]</span><br><span class="line">  Checksum 0x5c5a, unused inodes 8175</span><br><span class="line"><span class="meta">  #</span><span class="bash">主superblock在0号block里面，group描述符在1-8号block里面</span></span><br><span class="line">  Primary superblock at 0, Group descriptors at 1-8</span><br><span class="line">  Reserved GDT blocks at 9-1024</span><br><span class="line"><span class="meta">  #</span><span class="bash">block位图地址与inode位图地址</span></span><br><span class="line">  Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)</span><br><span class="line"><span class="meta">  #</span><span class="bash">Inode Table地址</span></span><br><span class="line">  Inode table at 1057-1568 (+1057)</span><br><span class="line"><span class="meta">  #</span><span class="bash">剩余可用inode和block</span></span><br><span class="line">  22550 free blocks, 8176 free inodes, 2 directories, 8175 unused inodes</span><br><span class="line"><span class="meta">  #</span><span class="bash">具体剩余索引</span></span><br><span class="line">  Free blocks: 9255-9309, 9366-9402, 10310-32767</span><br><span class="line">  Free inodes: 16, 18-8192</span><br></pre></td></tr></table></figure>

<p>上面信息中说每个group有8192个inode可用，其 计算公式为：</p>
<ul>
<li>Inode Table 占用的block数量为 <code>1568 - 1057 + 1 = 512</code></li>
<li>由于一个block大小为4096字节，所以inode table 总共占用 <code>512 * 4096 = 2097152</code> 字节</li>
<li>由于一个inode的大小为256字节，所以一个inode table可用容纳 <code>2097152 / 256 = 8192</code> 个inode</li>
</ul>
<p>根据文件系统的结构来看，可以知道新增一个档案的流程为：</p>
<ol>
<li>确定使用者是否有 wx 权限，有权限才能新增</li>
<li>从inode bitmap 中取出一个空闲的inode号码 ,并将权限写入此inode</li>
<li>从block bitmap 中根据文件大小取出对应个数的block并将文件内容写入block</li>
<li>将文件对应的block号码写入其对应的inode,如果block太多还需要申请更多的block来存储inode</li>
<li>将新写入的inode和block同步到inode bitmap,block bitmap, superblock 中</li>
</ol>
<p>对应的删除一个档案的流程为：</p>
<ol>
<li>确定使用者具有wx权限</li>
<li>将对应的block 和 inode 置为空闲并同步到 inode bitmap , block bitmap ,superblock 中<ul>
<li>这里仅仅是猜测文件系统为了效率是不会实际删除内容的，而是清除其标志即可。待后面分析其代码再回头来梳理</li>
</ul>
</li>
</ol>
<h2 id="目录与文件的关系"><a href="#目录与文件的关系" class="headerlink" title="目录与文件的关系"></a>目录与文件的关系</h2><p>通过inode与block的关系可以知道目录肯定有其自己的inode与block，其block链接至其他的文件，如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/dir2file.jpg?raw=true"></p>
<ul>
<li>使用命令 <code>ls -li</code> 可以列出当前目录下存储文档的inode </li>
</ul>
<p>需要注意的是：inode并不保存文件名，文件名是保存在目录的block中的， <strong>所以文件的读取都是要先经过目录的</strong></p>
<p>其流程为：</p>
<ol>
<li>根据文件系统挂载点得知起始目录的inode</li>
<li>读取目录inode权限确认可以访问对应block中的内容</li>
<li>读取目录block中的内容，并根据文件名匹配到对应的inode</li>
<li>根据文件的inode进行权限确认是否可以访问文件block</li>
<li>读取block中的内容…</li>
</ol>
<h2 id="日志档案系统的作用"><a href="#日志档案系统的作用" class="headerlink" title="日志档案系统的作用"></a>日志档案系统的作用</h2><p>当在文件的增删过程中如果出现意外(比如文件内容已经写入但是inode bitmap, block bitmap, superblock没有得到同步)，<br>这就会出现内容与描述不一致的情况，系统为了还原此描述就需要扫描整个文件系统内容来同步修复，这个效率显然是很低下的。</p>
<p>日志文件系统就是记录文件的修改过程，当出现不一致时系统直接来比对日志即可，这样效率就提高了不少。</p>
<h2 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h2><ul>
<li>通过命令 <code>ls -al /lib/modules/$(uname -r)/kernel/fs</code> 可以看到系统所支持的文件系统种类</li>
<li>通过命令 <code>cat /proc/filesystems</code> 可以查看已经载入到RAM中的文件系统</li>
</ul>
<h1 id="文件系统的操作"><a href="#文件系统的操作" class="headerlink" title="文件系统的操作"></a>文件系统的操作</h1><h2 id="查看目录与硬盘容量"><a href="#查看目录与硬盘容量" class="headerlink" title="查看目录与硬盘容量"></a>查看目录与硬盘容量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出当前系统已经挂载的文件系统，显示其使用率，挂载点等信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash">当只是简单查看时，可以不用加 <span class="string">&#x27;a&#x27;</span> 选项</span></span><br><span class="line">df -aTh</span><br><span class="line"><span class="meta">#</span><span class="bash">显示当前系统中已挂载文件系统inode的使用率</span></span><br><span class="line">df -ih</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出当前目录及其子目录占用总容量</span></span><br><span class="line">du -sh</span><br></pre></td></tr></table></figure>

<h2 id="软链接与硬链接"><a href="#软链接与硬链接" class="headerlink" title="软链接与硬链接"></a>软链接与硬链接</h2><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>软链接：新建一个文件，此文件的内容(block)指向的是被链接的文件名(由被链接文件的目录inode间接找到此文件名)</p>
<ul>
<li>使用 <code>ln -s &lt;src&gt; &lt;dst&gt;</code> 建立软链接</li>
<li>通过 <code>df -i</code> 可以看到 inode数量变化，以及通过 <code>ll -i</code> 可以看到新建文件指向的inode不一致</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/soft_link_overview.jpg?raw=true"><br>软链接优点：</p>
<ol>
<li>可以跨文件系统</li>
<li>可以链接目录<ul>
<li>对链接目录的软链接文件使用 <code>rm -rf soft_link_file</code> <strong>并不会删除对应目录，而仅仅是删除此软链接文件</strong></li>
</ul>
</li>
</ol>
<p>软链接缺点：</p>
<ol>
<li>会新建一个文件从而占用一个 inode和block</li>
<li>被链接的文件在其目录被删除后，无法通过链接文件访问文件内容</li>
</ol>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接：在目录的内容(block)中新建立一个指向被链接文件名的inode的映射关系</p>
<ul>
<li>使用 <code>ln &lt;src&gt; &lt;dst&gt;</code> 建立硬链接</li>
<li>通过 <code>df -i</code> 可以看到 inode数量不变，以及通过 <code>ll -i</code> 可以看到新建文件指向的inode一致,此时inode被链接数也会增加</li>
<li>新建的目录默认链接数是2(包括 “dir” 和 “dir/.”)而上层目录的链接数会加1(因为 “dir/..”) 会指向此目录</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_basic/hard_link_overview.jpg?raw=true"><br>硬链接的优点：</p>
<ol>
<li>仅仅是在目录block中建立映射关系，所以不会消耗更多的inode和block<ul>
<li>除非目录block已经满了，则还需要新增加一个block来存储</li>
</ul>
</li>
<li>当被链接文件在其目录中的对应关系被删除后，在当前文件依然可以访问文件内容</li>
</ol>
<p>硬链接的缺点：</p>
<ol>
<li>不能跨文件系统</li>
<li>不能链接目录</li>
</ol>
<h2 id="分区、格式化、挂载"><a href="#分区、格式化、挂载" class="headerlink" title="分区、格式化、挂载"></a>分区、格式化、挂载</h2><h3 id="查看磁盘分区状态"><a href="#查看磁盘分区状态" class="headerlink" title="查看磁盘分区状态"></a>查看磁盘分区状态</h3><ul>
<li>使用命令 <code>lsblk</code> 可以查看当前系统磁盘以及其分区状态<ul>
<li>使用 <code>-f</code> 选项可以查看对应的UUID</li>
</ul>
</li>
<li>使用命令 <code>parted /dev/xxx print</code> 查看某个磁盘具体分区情况<ul>
<li>其中 <code>Partiton Table</code> 指出了磁盘使用的分割表</li>
</ul>
</li>
</ul>
<h3 id="磁盘分割"><a href="#磁盘分割" class="headerlink" title="磁盘分割"></a>磁盘分割</h3><ul>
<li>使用 <code>fdisk /dev/xxx</code> 对使用MBR分割表的磁盘进行分割</li>
<li>使用 <code>gdisk /dev/xxx</code> 对使用GPT分割表的磁盘进行分割</li>
<li>分割完成后，使用 <code>partprobe -s</code> 来更新分区表</li>
</ul>
<p>嵌入式批量出厂时， 可以在 <code>sed</code> 的帮助下完成自动化的分割，来源于 <a href="https://superuser.com/questions/332252/how-to-create-and-format-a-partition-using-a-bash-script">[wiki上有很详细的解释]</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> to create the partitions programatically (rather than manually)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> we<span class="string">&#x27;re going to simulate the manual input to fdisk</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> The sed script strips off all the comments so that we can</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> document what we&#x27;</span>re doing in-line with the actual commands</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Note that a blank line (commented as <span class="string">&quot;default&quot;</span> will send a empty</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> line terminated with a newline to take the fdisk default.</span></span><br><span class="line">sed -e &#x27;s/\s*\([\+0-9a-zA-Z]*\).*/\1/&#x27; &lt;&lt; EOF | fdisk $&#123;TGTDEV&#125;</span><br><span class="line">  o # clear the in memory partition table</span><br><span class="line">  n # new partition</span><br><span class="line">  p # primary partition</span><br><span class="line">  1 # partition number 1</span><br><span class="line"><span class="meta">  #</span><span class="bash"> default - start at beginning of disk</span></span><br><span class="line">  +100M # 100 MB boot parttion</span><br><span class="line">  n # new partition</span><br><span class="line">  p # primary partition</span><br><span class="line">  2 # partion number 2</span><br><span class="line"><span class="meta">  #</span><span class="bash"> default, start immediately after preceding partition</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> default, extend partition to end of disk</span></span><br><span class="line">  a # make a partition bootable</span><br><span class="line">  1 # bootable partition is partition 1 -- /dev/sda1</span><br><span class="line">  p # print the in-memory partition table</span><br><span class="line">  w # write the partition table</span><br><span class="line">  q # and we&#x27;re done</span><br><span class="line">  EOF</span><br></pre></td></tr></table></figure>

<h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul>
<li>使用命令 <code>mkfs.ext4 /dev/xxxn</code> 来格式化对应分区</li>
</ul>
<h3 id="文件系统的检验"><a href="#文件系统的检验" class="headerlink" title="文件系统的检验"></a>文件系统的检验</h3><ul>
<li>使用命令 <code>fsck.ext4</code> 可以完成ext4 文件系统的检查</li>
</ul>
<h3 id="挂载与卸载"><a href="#挂载与卸载" class="headerlink" title="挂载与卸载"></a>挂载与卸载</h3><p>在挂载前需要注意的是：</p>
<ol>
<li><p>单一目录不应该重复挂载多个文件系统</p>
</li>
<li><p>要作为挂载点的目录需要是空目录</p>
</li>
</ol>
<ul>
<li><p>首先使用 <code>mkdir &lt;new dir&gt;</code> 新建空目录</p>
</li>
<li><p>然后使用 <code>mount /dev/xxxn &lt;new dir&gt;</code> 将分区挂载到空目录上</p>
</li>
<li><p>使用 <code>unmount &lt;dir&gt;</code> 来卸载分区</p>
</li>
</ul>
<h3 id="开机挂载"><a href="#开机挂载" class="headerlink" title="开机挂载"></a>开机挂载</h3><p>开机挂载规则存储于文件 <code>/etc/fstab</code> 中，如果需要增加挂载规则，那么在后面继续加入即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /etc/fstab: static file system information.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># Use &#x27;blkid&#x27; to print the universally unique identifier for a</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> device; this may be used with UUID= as a more robust way to name devices</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> that works even <span class="keyword">if</span> disks are added and removed. See fstab(5).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> / was on /dev/sda1 during installation</span></span><br><span class="line">UUID=db4b4bdb-ebff-4928-b154-786622f8438f /               ext4    errors=remount-ro 0       1</span><br><span class="line"><span class="meta">#</span><span class="bash"> swap was on /dev/sda5 during installation</span></span><br><span class="line">UUID=25fea792-68fb-4dcc-a793-c96933dd39a1 none            swap    sw              0       0</span><br></pre></td></tr></table></figure>

<p>其规则从左到右依次为：</p>
<ul>
<li>UUID : 分区的唯一ID</li>
<li>mount point: 挂载的目录路径</li>
<li>type : 文件系统类型</li>
<li>options : 文件系统参数</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>async/sync</td>
<td>是否以同步方式操作，一般为async</td>
</tr>
<tr>
<td>auto/noauto</td>
<td>当使用 mount -a 时，此文件系统是否会被主动测试挂载，默认为auto</td>
</tr>
<tr>
<td>rw/ro</td>
<td>整个文件系统的读写权限</td>
</tr>
<tr>
<td>exec/noexec</td>
<td>此文件系统中的档案是否可执行</td>
</tr>
<tr>
<td>user/nouser</td>
<td>是否允许普通用户可以挂载该文件系统，默认为nouser(不允许)</td>
</tr>
<tr>
<td>suid/nosuid</td>
<td>文件系统中的文件是否允许SUID的存在</td>
</tr>
<tr>
<td>default</td>
<td>默认:rw,suid,dev,exec,auto,nouser,async, 所以一般使用此参数即可</td>
</tr>
</tbody></table>
<ul>
<li>dump : 是否能被 dump 备份指定使用，一般设为 0</li>
<li>pass : 是否在开机是进行文件系统检查，为1代表需要检查 </li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">当 fstab 文件写入有误导致开机失败，那么可以进入维护模式然后使用命令  &quot;mount -n -o remount,rw /&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
        <category>fs</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统基本脉络</title>
    <url>/2024/09/17/linux_fs_training/</url>
    <content><![CDATA[<p>记录从上层用户操作到底层文件系统之间的调用流程以及数据流。<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/vfs_fileoperations.jpg?raw=true"></p>
<span id="more"></span>

<h1 id="simplefs-实战"><a href="#simplefs-实战" class="headerlink" title="simplefs 实战"></a>simplefs 实战</h1><p>[simplefs][<a href="https://github.com/psankar/simplefs]">https://github.com/psankar/simplefs]</a> 用最少的代码实现了文件系统的基本操作。</p>
<h2 id="基本体验"><a href="#基本体验" class="headerlink" title="基本体验"></a>基本体验</h2><h3 id="创建一个硬盘"><a href="#创建一个硬盘" class="headerlink" title="创建一个硬盘"></a>创建一个硬盘</h3><p>目前使用 <code>dd</code> 命令创建一个块大小为 4096字节，共100个块的硬盘文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">bs 指定一个块的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">count 指定块数目</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> 输入文件内容， /dev/zero 会不断输出0</span></span><br><span class="line"><span class="meta">#</span><span class="bash">of 输出文件名</span></span><br><span class="line"><span class="meta">#</span><span class="bash">此命令可以用来测试内存的操作速度</span></span><br><span class="line">dd bs=4096 count=100 if=/dev/zero of=image</span><br></pre></td></tr></table></figure>

<h3 id="格式化并挂载"><a href="#格式化并挂载" class="headerlink" title="格式化并挂载"></a>格式化并挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make </span><br><span class="line">./mkfs-simplefs image</span><br><span class="line">mkdir mount</span><br><span class="line">sudo insmod simplefs.ko </span><br><span class="line">mount -o loop -t simplefs image ./mount</span><br></pre></td></tr></table></figure>

<h3 id="查看内容"><a href="#查看内容" class="headerlink" title="查看内容"></a>查看内容</h3><p>接下来就是以root的身份进入到 <code>mount</code> 文件夹，便可以查看其文件及文件内容。</p>
<h2 id="格式化代码分析-mkfs-simplefs-c"><a href="#格式化代码分析-mkfs-simplefs-c" class="headerlink" title="格式化代码分析(mkfs-simplefs.c)"></a>格式化代码分析(mkfs-simplefs.c)</h2><p>其格式化的步骤为：</p>
<ol>
<li>写入superblock 的内容</li>
<li>写根目录inode</li>
<li>写文件inode</li>
<li>写根目录block</li>
<li>写文件block</li>
</ol>
<h3 id="写-superblock"><a href="#写-superblock" class="headerlink" title="写 superblock"></a>写 superblock</h3><p>此函数将一个block来保存superblock的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_MAGIC 0x10032013</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> version; <span class="comment">//版本号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> magic; <span class="comment">//魔数</span></span><br><span class="line">        <span class="keyword">uint64_t</span> block_size;<span class="comment">//super block 信息所占用的块大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">FIXME:</span> This should be moved to the inode store and not part of the sb */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inodes_count;<span class="comment">//目前已经使用了多少个inode</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint64_t</span> free_blocks;<span class="comment">//目前还剩下多少个block</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此部分是为了填充结构体，使整个结构体大小为4096字节</span></span><br><span class="line">        <span class="keyword">char</span> padding[SIMPLEFS_DEFAULT_BLOCK_SIZE - (<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>))];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_superblock</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> <span class="title">sb</span> =</span> &#123;</span><br><span class="line">                .version = <span class="number">1</span>,</span><br><span class="line">                .magic = SIMPLEFS_MAGIC,</span><br><span class="line">                .block_size = SIMPLEFS_DEFAULT_BLOCK_SIZE,</span><br><span class="line">                <span class="comment">/* One inode for rootdirectory and another for a welcome file that we are going to create */</span></span><br><span class="line">                .inodes_count = <span class="number">2</span>,<span class="comment">//使用一个inode对应根目录，一个inode对应一个文件</span></span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> Free blocks management is not implemented yet */</span></span><br><span class="line">                .free_blocks = (~<span class="number">0</span>) &amp; ~(<span class="number">1</span> &lt;&lt; WELCOMEFILE_DATABLOCK_NUMBER),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;sb, <span class="keyword">sizeof</span>(sb));</span><br><span class="line">        <span class="keyword">if</span> (ret != SIMPLEFS_DEFAULT_BLOCK_SIZE) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;bytes written [%d] are not equal to the default block size\n&quot;</span>,</span><br><span class="line">                         (<span class="keyword">int</span>)ret);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Super block written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写根文件inode"><a href="#写根文件inode" class="headerlink" title="写根文件inode"></a>写根文件inode</h3><p>根文件的inode紧接着superblock 往后填充，也就是在第2个block中存储inode.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">mode_t</span> mode; <span class="comment">//此inode表示的档案类型</span></span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//inode的索引号</span></span><br><span class="line">        <span class="keyword">uint64_t</span> data_block_number;<span class="comment">//与inode对应的block的索引号</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//文件大小或是目录对应的内容对</span></span><br><span class="line">                <span class="keyword">uint64_t</span> file_size;</span><br><span class="line">                <span class="keyword">uint64_t</span> dir_children_count;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_INODE_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIMPLEFS_INODESTORE_BLOCK_NUMBER = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode_store</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">root_inode</span>;</span></span><br><span class="line"></span><br><span class="line">        root_inode.mode = S_IFDIR;</span><br><span class="line">        root_inode.inode_no = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        root_inode.data_block_number = SIMPLEFS_ROOTDIR_DATABLOCK_NUMBER;</span><br><span class="line">        root_inode.dir_children_count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, &amp;root_inode, <span class="keyword">sizeof</span>(root_inode));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(root_inode)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The inode store was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;root directory inode written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件inode"><a href="#写文件inode" class="headerlink" title="写文件inode"></a>写文件inode</h3><p>通过此函数可以看出：所有的inode都存储在一个block中，而一个inode大小为 <code>28</code> 字节。<br>也就是说，此文件系统最多支持文件和文件夹的总数为 <code>4096 / 28 = 146 </code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_DEFAULT_BLOCK_SIZE 4096</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_INODE_NUMBER = <span class="number">2</span>;<span class="comment">//文件inode为2号</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> WELCOMEFILE_DATABLOCK_NUMBER = <span class="number">3</span>;<span class="comment">//文件内容block</span></span><br><span class="line"><span class="keyword">char</span> welcomefile_body[] = <span class="string">&quot;Love is God. God is Love. Anbe Murugan.\n&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> <span class="title">welcome</span> =</span> &#123;</span><br><span class="line">        .mode = S_IFREG,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">        .data_block_number = WELCOMEFILE_DATABLOCK_NUMBER,</span><br><span class="line">        .file_size = <span class="keyword">sizeof</span>(welcomefile_body),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write_inode</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_inode *i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">off_t</span> nbytes;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, i, <span class="keyword">sizeof</span>(*i));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(*i)) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The welcomefile inode was not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;welcomefile inode written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//算出需要移动到block尾需要多少字节(依次减去root inode 和 welcome inode)</span></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*i) - <span class="keyword">sizeof</span>(*i);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);</span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;The padding bytes are not written properly. Retry your mkfs\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;inode store padding bytes (after the two inodes) written sucessfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写根目录block"><a href="#写根目录block" class="headerlink" title="写根目录block"></a>写根目录block</h3><p>写根目录block就是写文件名以及其inode的索引,一个名称对的大小为 <code>264</code> 字节，<br>也就是说一个目录最多可以存储的名称对为 <code>4096 / 264 = 15</code> 个，也就是说一个目录<br>最多存储15个文件或目录名。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIMPLEFS_FILENAME_MAXLEN 255 <span class="comment">//文件名的最大长度</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> filename[SIMPLEFS_FILENAME_MAXLEN];</span><br><span class="line">        <span class="keyword">uint64_t</span> inode_no;<span class="comment">//文件名以及其对应的block索引</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> <span class="title">record</span> =</span> &#123;</span><br><span class="line">        .filename = <span class="string">&quot;vanakkam&quot;</span>,</span><br><span class="line">        .inode_no = WELCOMEFILE_INODE_NUMBER,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_dirent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct simplefs_dir_record *record)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> nbytes = <span class="keyword">sizeof</span>(*record), ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, record, nbytes);</span><br><span class="line">        <span class="keyword">if</span> (ret != nbytes) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the rootdirectory datablock (name+inode_no pair for welcomefile) has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;root directory datablocks (name+inode_no pair for welcomefile) written succesfully\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE - <span class="keyword">sizeof</span>(*record);</span><br><span class="line">        ret = lseek(fd, nbytes, SEEK_CUR);<span class="comment">//移动到下一个block</span></span><br><span class="line">        <span class="keyword">if</span> (ret == (<span class="keyword">off_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span></span><br><span class="line">                        (<span class="string">&quot;Writing the padding for rootdirectory children datablock has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span></span><br><span class="line">                (<span class="string">&quot;padding after the rootdirectory children written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件block"><a href="#写文件block" class="headerlink" title="写文件block"></a>写文件block</h3><p>写文件block就是把文件内容写进去即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_block</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *block, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">        ret = write(fd, block, len);</span><br><span class="line">        <span class="keyword">if</span> (ret != len) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Writing file body has failed\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block has been written succesfully\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>根据上面的格式化代码，可以知道其结构如下图：</p>
<p>！<a href="./simplefs_struct.jpg"></a></p>
<p>可以看出此文件系统的确是足够的简单：</p>
<ol>
<li>superblock描述极为简单</li>
<li>并不具备block bitmap 和 inode bitmap</li>
<li>最多支持的文件和文件夹总数为146个(因为仅用了一个block来存储inode)</li>
<li>一个文件夹中可以存储的文件和文件夹总数为15个</li>
<li>一个文件的内容不能超过一个block</li>
</ol>
<h3 id="文件系统操作逻辑"><a href="#文件系统操作逻辑" class="headerlink" title="文件系统操作逻辑"></a>文件系统操作逻辑</h3><p>根据以上简单结构的分析，可以猜测出其基本的文件操作逻辑：</p>
<ol>
<li>新建文件夹</li>
</ol>
<ul>
<li>从inode table 中填充一个文件夹类型的inode并获取其索引</li>
<li>为此索引的inode分配一个block并写入对应的inode</li>
<li>将新建文件夹的名称和inode索引对应存储在当前文件夹的block中</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="2">
<li>新建文件</li>
</ol>
<ul>
<li>从inode table 中填充一个文件类型的inode并获取其索引</li>
<li>为此索引的inode分配一个block并写入对应的inode</li>
<li>将文件内容写入其block中</li>
<li>将新建文件的名称和inode索引对应存储在当前文件夹的block中</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="3">
<li>删除文件或文件夹</li>
</ol>
<ul>
<li>去除当前文件夹中对应此文件或文件夹的描述字符串</li>
<li>更新 superblock 中的inode计数</li>
</ul>
<ol start="4">
<li>建立硬链接</li>
</ol>
<ul>
<li>在当前文件夹下拷贝一份目标文件所在的文件夹中对于此文件的描述字符串</li>
</ul>
<ol start="5">
<li>建立符号链接</li>
</ol>
<ul>
<li>首先新建一个文件</li>
<li>然后新建文件的内容指向目标文件所在的文件夹的inode</li>
</ul>
<p>基于这些猜测，接下来分析其文件系统操作代码。</p>
<h2 id="操作代码分析-simple-c"><a href="#操作代码分析-simple-c" class="headerlink" title="操作代码分析(simple.c)"></a>操作代码分析(simple.c)</h2><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>在载入模块时，会首先使用函数 ·kmem_cache_create· ，用于为文件系统的inode申请缓存以便达到快速访问的目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfs_inode_cachep = kmem_cache_create(<span class="string">&quot;sfs_inode_cache&quot;</span>,</span><br><span class="line">                                     <span class="keyword">sizeof</span>(struct simplefs_inode),</span><br><span class="line">                                     <span class="number">0</span>,</span><br><span class="line">                                     (SLAB_RECLAIM_ACCOUNT| SLAB_MEM_SPREAD),</span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>在挂载文件时，会调用函数 <code>simplefs_fill_super</code> 函数，此函数的主要目的就是填充 <code>super_block</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function, as the name implies, Makes the super_block valid and</span></span><br><span class="line"><span class="comment"> ,* fills filesystem specific information in the super block */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_fill_super</span><span class="params">(struct super_block *sb, <span class="keyword">void</span> *data, <span class="keyword">int</span> silent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">root_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb_disk</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret = -EPERM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从存储super block 描述的block(0)中读取数据</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_SUPERBLOCK_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到 simplefs_super_block 具体内容</span></span><br><span class="line">        sb_disk = (struct simplefs_super_block *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;The magic number obtained in disk is: [%llu]\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;magic);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;magic != SIMPLEFS_MAGIC)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The filesystem that you try to mount is not of type simplefs. Magicnumber mismatch.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(sb_disk-&gt;block_size != SIMPLEFS_DEFAULT_BLOCK_SIZE)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;simplefs seem to be formatted using a non-standard block size.&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_INFO</span><br><span class="line">               <span class="string">&quot;simplefs filesystem of version [%llu] formatted with a block size of [%llu] detected in the device.\n&quot;</span>,</span><br><span class="line">               sb_disk-&gt;version, sb_disk-&gt;block_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* A magic number that uniquely identifies our filesystem type */</span></span><br><span class="line">        sb-&gt;s_magic = SIMPLEFS_MAGIC;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* For all practical purposes, we will be using this s_fs_info as the super block */</span></span><br><span class="line">        <span class="comment">//设为私有地址，以便后面使用</span></span><br><span class="line">        sb-&gt;s_fs_info = sb_disk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大的文件大小就是为一个block</span></span><br><span class="line">        sb-&gt;s_maxbytes = SIMPLEFS_DEFAULT_BLOCK_SIZE;</span><br><span class="line">        <span class="comment">//super block 操作</span></span><br><span class="line">        sb-&gt;s_op = &amp;simplefs_sops;</span><br><span class="line"></span><br><span class="line">        root_inode = new_inode(sb);</span><br><span class="line">        <span class="comment">//跟目录的inode位置</span></span><br><span class="line">        root_inode-&gt;i_ino = SIMPLEFS_ROOTDIR_INODE_NUMBER;</span><br><span class="line">        inode_init_owner(root_inode, <span class="literal">NULL</span>, S_IFDIR);</span><br><span class="line">        root_inode-&gt;i_sb = sb;</span><br><span class="line">        <span class="comment">//根目录inode操作</span></span><br><span class="line">        root_inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        <span class="comment">//根目录操作</span></span><br><span class="line">        root_inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        root_inode-&gt;i_atime = root_inode-&gt;i_mtime = root_inode-&gt;i_ctime =</span><br><span class="line">                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到根目录的inode内容(并且会将此inode放入inode cache 中)</span></span><br><span class="line">        root_inode-&gt;i_private =</span><br><span class="line">                simplefs_get_inode(sb, SIMPLEFS_ROOTDIR_INODE_NUMBER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> move such stuff into separate header. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 3, 0)</span></span><br><span class="line">        sb-&gt;s_root = d_make_root(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        sb-&gt;s_root = d_alloc_root(root_inode);</span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">                iput(root_inode);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sb-&gt;s_root) &#123;</span><br><span class="line">                ret = -ENOMEM;</span><br><span class="line">                <span class="keyword">goto</span> release;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">release:</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其数据填充结果如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/struct_super_block.jpg?raw=true"><br>在 <code>super.h</code> 中有以下两个操作,对照上图就可以看出其意义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取 simplefs_super_block 结构体地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_super_block *<span class="title">SIMPLEFS_SB</span><span class="params">(struct super_block *sb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb-&gt;s_fs_info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件或目录 inode的地址</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct simplefs_inode *<span class="title">SIMPLEFS_INODE</span><span class="params">(struct inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inode-&gt;i_private;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读取文件夹内容"><a href="#读取文件夹内容" class="headerlink" title="读取文件夹内容"></a>读取文件夹内容</h3><p>为了获取文件夹的内容得先从目录inode找到其对应的block。</p>
<p>当在 <code>mount</code> 文件夹下使用命令 <code>ls</code> 时，其执行路径依次为：</p>
<ul>
<li>simplefs_iterate : 用于扫描目录中的文件或文件夹名称以及其对应的inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_iterate</span><span class="params">(struct file *filp, struct dir_context *ctx)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_readdir</span><span class="params">(struct file *filp, <span class="keyword">void</span> *dirent, <span class="keyword">filldir_t</span> filldir)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">loff_t</span> pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">        pos = ctx-&gt;pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pos = filp-&gt;f_pos;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        inode = filp-&gt;f_dentry-&gt;d_inode;</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos) &#123;</span><br><span class="line">                <span class="comment">/* <span class="doctag">FIXME:</span> We use a hack of reading pos to figure if we have filled in all data.</span></span><br><span class="line"><span class="comment">                 ,* We should probably fix this to work in a cursor based model and</span></span><br><span class="line"><span class="comment">                 ,* use the tokens correctly to not fill too many data in each cursor based call */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的inode</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!S_ISDIR(sfs_inode-&gt;mode))) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;inode [%llu][%lu] for fs object [%s] not a directory\n&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;inode_no, inode-&gt;i_ino,</span><br><span class="line">                       filp-&gt;f_dentry-&gt;d_name.name);</span><br><span class="line">                <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到目录的block</span></span><br><span class="line">        bh = sb_bread(sb, sfs_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取目录blockc内容</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="comment">//根据目录中含有的条目进行扫描</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_inode-&gt;dir_children_count; i++) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 11, 0)</span></span><br><span class="line">                <span class="comment">//返回文件名以及其对应的inode</span></span><br><span class="line">                dir_emit(ctx, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN,</span><br><span class="line">                         record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                ctx-&gt;pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                filldir(dirent, record-&gt;filename, SIMPLEFS_FILENAME_MAXLEN, pos,</span><br><span class="line">                        record-&gt;inode_no, DT_UNKNOWN);</span><br><span class="line">                filp-&gt;f_pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                pos += <span class="keyword">sizeof</span>(struct simplefs_dir_record);</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_lookup : 得到文件或文件夹的inode内容并初始化系统的 inode结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct dentry *<span class="title">simplefs_lookup</span><span class="params">(struct inode *parent_inode,</span></span></span><br><span class="line"><span class="params"><span class="function">                               struct dentry *child_dentry, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取目录inode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent</span> =</span> SIMPLEFS_INODE(parent_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> parent_inode-&gt;i_sb;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">record</span>;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的block</span></span><br><span class="line">        bh = sb_bread(sb, parent-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取目录的blockå����</span></span><br><span class="line">        record = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parent-&gt;dir_children_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(record-&gt;filename, child_dentry-&gt;d_name.name)) &#123;</span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> There is a corner case where if an allocated inode,</span></span><br><span class="line"><span class="comment">                         ,* is not written to the inode store, but the inodes_count is</span></span><br><span class="line"><span class="comment">                         ,* incremented. Then if the random string on the disk matches</span></span><br><span class="line"><span class="comment">                         ,* with the filename that we are comparing above, then we</span></span><br><span class="line"><span class="comment">                         ,* will use an invalid uninitialized inode */</span></span><br><span class="line"></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//根据文件inode号获取其内容</span></span><br><span class="line">                        sfs_inode = simplefs_get_inode(sb, record-&gt;inode_no);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//初始化inode结构体以及其对应的文件或文件夹操作</span></span><br><span class="line">                        inode = new_inode(sb);</span><br><span class="line">                        inode-&gt;i_ino = record-&gt;inode_no;</span><br><span class="line">                        inode_init_owner(inode, parent_inode, sfs_inode-&gt;mode);</span><br><span class="line">                        inode-&gt;i_sb = sb;</span><br><span class="line">                        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">                                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                                printk(KERN_ERR</span><br><span class="line">                                       <span class="string">&quot;Unknown inode type. Neither a directory nor a file&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* <span class="doctag">FIXME:</span> We should store these times to disk and retrieve them */</span></span><br><span class="line">                        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =</span><br><span class="line">                                CURRENT_TIME;</span><br><span class="line"></span><br><span class="line">                        inode-&gt;i_private = sfs_inode;</span><br><span class="line"></span><br><span class="line">                        d_add(child_dentry, inode);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                record++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printk(KERN_ERR</span><br><span class="line">               <span class="string">&quot;No inode found for the filename [%s]\n&quot;</span>,</span><br><span class="line">               child_dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_get_inode : 得到请求的inode号码的内容</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This functions returns a simplefs_inode with the given inode_no</span></span><br><span class="line"><span class="comment"> ,* from the inode store, if it exists. */</span></span><br><span class="line"><span class="function">struct simplefs_inode *<span class="title">simplefs_get_inode</span><span class="params">(struct super_block *sb,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">uint64_t</span> inode_no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sfs_sb</span> =</span> SIMPLEFS_SB(sb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_buffer</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The inode store can be read once and kept in memory permanently while mounting.</span></span><br><span class="line"><span class="comment">         ,* But such a model will not be scalable in a filesystem with</span></span><br><span class="line"><span class="comment">         ,* millions or billions of files (inodes) */</span></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        sfs_inode = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Failed to acquire mutex lock %s +%d\n&quot;</span>,</span><br><span class="line">                       __FILE__, __LINE__);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//扫描inode table 是否有与要求的序号匹配的Inode</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sfs_sb-&gt;inodes_count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sfs_inode-&gt;inode_no == inode_no) &#123;</span><br><span class="line">                        <span class="comment">//申请cache</span></span><br><span class="line">                        inode_buffer = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">                        <span class="built_in">memcpy</span>(inode_buffer, sfs_inode, <span class="keyword">sizeof</span>(*inode_buffer));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sfs_inode++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//      mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span></span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line">        <span class="keyword">return</span> inode_buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_iterate</li>
</ul>
<p>可以看出其基本思路是：</p>
<ol>
<li>通过文件夹的inode获取其block</li>
<li>扫描block有哪些文件或文件夹</li>
<li>获取这些扫描到的文件或文件夹的inode内容，为其操作做好准备</li>
</ol>
<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>可以猜测为了读取文件内容，首先要获取其inode才能找到其block.</p>
<p>当执行 <code>cat vanakkam</code> 时，执行的函数依次是：</p>
<ul>
<li>simplefs_iterate : 重复执行了8次</li>
<li>simplefs_read</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_read</span><span class="params">(struct file * filp, <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode</span> =</span></span><br><span class="line">                SIMPLEFS_INODE(filp-&gt;f_path.dentry-&gt;d_inode);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line">        <span class="keyword">int</span> nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*ppos &gt;= inode-&gt;file_size) &#123;</span><br><span class="line">                <span class="comment">/* Read request with offset beyond the filesize */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取block</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line">        nbytes = min((<span class="keyword">size_t</span>) inode-&gt;file_size, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buf, buffer, nbytes)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents to the userspace buffer\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        ,*ppos += nbytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_read</li>
</ul>
<p>可以看出其思路为：</p>
<ol>
<li>从目录inode获取目录block，进而获取到文件的inode</li>
</ol>
<ul>
<li>所以当你对一个目录都没有读权限时，是无法通过其inode来获取文件内容的</li>
</ul>
<ol start="2">
<li>从文件inode找到其对应block再读取其内容</li>
</ol>
<h3 id="写文件内容"><a href="#写文件内容" class="headerlink" title="写文件内容"></a>写文件内容</h3><p>可以猜测其与读文件内容的思路是一样的：</p>
<ol>
<li>从目录inode获取目录block，进而获取到文件的inode</li>
<li>从文件inode找到其对应block再写入对应的内容</li>
<li>更新inode描述(因为inode中具有文件信息)</li>
</ol>
<p>执行 echo “Hello world!” &gt; vanakkam 其执行路径为：</p>
<ul>
<li>simplefs_iterate : 重复执行了12次，没看懂为什么</li>
<li>simplefs_write : 写入数据并同步</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">simplefs_write</span><span class="params">(struct file * filp, <span class="keyword">const</span> <span class="keyword">char</span> __user * buf, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">loff_t</span> * ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/* After the commit dd37978c5 in the upstream linux kernel,</span></span><br><span class="line"><span class="comment">         ,* we can use just filp-&gt;f_inode instead of the</span></span><br><span class="line"><span class="comment">         ,* f-&gt;f_path.dentry-&gt;d_inode redirection */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *buffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        retval = generic_write_checks(filp, ppos, &amp;len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line">        <span class="comment">//获取inode内容</span></span><br><span class="line">        sfs_inode = SIMPLEFS_INODE(inode);</span><br><span class="line">        sb = inode-&gt;i_sb;</span><br><span class="line">        <span class="comment">//获取block地址</span></span><br><span class="line">        bh = sb_bread(filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb,</span><br><span class="line">                      sfs_inode-&gt;data_block_number);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bh) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;Reading the block number [%llu] failed.&quot;</span>,</span><br><span class="line">                       sfs_inode-&gt;data_block_number);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取block内容</span></span><br><span class="line">        buffer = (<span class="keyword">char</span> *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move the pointer until the required byte offset */</span></span><br><span class="line">        buffer += *ppos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(buffer, buf, len)) &#123;</span><br><span class="line">                brelse(bh);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Error copying file contents from the userspace buffer to the kernel space\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        ,*ppos += len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步数据到硬盘</span></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set new size</span></span><br><span class="line"><span class="comment">         ,* sfs_inode-&gt;file_size = max(sfs_inode-&gt;file_size, *ppos);</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* <span class="doctag">FIXME:</span> What to do if someone writes only some parts in between ?</span></span><br><span class="line"><span class="comment">         ,* The above code will also fail in case a file is overwritten with</span></span><br><span class="line"><span class="comment">         ,* a shorter buffer */</span></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sfs_inode-&gt;file_size = *ppos;</span><br><span class="line">        retval = simplefs_inode_save(sb, sfs_inode);</span><br><span class="line">        <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">                len = retval;</span><br><span class="line">        &#125;</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_inode_save : 更新inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_inode_save</span><span class="params">(struct super_block *sb, struct simplefs_inode *sfs_inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取inode table</span></span><br><span class="line">        bh = sb_bread(sb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从inode table 起始遍历出对应inode的内容</span></span><br><span class="line">        inode_iterator = simplefs_inode_search(sb,</span><br><span class="line">                                               (struct simplefs_inode *)bh-&gt;b_data,</span><br><span class="line">                                               sfs_inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(inode_iterator)) &#123;</span><br><span class="line">                <span class="comment">//更新 inode</span></span><br><span class="line">                <span class="built_in">memcpy</span>(inode_iterator, sfs_inode, <span class="keyword">sizeof</span>(*inode_iterator));</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;The inode updated\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//与硬盘同步</span></span><br><span class="line">                mark_buffer_dirty(bh);</span><br><span class="line">                sync_dirty_buffer(bh);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;The new filesize could not be stored to the inode.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_inode_search : 从inode table 中找到对应序列的inode</li>
</ul>
<h3 id="新建文件夹"><a href="#新建文件夹" class="headerlink" title="新建文件夹"></a>新建文件夹</h3><p>先来猜测新建文件夹的步骤：</p>
<ol>
<li>根据文件夹inode找到其block</li>
<li>为新建的文件夹在inode table 中获取一个inode</li>
<li>为新建的文件夹分配一个block</li>
<li>将新申请到的文件夹名称以及其inode号写入父文件夹的block中</li>
<li>更新父文件夹inode</li>
<li>与硬盘同步</li>
</ol>
<p>执行命令 <code>mkdir hello</code> 其调用函数依次为：</p>
<ul>
<li>simplefs_iterate : 浏览目录获取其档案及对应inode</li>
<li>simplefs_lookup : 查看当前目录是否已有此档案名</li>
<li>simplefs_mkdir : 新建文件夹</li>
<li>simplefs_create_fs_object : 新建档案</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">simplefs_create_fs_object</span><span class="params">(struct inode *dir, struct dentry *dentry,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">umode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">sfs_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">parent_dir_inode</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_dir_record</span> *<span class="title">dir_contents_datablock</span>;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> count;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_directory_children_update_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line">        sb = dir-&gt;i_sb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 super block 中记录的 inode 数目</span></span><br><span class="line">        ret = simplefs_sb_get_objects_count(sb, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(count &gt;= SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                <span class="comment">/* The above condition can be just == insted of the &gt;= */</span></span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Maximum number of objects supported by simplefs is already reached&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!S_ISDIR(mode) &amp;&amp; !S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_ERR</span><br><span class="line">                       <span class="string">&quot;Creation request but for neither a file nor a directory&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode = new_inode(sb);</span><br><span class="line">        <span class="keyword">if</span> (!inode) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inode-&gt;i_sb = sb;</span><br><span class="line">        inode-&gt;i_op = &amp;simplefs_inode_ops;</span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">        inode-&gt;i_ino = (count + SIMPLEFS_START_INO - SIMPLEFS_RESERVED_INODES + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        sfs_inode = kmem_cache_alloc(sfs_inode_cachep, GFP_KERNEL);</span><br><span class="line">        sfs_inode-&gt;inode_no = inode-&gt;i_ino;</span><br><span class="line">        inode-&gt;i_private = sfs_inode;</span><br><span class="line">        sfs_inode-&gt;mode = mode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New directory creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;dir_children_count = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_dir_operations;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(mode)) &#123;</span><br><span class="line">                printk(KERN_INFO <span class="string">&quot;New file creation request\n&quot;</span>);</span><br><span class="line">                sfs_inode-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">                inode-&gt;i_fop = &amp;simplefs_file_operations;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First get a free block and update the free map,</span></span><br><span class="line"><span class="comment">         ,* Then add inode to the inode store and update the sb inodes_count,</span></span><br><span class="line"><span class="comment">         ,* Then update the parent directory&#x27;s inode with the new child.</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,* The above ordering helps us to maintain fs consistency</span></span><br><span class="line"><span class="comment">         ,* even in most crashes</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="comment">//申请一个空闲的block</span></span><br><span class="line">        ret = simplefs_sb_get_a_freeblock(sb, &amp;sfs_inode-&gt;data_block_number);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;simplefs could not get a freeblock&quot;</span>);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//申请一个空闲的inode</span></span><br><span class="line">        simplefs_inode_add(sb, sfs_inode);</span><br><span class="line"></span><br><span class="line">        parent_dir_inode = SIMPLEFS_INODE(dir);</span><br><span class="line">        bh = sb_bread(sb, parent_dir_inode-&gt;data_block_number);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到父目录的block</span></span><br><span class="line">        dir_contents_datablock = (struct simplefs_dir_record *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Navigate to the last record in the directory contents */</span></span><br><span class="line">        dir_contents_datablock += parent_dir_inode-&gt;dir_children_count;</span><br><span class="line">        <span class="comment">//在父目录的blockä������������������inode对</span></span><br><span class="line">        dir_contents_datablock-&gt;inode_no = sfs_inode-&gt;inode_no;</span><br><span class="line">        <span class="built_in">strcpy</span>(dir_contents_datablock-&gt;filename, dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        sync_dirty_buffer(bh);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EINTR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存父目录inode</span></span><br><span class="line">        parent_dir_inode-&gt;dir_children_count++;</span><br><span class="line">        ret = simplefs_inode_save(sb, parent_dir_inode);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">                mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* <span class="doctag">TODO:</span> Remove the newly created inode from the disk and in-memory inode store</span></span><br><span class="line"><span class="comment">                 ,* and also update the superblock, freemaps etc. to reflect the same.</span></span><br><span class="line"><span class="comment">                 ,* Basically, Undo all actions done during this create call */</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_directory_children_update_lock);</span><br><span class="line"></span><br><span class="line">        inode_init_owner(inode, dir, mode);</span><br><span class="line">        d_add(dentry, inode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li>
<li>simplefs_sb_get_a_freeblock : 获取空闲block</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simplefs_sb_get_a_freeblock</span><span class="params">(struct super_block *vsb, <span class="keyword">uint64_t</span> * out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取super block</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                ret = -EINTR;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Loop until we find a free block. We start the loop from 3,</span></span><br><span class="line"><span class="comment">         ,* as all prior blocks will always be in use */</span></span><br><span class="line">        <span class="comment">//从第三个block 开始寻找，前两个分别是(super block 和 inode table)</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED; i++) &#123;</span><br><span class="line">                <span class="comment">//通过位与的方式来获取空位，这也就是为什么最多支持64个block(free_blocks 是64位)</span></span><br><span class="line">                <span class="keyword">if</span> (sb-&gt;free_blocks &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(i == SIMPLEFS_MAX_FILESYSTEM_OBJECTS_SUPPORTED)) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">&quot;No more free blocks available&quot;</span>);</span><br><span class="line">                ret = -ENOSPC;</span><br><span class="line">                <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ,*out = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新super block 中记录的空闲blockå��</span></span><br><span class="line">        <span class="comment">/* Remove the identified block from the free list */</span></span><br><span class="line">        sb-&gt;free_blocks &amp;= ~(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同步super block 与硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>simplefs_sb_sync : 同步super block 与硬盘</li>
<li>simplefs_inode_add : 获取一个inode</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simplefs_inode_add</span><span class="params">(struct super_block *vsb, struct simplefs_inode *inode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_super_block</span> *<span class="title">sb</span> =</span> SIMPLEFS_SB(vsb);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">simplefs_inode</span> *<span class="title">inode_iterator</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_inodes_mgmt_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bh = sb_bread(vsb, SIMPLEFS_INODESTORE_BLOCK_NUMBER);</span><br><span class="line">        BUG_ON(!bh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取inode table 内容</span></span><br><span class="line">        inode_iterator = (struct simplefs_inode *)bh-&gt;b_data;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mutex_lock_interruptible(&amp;simplefs_sb_lock)) &#123;</span><br><span class="line">                sfs_trace(<span class="string">&quot;Failed to acquire mutex lock\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the new inode in the end in the inode store */</span></span><br><span class="line">        <span class="comment">//移动到inode table 的第一个空闲处</span></span><br><span class="line">        inode_iterator += sb-&gt;inodes_count;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(inode_iterator, inode, <span class="keyword">sizeof</span>(struct simplefs_inode));</span><br><span class="line">        <span class="comment">//更新super block 计数</span></span><br><span class="line">        sb-&gt;inodes_count++;</span><br><span class="line"></span><br><span class="line">        mark_buffer_dirty(bh);</span><br><span class="line">        <span class="comment">//同步super block 到硬盘</span></span><br><span class="line">        simplefs_sb_sync(vsb);</span><br><span class="line">        brelse(bh);</span><br><span class="line"></span><br><span class="line">        mutex_unlock(&amp;simplefs_sb_lock);</span><br><span class="line">        mutex_unlock(&amp;simplefs_inodes_mgmt_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>simplefs_sb_sync </li>
<li>simplefs_inode_save </li>
<li>simplefs_inode_search </li>
</ul>
<h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>还是先来猜测一下新建文件的步骤：</p>
<ol>
<li>根据文件夹inode找到对应的block</li>
<li>从inode table 中为新建文件获取一个inode</li>
<li>从block 中为新建文件获取一个block，并填充其内容</li>
<li>更新文件的inode</li>
<li>更新文件夹的inode,以及block</li>
<li>更新super block 的 inode</li>
</ol>
<p>下面执行 <code>echo &quot;hello world!&quot; &gt; hello/hello.txt</code> 其条用函数依次为：</p>
<ul>
<li>simplefs_iterate : 首先通过根目录扫描其所包含的条目</li>
<li>simplefs_iterate : 然后通过扫描 =hello= 目录扫描其所包含的条目</li>
<li>simplefs_lookup : 查找是否存在 =hello.txt= 的inode</li>
<li>simplefs_create_fs_object: 新建文件</li>
<li>simplefs_sb_get_object_count ： 获取当前super block 中记录的inode数量</li>
<li>simplefs_sb_get_a_freeblock : 获取空闲block</li>
<li>simplefs_sb_sync : 同步super block 与硬盘</li>
<li>simplefs_inode_add : 获取一个inode</li>
<li>simplefs_sb_sync </li>
<li>simplefs_inode_save </li>
<li>simplefs_inode_search </li>
<li>simplefs_write : 写入文件内容</li>
<li>simplefs_inode_save : 更新inode</li>
<li>simplefs_inode_search </li>
</ul>
<h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>通过查看其代码可以发现，此文件系统还有以下功能未能实现：</p>
<ul>
<li>删除文件</li>
<li>删除文件夹</li>
<li>建立符号链接</li>
<li>建立硬链接</li>
</ul>
<p>下面来尝试一一实现：</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>前面已经新建了文件 <code>/hello/hello.txt</code> ，下面尝试将它删除。</p>
<p>根据已有的知识先来猜测一下如何以最简单的方式删除一个文件，<br>为了能够使得操作步骤尽量的少，其实没有必要去擦除文件block的内容，而只需要对其inode操作即可。</p>
<p>也就是说涉及以下几个部分：</p>
<ol>
<li>文件夹block的字符串和inode对擦除</li>
<li>文件夹inode中的描述修改</li>
<li>inode table 修改</li>
<li>super block 修改</li>
</ol>
<p>通过 <code>strace rm -f hello.txt</code> 观察到有这么一行输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unlinkat(AT_FDCWD, &quot;hello.txt&quot;, 0)      = -1 EPERM (Operation not permitted)</span><br></pre></td></tr></table></figure>

<p>对应驱动的调用接口应该是 <code>struct inode_operations</code> 下的 <code>unlink</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br></pre></td></tr></table></figure>

<ul>
<li>在实现的过程中发现，其在增加inode 和 dir content 时是直接简单粗暴的在尾部增加，很明显在删除文件时会产生漏洞，所以此bug也需要修复。</li>
</ul>
<h1 id="FUSE"><a href="#FUSE" class="headerlink" title="FUSE"></a>FUSE</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bfs%5D/%5BWhat%5DLinux--fs_struct/fuse.jpg?raw=true"><br>如上图所示，FUSE仅仅在内核中实现了一个简单的模块，用于接口VFS和用户空间，文件系统的操作细节则存在于用户空间中。</p>
<ul>
<li>这种方式导致操作效率低但便于调试</li>
</ul>
<h1 id="比较重要的数据结构"><a href="#比较重要的数据结构" class="headerlink" title="比较重要的数据结构"></a>比较重要的数据结构</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 文件系统总览</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> fs_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_REQUIRES_DEV1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_BINARY_MOUNTDATA2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_HAS_SUBTYPE4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_MOUNT8<span class="comment">/* Can be mounted by userns root */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_DEV_MOUNT16 <span class="comment">/* A userns mount does not imply MNT_NODEV */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_USERNS_VISIBLE32<span class="comment">/* FS must already be visible */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FS_RENAME_DOES_D_MOVE32768<span class="comment">/* FS will handle d_move() during rename() internally. */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">                                 <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">        <span class="keyword">void</span> (*kill_sb) (struct super_block *);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief super block 信息及操作结构体</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_list</span>;</span><span class="comment">/* Keep this first */</span></span><br><span class="line">        dev_ts_dev;<span class="comment">/* search index; _not_ kdev_t */</span></span><br><span class="line">        <span class="keyword">unsigned</span> chars_blocksize_bits;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_blocksize;</span><br><span class="line">        loff_ts_maxbytes;<span class="comment">/* Max file size */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>*<span class="title">s_type</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>*<span class="title">s_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>*<span class="title">dq_op</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>*<span class="title">s_qcop</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_flags;</span><br><span class="line">        <span class="keyword">unsigned</span> longs_iflags;<span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">        <span class="keyword">unsigned</span> longs_magic;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">s_root</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphores_umount</span>;</span></span><br><span class="line">        ints_count;</span><br><span class="line">        atomic_ts_active;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                    *s_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_heads_anon</span>;</span><span class="comment">/* anonymous dentries for (nfs) exporting */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_mounts</span>;</span><span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>*<span class="title">s_bdev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>*<span class="title">s_mtd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nodes_instances</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_quota_types;<span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">quota_infos_dquot</span>;</span><span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sb_writerss_writers</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> s_id[<span class="number">32</span>];<span class="comment">/* Informational name */</span></span><br><span class="line">        u8 s_uuid[<span class="number">16</span>];<span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *s_fs_info;<span class="comment">/* Filesystem private info */</span></span><br><span class="line">        <span class="keyword">unsigned</span> ints_max_links;</span><br><span class="line">        fmode_ts_mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Granularity of c/m/atime in ns.</span></span><br><span class="line"><span class="comment">           Cannot be worse than a second */</span></span><br><span class="line">        u32   s_time_gran;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">         ,* even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span><span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">         ,* in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved mount options for lazy filesystems using</span></span><br><span class="line"><span class="comment">         ,* generic_show_options()</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">char</span> __rcu *s_options;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Saved pool identifier for cleancache (-1 means none)</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> cleancache_poolid;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span><span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">        <span class="keyword">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Being remounted read-only */</span></span><br><span class="line">        <span class="keyword">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">s_dio_done_wq</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">s_pins</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Keep the lru lists last in the structure so they always sit on their</span></span><br><span class="line"><span class="comment">         ,* own individual cachelines.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_dentry_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_lrus_inode_lru</span> ____<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_headrcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_structdestroy_work</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutexs_sync_lock</span>;</span><span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">        spinlock_ts_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_heads_inodes</span>;</span><span class="comment">/* all inodes */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> ,* the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> ,* of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">        <span class="keyword">umode_t</span>                i_mode;</span><br><span class="line">        <span class="keyword">unsigned</span>               shorti_opflags;</span><br><span class="line">        <span class="keyword">kuid_t</span>                 i_uid;</span><br><span class="line">        <span class="keyword">kgid_t</span>                 i_gid;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_flags;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_acl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>       *<span class="title">i_default_acl</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>  *<span class="title">i_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>             *<span class="title">i_sb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           *<span class="title">i_mapping</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                           *i_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>                  i_ino;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">         ,* following functions for modification:</span></span><br><span class="line"><span class="comment">         ,*</span></span><br><span class="line"><span class="comment">         ,*    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">         ,*    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i_nlink;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">int</span> __i_nlink;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">dev_t</span>                  i_rdev;</span><br><span class="line">        <span class="keyword">loff_t</span>                 i_size;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span></span><br><span class="line">        spinlock_ti_lock;<span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>         i_bytes;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>           i_blkbits;</span><br><span class="line">        <span class="keyword">blkcnt_t</span>               i_blocks;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">        <span class="keyword">seqcount_t</span>             i_size_seqcount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Misc */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          i_state;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>           <span class="title">i_mutex</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_when;<span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span>          dirtied_time_when;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>      <span class="title">i_hash</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>       <span class="title">i_io_list</span>;</span><span class="comment">/* backing dev IO list */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>   *<span class="title">i_wb</span>;</span><span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">        <span class="keyword">int</span>                     i_wb_frn_winner;</span><br><span class="line">        u16                     i_wb_frn_avg_time;</span><br><span class="line">        u16                     i_wb_frn_history;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_lru</span>;</span><span class="comment">/* inode LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">i_sb_list</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>  <span class="title">i_dentry</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">i_rcu</span>;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        u64                        i_version;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_dio_count;</span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_writecount;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_IMA</span></span><br><span class="line">        <span class="keyword">atomic_t</span>                   i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>   *<span class="title">i_fop</span>;</span><span class="comment">/* former -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>       *<span class="title">i_flctx</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>           <span class="title">i_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>               <span class="title">i_devices</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">i_pipe</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">i_bdev</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>            *<span class="title">i_cdev</span>;</span></span><br><span class="line">                <span class="keyword">char</span>                   *i_link;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        __u32                          i_generation;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">        __u32                          i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>              <span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>                           *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="title">unsigned</span> <span class="title">int</span>);</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * (*follow_link) (struct dentry *, <span class="keyword">void</span> **);</span><br><span class="line">        <span class="keyword">int</span> (*permission) (struct inode *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> * (*<span class="title">get_acl</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="title">int</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*readlink) (struct dentry *, <span class="keyword">char</span> __user *,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">void</span> (*put_link) (struct inode *, <span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> (*create) (struct inode *,struct dentry *, <span class="keyword">umode_t</span>, <span class="keyword">bool</span>);</span><br><span class="line">        <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*mkdir) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rmdir) (struct inode *,struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*mknod) (struct inode *,struct dentry *,<span class="keyword">umode_t</span>,<span class="keyword">dev_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*rename) (struct inode *, struct dentry *,</span><br><span class="line">                       struct inode *, struct dentry *);</span><br><span class="line">        <span class="keyword">int</span> (*rename2) (struct inode *, struct dentry *,</span><br><span class="line">                        struct inode *, struct dentry *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*setattr) (struct dentry *, struct iattr *);</span><br><span class="line">        <span class="keyword">int</span> (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</span><br><span class="line">        <span class="keyword">int</span> (*setxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *,<span class="keyword">const</span> <span class="keyword">void</span> *,<span class="keyword">size_t</span>,<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*getxattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">void</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">ssize_t</span> (*listxattr) (struct dentry *, <span class="keyword">char</span> *, <span class="keyword">size_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*removexattr) (struct dentry *, <span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">int</span> (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,</span><br><span class="line">                      u64 len);</span><br><span class="line">        <span class="keyword">int</span> (*update_time)(struct inode *, struct timespec *, <span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">int</span> (*atomic_open)(struct inode *, struct dentry *,</span><br><span class="line">                           struct file *, <span class="keyword">unsigned</span> open_flag,</span><br><span class="line">                           <span class="keyword">umode_t</span> create_mode, <span class="keyword">int</span> *opened);</span><br><span class="line">        <span class="keyword">int</span> (*tmpfile) (struct inode *, struct dentry *, <span class="keyword">umode_t</span>);</span><br><span class="line">        <span class="keyword">int</span> (*set_acl)(struct inode *, struct posix_acl *, <span class="keyword">int</span>);</span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表的是一个路径</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">        <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;<span class="comment">/* protected by d_lock */</span></span><br><span class="line">        <span class="keyword">seqcount_t</span> d_seq;<span class="comment">/* per dentry seqlock */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span><span class="comment">/* lookup hash list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span><span class="comment">/* parent directory */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span><span class="comment">/* Where the name belongs to - NULL is</span></span><br><span class="line"><span class="comment">                               ,* negative */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN];<span class="comment">/* small names */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span><span class="comment">/* per-dentry lock and refcount */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span><span class="comment">/* The root of the dentry tree */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;<span class="comment">/* used by d_revalidate */</span></span><br><span class="line">        <span class="keyword">void</span> *d_fsdata;<span class="comment">/* fs-specific data */</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span><span class="comment">/* LRU list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span><span class="comment">/* child of parent list */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span><span class="comment">/* our children */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span><span class="comment">/* inode alias list */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">        &#125; d_u;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 代表一个文件的引用（一个文件可以被打开多次就有多个引用，但inode却是仅有一个）</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>     <span class="title">fu_llist</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>       <span class="title">fu_rcuhead</span>;</span></span><br><span class="line">        &#125; f_u;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                   <span class="title">f_path</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                  *<span class="title">f_inode</span>;</span><span class="comment">/* cached value */</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>  *<span class="title">f_op</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">         ,* Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>                    f_lock;</span><br><span class="line">        <span class="keyword">atomic_long_t</span>                 f_count;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>                  f_flags;</span><br><span class="line">        <span class="keyword">fmode_t</span>                       f_mode;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>                  <span class="title">f_pos_lock</span>;</span></span><br><span class="line">        <span class="keyword">loff_t</span>                        f_pos;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>            <span class="title">f_owner</span>;</span></span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>             *<span class="title">f_cred</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>          <span class="title">f_ra</span>;</span></span><br><span class="line"></span><br><span class="line">        u64                           f_version;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">        <span class="keyword">void</span>                          *f_security;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* needed for tty driver, and maybe others */</span></span><br><span class="line">        <span class="keyword">void</span>                          *private_data;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">        <span class="comment">/* Used by fs/eventpoll.c to link all the hooks to this file */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_ep_links</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>              <span class="title">f_tfile_llink</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>          *<span class="title">f_mapping</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>)));<span class="comment">/* lest something weird decides that 2 is OK */</span></span><br></pre></td></tr></table></figure>

<p>inode Tab 存在于硬盘中，如果每次CPU从硬盘中读取那么效率会比较低下，<br>所以内核会为inode Table 申请一段内存以作为缓存，称为 <strong>对应文件系统的 inode cache</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">init_inodecache</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ext4_inode_cachep = kmem_cache_create(<span class="string">&quot;ext4_inode_cache&quot;</span>,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(struct ext4_inode_info),</span><br><span class="line">                                              <span class="number">0</span>, (SLAB_RECLAIM_ACCOUNT|</span><br><span class="line">                                                  SLAB_MEM_SPREAD),</span><br><span class="line">                                              init_once);</span><br><span class="line">        <span class="keyword">if</span> (ext4_inode_cachep == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样在VFS层面上，也会对抽象出来的 inode 和 路径进行缓存(dentry), 分别称为 icache 和 dcache.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __init <span class="title">dcache_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         ,* A constructor could be added for stable state like the lists,</span></span><br><span class="line"><span class="comment">         ,* but it is probably not worth it because of the cache nature</span></span><br><span class="line"><span class="comment">         ,* of the dcache.</span></span><br><span class="line"><span class="comment">         ,*/</span></span><br><span class="line">        dentry_cache = KMEM_CACHE(dentry,</span><br><span class="line">                                  SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in dcache_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        dentry_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Dentry cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_bl_head),</span><br><span class="line">                                        dhash_entries,</span><br><span class="line">                                        <span class="number">13</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;d_hash_shift,</span><br><span class="line">                                        &amp;d_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; d_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_BL_HEAD(dentry_hashtable + loop);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> __init <span class="title">inode_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> loop;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* inode slab cache */</span></span><br><span class="line">        inode_cachep = kmem_cache_create(<span class="string">&quot;inode_cache&quot;</span>,</span><br><span class="line">                                         <span class="keyword">sizeof</span>(struct inode),</span><br><span class="line">                                         <span class="number">0</span>,</span><br><span class="line">                                         (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|</span><br><span class="line">                                          SLAB_MEM_SPREAD),</span><br><span class="line">                                         init_once);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Hash may have been set up in inode_init_early */</span></span><br><span class="line">        <span class="keyword">if</span> (!hashdist)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        inode_hashtable =</span><br><span class="line">                alloc_large_system_hash(<span class="string">&quot;Inode-cache&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(struct hlist_head),</span><br><span class="line">                                        ihash_entries,</span><br><span class="line">                                        <span class="number">14</span>,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        &amp;i_hash_shift,</span><br><span class="line">                                        &amp;i_hash_mask,</span><br><span class="line">                                        <span class="number">0</span>,</span><br><span class="line">                                        <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (loop = <span class="number">0</span>; loop &lt; (<span class="number">1U</span> &lt;&lt; i_hash_shift); loop++)</span><br><span class="line">                INIT_HLIST_HEAD(&amp;inode_hashtable[loop]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这些申请的缓存都是内核通过LRU算法进行回收的(内核通过 shrink方法来回收slab内存)</p>
<ul>
<li>shrink 方法需要驱动编写者来主动实现</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>fs</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Grabserial来检测代码运行时间</title>
    <url>/2023/08/10/linux_kernel_debug_grabserial_tutorial/</url>
    <content><![CDATA[<p><a href="https://elinux.org/Grabserial">Grabserial</a> 是一个串口监视工具，其最大的特色在于：可以监视每一行串口输出的时间和相对上一行串口输出的时间差。</p>
<p>基础此功能，我们可以推导出使用此工具可以完成以下调试工作：</p>
<ol>
<li>检查系统启动的完整时间（Linux，RT-thread…）</li>
<li>检查特定一段代码的运行时间(比如调试应用程序的算法效率)</li>
</ol>
<blockquote>
<p><code>minicom</code> 使用 <code>CTAL + a + n</code> 也可以打开时间戳模式，但是最多只能精确到 1ms 并且没有时间差的显示</p>
</blockquote>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拷贝库</span></span><br><span class="line">git clone https://github.com/tbird20d/grabserial</span><br><span class="line">cd grabserial</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>grabserial 的默认配置为：</p>
<ul>
<li>端口号： /dev/ttyS0</li>
<li>波特率： 115200</li>
<li>8位数据位且无停止位</li>
</ul>
<p>所以一般情况下在传输协议上的设置只需要设置端口号即可。</p>
<p>其输出格式为： [绝对时间][相对上一行的时间] 串口内容</p>
<p><strong>以下命令都比较长，建议常用的命令可以使用 alias命令封装一次。</strong></p>
<h2 id="持续捕捉输出"><a href="#持续捕捉输出" class="headerlink" title="持续捕捉输出"></a>持续捕捉输出</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 显示详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 设置端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 显示每一行的时间</span></span><br><span class="line">sudo grabserial -v -d /dev/ttyUSB0 -t</span><br></pre></td></tr></table></figure>

<p>使用上面的命令 grabserial 将会一直捕捉标准输出，使用 <code>CTRL+C</code> 退出。</p>
<h2 id="捕捉系统的启动时间"><a href="#捕捉系统的启动时间" class="headerlink" title="捕捉系统的启动时间"></a>捕捉系统的启动时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 显示详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 设置端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 显示每一行的时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e 持续捕捉多少秒</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -m 当匹配到指定字符串后，清零时间重新计时(字符串使用正则表达式)</span></span><br><span class="line">sudo grabserial -v -d /dev/ttyUSB0 -e 30 -t -m &quot;^Linux version.*&quot;</span><br></pre></td></tr></table></figure>

<h2 id="捕捉两段特定输出之间的时间差"><a href="#捕捉两段特定输出之间的时间差" class="headerlink" title="捕捉两段特定输出之间的时间差"></a>捕捉两段特定输出之间的时间差</h2><p><strong>注意：</strong> 此命令需要字符串输出在同一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -v 显示详细信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 设置端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t 显示每一行的时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -i 一行中的停止字符串(字符串使用正则表达式)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此行命令用户捕捉Linux内核的解压缩时间</span></span><br><span class="line">sudo grabserial -v -d /dev/ttyUSB0 -e 30 -t -m &quot;Uncompressing Linux&quot; -i &quot;done,&quot;</span><br></pre></td></tr></table></figure>

<h1 id="关于网络数据的时间截取"><a href="#关于网络数据的时间截取" class="headerlink" title="关于网络数据的时间截取"></a>关于网络数据的时间截取</h1><p>有的时候需要截取通过网络发送过来信息的时间戳，对此有两个解决方案：</p>
<ol>
<li>通过分析 grabserial 的代码，为其添加连接 socket 的代码</li>
<li>通过 secure CRT 的日志时间戳功能粗略的计算</li>
</ol>
<ul>
<li>此方法无法显示时间戳的相对值</li>
</ul>
<h2 id="通过secure-CRT-来截取"><a href="#通过secure-CRT-来截取" class="headerlink" title="通过secure CRT 来截取"></a>通过secure CRT 来截取</h2><p>在 <code>Session Optons -&gt; Log File</code> 中依次做如下设置：</p>
<ul>
<li>在 <code>Log file name</code> 来设置输出日志文件名</li>
<li>选中 <code>Start log upon connect</code> 选项</li>
<li>在 <code>On each line:</code> 条目中输入 “%h:%m:%s(%t):” (去掉引号) 以显示时:分:秒:(毫秒)</li>
<li>然后重新连接服务器即可</li>
</ul>
<p>关于时间戳可以用的格式如下(更多的信息需查看其help文件)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">H - hostname</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">S - session name</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">Y - four-digit year</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">y - two-digit year</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">M - two-digit month</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">D - two-digit day of the month</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">P - port</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">h - two-digit hour</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">m - two-digit minute</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">s - two-digit seconds</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">t - three-digit milliseconds</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">% - percent (%)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">%</span><span class="bash">envvar% - environment variable</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试之Oops</title>
    <url>/2023/08/08/linux_kernel_debug_oops/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>总结在Linux内核下使用 Oops 输出调试内核。</p>
<span id="more"></span>

<h1 id="输出分析"><a href="#输出分析" class="headerlink" title="输出分析"></a>输出分析</h1><p>当内核出现异常时，内核会抛出 Oops 信息，这些信息会被输出到控制台。</p>
<p>在Oops 的输出信息中, 需要注意的一些信息是:</p>
<ul>
<li>Oops 最开始的输出信息中已经大致说明了异常的原因</li>
<li><code>PC is at [function_name] + [address]</code> ：此行指出了出错的函数，以及执行语句在函数中的偏移地址。 然后可以通过命令得出反汇编代码, 找出C代码位置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-objdump -d -S file.o</span><br></pre></td></tr></table></figure>

<ul>
<li>寄存器列表：当出错的函数有参数时, 可以通过寄存器列表来查看输入的参数是否正确(如果参数过多, 还要查看栈信息)</li>
<li>函数调用顺序：通过查看栈信息, 可以知道此函数是如何被以层层调用进来的</li>
</ul>
<h1 id="Oops-与-Panic"><a href="#Oops-与-Panic" class="headerlink" title="Oops 与 Panic"></a>Oops 与 Panic</h1><p>Panic 属于 Oops 的一种，内核发现异常会抛出Oops，但错误不严重的情况下内核还会继续运行。如果严重则会抛出 Panic，此时内核便会停止运行。</p>
<p>但为了便于调试，一般需要做如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/kernel/panic_on_oops</span><br></pre></td></tr></table></figure>

<p>这是为了内核无论是出现 Oops 还是 Panic 都要停止内核运行，以便正确并及时的捕捉错误的位置。</p>
<h1 id="显示使用-BUG-ON-和-WARN-ON"><a href="#显示使用-BUG-ON-和-WARN-ON" class="headerlink" title="显示使用 BUG_ON() 和 WARN_ON()"></a>显示使用 BUG_ON() 和 WARN_ON()</h1><p>BUG_ON() 和 WARN_ON() 是内核提供的警告宏。</p>
<p>首先使能 <code>CONFIG_BUG</code> 宏:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">General setup -&gt; Configure standard kernel features(expert users) -&gt; BUG() support</span><br></pre></td></tr></table></figure>

<p>其中BUG_ON()成立时主动抛出 Oops 的宏，WARN_ON() 成立时抛出栈调用。我们在必要的位置可以加上者两个宏,以达到：</p>
<ul>
<li>判断出了错误</li>
<li>查看错误时的参数调用</li>
<li>查看函数调用栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// path of file: /include/asm-generic/bug.h</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t use BUG() or BUG_ON() unless there&#x27;s really no way out; one</span></span><br><span class="line"><span class="comment"> * example might be detecting data structure corruption in the middle</span></span><br><span class="line"><span class="comment"> * of an operation that can&#x27;t be backed out of.  If the (sub)system</span></span><br><span class="line"><span class="comment"> * can somehow continue operating, perhaps with reduced functionality,</span></span><br><span class="line"><span class="comment"> * it&#x27;s probably not BUG-worthy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you&#x27;re tempted to BUG(), think again:  is completely giving up</span></span><br><span class="line"><span class="comment"> * really the *only* solution?  There are usually better options, where</span></span><br><span class="line"><span class="comment"> * users don&#x27;t need to reboot ASAP and can mostly shut down cleanly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_ARCH_BUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUG() do &#123; \</span></span><br><span class="line"><span class="meta">	printk(<span class="meta-string">&quot;BUG: failure at %s:%d/%s()!\n&quot;</span>, __FILE__, __LINE__, __func__); \</span></span><br><span class="line"><span class="meta">	barrier_before_unreachable(); \</span></span><br><span class="line"><span class="meta">	panic(<span class="meta-string">&quot;BUG!&quot;</span>); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_ARCH_BUG_ON</span></span><br><span class="line"><span class="comment">// 当 condition 为真时，才会触发 BUG()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUG_ON(condition) do &#123; <span class="meta-keyword">if</span> (unlikely(condition)) BUG(); &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WARN_ON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WARN_ON(condition) (&#123;						\</span></span><br><span class="line"><span class="meta">	int __ret_warn_on = !!(condition);				\</span></span><br><span class="line"><span class="meta">	<span class="meta-keyword">if</span> (unlikely(__ret_warn_on))					\</span></span><br><span class="line"><span class="meta">		__WARN();						\</span></span><br><span class="line"><span class="meta">	unlikely(__ret_warn_on);					\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 printk 调试内核</title>
    <url>/2023/07/31/linux_kernel_debug_printk/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>总结在 Linux 内核下使用串口打印调试信息。</p>
<span id="more"></span>

<h1 id="printk-基本使用"><a href="#printk-基本使用" class="headerlink" title="printk 基本使用"></a>printk 基本使用</h1><p><code>printk()</code> 函数用于打印内核的调试信息，同时会将这些信息输出到一个缓冲区中。</p>
<p>可以通过 <code>dmesg</code> 命令查看内核打印缓冲区, 当使用 <code>dmesg -c</code> 则不仅会显示 <code>__log_buf</code> 还会清除该缓冲区的内容。</p>
<p>也可以通过 <code>cat /proc/kmsg</code> 命令来一直显示内核信息。</p>
<h2 id="信息缓冲区大小设置"><a href="#信息缓冲区大小设置" class="headerlink" title="信息缓冲区大小设置"></a>信息缓冲区大小设置</h2><p>信息缓冲区的填写是一个环形队列的形式，所以如果消息太多以前的消息就会被覆盖掉，有的时候需要设置更大的缓冲区显示更多的信息。</p>
<p>信息缓冲区代码位于 <code>kernel/printk/printk.c</code> 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span></span><br><span class="line"><span class="comment">// 限制最大的日志大小是 2G</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_LEN_MAX (u32)(1 &lt;&lt; 31)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *log_buf = __log_buf;</span><br><span class="line"><span class="keyword">static</span> u32 log_buf_len = __LOG_BUF_LEN;</span><br></pre></td></tr></table></figure>

<p>可以看出缓存的大小是 <code>2 ^ CONFIG_LOG_BUF_SHIFT</code> 个字节， <code>CONFIG_LOG_BUF_SHIFT</code> 的设置是由 <code>init/Kconfig</code> 来完成的，在Menuconfig中的路径为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">General setup -&gt; Kernel log buffer size(16 =&gt; 64KB, 17 =&gt; 128kB)</span><br></pre></td></tr></table></figure>

<p>但如果在启动参数中使用<code>log_buf_len</code>，则以启动参数中的值为准。</p>
<p>如果存在多核对称处理器（SMP），那么还会根据<code>CONFIG_LOG_CPU_MAX_BUF_SHIFT</code> 来配置日志缓存的大小（参考 <code>log_buf_add_cpu()</code> 函数）。</p>
<blockquote>
<p>由于上面的缓存是 static 形式的，所以如果 SMP 新增日志缓存生效，则意味着这段内存就不会被使用（浪费了）。</p>
</blockquote>
<h2 id="消息级别"><a href="#消息级别" class="headerlink" title="消息级别"></a>消息级别</h2><p>printk()定义了8个消息级别(0~7)，<strong>数值越低，级别越高</strong> 。</p>
<p>在实际使用中，会有默认的消息级别打印， <strong>只有低于消息级别的消息才会打印</strong> 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 位于 /include/linux/kern_levels.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_SOH   <span class="meta-string">&quot;\001&quot;</span>  <span class="comment">/*ASCII Start of header*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_SOH_ASCII <span class="meta-string">&#x27;\001&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_EMERG   KERN_SOH <span class="meta-string">&quot;0&quot;</span> <span class="comment">//紧急事件,一般是系统崩溃之前提示的消息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_ALERT   KERN_SOH <span class="meta-string">&quot;1&quot;</span> <span class="comment">//必须立即采取行动</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_CRIT    KERN_SOH <span class="meta-string">&quot;2&quot;</span> <span class="comment">//临界状态,通常涉及严重的硬件或软件操作失败</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_ERR     KERN_SOH <span class="meta-string">&quot;3&quot;</span> <span class="comment">//用于报告错误状态,设备驱动代码经常使用它报告硬件问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_WARNING KERN_SOH <span class="meta-string">&quot;4&quot;</span> <span class="comment">//对可能出现问题的情况进行警告,不会对系统造成严重的问题</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_NOTICE  KERN_SOH <span class="meta-string">&quot;5&quot;</span> <span class="comment">//有必要进行提示的正常情形,许多与安全攸关的情况用这个级别</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_INFO    KERN_SOH <span class="meta-string">&quot;6&quot;</span> <span class="comment">//提示性的信息,驱动程序使用它打印出一般信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_DEBUG   KERN_SOH <span class="meta-string">&quot;7&quot;</span> <span class="comment">//调试信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERN_DEFAULT  <span class="meta-string">&quot;&quot;</span> <span class="comment">//默认级别</span></span></span><br></pre></td></tr></table></figure>

<h2 id="修改消息级别的方法"><a href="#修改消息级别的方法" class="headerlink" title="修改消息级别的方法"></a>修改消息级别的方法</h2><h3 id="在menuconfig中修改"><a href="#在menuconfig中修改" class="headerlink" title="在menuconfig中修改"></a>在menuconfig中修改</h3><p>对应的路径为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Kernel hacking -&gt; printk and dmesg options -&gt; Default message log level(1-7)</span><br></pre></td></tr></table></figure>

<h3 id="在系统中修改-prink-文件"><a href="#在系统中修改-prink-文件" class="headerlink" title="在系统中修改 prink 文件:"></a>在系统中修改 prink 文件:</h3><p>通过 <code>/proc/sys/kernel/printk</code> 文件可以调节 printk() 的输出等级,该文件的4个数值表示为：</p>
<ol>
<li>控制台的日志级别：当前的打印级别，优先级高于该值（值越小，优先级越高）的消息将被打印至控制台</li>
<li>默认的消息日志级别：将用该优先级来打印没有优先级前缀的消息,也就是直接写 <code>printk(&quot;xxx&quot;)</code> 而不带打印级别的情况下，会使用该打印级别</li>
<li>最低的控制台日志级别：控制台日志级别可被设置的最小值（一般是1）</li>
<li>默认的控制台日志级别：控制台日志级别的默认值</li>
</ol>
<p>使用如下命令打印所有信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shell</span><br><span class="line">#echo 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<p>此文件并不控制内核消息进入 <code>__log_buf</code> 的门槛，因此无论消息级别是多少,都会进入 <code>__log_buf</code> 中，但是最终只有高于当前打印级别的内核消息才会从控制台打印。</p>
<h3 id="修改启动参数"><a href="#修改启动参数" class="headerlink" title="修改启动参数"></a>修改启动参数</h3><p>通过在 <code>bootargs</code> 中设置 <code>ignore_loglevel</code> 来忽略打印级别。<br>在系统启动后，也可以通过写 <code>/sys/module/printk/parameters/ignore_loglevel</code> 文件来动态设置是否忽略打印级别。</p>
<h2 id="带时间戳的输出"><a href="#带时间戳的输出" class="headerlink" title="带时间戳的输出"></a>带时间戳的输出</h2><p>在 <code>menuconfig</code> 中使能 <code>printk</code> 带时间戳输出，有助于判断代码执行时间。</p>
<p>路径:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Kernel hacking -&gt; printk and dmesg options -&gt; Show timing information on printks</span><br></pre></td></tr></table></figure>

<h1 id="调试信息的输出"><a href="#调试信息的输出" class="headerlink" title="调试信息的输出"></a>调试信息的输出</h1><h2 id="pr-xxx-位于-include-linux-printk-h"><a href="#pr-xxx-位于-include-linux-printk-h" class="headerlink" title="pr_xxx(): 位于 /include/linux/printk.h"></a>pr_xxx(): 位于 <code>/include/linux/printk.h</code></h2><p>通常使用封装了 <code>printk()</code> 的宏，来显示调试信息。比如 <code>pr_debug()</code>，<code>pr_info()</code>。<br>使用 <code>pr_xxx()</code> API的好处是可以在文件最开头通过 <code>pr_fmt()</code> 定义一个打印格式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印消息头带有 &quot;[driver] watchdog:&quot;前缀</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) <span class="meta-string">&quot;[driver] watchdog:&quot;</span> fmt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于模块的话，可以使用模块名称的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) KBUILD_MODNAME <span class="meta-string">&quot;: &quot;</span> fmt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果要打印函数名的话，还可以这样：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) <span class="meta-string">&quot;%s:%s: &quot;</span> fmt, KBUILD_MODNAME, __func__</span></span><br></pre></td></tr></table></figure>

<p>定义打印格式后，其实就是在 <code>printk</code> 前加入该宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pr_info - Print an info-level message</span></span><br><span class="line"><span class="comment"> * @fmt: format string</span></span><br><span class="line"><span class="comment"> * @...: arguments for the format string</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This macro expands to a printk with KERN_INFO loglevel. It uses pr_fmt() to</span></span><br><span class="line"><span class="comment"> * generate the format string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">	printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<h2 id="dev-xxx-位于-include-linux-dev-printk-h"><a href="#dev-xxx-位于-include-linux-dev-printk-h" class="headerlink" title="dev_xxx(): 位于 /include/linux/dev_printk.h"></a>dev_xxx(): 位于 <code>/include/linux/dev_printk.h</code></h2><p>使用<code>dev_xxx()</code> 打印的时候，设备名称会被自动打印到打印消息的前面。</p>
<h2 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h2><ul>
<li>能使用 <code>dev_xxx()</code> 的时候就尽量使用它，因为它可以打印出设备的名称。<ul>
<li>这在一个驱动对应多个设备，而某个设备出问题的情况下比较好排查。</li>
</ul>
</li>
<li>在不能使用 <code>dev_xxx()</code> 的场合才使用 <code>pr_xxx()</code> <ul>
<li>为了明确信息是由 <code>pr_xxx()</code> 输出的信息，建议在信息头中加上标识符。<ul>
<li>驱动中调试加上 <code>[driver]</code></li>
<li>内存中调试加上 <code>[mem]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="默认调试信息输出"><a href="#默认调试信息输出" class="headerlink" title="默认调试信息输出"></a>默认调试信息输出</h2><p>内核默认有很多使用 <code>pr_debug()</code>/<code>dev_dbg()</code> 的输出,但需要满足如下条件:</p>
<ol>
<li>开启了 DEBUG 宏</li>
<li>kernel printk 的默认日志级别大于7</li>
</ol>
<h3 id="开启DEBUG"><a href="#开启DEBUG" class="headerlink" title="开启DEBUG"></a>开启DEBUG</h3><ul>
<li>方法1：在要输出信息的文件的<strong>最开头</strong>加上宏定义 <code>#define DEBUG</code></li>
<li>方法2：在编译内核的时候传入参数 <code>KCFLAGS=-DDEBUG</code> 打开全局输出（不推荐，相关的输出实在是太多了）</li>
</ul>
<h1 id="早期信息的打印"><a href="#早期信息的打印" class="headerlink" title="早期信息的打印"></a>早期信息的打印</h1><h2 id="使能"><a href="#使能" class="headerlink" title="使能"></a>使能</h2><p>为了能够在控制台驱动初始化之前就打印信息,需要在<code>menuconfig</code>中设置: </p>
<ul>
<li>选择 <code>Kernel low-level debug</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Kernel hacking &gt; arm Debugging -&gt; Kernel low-<span class="function">level debugging <span class="title">functions</span><span class="params">(read help!)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>选择 Early printk</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Kernel hacking -&gt; Early printk</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>bootargs</code> 中添加 <code>earlyprintk</code> 字符串</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/early_printk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">early_printk(<span class="string">&quot;Hello world\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="与用户空间顺序输出"><a href="#与用户空间顺序输出" class="headerlink" title="与用户空间顺序输出"></a>与用户空间顺序输出</h1><p>在精简的嵌入式系统中，当用户空间在使用 <code>printf</code> 的同时内核在使用 <code>printk</code> 时会造成两个输出相互干扰，与造成竞态的效果一样。</p>
<p>内核为用户空间提供了设备文件 <code>/dev/ttyprintk</code> 以让用户空间的log可以在内核中打印，打印的Log前会加上 <code>[U]</code> 标识，<br>这样便不会造成二者干扰了。</p>
<p>在嵌入式内核中，可能没有 <code>/dev/ttyprintk</code> 设备，可以使用 <code>/dev/kmsg</code> 来达到目的。</p>
<p>通过 <code>/dev/kmsg</code> 没有前缀输出，但是我们可以自己加入前缀以达到同样的效果。</p>
<p>如下用户空间代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KernelWrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	n = vsnprintf(buf, <span class="number">256</span>, fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">	write(fd, buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/ttyprintk&quot;</span>, O_WRONLY);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open file failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	KernelWrite(<span class="string">&quot;The ttyprintk index is %d\n&quot;</span>, fd);</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>dmesg</code> 查看，输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[U] The ttyprintk index is 3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 Linux 内核中的双向环形链表</title>
    <url>/2023/03/26/linux_kernel_ds_list/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>Linux 内核中的双向环形链表，巧妙的实现了将对象挂在节点上，而不是传统的将节点挂在对象上。</p>
<span id="more"></span>

<p>linux 在 <code>include/linux/list.h</code> 中提供了双向环形链表的操作函数，此代码可以移植到其他应用环境中,方便使用。</p>
<blockquote>
<p>在内核编程环境中，需要 <code>#include &lt;linux/list.h&gt;</code> 来包含该头文件</p>
</blockquote>
<p>需要注意的是：</p>
<ol>
<li>linux是通过<strong>将此链表嵌入在其他数据结构中， 从而将很多不同的数据结构链接起来！</strong>（而不是链表中包含数据）。</li>
<li>函数中的参数 <code>head</code> 代表的即为链表头！</li>
<li><code>typeof</code> 是GCC扩展的关键字, 所以不能在编译选项中添加 <code>-std=c99</code> ，而是使用 <code>-std=gnu99</code> 。<ul>
<li>为了兼容所有编译器，我在<a href="https://github.com/KcMeterCEC/common_code/tree/master/c/data_structure/list/circular">github</a>中移植了通用版本。</li>
</ul>
</li>
</ol>
<h1 id="认识环形链表"><a href="#认识环形链表" class="headerlink" title="认识环形链表"></a>认识环形链表</h1><h2 id="认识节点"><a href="#认识节点" class="headerlink" title="认识节点"></a>认识节点</h2><p>通过阅读代码来理解实现，那么首先来看链表中的节点是如何定义的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>list_head</code>就代表一个节点，节点包含指向上一个节点和下一个节点的前驱（prev）和后继（next）指针。</p>
<h2 id="定义并初始化头节点"><a href="#定义并初始化头节点" class="headerlink" title="定义并初始化头节点"></a>定义并初始化头节点</h2><p>在链表中，首先需要创建的便是头节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">    struct list_head name = LIST_HEAD_INIT(name)</span></span><br></pre></td></tr></table></figure>

<p>宏<code>LIST_HEAD</code>便完成了定义头节点，并对其完成初始化。初始化后的头节点其前驱和后继指针都指向自己，这便形成了最初始的环（也就空链表）。</p>
<p>除了上面的宏完成定义和初始化外，还有函数来单独初始化头节点，相当于将节点初始化为空链表了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_LIST_HEAD</span><span class="params">(struct list_head *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">    WRITE_ONCE(<span class="built_in">list</span>-&gt;prev, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于是在后期对节点的更改，这里使用了<code>WRITE_ONCE</code>原子操作来避免 data race。</p>
</blockquote>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><h3 id="底层操作"><a href="#底层操作" class="headerlink" title="底层操作"></a>底层操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_add(struct list_head *<span class="keyword">new</span>,</span><br><span class="line">                  struct list_head *prev,</span><br><span class="line">                  struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!__list_add_valid(<span class="keyword">new</span>, prev, next))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = prev;</span><br><span class="line">    WRITE_ONCE(prev-&gt;next, <span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的目的就是将节点<code>new</code>插入到节点<code>prev</code>和<code>next</code>之间。</p>
<p>其中这里面的<code>__list_add_valid</code>则是对参数的正确性做检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> __must_check <span class="keyword">bool</span> <span class="title">check_data_corruption</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_DATA_CORRUPTION(condition, fmt, ...)             \</span></span><br><span class="line"><span class="meta">    check_data_corruption((&#123;                     \</span></span><br><span class="line"><span class="meta">        bool corruption = unlikely(condition);             \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (corruption) &#123;                     \</span></span><br><span class="line"><span class="meta">            <span class="meta-keyword">if</span> (IS_ENABLED(CONFIG_BUG_ON_DATA_CORRUPTION)) &#123; \</span></span><br><span class="line"><span class="meta">                pr_err(fmt, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">                BUG();                     \</span></span><br><span class="line"><span class="meta">            &#125; <span class="meta-keyword">else</span>                         \</span></span><br><span class="line"><span class="meta">                WARN(1, fmt, ##__VA_ARGS__);         \</span></span><br><span class="line"><span class="meta">        &#125;                             \</span></span><br><span class="line"><span class="meta">        corruption;                         \</span></span><br><span class="line"><span class="meta">    &#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> __list_add_valid(struct list_head *<span class="keyword">new</span>, struct list_head *prev,</span><br><span class="line">              struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (CHECK_DATA_CORRUPTION(prev == <span class="literal">NULL</span>,</span><br><span class="line">            <span class="string">&quot;list_add corruption. prev is NULL.\n&quot;</span>) ||</span><br><span class="line">        CHECK_DATA_CORRUPTION(next == <span class="literal">NULL</span>,</span><br><span class="line">            <span class="string">&quot;list_add corruption. next is NULL.\n&quot;</span>) ||</span><br><span class="line">        CHECK_DATA_CORRUPTION(next-&gt;prev != prev,</span><br><span class="line">            <span class="string">&quot;list_add corruption. next-&gt;prev should be prev (%px), but was %px. (next=%px).\n&quot;</span>,</span><br><span class="line">            prev, next-&gt;prev, next) ||</span><br><span class="line">        CHECK_DATA_CORRUPTION(prev-&gt;next != next,</span><br><span class="line">            <span class="string">&quot;list_add corruption. prev-&gt;next should be next (%px), but was %px. (prev=%px).\n&quot;</span>,</span><br><span class="line">            next, prev-&gt;next, prev) ||</span><br><span class="line">        CHECK_DATA_CORRUPTION(<span class="keyword">new</span> == prev || <span class="keyword">new</span> == next,</span><br><span class="line">            <span class="string">&quot;list_add double add: new=%px, prev=%px, next=%px.\n&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span>, prev, next))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__list_add_valid);</span><br></pre></td></tr></table></figure>

<p>上面这个函数就是为了检查以下几种异常：</p>
<ol>
<li><p>prev 或 next 节点是空指针</p>
</li>
<li><p>prev 和 next 节点并不是相邻的关系，如果继续操作则会跳过中间的节点</p>
</li>
<li><p>new 等于 prev 或 next 节点</p>
</li>
</ol>
<p>有了前面的底层操作函数，其它的操作便可以基于此来完成了。</p>
<h3 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将节点 new 插入到节点 head 的后面，就像是一个压栈的操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将节点 new 插入到节点 head 的前面，就像是插入到队列尾部</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_add_tail</span><span class="params">(struct list_head *<span class="keyword">new</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_add(<span class="keyword">new</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><h3 id="底层操作-1"><a href="#底层操作-1" class="headerlink" title="底层操作"></a>底层操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    WRITE_ONCE(prev-&gt;next, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除<code>prev</code>和<code>next</code>之间的所有节点，这其实可以删除 0~N 个节点，但一般都用于删除一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_clearprev(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">    entry-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数相当于将节点 entry 从链表中删除了，且 entry 的 prev 指向了空。主要是用于网络代码中使用，以高效的删除一个节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_del_entry(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!__list_del_entry_valid(entry))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就是删除<code>entry</code>这个节点。</p>
<h3 id="用户接口-1"><a href="#用户接口-1" class="headerlink" title="用户接口"></a>用户接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are non-NULL pointers that will result in page faults</span></span><br><span class="line"><span class="comment"> * under normal circumstances, used to verify that nobody uses</span></span><br><span class="line"><span class="comment"> * non-initialized list entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_POISON2  ((void *) 0x122 + POISON_POINTER_DELTA)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    entry-&gt;next = LIST_POISON1;</span><br><span class="line">    entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数才应该是用户所使用的函数，删除节点后，将节点的前驱和后继指针都指向了一段特殊地址。如果有代码操作该特殊地址便会触发 pagefault。 </p>
<h2 id="其它用户操作接口"><a href="#其它用户操作接口" class="headerlink" title="其它用户操作接口"></a>其它用户操作接口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 old 节点替换为 new 节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace</span><span class="params">(struct list_head *old,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = old-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next-&gt;prev = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev = old-&gt;prev;</span><br><span class="line">    <span class="keyword">new</span>-&gt;prev-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 old 节点替换为 new 节点，并且将 old 节点初始化一个空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_replace_init</span><span class="params">(struct list_head *old,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct list_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_replace(old, <span class="keyword">new</span>);</span><br><span class="line">    INIT_LIST_HEAD(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换 entry1 和 entry2 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_swap</span><span class="params">(struct list_head *entry1,</span></span></span><br><span class="line"><span class="params"><span class="function">                 struct list_head *entry2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span> =</span> entry2-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list_del</span>(entry2);</span><br><span class="line">    <span class="built_in">list_replace</span>(entry1, entry2);</span><br><span class="line">    <span class="keyword">if</span> (pos == entry1)</span><br><span class="line">        pos = entry2;</span><br><span class="line">    <span class="built_in">list_add</span>(entry1, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从链表上删除 entry 并将 entry 初始化为空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    INIT_LIST_HEAD(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点 list 从其原来的列表删除，然后放到节点 head 的后面</span></span><br><span class="line"><span class="comment">// 那就是说：将 list 节点移动到节点 head 后面</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_move</span><span class="params">(struct list_head *<span class="built_in">list</span>, struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 list 节点移动到节点 head 前面</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_move_tail</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                  struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">    list_add_tail(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 first 至 last 节点之间（包含二者）的所有节点，移动到 head 节点之前</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_bulk_move_tail</span><span class="params">(struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">                       struct list_head *first,</span></span></span><br><span class="line"><span class="params"><span class="function">                       struct list_head *last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    first-&gt;prev-&gt;next = last-&gt;next;</span><br><span class="line">    last-&gt;next-&gt;prev = first-&gt;prev;</span><br><span class="line"></span><br><span class="line">    head-&gt;prev-&gt;next = first;</span><br><span class="line">    first-&gt;prev = head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    last-&gt;next = head;</span><br><span class="line">    head-&gt;prev = last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当当前节点的前驱节点是头节点时，那就意味着它是第一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_first</span><span class="params">(<span class="keyword">const</span> struct list_head *<span class="built_in">list</span>, <span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;prev == head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当当前节点的后继节点是头节点时，那就意味着它是最后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_last</span><span class="params">(<span class="keyword">const</span> struct list_head *<span class="built_in">list</span>, <span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;next == head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当当前节点的地址与头节点一致，那它就是头节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_head</span><span class="params">(<span class="keyword">const</span> struct list_head *<span class="built_in">list</span>, <span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span> == head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当头节点的后继节点是自己时，那这就是一个空链表了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> READ_ONCE(head-&gt;next) == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存安全形式的删除节点和置空一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_del_init_careful</span><span class="params">(struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __list_del_entry(entry);</span><br><span class="line">    WRITE_ONCE(entry-&gt;prev, entry);</span><br><span class="line">    smp_store_release(&amp;entry-&gt;next, entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 确保在没有其它线程操作该链表时，判断链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_empty_careful</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span> =</span> smp_load_acquire(&amp;head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> list_is_head(next, head) &amp;&amp; (next == READ_ONCE(head-&gt;prev));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将头节点右边的节点移动到头节点的左边</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_rotate_left</span><span class="params">(struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">first</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(head)) &#123;</span><br><span class="line">        first = head-&gt;next;</span><br><span class="line">        list_move_tail(first, head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动 head 节点到 list 节点前面，那就是说 list 节点就是第一个节点了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_rotate_to_front</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list_move_tail(head, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前链表仅有一个节点时，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">list_is_singular</span><span class="params">(<span class="keyword">const</span> struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="切割链表"><a href="#切割链表" class="headerlink" title="切割链表"></a>切割链表</h2><h3 id="底层操作-2"><a href="#底层操作-2" class="headerlink" title="底层操作"></a>底层操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 head 之后一直到 entry（包含 entry）的节点切割到以 list 为头节点的链表中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_cut_position(struct list_head *<span class="built_in">list</span>,</span><br><span class="line">        struct list_head *head, struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">new_first</span> =</span> entry-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = head-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = entry;</span><br><span class="line">    entry-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    head-&gt;next = new_first;</span><br><span class="line">    new_first-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 list 中的节点插入到节点 prev 和 next 之间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __list_splice(<span class="keyword">const</span> struct list_head *<span class="built_in">list</span>,</span><br><span class="line">                 struct list_head *prev,</span><br><span class="line">                 struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">first</span> =</span> <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">last</span> =</span> <span class="built_in">list</span>-&gt;prev;</span><br><span class="line"></span><br><span class="line">    first-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = first;</span><br><span class="line"></span><br><span class="line">    last-&gt;next = next;</span><br><span class="line">    next-&gt;prev = last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户接口-2"><a href="#用户接口-2" class="headerlink" title="用户接口"></a>用户接口</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 head 之后一直到 entry（包含 entry）的节点切割到以 list 为头节点的链表中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_cut_position</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        struct list_head *head, struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(head))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_is_singular(head) &amp;&amp; !list_is_head(entry, head) &amp;&amp; (entry != head-&gt;next))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_is_head(entry, head))</span><br><span class="line">        INIT_LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __list_cut_position(<span class="built_in">list</span>, head, entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 head 之后及 entry 之前(不包含 entry)的节点移动到 list 为头节点的链表中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_cut_before</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct list_head *head,</span></span></span><br><span class="line"><span class="params"><span class="function">                   struct list_head *entry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == entry) &#123;</span><br><span class="line">        INIT_LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = head-&gt;next;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev = entry-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;prev-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    head-&gt;next = entry;</span><br><span class="line">    entry-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 list 中的节点插入到节点 head 之后</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice</span><span class="params">(<span class="keyword">const</span> struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>))</span><br><span class="line">        __list_splice(<span class="built_in">list</span>, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 list 中的节点插入到节点 head 之前</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_tail</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>))</span><br><span class="line">        __list_splice(<span class="built_in">list</span>, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 list 中的节点插入到节点 head 之后，并设 list 为空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_init</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                    struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        __list_splice(<span class="built_in">list</span>, head, head-&gt;next);</span><br><span class="line">        INIT_LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 list 中的节点插入到节点 head 之前，并设 list 为空链表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">list_splice_tail_init</span><span class="params">(struct list_head *<span class="built_in">list</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                     struct list_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        __list_splice(<span class="built_in">list</span>, head-&gt;prev, head);</span><br><span class="line">        INIT_LIST_HEAD(<span class="built_in">list</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏操作"><a href="#宏操作" class="headerlink" title="宏操作"></a>宏操作</h2><p>双向环形链表需要配合宏操作才能够发挥其威力。</p>
<h3 id="反推节点的地址"><a href="#反推节点的地址" class="headerlink" title="反推节点的地址"></a>反推节点的地址</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Are two types/vars the same type (ignoring qualifiers)? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __same_type(a, b) \</span></span><br><span class="line"><span class="meta"> __builtin_types_compatible_p(typeof(a), typeof(b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 0 地址强行转换为 type 类型，然后便可以得出 member 成员在该结构体中的偏移值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ptr ：当前数据成员的地址</span></span><br><span class="line"><span class="comment">// type ：当前结构体类型</span></span><br><span class="line"><span class="comment">// member ：该数据成员在结构体的名称</span></span><br><span class="line"><span class="comment">// 最开始经过类型检查后，便使用当前地址减去成员偏移，就可以得到结构体的首地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;                \</span></span><br><span class="line"><span class="meta">    void *__mptr = (void *)(ptr);                    \</span></span><br><span class="line"><span class="meta">    static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||    \</span></span><br><span class="line"><span class="meta">              __same_type(*(ptr), void),            \</span></span><br><span class="line"><span class="meta">              <span class="meta-string">&quot;pointer type mismatch in container_of()&quot;</span>);    \</span></span><br><span class="line"><span class="meta">    ((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure>

<p>其实就是当前成员变量的地址减去其偏移地址，便可以得到结构体的首地址。</p>
<blockquote>
<p>唯一需要注意的是，减去偏移时指针要转换为 char 型，以进行字节型的运算</p>
</blockquote>
<p>示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member)  ((size_t)&amp;((type*)0)-&gt;member)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (type*)((char*)ptr - offsetof(type, member))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hello</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello</span> <span class="title">obj</span> =</span> &#123;</span><br><span class="line">        .a = <span class="number">1</span>,</span><br><span class="line">        .b = <span class="number">2</span>,</span><br><span class="line">        .c = <span class="number">3</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj a = %d, b = %d, c = %f\n&quot;</span>,</span><br><span class="line">    obj.a, obj.b, obj.c);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hello</span>* <span class="title">ret</span> =</span> container_of(&amp;obj.c, struct hello, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get value of struct, a = %d, b = %d, c = %f\n&quot;</span>,</span><br><span class="line"></span><br><span class="line">    ret-&gt;a, ret-&gt;b, ret-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关操作函数"><a href="#相关操作函数" class="headerlink" title="相关操作函数"></a>相关操作函数</h3><p>有了前面的认识，再来理解下面的宏就相对容易些了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry - 根据节点的地址及成员名，得出结构体对象的</span></span><br><span class="line"><span class="comment"> * @ptr:    the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment"> * @type:    the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_first_entry - 根据头节点的地址及成员名，得出链表的第一个结构体对象的地址</span></span><br><span class="line"><span class="comment"> * @ptr:    the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:    the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, that list is expected to be not empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_last_entry - 根据头节点的地址及成员名，得出链表的最后一个结构体对象的</span></span><br><span class="line"><span class="comment"> * @ptr:    the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:    the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, that list is expected to be not empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_last_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    list_entry((ptr)-&gt;prev, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_first_entry_or_null - 从链表头获取第一个对象，如果是空链表则返回 NULL</span></span><br><span class="line"><span class="comment"> * @ptr:    the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:    the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that if the list is empty, it returns NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_first_entry_or_null(ptr, type, member) (&#123; \</span></span><br><span class="line"><span class="meta">    struct list_head *head__ = (ptr); \</span></span><br><span class="line"><span class="meta">    struct list_head *pos__ = READ_ONCE(head__-&gt;next); \</span></span><br><span class="line"><span class="meta">    pos__ != head__ ? list_entry(pos__, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_next_entry - 根据当前节点与节点名称，获取下一个节点关联对象的地址</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to cursor</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.next, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_next_entry_circular - 根据当前节点与节点名称，获取下一个节点关联对象的地址</span></span><br><span class="line"><span class="comment"> * 如果当前节点是最后一个节点，则返回第一个节点</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wraparound if pos is the last element (return the first element).</span></span><br><span class="line"><span class="comment"> * Note, that list is expected to be not empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_next_entry_circular(pos, head, member) \</span></span><br><span class="line"><span class="meta">    (list_is_last(&amp;(pos)-&gt;member, head) ? \</span></span><br><span class="line"><span class="meta">    list_first_entry(head, typeof(*(pos)), member) : list_next_entry(pos, member))   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_prev_entry - 根据当前节点与节点名称，获取上一个节点关联对象的地址</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to cursor</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry(pos, member) \</span></span><br><span class="line"><span class="meta">    list_entry((pos)-&gt;member.prev, typeof(*(pos)), member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_prev_entry_circular - 根据当前节点与节点名称，获取上一个节点关联对象的地址</span></span><br><span class="line"><span class="comment"> * 如果当前节点是第一个节点，则返回最后一个节点</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wraparound if pos is the first element (return the last element).</span></span><br><span class="line"><span class="comment"> * Note, that list is expected to be not empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prev_entry_circular(pos, head, member) \</span></span><br><span class="line"><span class="meta">    (list_is_first(&amp;(pos)-&gt;member, head) ? \</span></span><br><span class="line"><span class="meta">    list_last_entry(head, typeof(*(pos)), member) : list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each    -    遍历当前链表，pos 则返回当前的节点</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next; !list_is_head(pos, (head)); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_rcu - Iterate over a list in an RCU-safe fashion</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_rcu(pos, head)          \</span></span><br><span class="line"><span class="meta">    for (pos = rcu_dereference((head)-&gt;next); \</span></span><br><span class="line"><span class="meta">         !list_is_head(pos, (head)); \</span></span><br><span class="line"><span class="meta">         pos = rcu_dereference(pos-&gt;next)) </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_continue - 从当前节点处继续往后遍历遍历链表</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Continue to iterate over a list, continuing after the current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_continue(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = pos-&gt;next; !list_is_head(pos, (head)); pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_prev    -    从当前节点处，继续往前遍历链表</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev(pos, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev; !list_is_head(pos, (head)); pos = pos-&gt;prev)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_safe - 以安全的方式对链表进行遍历，避免对当前节点执行删除操作后，便无法继续往后遍历了</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another &amp;struct list_head to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;next, n = pos-&gt;next; \</span></span><br><span class="line"><span class="meta">         !list_is_head(pos, (head)); \</span></span><br><span class="line"><span class="meta">         pos = n, n = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_prev_safe - 以安全的方式对链表进行遍历，避免对当前节点执行删除操作后，便无法继续往后遍历了</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct list_head to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another &amp;struct list_head to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">    for (pos = (head)-&gt;prev, n = pos-&gt;prev; \</span></span><br><span class="line"><span class="meta">         !list_is_head(pos, (head)); \</span></span><br><span class="line"><span class="meta">         pos = n, n = pos-&gt;prev)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry_is_head - 判断当前对象是否在头节点</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to cursor</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_entry_is_head(pos, head, member)                \</span></span><br><span class="line"><span class="meta">    (&amp;pos-&gt;member == (head))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry    -    这个是以对象的形式对链表进行正向遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry(pos, head, member)                \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member);    \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);            \</span></span><br><span class="line"><span class="meta">         pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_reverse - 这个是以对象的形式对链表进行反向遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_reverse(pos, head, member)            \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry(head, typeof(*pos), member);        \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);             \</span></span><br><span class="line"><span class="meta">         pos = list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_prepare_entry - 提取对象，为 list_for_each_entry_continue 做准备</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a start point</span></span><br><span class="line"><span class="comment"> * @head:    the head of the list</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prepares a pos entry for use as a start point in list_for_each_entry_continue().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_prepare_entry(pos, head, member) \</span></span><br><span class="line"><span class="meta">    ((pos) ? : list_entry(head, typeof(*pos), member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_continue - 以对象的方式，继续向后遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Continue to iterate over list of given type, continuing after</span></span><br><span class="line"><span class="comment"> * the current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue(pos, head, member)         \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member);            \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);            \</span></span><br><span class="line"><span class="meta">         pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_continue_reverse - 以对象的方式，继续向前遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Start to iterate over list of given type backwards, continuing after</span></span><br><span class="line"><span class="comment"> * the current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member)        \</span></span><br><span class="line"><span class="meta">    for (pos = list_prev_entry(pos, member);            \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);            \</span></span><br><span class="line"><span class="meta">         pos = list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_from - 从当前节点，继续向后遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over list of given type, continuing from current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from(pos, head, member)             \</span></span><br><span class="line"><span class="meta">    for (; !list_entry_is_head(pos, head, member);            \</span></span><br><span class="line"><span class="meta">         pos = list_next_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_from_reverse - 从当前节点，继续向前遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate backwards over list of given type, continuing from current position.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_from_reverse(pos, head, member)        \</span></span><br><span class="line"><span class="meta">    for (; !list_entry_is_head(pos, head, member);            \</span></span><br><span class="line"><span class="meta">         pos = list_prev_entry(pos, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_safe - 以安全的方式向后遍历，避免当前对象被删除而无法遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another type * to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)            \</span></span><br><span class="line"><span class="meta">    for (pos = list_first_entry(head, typeof(*pos), member),    \</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);            \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);             \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_next_entry(n, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_safe_continue - 以安全的方式，继续向后遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another type * to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over list of given type, continuing after current point,</span></span><br><span class="line"><span class="comment"> * safe against removal of list entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_continue(pos, n, head, member)         \</span></span><br><span class="line"><span class="meta">    for (pos = list_next_entry(pos, member),                 \</span></span><br><span class="line"><span class="meta">        n = list_next_entry(pos, member);                \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);                \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_next_entry(n, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_safe_from - 以安全的方式，从当前节点向后遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another type * to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate over list of given type from current point, safe against</span></span><br><span class="line"><span class="comment"> * removal of list entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_from(pos, n, head, member)             \</span></span><br><span class="line"><span class="meta">    for (n = list_next_entry(pos, member);                    \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);                \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_next_entry(n, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry_safe_reverse - 以安全的方式向前遍历，避免当前对象被删除而无法遍历</span></span><br><span class="line"><span class="comment"> * @pos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @n:        another type * to use as temporary storage</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterate backwards over list of given type, safe against removal</span></span><br><span class="line"><span class="comment"> * of list entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_for_each_entry_safe_reverse(pos, n, head, member)        \</span></span><br><span class="line"><span class="meta">    for (pos = list_last_entry(head, typeof(*pos), member),        \</span></span><br><span class="line"><span class="meta">        n = list_prev_entry(pos, member);            \</span></span><br><span class="line"><span class="meta">         !list_entry_is_head(pos, head, member);             \</span></span><br><span class="line"><span class="meta">         pos = n, n = list_prev_entry(n, member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_safe_reset_next - reset a stale list_for_each_entry_safe loop</span></span><br><span class="line"><span class="comment"> * @pos:    the loop cursor used in the list_for_each_entry_safe loop</span></span><br><span class="line"><span class="comment"> * @n:        temporary storage used in list_for_each_entry_safe</span></span><br><span class="line"><span class="comment"> * @member:    the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * list_safe_reset_next is not safe to use in general if the list may be</span></span><br><span class="line"><span class="comment"> * modified concurrently (eg. the lock is dropped in the loop body). An</span></span><br><span class="line"><span class="comment"> * exception to this is if the cursor element (pos) is pinned in the list,</span></span><br><span class="line"><span class="comment"> * and list_safe_reset_next is called after re-taking the lock and before</span></span><br><span class="line"><span class="comment"> * completing the current iteration of the loop body.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> list_safe_reset_next(pos, n, member)                \</span></span><br><span class="line"><span class="meta">    n = list_next_entry(pos, member)         </span></span><br></pre></td></tr></table></figure>



<h1 id="链表的演化"><a href="#链表的演化" class="headerlink" title="链表的演化"></a>链表的演化</h1><p>以上是双向环形链表的实现，它还可以很方便的演化为以下几种数据结构：</p>
<ul>
<li><p>去掉前驱指针，就是单向循环链表</p>
</li>
<li><p>对接口进行进一步封装，只允许头的取出和尾的插入操作，就是 FIFO</p>
</li>
<li><p>对接口进行进一步封装，只允许头的取出和插入操作，就是栈</p>
</li>
</ul>
<p>由于上面的链表实现方式可以被插入到任意一种数据结构中，还有一种妙用：一个数据结构根据用途插入多个链表节点！</p>
<blockquote>
<p>相当于是以不同的角度来看这个数据结构</p>
</blockquote>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>下面编写一个简单的内核模块，来简单的使用一下链表，模块代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) <span class="meta-string">&quot;[list]: &quot;</span> fmt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_COUNT  (10)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(item_head);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_list</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;I have these items:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span>* <span class="title">get_item</span>;</span></span><br><span class="line">    list_for_each_entry(get_item, &amp;item_head, node) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;val: %d\n&quot;</span>, get_item-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    pr_info(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">list_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;%s -&gt; %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ITEM_COUNT; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">item</span>* <span class="title">new_item</span> =</span> (struct item* )kmalloc(<span class="keyword">sizeof</span>(struct item), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!new_item) &#123;</span><br><span class="line">            pr_err(<span class="string">&quot;Can&#x27;t malloc memory!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        new_item-&gt;val = i;</span><br><span class="line"></span><br><span class="line">        list_add(&amp;(new_item-&gt;node), &amp;item_head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    show_list();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(list_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">list_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;%s -&gt; %d\n&quot;</span>, __func__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span>* <span class="title">get_item</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">item</span>* <span class="title">tmp_item</span>;</span></span><br><span class="line">    list_for_each_entry_safe(get_item, tmp_item, &amp;item_head, node) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;delete item : %d\n&quot;</span>, get_item-&gt;val);</span><br><span class="line"></span><br><span class="line">        list_del(&amp;(get_item-&gt;node));</span><br><span class="line">        show_list();</span><br><span class="line"></span><br><span class="line">        kfree(get_item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">module_exit(list_exit);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kcmetercec &lt;kcmeter.ece@gmail.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple demo which uses list&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;list demo&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;ver1.0&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>对应的 Makefile 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KVERS = $(shell uname -r)</span><br><span class="line"></span><br><span class="line">obj-m += <span class="built_in">list</span>.o</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS = -<span class="built_in">std</span>=gnu99</span><br><span class="line"></span><br><span class="line">build: kernel_modules</span><br><span class="line"></span><br><span class="line">kernel_modules:</span><br><span class="line">        make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>需要注意的是：上面使用了 gnu99 编译选项。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>kernel</category>
        <category>data_struct</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Swupdate 的简易使用</title>
    <url>/2024/12/19/linux_make_swupdate/</url>
    <content><![CDATA[<p>这里记录 Swupdate 的简易使用说明。</p>
<span id="more"></span>

<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>SWUpdate 是位于用户空间的应用程序，用于升级嵌入式系统（不包含 bootloader）。</p>
<p>它以事务的方式标识整个升级过程，事务的标识会写入到 bootloader 中，bootloader 会根据事务标记的值来确认当前升级是否成功。</p>
<p>比如 SWUpdate 通过设置环境变量<code>recovery_status</code>，来表示升级过程：</p>
<ol>
<li><p>开始升级时，其值为<code>progress</code></p>
</li>
<li><p>升级成功后，其值会被擦除</p>
</li>
<li><p>升级失败，其值为<code>failed</code></p>
</li>
</ol>
<p>bootloader 通过查看其值为<code>progress</code>或<code>failed</code>则代表其升级未完成：</p>
<ul>
<li><p>如果当前为<code>single-copy</code>模式，则会再次启动升级流程</p>
</li>
<li><p>如果当前为<code>double-copy</code>模式，则会启动上一个版本的程序</p>
</li>
</ul>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_file_struct.jpg?raw=true"><br>上图为其打包后的文件版本，主要是<code>sw-description</code>来实现多个镜像文件的描述。</p>
<p>可以看到它是将多个文件打包为一个<code>cpio</code>文件，那么这里再来复习一下<code>cpio</code>工具的操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 打包</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建打包：通过 find 遍历当前文件及文件夹输出给 cpio</span></span><br><span class="line">find . -depth -print | cpio -o &gt; /path/archive.cpio</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 解包</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以解包所有文件</span></span><br><span class="line">cpio -i -vd &lt; archive.cpio</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以只提取指定文件</span></span><br><span class="line">cpio -i -d /etc/fstab &lt; archive.cpio</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 查看</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 仅查看内容不解包</span></span><br><span class="line">cpio -t &lt; archive.cpio</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong> cpio 打包后的文件大小不能超过 4GB.</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>在 <code>buildroot</code>中只需要搜<code>swupdate</code>就可以找到该包并使能，如果想要更细致的配置，可以通过以下命令配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make swupdate-menuconfig</span><br></pre></td></tr></table></figure>

<p>在输出路径<code>output/build/swupdate/tools</code>中有文件<code>swupdate-progress.c</code>可以作为很好的参考，用于与<code>swupdate</code>交互获取当前的状态。</p>
<p>为了与 U-Boot 交互，则需要进行以下配置：</p>
<ul>
<li><p>在<code>Bootloader Interfaces</code>中使能 U-Boot，并设定文件<code>/etc/fw_env.config</code>以及<code>/etc/u-boot-initial-en</code></p>
</li>
<li><p>设定<code>U-Boot</code>中变量为<code>ustate</code></p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>swupdate</code>的一般流程如下：</p>
<ol>
<li><p>提取<code>sw-description</code>并校验，如果还使能了签名验证，还会提取<code>sw-description.sig</code> 文件进行签名验证。</p>
</li>
<li><p>根据<code>sw-description</code>中提供的信息，读取当前设备的硬件版本，来验证是否有兼容该硬件版本的软件包。</p>
</li>
<li><p>根据<code>sw-description</code>中的信息识别哪些软件包需要被安装，如果具有<code>embedded-script</code>则会在解析这些软件包前执行这些脚本，如果具有<code>hooks</code>则会在解析软件包时执行（即使这些软件包会被跳过）。最终生成一张执行列表和对应的哪些<code>handler</code>需要被调用。</p>
</li>
<li><p>如果有<code>pre update command</code>，则先执行这些命令</p>
</li>
<li><p>如果有分区的必要，则执行<code>partition handlers</code></p>
</li>
<li><p>依次从<code>cpio</code>文件中提取需要安装的软件包，在读取软件包时还会进行内容校验，如果检验失败则报错。</p>
</li>
<li><p>在安装软件包之前，如果具有<code>pre-install</code>脚本，则会先执行这些脚本</p>
</li>
<li><p>执行对应软件包的<code>handler</code>来安装软件包</p>
</li>
<li><p>安装完成后，如果具有<code>post-install</code>脚本，则会执行这些脚本</p>
</li>
<li><p>更新 bootloader 的环境变量</p>
</li>
<li><p>向外部接口输出升级状态</p>
</li>
<li><p>如果具有<code>post update command</code>则执行这些命令</p>
</li>
</ol>
<p>使用<code>swupdate</code>执行升级命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swupdate -i &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>也可以启动一个网络服务，通过网页来升级：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动后就可以通过 http://&lt;target_ip&gt;:8080 来访问</span></span><br><span class="line">swupdate -w &quot;--document-root ./www --port 8080&quot;</span><br></pre></td></tr></table></figure>

<h2 id="改变-U-BOOT"><a href="#改变-U-BOOT" class="headerlink" title="改变 U-BOOT"></a>改变 U-BOOT</h2><p><code>U-BOOT</code>可以保存两份环境变量，便于保证在更新环境变量时的安全性，要使能这个特性，需要配置<code>CONFIG_ENV_OFFSET_REDUND</code>或<code>CONFIG_ENV_ADDR_REDUND</code>。</p>
<p>除此之外，还可以在<code>U-BOOT</code>中增加一个启动计数器，如果计数器没有正确的被应用程序清零则意味着这个版本升级的应用没有正常运行，然后可以切换到之前备份的应用。</p>
<h2 id="构建升级包"><a href="#构建升级包" class="headerlink" title="构建升级包"></a>构建升级包</h2><p>升级包需要<code>sw-updescription</code>是第一个文件，其余的镜像可以依次往后放即可。使用类似下面的脚本就可以打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONTAINER_VER=&quot;1.0&quot;</span><br><span class="line">PRODUCT_NAME=&quot;my-software&quot;</span><br><span class="line">FILES=&quot;sw-description image1.ubifs  \</span><br><span class="line">       image2.gz.u-boot uImage.bin myfile sdcard.img&quot;</span><br><span class="line">for i in $FILES;do</span><br><span class="line">        echo $i;done | cpio -ov -H crc &gt;  $&#123;PRODUCT_NAME&#125;_$&#123;CONTAINER_VER&#125;.swu</span><br></pre></td></tr></table></figure>

<p>也可以通过<a href="https://github.com/sbabic/swugenerator/">GitHub - sbabic/swugenerator: A host tool to generate SWU update package for SWUpdate</a>来打包生成升级包。</p>
<p>升级包的查看可以通过下面的命令完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swupdate -c -i my-software_1.0.swu</span><br></pre></td></tr></table></figure>

<h1 id="升级策略"><a href="#升级策略" class="headerlink" title="升级策略"></a>升级策略</h1><h2 id="single-copy"><a href="#single-copy" class="headerlink" title="single copy"></a>single copy</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_single_copy.jpg?raw=true"><br>正常情况下，bootloader 直接启动用户的内核，进入文件系统运行应用程序。</p>
<p>当需要升级时：</p>
<ol>
<li><p>通知 bootloader 需要启动<code>swupdate</code>，然后重启系统</p>
<ul>
<li>通知的方式多种多样，比如通过环境变量、GPIO等</li>
</ul>
</li>
<li><p>bootloader 启动带 swupdate 的内核和 RAMFS</p>
</li>
<li><p>在 RAMFS 中启动<code>swupdate</code>分析升级包并升级</p>
</li>
</ol>
<p>如果升级过程失败，应用程序无法正确清空 bootloader 的启动计数器，则 bootloader 会主动进入升级系统。</p>
<h2 id="double-copy"><a href="#double-copy" class="headerlink" title="double copy"></a>double copy</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_double_copy.jpg?raw=true"><br>bootloader 交替的启动切换最新的软件，<code>swupdate</code>则升级那个未被启动的软件分区。</p>
<p>当当前应用程序没有正确清空 bootloader 的启动计数器时，bootloader 会主动切换回上一个版本的应用程序。</p>
<p>bootloader 根据变量<code>ustate</code>的值为1，来确认目前有新的软件被安装，那么就需要通过计数器来测试该软件是否安装正确。当测试失败，bootloader 也可以修改<code>ustate</code>的值为 3，来通知应用程序升级是否成功。</p>
<ul>
<li><p>当<code>ustate=0</code>，则表示当前无新升级，bootloader 正常引导</p>
</li>
<li><p>当<code>ustate=1</code>，表示有新软件被安装，需要测试</p>
<ul>
<li><p>测试失败，由 bootloader 将值设置为 3</p>
</li>
<li><p>测试成功，由应用程序将值设置为 0</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_statemachine.jpg?raw=true"><br>在 bootloader 中，需要准备的变量有：</p>
<ol>
<li><h2 id="double-copy-with-rescue-system"><a href="#double-copy-with-rescue-system" class="headerlink" title="double-copy with rescue system"></a>double-copy with rescue system</h2></li>
</ol>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_double_copy_rescue.jpg?raw=true"><br>在<code>double-copy</code>的基础上，还可以增加一个救援系统，这样当两个版本都无法正确运行（或那个硬盘损坏）的情况下，仍然可以启动救援系统来重新格式化、更新系统。</p>
<blockquote>
<p>这个救援系统也是可以被更新的</p>
</blockquote>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>一个典型的<code>sw-description</code>文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        description = &quot;Firmware update for XXXXX Project&quot;;</span><br><span class="line"></span><br><span class="line">        hardware-compatibility: [ &quot;1.0&quot;, &quot;1.2&quot;, &quot;1.3&quot;];</span><br><span class="line"></span><br><span class="line">        /* partitions tag is used to resize UBI partitions */</span><br><span class="line">        partitions: ( /* UBI Volumes */</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;rootfs&quot;;</span><br><span class="line">                        device = &quot;mtd4&quot;;</span><br><span class="line">                        size = 104896512; /* in bytes */</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;data&quot;;</span><br><span class="line">                        device = &quot;mtd5&quot;;</span><br><span class="line">                        size = 50448384; /* in bytes */</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        images: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;rootfs.ubifs&quot;;</span><br><span class="line">                        volume = &quot;rootfs&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;swupdate.ext3.gz.u-boot&quot;;</span><br><span class="line">                        volume = &quot;fs_recovery&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;sdcard.ext3.gz&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">                        compressed = &quot;zlib&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;bootlogo.bmp&quot;;</span><br><span class="line">                        volume = &quot;splash&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;uImage.bin&quot;;</span><br><span class="line">                        volume = &quot;kernel&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;fpga.txt&quot;;</span><br><span class="line">                        type = &quot;fpga&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;bootloader-env&quot;;</span><br><span class="line">                        type = &quot;bootloader&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        files: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;README&quot;;</span><br><span class="line">                        path = &quot;/README&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">                        filesystem = &quot;vfat&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        scripts: (</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;erase_at_end&quot;;</span><br><span class="line">                        type = &quot;lua&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        filename = &quot;display_info&quot;;</span><br><span class="line">                        type = &quot;lua&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        bootenv: (</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;vram&quot;;</span><br><span class="line">                        value = &quot;4M&quot;;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        name = &quot;addfb&quot;;</span><br><span class="line">                        value = &quot;setenv bootargs $&#123;bootargs&#125; omapfb.vram=1:2M,2:2M,3:2M omapdss.def_disp=lcd&quot;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以<code>software</code>tag为顶层描述，下面的就是为各个镜像的单独说明。</p>
<p>上面中的<code>hardware-compatib</code>是为了软件与硬件的兼容，而硬件的信息则存储于<code>/etc/hwrevision</code>中，其格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> boardname：设备名称，为了便于一个升级包还可以升级多种不同设备</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> revision：设备的硬件版本</span></span><br><span class="line">&lt;boardname&gt; &lt;revision&gt;</span><br></pre></td></tr></table></figure>

<p>对于 double copy 的升级策略，一个升级包可能会对应两个分区，那么配置文件应该这样描述：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        stable = &#123;</span><br><span class="line">                copy-1: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                        &#123;</span><br><span class="line">                                device = &quot;/dev/mtd4&quot;</span><br><span class="line">                                ...</span><br><span class="line">                        &#125;</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                copy-2: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                        &#123;</span><br><span class="line">                                device = &quot;/dev/mtd5&quot;</span><br><span class="line">                                ...</span><br><span class="line">                        &#125;</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际升级时，到底应该是选择哪个分区，则是由应用程序来区分（比如查看当前程序是挂载在哪个分区），然后给<code>swupdate</code>发送消息。</p>
<blockquote>
<p>这个消息是要在 <code>swupdate</code>启动前就确认要升级哪个分区，然后通过<code>-e &lt;selection,mode&gt;</code>来告知<code>swupdate</code>。</p>
<p>也可以在启动前创建一个连接文件<code>/dev/standby</code>指向需要被升级的分区。</p>
<p>如果要在运行时来区分，就要在<code>sw-description</code>中编写嵌入式脚本来区分，Lua 脚本使用<code>getroot()</code>函数获取当前文件系统挂载的分区。</p>
</blockquote>
<h2 id="硬件兼容性"><a href="#硬件兼容性" class="headerlink" title="硬件兼容性"></a>硬件兼容性</h2><p>一个软件包可以兼容多个版本的硬件，则可以像前面一样，在文件内容开始一次性给出。但也有可能在不同的硬件版本下的文件会略有不同，那么还可以再进一步说明：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        myboard = &#123;</span><br><span class="line">            stable = &#123;</span><br><span class="line"></span><br><span class="line">                hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.3&quot;, &quot;3.0&quot;, &quot;3.1&quot;];</span><br><span class="line">                rev-1.0: &#123;</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-1.2: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;1.2&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-2.0: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;2.0&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                           ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-1.3: &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;1.3&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                            ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                            ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rev-3.0:</span><br><span class="line">                &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;3.0&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">                rev-3.1:</span><br><span class="line">                &#123;</span><br><span class="line">                        hardware-compatibility: [&quot;3.1&quot;];</span><br><span class="line">                        images: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                        scripts: (</span><br><span class="line">                                ...</span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果其中有部分版本完全一致，那么还可以使用引用的方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line"> &#123;</span><br><span class="line">         version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">         myboard = &#123;</span><br><span class="line">             stable = &#123;</span><br><span class="line"></span><br><span class="line">                 hardware-compatibility: [&quot;1.0&quot;, &quot;1.2&quot;, &quot;2.0&quot;, &quot;1.3&quot;, &quot;3.0&quot;, &quot;3.1&quot;];</span><br><span class="line">                 rev-1x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                            ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                             ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.2 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev1.3 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-1x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev-2x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev2.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-2x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 rev-3x: &#123;</span><br><span class="line">                         images: (</span><br><span class="line">                              ...</span><br><span class="line">                         );</span><br><span class="line">                         scripts: (</span><br><span class="line">                               ...</span><br><span class="line">                         );</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev3.0 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-3x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 rev3.1 = &#123;</span><br><span class="line">                         ref = &quot;#./rev-3x&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ref</code>是表示引用的关键字，后面的<code>#</code>是必须的。可以用<code>./</code>表示当前层级，用<code>../</code>表示上一个层级。</p>
<p><code>swupdate</code>获取版本号是在<code>/etc/hwrevision</code>文件中，但是这个文件的内容则可以在应用程序启动时通过各种方式进行更新，比如读取当前硬件上的 EEPROM 获取版本号等。</p>
<h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><p><code>images</code>标识表示要更新到系统中的镜像文件，其语法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">images: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename[mandatory] = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                volume[optional] = &lt;destination volume&gt;;</span><br><span class="line">                device[optional] = &lt;destination volume&gt;;</span><br><span class="line">                mtdname[optional] = &lt;destination mtd name&gt;;</span><br><span class="line">                type[optional] = &lt;handler&gt;;</span><br><span class="line">                /* optionally, the image can be copied at a specific offset */</span><br><span class="line">                offset[optional] = &lt;offset&gt;;</span><br><span class="line">                /* optionally, the image can be compressed if it is in raw mode */</span><br><span class="line">                compressed;</span><br><span class="line">        &#125;,</span><br><span class="line">        /* Next Image */</span><br><span class="line">        .....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>对于 emmc 而言，其内容大体如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        filename = &quot;core-image-base.ext3&quot;;</span><br><span class="line">        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 flash 而言，其内容大体如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        filename = &quot;u-boot.bin&quot;;</span><br><span class="line">        device = &quot;/dev/mmcblk0p1&quot;;</span><br><span class="line">        offset = &quot;16K&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p><code>files</code>标识用于拷贝文件到系统，其语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">files: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                path = &lt;path in filesystem&gt;;</span><br><span class="line">                device[optional] = &lt;device node &gt;;</span><br><span class="line">                filesystem[optional] = &lt;filesystem for mount&gt;;</span><br><span class="line">                properties[optional] = &#123;create-destination = &quot;true&quot;;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>主要就是将文件拷贝到对应路径。</p>
<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p><code>scripts</code>标记用于执行一系列的脚本，默认情况下如果没有标注脚本的类型，<code>swupdate</code>会认为是<code>lua</code>脚本。</p>
<h3 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;lua&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>lua 脚本必须至少包含 3 个函数：</p>
<ul>
<li><p><code>function preinst()</code>：安装镜像前会被执行</p>
</li>
<li><p><code>function postinst()</code>：安装镜像后会被执行</p>
</li>
<li><p><code>function postfailure()</code>：升级失败后会被执行</p>
</li>
</ul>
<h3 id="shellscript"><a href="#shellscript" class="headerlink" title="shellscript"></a>shellscript</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;shellscript&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>swupdate</code>会在镜像安装前后执行脚本，在执行时会传入参数”preinst”、”postinst”或”postfailure”，脚本可以依据这些参数进行不同的操作。</p>
<p>除此之外，也可以单独编写<code>preinstall</code>和<code>postinstall</code>脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;preinstall&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &lt;Name in CPIO Archive&gt;;</span><br><span class="line">                type = &quot;postinstall&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="升级过程中的标记状态"><a href="#升级过程中的标记状态" class="headerlink" title="升级过程中的标记状态"></a>升级过程中的标记状态</h2><p>默认情况下<code>swupdate</code>通过设置 bootloader 的环境变量<code>recovery_status</code>来表示升级的过程，其值有以下几种情况：</p>
<ul>
<li><p><code>in_progress</code>：正在升级过程中</p>
</li>
<li><p>值被清空：升级成功</p>
</li>
<li><p><code>failed</code>：升级失败</p>
</li>
</ul>
<p>如果想关闭这些状态记录，可以在配置文件中设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        bootloader_transaction_marker = false;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>除了这种字符串标记外，还有将 bootloader 的环境变量<code>ustate</code>来设数值方式：</p>
<ul>
<li><p><code>1</code>：安装成功</p>
</li>
<li><p><code>3</code>：安装失败</p>
</li>
</ul>
<p>关闭<code>ustate</code>也是在配置文件中设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line">        bootloader_state_markerer = false;</span><br></pre></td></tr></table></figure>

<h2 id="更新-bootloader-的环境变量"><a href="#更新-bootloader-的环境变量" class="headerlink" title="更新 bootloader 的环境变量"></a>更新 bootloader 的环境变量</h2><p>有两种方式可以更新 bootloader 的环境变量，一种方式是将变量写在文件中，然后将此文件在配置文件中标注一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">images: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &quot;bootloader-env&quot;;</span><br><span class="line">                type = &quot;bootloader&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>文件中变量赋值的格式为：<code>&lt;name of variable&gt;=&lt;value&gt;</code>，如果值不设置，则该变量会被清除掉。</p>
<p>就像下面这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Default variables</span></span><br><span class="line">bootslot=0</span><br><span class="line">board_name=myboard</span><br><span class="line">baudrate=115200</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Board Revision dependent</span></span></span><br><span class="line">board_revision=1.0</span><br></pre></td></tr></table></figure>

<p>另一种方式是直接在配置文件中就写变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bootenv: (</span><br><span class="line">        &#123;</span><br><span class="line">                name = &lt;Variable name&gt;;</span><br><span class="line">                value = &lt;Variable value&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p><code>swupdate</code>可以进行版本号比较，默认格式为：<code>&lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;.&lt;build&gt;</code></p>
<p>每个小段都是由数值组成的，其值为 0~65535，4 个 16 位组合成 64 位进行大小比较。</p>
<p>在启动<code>swupdate</code>之前，应用软件需要更新<code>/etc/sw-versions</code>来保存各个软件包的版本，然后再来启动<code>swupdate</code>进行版本管理，文件内容格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;name of component&gt;     &lt;version&gt;</span><br></pre></td></tr></table></figure>

<h2 id="嵌入式脚本-Embedded-Script"><a href="#嵌入式脚本-Embedded-Script" class="headerlink" title="嵌入式脚本(Embedded Script)"></a>嵌入式脚本(Embedded Script)</h2><p>嵌入式脚本指的是在<code>sw-description</code>中嵌入脚本，该脚本是对配置文件全局可见的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">embedded-script = &quot;&lt;Lua code&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>在编写脚本时需要注意：双引号应该使用转义字符进行转义，以避免影响脚本的解析。</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print (\&quot;Test\&quot;)</span><br></pre></td></tr></table></figure>

<p>在配置文件中的镜像文件或普通文件类型都可以调用一个嵌入式脚本的函数，通过<code>hook</code>标记函数名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">files: (</span><br><span class="line">        &#123;</span><br><span class="line">                filename = &quot;examples.tar&quot;;</span><br><span class="line">                type = &quot;archive&quot;;</span><br><span class="line">                path = &quot;/tmp/test&quot;;</span><br><span class="line">                hook = &quot;set_version&quot;;</span><br><span class="line">                preserve-attributes = true;</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>一个脚本的示例如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set_version</span><span class="params">(image)</span></span></span><br><span class="line">        <span class="built_in">print</span> (\<span class="string">&quot;RECOVERY_STATUS.RUN: \&quot;.. swupdate.RECOVERY_STATUS.RUN)</span></span><br><span class="line"><span class="string">        for k,l in pairs(image) do</span></span><br><span class="line"><span class="string">                swupdate.trace(\&quot;image[\&quot; .. tostring(k) .. \&quot;] = \&quot; .. tostring(l))</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        image.version = \&quot;1.0\&quot;</span></span><br><span class="line"><span class="string">        image.install_if_different = true</span></span><br><span class="line"><span class="string">        return true, image</span></span><br><span class="line"><span class="string">end</span></span><br></pre></td></tr></table></figure>

<p>上述的<code>image</code>则为传入的参数列表，该脚本设置了版本和安装属性然后返回。</p>
<p><code>swupdate</code>提供了一些函数便于调用，在脚本前需要写入：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> (<span class="string">&#x27;swupdate&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="验证与签名"><a href="#验证与签名" class="headerlink" title="验证与签名"></a>验证与签名</h1><h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p><code>swupdate</code>的逻辑为：</p>
<ol>
<li><p>对<code>sw-description</code>进行签名验证，确保该文件未被篡改</p>
</li>
<li><p>在<code>sw-description</code>中包含各个独立镜像文件的哈希校验，确认这些镜像文件的正确性</p>
</li>
</ol>
<p><code>swupdate</code>可以通过<code>menuconfig</code>来配置签名验证使用的算法</p>
<ul>
<li><p>RSA 公钥/私钥验证：私钥存放在构建主机中，公钥存放在目标设备上</p>
</li>
<li><p>CMS 用于证书</p>
</li>
<li><p>GPG 用于签名</p>
</li>
</ul>
<h2 id="生成密钥和证书"><a href="#生成密钥和证书" class="headerlink" title="生成密钥和证书"></a>生成密钥和证书</h2><p>对于<code>RSA</code>和<code>CMS</code>算法，OpenSSL 用来生成密钥，对于<code>GPG</code>，gpg 用于生成密钥和对镜像文件签名。</p>
<h3 id="使用-RSA"><a href="#使用-RSA" class="headerlink" title="使用 RSA"></a>使用 RSA</h3><p>生成公钥和私钥：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先生成私钥</span></span><br><span class="line">openssl genrsa -aes256 -out priv.pem</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再生成公钥</span></span><br><span class="line">openssl rsa -in priv.pem -out public.pem -outform PEM -pubout</span><br></pre></td></tr></table></figure>

<p>使用 RSA 生成签名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对 sw-description 生成 rsa-pkcs<span class="comment">#1.5 签名</span></span></span><br><span class="line">openssl dgst -sha256 -sign priv.pem sw-description &gt; sw-description.sig</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以生成 rsa-pss 签名</span></span><br><span class="line">openssl dgst -sha256 -sign priv.pem -sigopt rsa_padding_mode:pss \</span><br><span class="line">    -sigopt rsa_pss_saltlen:-2 sw-description &gt; sw-description.sig</span><br></pre></td></tr></table></figure>

<h3 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \</span><br><span class="line">    -out mycert.cert.pem -subj &quot;/O=SWUpdate /CN=target&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>mycert.key.pem</code>用于保存在构建主机上</p>
</li>
<li><p><code>mycert.cert.pe</code>用于保存在目标设备机上</p>
</li>
</ul>
<h3 id="使用-CMS-进行签名"><a href="#使用-CMS-进行签名" class="headerlink" title="使用 CMS 进行签名"></a>使用 CMS 进行签名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \</span><br><span class="line">        -inkey mycert.key.pem -outform DER -nosmimecap -binary</span><br></pre></td></tr></table></figure>

<h2 id="使用签名和验证"><a href="#使用签名和验证" class="headerlink" title="使用签名和验证"></a>使用签名和验证</h2><p>对于签名而言，配置文件<code>sw-description</code>和<code>sw-description.sig</code>结合使用，签名文件跟在配置文件之后。</p>
<p>在配置文件中的镜像都需要包含属性<code>sha256</code>，代表该镜像文件的校验和。</p>
<p>下面的脚本演示了如何打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">MODE=&quot;RSA-PKCS-1.5&quot;</span><br><span class="line">PRODUCT_NAME=&quot;myproduct&quot;</span><br><span class="line">CONTAINER_VER=&quot;1.0&quot;</span><br><span class="line">IMAGES=&quot;rootfs kernel&quot;</span><br><span class="line">FILES=&quot;sw-description sw-description.sig $IMAGES&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">if</span> you use RSA</span></span><br><span class="line">if [ x&quot;$MODE&quot; == &quot;xRSA-PKCS-1.5&quot; ]; then</span><br><span class="line">    openssl dgst -sha256 -sign priv.pem sw-description &gt; sw-description.sig</span><br><span class="line">elif if [ x&quot;$MODE&quot; == &quot;xRSA-PSS&quot; ]; then</span><br><span class="line">    openssl dgst -sha256 -sign priv.pem -sigopt rsa_padding_mode:pss \</span><br><span class="line">        -sigopt rsa_pss_saltlen:-2 sw-description &gt; sw-description.sig</span><br><span class="line">elif if [ x&quot;$MODE&quot; == &quot;xGPG&quot; ]; then</span><br><span class="line">    gpg --batch --homedir &quot;$&#123;GPG_HOME_DIR&#125;&quot; --default-key &quot;$&#123;GPG_KEY&#125;&quot; \</span><br><span class="line">        --output sw-description.sig --detach-sig sw-description</span><br><span class="line">else</span><br><span class="line">    openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \</span><br><span class="line">        -inkey mycert.key.pem -outform DER -nosmimecap -binary</span><br><span class="line">fi</span><br><span class="line">for i in $FILES;do</span><br><span class="line">        echo $i;done | cpio -ov -H crc &gt;  $&#123;PRODUCT_NAME&#125;_$&#123;CONTAINER_VER&#125;.swu</span><br></pre></td></tr></table></figure>

<p>下面的配置文件演示了带有 sha256 校验的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.1.0&quot;;</span><br><span class="line"></span><br><span class="line">        hardware-compatibility: [ &quot;revC&quot;];</span><br><span class="line"></span><br><span class="line">        images: (</span><br><span class="line">                &#123;</span><br><span class="line">                    filename = &quot;core-image-full-cmdline-beaglebone.ext3&quot;;</span><br><span class="line">                    device = &quot;/dev/mmcblk0p2&quot;;</span><br><span class="line">                    type = &quot;raw&quot;;</span><br><span class="line">                    sha256 = &quot;43cdedde429d1ee379a7d91e3e7c4b0b9ff952543a91a55bb2221e5c72cb342b&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        scripts: (</span><br><span class="line">                &#123;</span><br><span class="line">                    filename = &quot;test.lua&quot;;</span><br><span class="line">                    type = &quot;lua&quot;;</span><br><span class="line">                    sha256 = &quot;f53e0b271af4c2896f56a6adffa79a1ffa3e373c9ac96e00c4cfc577b9bea5f1&quot;;</span><br><span class="line">                 &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p><code>swupdate</code>支持使用 AES 对镜像文件进行对称加密，在配置<code>swupdate</code>时需要使能<code>ENCRYPTED_IMAGES</code>.其使用步骤如下：</p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>对于<code>aes-256-cbc</code>，需要生成 32 字节密钥和 16 字节初始化向量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rand -hex 32</span><br><span class="line"><span class="meta">#</span><span class="bash"> key, <span class="keyword">for</span> example 390ad54490a4a5f53722291023c19e08ffb5c4677a59e958c96ffa6e641df040</span></span><br><span class="line">openssl rand -hex 16</span><br><span class="line"><span class="meta">#</span><span class="bash"> IV, <span class="keyword">for</span> example d5d601bacfe13100b149177318ebc7a4</span></span><br></pre></td></tr></table></figure>

<h2 id="加密镜像"><a href="#加密镜像" class="headerlink" title="加密镜像"></a>加密镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl enc -aes-256-cbc -in &lt;INFILE&gt; -out &lt;OUTFILE&gt; -K &lt;KEY&gt; -iv &lt;IV&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>&lt;INFILE&gt;</code>：输入的原始镜像文件</p>
</li>
<li><p><code>&lt;OUTFILE&gt;</code>：加密后的镜像文件</p>
</li>
<li><p><code>&lt;KEY&gt;</code>：上面生成的 32 字节的密钥</p>
</li>
<li><p><code>&lt;IV&gt;</code>：上面生成的 16 字节初始化向量</p>
</li>
</ul>
<h2 id="创建密钥文件"><a href="#创建密钥文件" class="headerlink" title="创建密钥文件"></a>创建密钥文件</h2><p>创建密钥文件，将密钥和初始化向量以空格分隔，写入文件。并在启动 <code>swupdate</code>时，以<code>-K</code>选项传入该文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">390ad54490a4a5f53722291023c19e08ffb5c4677a59e958c96ffa6e641df040 d5d601bacfe13100b149177318ebc7a4</span><br></pre></td></tr></table></figure>

<h2 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h2><p>最后是在配置文件中加入描述：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">software =</span><br><span class="line">&#123;</span><br><span class="line">        version = &quot;0.0.1&quot;;</span><br><span class="line">        images: ( &#123;</span><br><span class="line">                        filename = &quot;core-image-full-cmdline-beaglebone.ext3.enc&quot;;</span><br><span class="line">                        device = &quot;/dev/mmcblk0p3&quot;;</span><br><span class="line">                        encrypted = true;</span><br><span class="line">                        ivt = &quot;65D793B87B6724BB27954C7664F15FF3&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h1><p><code>handler</code>指的就是对各种镜像文件的安装处理程序，根据镜像文件的类型来匹配不同的<code>handler</code>。</p>
<p><code>swupdate</code>开放了接口，可以扩展增加各种<code>handler</code>，以适配用户定义的类型。</p>
<h2 id="创建新的-handler"><a href="#创建新的-handler" class="headerlink" title="创建新的 handler"></a>创建新的 <code>handler</code></h2><p>只需要按照<code>swupdate</code>的接口注册执行函数就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_handler</span><span class="params">(struct img_type *img,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">void</span> __attribute__ ((__unused__)) *data)</span></span></span><br></pre></td></tr></table></figure>

<p><code>img_type</code>指向要安装的镜像文件的起始，处理函数通过此结构体获取文件的信息，然后读取文件内容并执行安装。</p>
<p><code>data</code>是用于描述安装过程的数据指针，对于脚本的 handler，其为<code>struct script_handler_data</code></p>
<p><code>swupdate</code>还提供了通用函数，将流数据拷贝到目的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copyfile</span><span class="params">(<span class="keyword">int</span> fdin, <span class="keyword">int</span> fdout, <span class="keyword">int</span> nbytes, <span class="keyword">unsigned</span> <span class="keyword">long</span> *offs,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> skip_file, <span class="keyword">int</span> compressed, <span class="keyword">uint32_t</span> *checksum, <span class="keyword">unsigned</span> <span class="keyword">char</span> *hash)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>fdin</code>：输入流，在处理函数中通过<code>img-&gt;fdin</code>获得</p>
</li>
<li><p><code>hash</code>：镜像文件的签名</p>
</li>
</ul>
<p>用户通过下面的函数注册新的<code>handler</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_handler_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">register_handler</span>(<span class="string">&quot;mytype&quot;</span>, my_handler, my_mask, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">register_handler</span>(my_image_type, my_handler, my_mask, data);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>my_image_type</code>：以字符串表示的匹配镜像文件类型</p>
</li>
<li><p><code>my_handler</code>：处理函数的指针</p>
</li>
<li><p><code>my_mask</code>：<code>HANDLER_MASK</code>枚举值，表示可以处理的类型</p>
</li>
<li><p><code>data</code>：用于传递给处理函数的数据</p>
</li>
</ul>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p><code>swupdate</code>具有可被外部程序调用的 API，用于启动<code>swupdate</code>，发送镜像文件，获取状态等。</p>
<p><code>swupdate</code>使用的是 Unix Domain Socket，socket 路径按照以下顺序来决定：</p>
<ol>
<li><p>编译时配置的<code>CONFIG_SOCKET_CTRL_PATH</code></p>
</li>
<li><p>当环境变量<code>RUNTIME_DIRECTORY</code>设置了，则其位于<code>$RUNTIME_DIRECTORY/sockinstctrl</code></p>
</li>
<li><p>当环境变量<code>TMPDIR</code>设置了，则其位于<code>$TMPDIR/sockinstctrl</code></p>
</li>
<li><p><code>/tmp/sockinstctrl</code></p>
</li>
</ol>
<blockquote>
<p>swupdate 也编译了一个 <code>swupdate-client</code>工具，用于演示客户端如何与服务端进行通信。</p>
</blockquote>
<p>这也就意味着<code>swupdate</code>在系统启动后就已经启动服务了，其脚本<code>swupdate.sh</code>，用于启动该服务。该脚本还会遍历位于<code>/etc/swupdate/conf.d/</code>处的配置文件。</p>
<h2 id="客户端与服务端的通信逻辑"><a href="#客户端与服务端的通信逻辑" class="headerlink" title="客户端与服务端的通信逻辑"></a>客户端与服务端的通信逻辑</h2><p>同时，<code>swupdate</code>提供了客户端库，便于以直接调用函数的方式来完成通信。</p>
<p>在文件<code>network_ipc.h</code>中定义了通信的帧结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> magic;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        msgdata data;</span><br><span class="line">&#125; ipc_message;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>magic</code>：通信包的魔数</p>
</li>
<li><p><code>type</code>：包类型，包含：<code>REQ_INSTALL, ACK, NACK, GET_STATUS, POST_UPDATE, SWUPDATE_SUBPROCESS, SET_AES_KEY</code></p>
</li>
<li><p><code>msgdata</code>：通信的数据数据</p>
</li>
</ul>
<p>客户端和<code>swupdate</code>通信的流程如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/swupdate_progress.jpg?raw=true"></p>
<ol>
<li><p>客户端先发<code>REQ_INSTALL</code>，等待获取到<code>ACK</code>，然后就可以发送镜像文件了</p>
</li>
<li><p>客户端持续发送镜像文件直到发送完成，发送标记给<code>swupdate</code></p>
</li>
<li><p>客户端从<code>swupdate</code>获取多次获取状态，来记录升级的进度</p>
</li>
</ol>
<h2 id="客户端的-API-库说明"><a href="#客户端的-API-库说明" class="headerlink" title="客户端的 API 库说明"></a>客户端的 API 库说明</h2><h3 id="启动升级"><a href="#启动升级" class="headerlink" title="启动升级"></a>启动升级</h3><p>与升级相关的 API 有以下几个：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swupdate_async_start</span><span class="params">(writedata wr_func, getstatus status_func,</span></span></span><br><span class="line"><span class="params"><span class="function">        terminated end_func, <span class="keyword">void</span> *req, <span class="keyword">ssize_t</span> size)</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*writedata)</span><span class="params">(<span class="keyword">char</span> **buf, <span class="keyword">int</span> *size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*getstatus)</span><span class="params">(ipc_message *msg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*terminated)</span><span class="params">(RECOVERY_STATUS status)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>swupdate_async_start</code>：创建了一个线程与<code>swupdate</code>进行通信<ul>
<li><p><code>wr_func</code>：当需要获取升级包时，此函数会被调用</p>
</li>
<li><p><code>status_func</code>：当完成数据流传输时，有状态改变时该函数会被调用</p>
</li>
<li><p><code>end_func</code>：当 <code>swupdate</code>停止后，该函数会被调用</p>
</li>
<li><p><code>req</code>：是<code>swupdate_request</code>结构体，用于控制升级过程</p>
</li>
<li><p><code>size</code>：即为结构体的大小</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swupdate_request</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> apiversion;</span><br><span class="line">        sourcetype source;</span><br><span class="line">        <span class="keyword">int</span> dry_run;</span><br><span class="line">        <span class="keyword">size_t</span> len;</span><br><span class="line">        <span class="keyword">char</span> info[<span class="number">512</span>];</span><br><span class="line">        <span class="keyword">char</span> software_set[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">char</span> running_mode[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>source</code>：指定数据源的类型，包含<code>SOURCE_UNKNOWN, SOURCE_WEBSERVER, SOURCE_SURICATTA, SOURCE_DOWNLOADER, SOURCE_LOCAL</code></p>
</li>
<li><p><code>dry_run</code>：运行状态，包含<code>RUN_DEFAULT (set from command line), RUN_DRYRUN, RUN_INSTALL</code></p>
</li>
<li><p><code>info,len</code>：用于转发处理进程的接口</p>
</li>
<li><p><code>software_set,running_mode</code>：选择设置状态</p>
</li>
</ul>
<p><code>swupdate_request</code>结构体需要首先通过<code>swupdate_prepare_req()</code>来设置为默认值后再来进一步设置。</p>
<p>具体的使用流程，可以参考<code>examples/client</code>文件夹。</p>
<h3 id="设置-AES-密钥"><a href="#设置-AES-密钥" class="headerlink" title="设置 AES 密钥"></a>设置 AES 密钥</h3><p>AES 解密的密钥可以在命令行通过<code>-K</code>选项输入，也可以通过下面的函数输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swupdate_set_aes</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">char</span> *ivt)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里固定了是 AES-256 算法，所以<code>key</code>的长度是 64 字节的字符串，<code>ivt</code>是 32 字节的字符串。</p>
<h3 id="控制swupdate"><a href="#控制swupdate" class="headerlink" title="控制swupdate"></a>控制<code>swupdate</code></h3><p>函数<code>ipc_send_cmd</code>用于给<code>swupdate</code>发送命令，这个函数是同步发送的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_message</span> &#123;</span></span><br><span class="line">   sourcetype source; <span class="comment">/* Who triggered the update */</span></span><br><span class="line">   <span class="keyword">int</span>     cmd;       <span class="comment">/* Optional encoded command */</span></span><br><span class="line">   <span class="keyword">int</span>     timeout;     <span class="comment">/* timeout in seconds if an aswer is expected */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> len;    <span class="comment">/* Len of data valid in buf */</span></span><br><span class="line">   <span class="keyword">char</span>    buf[<span class="number">2048</span>];   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * Buffer that each source can fill</span></span><br><span class="line"><span class="comment">                         * with additional information</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">ipc_send_cmd</span><span class="params">(ipc_message *msg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>source</code>的值为<code>SWUPDATE_SUBPROCESS</code></p>
</li>
<li><p><code>cmd</code>的类型可以参考<code>network_ipc.h</code></p>
</li>
</ul>
<h3 id="在升级过程中获取信息"><a href="#在升级过程中获取信息" class="headerlink" title="在升级过程中获取信息"></a>在升级过程中获取信息</h3><p>除了可以获取升级的成功与失败外，还可以获取升级过程中的进度。客户端可以注册一个函数，来获取升级过程中的状态。</p>
<blockquote>
<p>swupdate-progress 是一个工具用于获取升级过程中的状态</p>
</blockquote>
<p>客户端注册的方式是通过<code>connect</code>来连接<code>/tmp/swupdateprog</code>，然后使用<code>recv</code>来获取消息即可，消息的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">progress_msg</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    magic;          <span class="comment">/* Magic Number */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    status;         <span class="comment">/* Update Status (Running, Failure) */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    dwl_percent;    <span class="comment">/* % downloaded data */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> dwl_bytes;   <span class="comment">/* total of bytes to be downloaded */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    nsteps;         <span class="comment">/* No. total of steps */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    cur_step;       <span class="comment">/* Current step index */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    cur_percent;    <span class="comment">/* % in current step */</span></span><br><span class="line">        <span class="keyword">char</span>            cur_image[<span class="number">256</span>]; <span class="comment">/* Name of image to be installed */</span></span><br><span class="line">        <span class="keyword">char</span>            hnd_name[<span class="number">64</span>];   <span class="comment">/* Name of running handler */</span></span><br><span class="line">        sourcetype      source;         <span class="comment">/* Interface that triggered the update */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>    infolen;        <span class="comment">/* Len of data valid in info */</span></span><br><span class="line">        <span class="keyword">char</span>            info[<span class="number">2048</span>];     <span class="comment">/* additional information about install */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>status</code>：大的状态，包含<code>START, RUN, SUCCESS, FAILURE, DOWNLOAD, DONE</code></p>
</li>
<li><p><code>dwl_percent</code>：当状态为<code>DOWNLOAD</code>时，表示下载的状态</p>
</li>
<li><p><code>dwl_bytes</code>：已经下载的总字节数</p>
</li>
<li><p><code>nsteps</code>：总共运行的 handler 的数量</p>
</li>
<li><p><code>cur_step</code>：当前运行的 handler 的序号</p>
</li>
<li><p><code>cur_percent</code>：当前运行的 <code>handler</code>的进度</p>
</li>
<li><p><code>cur_images</code>：当前正在安装的镜像名</p>
</li>
<li><p><code>hnd_name</code>：当前正在运行的 handler 名</p>
</li>
<li><p><code>infolen</code>：info 数组中包含的数据长度</p>
</li>
<li><p><code>info</code>：安装过程的附加信息</p>
</li>
</ul>
<p>整个过程的示例代码位于：<code>tools/swupdate-progress.c</code></p>
<h3 id="bootloader-接口"><a href="#bootloader-接口" class="headerlink" title="bootloader 接口"></a>bootloader 接口</h3><p>bootloader 接口主要是对其环境变量进行设定的接口，其位于<code>include/bootloader.h</code>文件中，包含的有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">env_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 删除环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">env_unset</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 从文件中读取并批量写入文件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apply_list</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些函数需要一开始被注册：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> bootloader trunk = &#123;</span><br><span class="line">    .env_get = &amp;do_env_get,</span><br><span class="line">    .env_set = &amp;do_env_set,</span><br><span class="line">    .env_unset = &amp;do_env_unset,</span><br><span class="line">    .apply_list = &amp;do_apply_list</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trunk_probe</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">register_bootloader</span>(BOOTLOADER_TRUNK, &amp;trunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>bootloader/uboot.c</code>中有使用示例。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>swupdate</category>
      </categories>
      <tags>
        <tag>swupdate</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 bootloader</title>
    <url>/2024/02/04/linux_make_yocto_bootloader/</url>
    <content><![CDATA[<p>重新整理引导的构建相关知识。</p>
<span id="more"></span>

<h1 id="bootloader-的职责"><a href="#bootloader-的职责" class="headerlink" title="bootloader 的职责"></a>bootloader 的职责</h1><p>bootloader 主要就是用于依次做两件事：</p>
<ol>
<li>初始化系统的硬件环境</li>
<li>载入内核</li>
</ol>
<p>在系统最开始上电时，能用的资源只有：</p>
<ol>
<li>一个单核</li>
<li>有限的内部 SRAM</li>
<li>一个 boot ROM</li>
</ol>
<h1 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h1><p>对于现代 SOC 而言，其通常的启动顺序如下。</p>
<h2 id="初始阶段：ROM-code"><a href="#初始阶段：ROM-code" class="headerlink" title="初始阶段：ROM code"></a>初始阶段：ROM code</h2><p><code>ROM code</code>便是 SOC 启动时的初始代码，它通过单核运行。</p>
<p>根据启动配置引脚从对应的接口载入代码到内部 SRAM 中，然后运行该代码。</p>
<blockquote>
<p>由于 SRAM 中运行的代码是第二阶段运行的代码，所以它也叫做 SPL（secondary program loader）</p>
</blockquote>
<p>ROM code 读取 SPL 有多种方式，但从数据的角度讲有两种：</p>
<ol>
<li><p>ROM code 不支持文件系统，只能在设备存储底层固定位置偏移处进行读取</p>
</li>
<li><p>ROM code 支持文件系统，根据设置中的文件名获取</p>
</li>
</ol>
<blockquote>
<p>bbb 上的 AM335X 则可以支持两种方式的读出 SPL</p>
</blockquote>
<h3 id="imx8mm的-ROM-code"><a href="#imx8mm的-ROM-code" class="headerlink" title="imx8mm的 ROM code"></a>imx8mm的 ROM code</h3><p>imx8mm 上电后最开始当然也是先运行 ROM code，它根据寄存器<code>BOOT_MODE[1:0]</code>、eFUSEs 状态 和 GPIO 的设定来决定启动的行为。</p>
<p>ROM code 还可以从启动设备的代码中获取配置信息，根据该配置来配置 DDR 等外设。</p>
<p>ROM code 还可以对启动代码进行验证，如果是未经授权的代码则不会被执行。</p>
<h3 id="imx8mm-的-BOOT-MODE-寄存器"><a href="#imx8mm-的-BOOT-MODE-寄存器" class="headerlink" title="imx8mm 的 BOOT_MODE 寄存器"></a>imx8mm 的 BOOT_MODE 寄存器</h3><p>BOOT_MODE 寄存器的[1:0] 两位是在上电时，根据管脚<code>BOOT_MODE0</code>和<code>BOOT_MODE1</code>来决定的：</p>
<table>
<thead>
<tr>
<th>BOOT_MODE[1:0]</th>
<th>Boot Type</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>Boot From Fuses</td>
</tr>
<tr>
<td>01</td>
<td>Serial Downloader</td>
</tr>
<tr>
<td>10</td>
<td>Internal Boot</td>
</tr>
<tr>
<td>11</td>
<td>Reserved</td>
</tr>
</tbody></table>
<p><strong>Boot From Fuses：</strong></p>
<p>ROM code 从 eFUSE 读取的 <code>BT_FUSE_SEL</code>来决定如何启动，GPIO 配置会被忽略：</p>
<ul>
<li>BT_FUSE_SEL = 0：通过<code>Serial Downloader</code>启动</li>
<li>BT_FUSE_SEL = 1：通过 eFUSE 的设定的启动设备启动</li>
</ul>
<p>在产品出厂时，一般会选择这种模式来启动：</p>
<blockquote>
<p>由于一开始 BT_FUSE_SEL = 0，会通过<code>Serial Downloader</code>模式启动。这部分代码启动后完成多个镜像的烧写，然后配置  BT_FUSE_SEL = 1，并设置对应启动设备。</p>
<p>下次再次启动设备时，ROM code 就会从指定的启动设备启动。</p>
</blockquote>
<p><strong>Serial Downloader：</strong></p>
<p>这里的<code>Serial Downloader</code>其实指的就是通过 USB 来启动设备。</p>
<p>如果在<code>USDHC2</code>端口上有 SD 卡/EMMC，那么 ROM code 会先尝试从它们启动。</p>
<blockquote>
<p>可以通过配置 fuse 来关闭这种启动。</p>
</blockquote>
<p><strong>Internal Boot：</strong></p>
<p>ROM code 会从 GPIO 指定的引脚来确定启动设备，如果启动失败会尝试<code>Serial Downloader</code>。</p>
<p>如果<code>BT_FUSE_SEL = 1</code>，则会从 eFUSE 设定的设备启动。</p>
<p>管脚<code>SAI1_RXD0~7,SAI1_TXD0~7</code>依次决定了<code>BOOT_CFG</code>寄存器的 0~15 位。</p>
<p>其中，<code>BOOT_CFG</code>的 12~14 位用于选择启动设备：</p>
<table>
<thead>
<tr>
<th>BOOT_CFG[14:12]</th>
<th>Boot device</th>
</tr>
</thead>
<tbody><tr>
<td>001</td>
<td>SD/eSD</td>
</tr>
<tr>
<td>010</td>
<td>MMC/eMMC</td>
</tr>
<tr>
<td>011</td>
<td>NAND</td>
</tr>
<tr>
<td>100</td>
<td>Serial NOR boot via FlexSPI</td>
</tr>
<tr>
<td>110</td>
<td>Serial(SPI) NOR</td>
</tr>
</tbody></table>
<p>当选择对应设备时，<code>BOOT_CFG</code>的 0~11，15 用于指定设备的配置细节。比如操作频率，等待时间等。</p>
<p>米尔科技将<code>BOOT_CFG</code>的 0~13 位以及 <code>BOOT_MODE0</code>和<code>BOOT_MODE1</code>都引了到拨码开关 SW1,2。那么就可以灵活的配置其启动模式。</p>
<h2 id="第二阶段：SPL"><a href="#第二阶段：SPL" class="headerlink" title="第二阶段：SPL"></a>第二阶段：SPL</h2><p>SPL 的主要目标就是初始化 SDRAM ，然后将下一阶段的 bootloader 拷贝进 SDRAM，跳转后运行。</p>
<blockquote>
<p>SDRAM 的 bootloader 属于第三阶段，所以也叫做 TPL（Tertiary Program Loader）。</p>
</blockquote>
<p>imx8mm 具有 256 + 32 KB 的 SRAM，其中 256 KB 用于载入 SPL，而 32 KB 是备用区。</p>
<ul>
<li>256KB SRAM 的地址范围是 0x00910000 ~ 0x0091FFFF</li>
<li>32KB SRAM 的起始地址是 0x0090000</li>
</ul>
<blockquote>
<p> 所以 imx8mm 的 SPL 大小不能超过 256 KB.</p>
</blockquote>
<p>bbb 上的 AM335X 的 SPL 大小不能超过 128KB。</p>
<h2 id="第三阶段：TPL"><a href="#第三阶段：TPL" class="headerlink" title="第三阶段：TPL"></a>第三阶段：TPL</h2><p>第三阶段的 bootloader 就可以与用户交互，并具备了诊断硬件的功能。</p>
<p>最终还是为了将内核和文件系统载入进 SDRAM，然后跳转去运行内核。</p>
<p>一旦进入到内核，该阶段 bootloader 所占用的内存就被释放了。</p>
<blockquote>
<p>在有了设备树后，需要传递给内核的参数基本上由设备树来设定了。</p>
<p>bootloader 只需要告诉内核，设备树所位于的地址。</p>
</blockquote>
<h1 id="设备树复习"><a href="#设备树复习" class="headerlink" title="设备树复习"></a>设备树复习</h1><p>现在再回过头来看设备树，其实它也就是一个配置文件而已，只是配置的目标是硬件，并且符合<a href="%5BDeviceTree%5D(https://www.devicetree.org/)">设备树标准</a>。</p>
<blockquote>
<p>而面对已有的设备，需要修改设备树。那么就可以参考其对应文档的说明，文档位于<code>Documentation/devicetree/bindings</code></p>
</blockquote>
<h2 id="设备树基础"><a href="#设备树基础" class="headerlink" title="设备树基础"></a>设备树基础</h2><p>设备树的起始源文件存储于：</p>
<ul>
<li>Linux：<code>arch/$&#123;ARCH&#125;/boot/dts</code></li>
<li>U-boot：<code>arch/$&#123;ARCH&#125;/dts</code></li>
</ul>
<p>设备树从根节点开始，向下以树的形式扩展子节点，节点的内容由<code>属性=值</code>的方式组成。</p>
<p>简单的示例如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/&#123;</span><br><span class="line">    model = <span class="string">&quot;TI AM335x BeagleBone&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;ti,am33xx&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">    cpus &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;</span>;</span></span><br><span class="line">        cpu@<span class="number">0</span> &#123;</span><br><span class="line">            compatible = <span class="string">&quot;arm,cortex-a8&quot;</span>;</span><br><span class="line">            <span class="comment">// 指定节点的类型</span></span><br><span class="line">            device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">            reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    memory@<span class="number">0x80000000</span> &#123;</span><br><span class="line">        <span class="comment">// 指定节点的类型</span></span><br><span class="line">        device_type = <span class="string">&quot;memory&quot;</span>;</span><br><span class="line">        <span class="comment">// 起始地址和大小</span></span><br><span class="line">        reg = &lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;; <span class="comment">/* 512 MB */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;        </span><br></pre></td></tr></table></figure>

<h2 id="reg-属性"><a href="#reg-属性" class="headerlink" title="reg 属性"></a>reg 属性</h2><p>reg 属性中值的规则由其父节点的<code>#address-cells</code>和<code>#size-cells</code>来确定：</p>
<ul>
<li><code>#address-cells</code>：代表由多少个 cells 来表示一个完整的地址</li>
<li><code>#size-cells</code>：代表由多少个 cells 来表示大小</li>
</ul>
<p>比如上面的 cpu节点，由于只需要表示地址而无需表示大小，所以：</p>
<blockquote>
<p>#address-cells = &lt;1&gt;;</p>
<p>#size-cells = &lt;0&gt;;</p>
</blockquote>
<p>而对于 32 位内存空间，就需要一个 cell 表示地址，一个 cell 表示大小，所以：</p>
<blockquote>
<p>#address-cells = &lt;1&gt;;<br>#size-cells = &lt;1&gt;;</p>
<p>// 起始地址是 0x80000000 ，大小是 0x20000000，也就是 512 MB</p>
<p>reg = &lt;0x80000000 0x20000000&gt;; /* 512 MB */</p>
</blockquote>
<p>而如果是 64 位地址空间，那么就必然需要两个 cell 表示地址，两个 cell 表示大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="meta-string">&lt;2&gt;</span>;</span></span><br><span class="line">    memory@<span class="number">80000000</span> &#123;</span><br><span class="line">        device_type = <span class="string">&quot;memory&quot;</span>;</span><br><span class="line">        <span class="comment">// 前两个 cells 表示起始地址，后两个 cells 表示大小</span></span><br><span class="line">        reg = &lt;<span class="number">0x00000000</span> <span class="number">0x80000000</span> <span class="number">0</span> <span class="number">0x80000000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="label-和中断"><a href="#label-和中断" class="headerlink" title="label 和中断"></a>label 和中断</h2><p>通常一个节点的名称是包含其字符串和地址，很多时候我们需要引用这个节点或对其内容进行修改或增加，那么为其添加一个 label ，以便于以后引用方便。这个 label 就被称为 <code>phandles</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">&#123;    </span><br><span class="line">    intc: interrupt-controller@<span class="number">48200000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;ti,am33xx-intc&quot;</span>;</span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="meta-string">&lt;1&gt;</span>;</span></span><br><span class="line">        reg = &lt;<span class="number">0x48200000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">    lcdc: lcdc@<span class="number">4830e000</span> &#123;</span><br><span class="line">        compatible = <span class="string">&quot;ti,am33xx-tilcdc&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x4830e000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">        interrupt-parent = &lt;&amp;intc&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">36</span>&gt;;</span><br><span class="line">        ti,hwmods = <span class="string">&quot;lcdc&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面为中断控制器设定了<code>intc</code>为其<code>phandle</code>，所以在 lcdc 节点中就可以通过<code>&amp;intc</code>的方式来引用。</p>
<p>中断控制器中的<code>#interrupt-cells = &lt;1&gt;;</code>代表使用该中断控制器的节点需要在其<code>interrupts</code>属性中填入一个值即可。</p>
<h2 id="设备树包含"><a href="#设备树包含" class="headerlink" title="设备树包含"></a>设备树包含</h2><p>设备树的公有部分的文件后缀是<code>.dtsi</code>，以被其他设备树文件以<code>/include/</code>的方式包含：</p>
<blockquote>
<p>/include/ “vexpress-v2m.dtsi”</p>
</blockquote>
<p>除了上面这种方式，设备树还可以包含 c 头文件，以获取其文件内部的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/gpio/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/pinctrl/am33xx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/clock/am3.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="编译设备树"><a href="#编译设备树" class="headerlink" title="编译设备树"></a>编译设备树</h2><p>使用设备树编译器<code>dtc</code>，将设备树源文件<code>dts</code>，编译为设备树二进制文件<code>dtb</code>：</p>
<blockquote>
<p>$ dtc simpledts-1.dts -o simpledts-1.dtb</p>
</blockquote>
<h1 id="U-Boot"><a href="#U-Boot" class="headerlink" title="U-Boot"></a>U-Boot</h1><p>为了使这个步骤尽量简单，我们不使用[原本的U-boot](<a href="https://www.denx.de/wiki/U-Boot">WebHome &lt; U-Boot &lt; DENX</a>)，而是使用<a href="https://github.com/MYiR-Dev/myir-imx-uboot">米尔科技的 U-boot 分支</a>。</p>
<h2 id="imx8mm-在-ROM-code-之后的启动流程"><a href="#imx8mm-在-ROM-code-之后的启动流程" class="headerlink" title="imx8mm 在 ROM code 之后的启动流程"></a>imx8mm 在 ROM code 之后的启动流程</h2><p>前面说过，在 ROM code 之后便是根据配置选择启动设备，从中读出代码，代码依次分为这么几部分：</p>
<ol>
<li><p><a href="https://source.codeaurora.org/external/imx/imx-atf/">i.MX ARM Trusted firmware</a>：用于配置是否使用安全启动</p>
</li>
<li><p>imx-uboot：uboot 就分为了 SPL 和 TPL</p>
<blockquote>
<p>U-boot 的 falcon 模式可以直接从 SPL 装载内核然后运行，节约开机时间</p>
</blockquote>
</li>
<li><p>controller firmware：用于 uboot 的 SPL 调用，来初始化 ddr</p>
</li>
</ol>
<h2 id="编译-imx-atf"><a href="#编译-imx-atf" class="headerlink" title="编译 imx-atf"></a>编译 imx-atf</h2><p>首先需要将交叉编译工具链，加入当前 SHELL 的环境变量中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/home/cec/x-tools/aarch64-unknown-linux-gnu/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>

<p>由于 imx-atf 使用的是 Makefile 编译，并且查看其源文件也可以看到它会使用变量<code>CROSS_COMPILE</code>，所以需要设定变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CROSS_COMPILE=aarch64-unknown-linux-gnu-</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照惯例，先 clean 一次</span></span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p>然后可以使用<code>make help</code>查看编译说明：</p>
<blockquote>
<p>usage: make PLAT=&lt;a70x0|a70x0_amc|a80x0|a80x0_mcbin|fvp|hikey|hikey960|imx8dx|imx8dxl|imx8mm|imx8mn|imx8mp|imx8mq|imx8qm|imx8qx|juno|k3|ls1043|mt6795|mt8173|poplar|qemu|rk3328|rk3368|rk3399|rpi3|sgi575|sgm775|stm32mp1|sun50i_a64|sun50i_h6|synquacer|tegra|uniphier|warp7|zynqmp&gt; [OPTIONS] [TARGET]</p>
<p>PLAT is used to specify which platform you wish to build.<br>If no platform is specified, PLAT defaults to: fvp</p>
</blockquote>
<p>可以看到需要为其指定 SOC，那么我们自然是指定 <code>imx8mm</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make PLAT=imx8mm</span><br></pre></td></tr></table></figure>

<p>最后生成文件<code>build/imx8mm/release/bl31.bin</code>。</p>
<h2 id="编译-U-boot"><a href="#编译-U-boot" class="headerlink" title="编译 U-boot"></a>编译 U-boot</h2><p>编译 U-boot 的步骤和编译内核都差不多：</p>
<ol>
<li>使用一个最接近当前硬件的配置</li>
<li>使用<code>menuconfig</code>进行进一步细节配置</li>
<li>使用<code>make</code>编译</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照惯例先 clean 一次</span></span><br><span class="line">make distclean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于 bbb 而言，就是 am335x_evm_defconfig</span></span><br><span class="line">make myd_imx8mm_defconfig</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始编译</span></span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<p>然后会生成以下几个文件：</p>
<ul>
<li><code>u-boot</code>：U-boot 的 ELF 目标文件，里面包含了调试信息</li>
<li><code>u-boot.map</code>：符号表</li>
<li><code>u-boot.bin</code>：去掉调试信息的二进制文件</li>
<li><code>u-boot.img</code>：在 <code>u-boot.bin</code>之上包含 U-boot 头信息</li>
<li><code>u-boot.srec</code>：U-boot 的 SRC 格式，可以通过串口传输</li>
<li><code>spl/u-boot-spl.bin</code>：SPL 阶段运行的代码</li>
</ul>
<blockquote>
<p>对于 bbb 而言，如果是以文件系统的方式启动 SPL，它需要的 SPL 叫做 MLO，这也会在编译 uboot 时顺带编译了。</p>
</blockquote>
<h2 id="启动-U-boot"><a href="#启动-U-boot" class="headerlink" title="启动 U-boot"></a>启动 U-boot</h2><p>查看脚本文件<code>make-uboot-emmc.sh</code>内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp myir-imx-uboot/tools/mkimage                      ./imx-mkimage/iMX8M/mkimage_uboot</span><br><span class="line">cp myir-imx-uboot/arch/arm/dts/myb-imx8mm-base.dtb   ./imx-mkimage/iMX8M/fsl-imx8mm-ddr4-evk.dtb</span><br><span class="line">cp myir-imx-uboot/spl/u-boot-spl.bin                 ./imx-mkimage/iMX8M/</span><br><span class="line">cp myir-imx-uboot/u-boot-nodtb.bin                   ./imx-mkimage/iMX8M/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> firmware-imx-8.7</span> </span><br><span class="line">cp firmware-imx-8.7/firmware/ddr/synopsys/ddr4_dmem_1d.bin                     ./imx-mkimage/iMX8M/</span><br><span class="line">cp firmware-imx-8.7/firmware/ddr/synopsys/ddr4_dmem_2d.bin                     ./imx-mkimage/iMX8M/</span><br><span class="line">cp firmware-imx-8.7/firmware/ddr/synopsys/ddr4_imem_1d.bin                     ./imx-mkimage/iMX8M/</span><br><span class="line">cp firmware-imx-8.7/firmware/ddr/synopsys/ddr4_imem_2d.bin                     ./imx-mkimage/iMX8M/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> imx8mm-atf</span></span><br><span class="line">cp imx-atf/build/imx8mm/release/bl31.bin                                    ./imx-mkimage/iMX8M/</span><br><span class="line"></span><br><span class="line">cd imx-mkimage</span><br><span class="line">make SOC=iMX8MM clean</span><br><span class="line">make SOC=iMX8MM flash_ddr4_evk</span><br></pre></td></tr></table></figure>

<p>可以看到，其主要是将之前编译的文件拷贝到<code>imx-mkimage</code>文件夹中，然后运行<code>make</code>开始制作。</p>
<p><a href="https://source.codeaurora.org/external/imx/imx-mkimage">imx-mkimage</a>是 IMX 做的打包工具，最终生成文件<code>flash.bin</code>。</p>
<p>那这个<code>flash.bin</code>应该放在哪里，在<code>imx_linux_users_guide</code>中有说明：</p>
<blockquote>
<p> Execute the following command to copy the U-Boot image to the SD/MMC card:</p>
<blockquote>
<p>$ sudo dd if=<U-Boot image> of=/dev/sdx bs=1k seek=<offset> conv=fsync</p>
</blockquote>
<p>Where offset is:</p>
<ul>
<li>1 - for i.MX 6 or i.MX 7</li>
<li>33 - for i.MX 8QuadMax A0, i.MX 8QuadXPlus A0, and i.MX 8M Quad</li>
<li>32 - for i.MX 8QuadXPlus B0, i.MX 8QuadMax B0, i.MX 8DualX, i.MX 8DXL,i.MX 8M Nano, i.MX 8M Mini, and i.MX 8M Plus</li>
</ul>
<p>The first 16 KB of the SD/MMC card, which includes the partition table, is reserved.</p>
</blockquote>
<p>由于我们使用的是 IMX8MM，按照上面说明<code>seek</code>应该是<code>32</code>。</p>
<blockquote>
<p> 但实际测试发现需要设置<code>33</code>才行，米尔的手册上面也是 33……</p>
</blockquote>
<p>最后就是熟悉的启动输出了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">U-Boot SPL 2019.04-g65e4ca0a-dirty (Sep 03 2021 - 17:02:00 +0800)</span><br><span class="line">power_bd71837_init</span><br><span class="line">DDRINFO: start DRAM init</span><br><span class="line">DDRINFO:ddrphy calibration done</span><br><span class="line">DDRINFO: ddrmix config done</span><br><span class="line">Normal Boot</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">U-Boot 2019.04-g65e4ca0a-dirty (Sep 03 2021 - 17:02:00 +0800)</span><br><span class="line"></span><br><span class="line">CPU:   Freescale i.MX8MMQ rev1.0 1800 MHz (running at 1200 MHz)</span><br><span class="line">CPU:   Commercial temperature grade (0C to 95C)CPU Temperature (43000C) has beyond alert (85000C), close to critical (95000C) at 43C</span><br><span class="line">Reset cause: POR</span><br><span class="line">Model: MYD i.MX8MM  board</span><br><span class="line">DRAM:  2 GiB</span><br><span class="line">MMC:   FSL_SDHC: 1, FSL_SDHC: 2</span><br><span class="line">Loading Environment from MMC... Run CMD11 1.8V switch</span><br><span class="line">*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial</span><br><span class="line">Out:   serial</span><br><span class="line">Err:   serial</span><br><span class="line"></span><br><span class="line"> BuildInfo:</span><br><span class="line">  - ATF f1a195b</span><br><span class="line">  - U-Boot 2019.04-g65e4ca0a-dirty</span><br><span class="line"></span><br><span class="line">Run CMD11 1.8V switch</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc1 is current device</span><br><span class="line">flash target is MMC:1</span><br><span class="line">Run CMD11 1.8V switch</span><br><span class="line">Net:   </span><br><span class="line">Error: ethernet@30be0000 address not set.</span><br><span class="line"></span><br><span class="line">eth-1: ethernet@30be0000</span><br><span class="line">Fastboot: Normal</span><br><span class="line">Normal Boot</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">Run CMD11 1.8V switch</span><br><span class="line">switch to partitions #0, OK</span><br><span class="line">mmc1 is current device</span><br><span class="line">Run CMD11 1.8V switch</span><br><span class="line">** Unrecognized filesystem type **</span><br><span class="line"></span><br><span class="line">Booting from net ...</span><br><span class="line"></span><br><span class="line">Error: ethernet@30be0000 address not set.</span><br><span class="line"></span><br><span class="line">WARN: Cannot load the DT</span><br><span class="line">u-boot=&gt; </span><br></pre></td></tr></table></figure>

<h2 id="复习-U-boot-的基础知识"><a href="#复习-U-boot-的基础知识" class="headerlink" title="复习  U-boot 的基础知识"></a>复习  U-boot 的基础知识</h2><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>U-boot 使用<code>name=value</code>的形式来表示环境变量，一些环境变量是最开始在头文件中已经配置了默认值。在启动后读入内存，便可以被修改了。</p>
<blockquote>
<p>对环境变量的操作都在<code>env</code>命令中</p>
</blockquote>
<p>如何找到环境变量在代码中的位置？</p>
<p>以 AM335 为例，可以搜索其对应的 config 文件，比如<code>am335x_evm_defconfig</code>，就可以找到其维护说明文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AM335X BOARD</span><br><span class="line">M:    Tom Rini &lt;trini@konsulko.com&gt;</span><br><span class="line">S:    Maintained</span><br><span class="line">F:    board/ti/am335x/</span><br><span class="line">F:    include/configs/am335x_evm.h</span><br><span class="line">F:    configs/am335x_boneblack_vboot_defconfig</span><br><span class="line">F:    configs/am335x_evm_defconfig</span><br><span class="line">F:    configs/am335x_evm_spiboot_defconfig</span><br></pre></td></tr></table></figure>

<p>然后可以看到其配置文件是 <code>am335x_evm.h</code>，搜索该文件的名字<code>am335x_evm</code>，可以看到对应的配置使能：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">    default &quot;am335x_evm&quot;</span><br></pre></td></tr></table></figure>

<p>所以虽然在代码中没有明确搜到<code>#include &quot;am335x_evm.h&quot;</code>这种代码，但是可以看到是根据配置自动生成的中间代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> include/config.h</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Prior to Kconfig, it was generated by mkconfig. Now it is created here.</span></span><br><span class="line">define filechk_config_h</span><br><span class="line">    (echo &quot;/* Automatically generated - do not edit */&quot;;        \</span><br><span class="line">    for i in $$(echo $(CONFIG_SYS_EXTRA_OPTIONS) | sed &#x27;s/,/ /g&#x27;); do \</span><br><span class="line">        echo \#define CONFIG_$$i                \</span><br><span class="line">        | sed &#x27;/=/ &#123;s/=/    /;q; &#125; ; &#123; s/$$/    1/; &#125;&#x27;; \</span><br><span class="line">    done;                                \</span><br><span class="line">    echo \#define CONFIG_BOARDDIR board/$(if $(VENDOR),$(VENDOR)/)$(BOARD);\</span><br><span class="line">    echo \#include \&lt;config_uncmd_spl.h\&gt;;                \</span><br><span class="line">    echo \#include \&lt;configs/$(CONFIG_SYS_CONFIG_NAME).h\&gt;;        \</span><br><span class="line">    echo \#include \&lt;asm/config.h\&gt;;                \</span><br><span class="line">    echo \#include \&lt;linux/kconfig.h\&gt;;                \</span><br><span class="line">    echo \#include \&lt;config_fallbacks.h\&gt;;)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>该文件中定义的宏<code>CONFIG_EXTRA_ENV_SETTINGS</code>，就会被包含在<code>default_environment</code>中。</p>
<p>最后该只读字符串就会在<code>env_init()</code>被赋值到全局地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret == -ENOENT) &#123;</span><br><span class="line">    gd-&gt;env_addr = (ulong)&amp;default_environment[<span class="number">0</span>];</span><br><span class="line">    gd-&gt;env_valid = ENV_VALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会被放入初始化列表<code>init_sequence_f</code>中进行调用。</p>
<p>需要注意的是：如果在 u-boot 中定义了环境变量<code>bootargs</code>，那么它就会在启动时，将该变量内容覆盖到设备树中的 bootargs！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdt_chosen</span><span class="params">(<span class="keyword">void</span> *fdt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>   nodeoffset;</span><br><span class="line">    <span class="keyword">int</span>   err;</span><br><span class="line">    <span class="keyword">char</span>  *str;        <span class="comment">/* used to set string properties */</span></span><br><span class="line"></span><br><span class="line">    err = fdt_check_header(fdt);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fdt_chosen: %s\n&quot;</span>, fdt_strerror(err));</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* find or create &quot;/chosen&quot; node. */</span></span><br><span class="line">    nodeoffset = fdt_find_or_add_subnode(fdt, <span class="number">0</span>, <span class="string">&quot;chosen&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nodeoffset &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nodeoffset;</span><br><span class="line"></span><br><span class="line">    str = env_get(<span class="string">&quot;bootargs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">        err = fdt_setprop(fdt, nodeoffset, <span class="string">&quot;bootargs&quot;</span>, str,</span><br><span class="line">                  <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;WARNING: could not set bootargs %s.\n&quot;</span>,</span><br><span class="line">                   fdt_strerror(err));</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fdt_fixup_stdout(fdt, nodeoffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="载入内核"><a href="#载入内核" class="headerlink" title="载入内核"></a>载入内核</h3><p>对于 u-boot 而言有多种方式可以载入内核，比如：</p>
<p>通过 <code>mmc</code> 载入并读取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 扫描 mmc</span></span><br><span class="line">mmc rescan</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从 mmc0 的第一个分区读取文件 uImage 到物理内存 0x82000000 处</span></span><br><span class="line">fatload mmc 0:1 82000000 uImage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 分析文件</span></span><br><span class="line">iminfo 82000000</span><br></pre></td></tr></table></figure>

<p>通过<code>tftp</code>读取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置本机和服务端（PC）的地址</span></span><br><span class="line">setenv ipaddr 192.168.159.42</span><br><span class="line">setenv serverip 192.168.159.99</span><br><span class="line"><span class="meta">#</span><span class="bash"> tftp 读取 uImage 到 0x82000000</span></span><br><span class="line">tftp 82000000 uImage</span><br></pre></td></tr></table></figure>

<h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><p>使用<code>bootm</code>启动内核，其语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bootm &lt;address of kernel&gt; [address of ramdisk] [address of </span><br><span class="line">dtb]</span><br></pre></td></tr></table></figure>

<p>其中<code>address of kernel</code>是必须的，后面两项不是必须的。</p>
<p>如果没有<code>address of ramdisk</code>但是有<code>address of dtb</code>，那么使用短横线代替即可:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; bootm 82000000 – 83000000</span><br></pre></td></tr></table></figure>

<p>除了在调试阶段需要手动输入这些命令，实际使用阶段是经过脚本来完成，比如 imx8mm 默认环境变量如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mmcdev=1</span><br><span class="line">mmcpart=1</span><br><span class="line">loadaddr=0x40480000</span><br><span class="line">script=boot.scr</span><br><span class="line">bootscript=echo Running bootscript from mmc ...; source</span><br><span class="line">image=Image</span><br><span class="line">fdt_addr=0x43000000</span><br><span class="line">fdt_file=myb-imx8mm-lcd-hontron-7.dtb</span><br><span class="line">boot_fdt=try</span><br><span class="line">console=ttymxc1,115200 earlycon=ec_imx6q,0x30890000,115200</span><br><span class="line">mmcroot=/dev/mmcblk1p2 rootwait rw</span><br><span class="line"></span><br><span class="line">mmcargs=setenv bootargs $&#123;jh_clk&#125; console=$&#123;console&#125; root=$&#123;mmcroot&#125;</span><br><span class="line">loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;</span><br><span class="line"></span><br><span class="line">loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</span><br><span class="line">loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;</span><br><span class="line"></span><br><span class="line">mmcboot=\</span><br><span class="line">echo Booting from mmc ...;\</span><br><span class="line">run mmcargs;\</span><br><span class="line">if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try;\</span><br><span class="line">then if run loadfdt;\</span><br><span class="line">     then booti $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;\</span><br><span class="line">     else echo WARN: Cannot load the DT;\</span><br><span class="line">     fi;\</span><br><span class="line">else echo wait for boot;\</span><br><span class="line">fi;\</span><br><span class="line"></span><br><span class="line">bootcmd=\</span><br><span class="line">mmc dev $&#123;mmcdev&#125;;\</span><br><span class="line">if mmc rescan;\ # 扫描 mmc，发现有 mmc</span><br><span class="line">then if run loadbootscript;\ </span><br><span class="line">     then run bootscript;\ # 如果从 mmc 读取文件成功，则运行启动脚本</span><br><span class="line">     else if run loadimage;\ # 或者从 mmc 读取指定名称文件</span><br><span class="line">          then run mmcboot;\ # 读取成功则运行启动脚本</span><br><span class="line">          else run netboot;\ # 然后会尝试通过网络启动</span><br><span class="line">          fi;\ </span><br><span class="line">     fi;\ </span><br><span class="line">else booti $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;\ </span><br><span class="line">fi\</span><br></pre></td></tr></table></figure>

<p><code>bootcmd</code>将会是 U-boot 启动以后自动执行的命令。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 构建系统</title>
    <url>/2024/03/09/linux_make_yocto_build_system/</url>
    <content><![CDATA[<p>前面已经手撸了整个嵌入式系统的构建过程，但是在实际工作中，尤其是根文件系统的建立是很费时间的。这个时候一个自动化的构建工具就非常重要了。</p>
<p>自动化构建工具，需要能完成：</p>
<ol>
<li>自动化的获取源码（不管是网络还是本地）</li>
<li>为源码打补丁，并进行一些配置</li>
<li>完成构建</li>
<li>将构建的文件组织成根文件系统</li>
<li>最终可以将多个镜像文件打包并装载到目标机。</li>
</ol>
<p>以上的过程都是可以用户灵活配置的，并可以输出 SDK 便于多个开发人员的环境统一。</p>
<p>目前有以下自动化构建工具：</p>
<ol>
<li><a href="https://buildroot.org/">Buildroot</a>：使用 Make 和 Kconfig 的构建工具，非常易于使用。</li>
<li><a href="https://www.embtoolkit.org/">EmbToolkit</a>：用于构建跟文件系统和工具链的简单构建工具</li>
<li><a href="https://openembedded.org/">OpenEmbedded</a>：功能强大的构建系统，是 Yocto 的核心组件</li>
<li><a href="https://openwrt.org/">OpenWrt</a>：专用于构建无线路由器软件包的工具</li>
<li><a href="https://www.ptxdist.org/">PTXdist</a>：简单的构建工具</li>
<li><a href="https://www.yoctoproject.org/">Yocto</a>基于 OpenEmbedded 扩展的元数据、工具、文档集，更为强大的构建工具</li>
</ol>
<p>其中 Buildroot 最易用，Yocto 最完善，所以这里只关注 Buildroot 和 Yocto。</p>
<span id="more"></span>

<h1 id="使用-Buildroot-构建"><a href="#使用-Buildroot-构建" class="headerlink" title="使用 Buildroot 构建"></a>使用 Buildroot 构建</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>要正常使用 Buildroot 需要至少安装以下依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install -y sed make binutils build-essential \</span><br><span class="line">diffutils gcc g++ bash patch gzip bzip2 perl tar cpio unzip \</span><br><span class="line">rsync file bc findutils wget python3 libncurses5-dev </span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>buildroot 具有一些默认配置文件，存在于<code>configs</code>文件夹下，也可以使用<code>make list-defconfigs</code> 来列出所有的默认配置。</p>
<p>对于 bbb 而言就是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make beaglebone_defconfig menuconfig</span><br></pre></td></tr></table></figure>

<p>接下来需要对配置做一些修改。</p>
<ol>
<li><p>选择自己构建的工具链：</p>
<ul>
<li><p><strong>Toolchain-&gt;Toolchain type-&gt;External toolchain</strong></p>
</li>
<li><p><strong>Toolchain-&gt;Toolchain-&gt;Custom toolchain</strong></p>
</li>
<li><p><strong>Toolchain-&gt;Toolchain path</strong>：填入工具链的路径</p>
</li>
<li><p><strong>Toolchain-&gt;Toolchain prefix</strong>：修改为正确的工具链前缀</p>
</li>
<li><p>选择 c 库为 glibc</p>
</li>
</ul>
</li>
<li><p>配置工具链的版本：</p>
<ul>
<li><strong>Toolchain-&gt;External toolchain gcc version</strong>：可以通过<code>arm-cortex_a8-linux-gnueabihf-gcc -v</code> 查看</li>
</ul>
</li>
</ol>
<p>工具链对应的头文件版本，有对应的说明：</p>
<blockquote>
<p>If unsure what version your toolchain is using, you can look  at the value of LINUX_VERSION_CODE in linux/version.h in your  toolchain. The Linux version is M.m.p, with:<br> M = ( LINUX_VERSION_CODE &gt;&gt; 16 ) &amp; 0xFF<br> m = ( LINUX_VERSION_CODE &gt;&gt; 8  ) &amp; 0xFF<br> p = ( LINUX_VERSION_CODE &gt;&gt; 0  ) &amp; 0xFF </p>
</blockquote>
<p>那么查看当前工具链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ./arm-cortex_a8-linux-gnueabihf/sysroot/usr/include/linux/version.h</span><br></pre></td></tr></table></figure>

<p>得到如下输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">define LINUX_VERSION_CODE 328466</span></span><br><span class="line"><span class="meta">#</span><span class="bash">define KERNEL_VERSION(a,b,c) (((a) &lt;&lt; <span class="string">16) + ((b) &lt;&lt; 8) + (c))</span></span></span><br></pre></td></tr></table></figure>

<p>那么就得到对应的版本是：5.03.18</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_compiler.jpg?raw=true"><br>3. 以 initramfs 的方式构建：</p>
<ul>
<li><strong>Filesystem images-&gt;cpio the root filesystem (for use as an initial RAM filesystem)</strong></li>
<li><strong>Compression method-&gt;lz4</strong>：这是为了文件系统尽量的小</li>
</ul>
<ol start="4">
<li>取消 Kernel 和 Uboot 的构建，因为前面几章已经构建了自己的 bootloader 和 Kernel</li>
</ol>
<p>在取消了内核和 Uboot 构建后，需要修改文件 <code>board/beaglebone/genimage.cfg</code>，让它只生成 rootfs.cpio：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">image boot.vfat &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    vfat &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        files = &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;MLO&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;u-boot.img&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;zImage&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;uEnv.txt&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-evm.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-evmsk.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bone.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-boneblack.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bonegreen.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-boneblack-wireless.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;am335x-bonegreen-wireless.dtb&quot;</span>,</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            <span class="string">&quot;extlinux&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    &#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#    size = 16M</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line"></span><br><span class="line">image sdcard.img &#123;</span><br><span class="line">    hdimage &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #partition u-boot &#123;</span><br><span class="line">    #    partition-type = 0xC</span><br><span class="line">    #    bootable = &quot;true&quot;</span><br><span class="line">    #    image = &quot;boot.vfat&quot;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    partition rootfs &#123;</span><br><span class="line">        partition-type = 0x83</span><br><span class="line">        image = &quot;rootfs.cpio&quot;</span><br><span class="line">        size = 512M</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用 <code>make</code> 构建后，会产生两个新的目录：</p>
<ul>
<li><p><code>dl</code>：用于 Buildroot 构建的，从网络下载的软件包</p>
</li>
<li><p><code>output</code>：包含编译的中间文件和最终的文件</p>
</li>
</ul>
<p>在 <code>output</code>中有以下目录：</p>
<ul>
<li><p><code>build</code>：包含所有组件的编译输出</p>
</li>
<li><p><code>host</code>：包含 Buildroot 所需要的主机上的工具</p>
</li>
<li><p><code>images</code>：打包好的镜像文件和一些脚本</p>
</li>
<li><p><code>staging</code>：指向编译器的<code>sysroot</code>的符号链接</p>
</li>
<li><p><code>target</code>：根文件系统，但是其权限不对，所以无法直接使用</p>
</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来，只需要把生成的<code>rootfs.cpio</code>编译进内核，然后在 Uboot 中输入命令就可以进入新做的文件系统了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/sbin/init</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure>

<h2 id="sdcard-img-内容查看"><a href="#sdcard-img-内容查看" class="headerlink" title="sdcard.img 内容查看"></a>sdcard.img 内容查看</h2><p>查看 sdcard.img 可以通过 fdisk 和 mount 在本机上查看：</p>
<p>先通过 <code>fdisk -l ./sdcard.img</code> 查看分区情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:$ fdisk -l ./sdcard.img </span><br><span class="line">Disk ./sdcard.img: 38.58 MiB, 40458240 bytes, 79020 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x00000000</span><br><span class="line"></span><br><span class="line">Device        Boot Start     End Sectors  Size Id Type</span><br><span class="line">./sdcard.img1 *        1   32768   32768   16M  c W95 FAT32 (LBA)</span><br><span class="line">./sdcard.img2      32769 1081344 1048576  512M 83 Linux</span><br></pre></td></tr></table></figure>

<p>可以看到分区大小和类型，然后可以挂载在当前某个空目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> offset 指定挂载的起始位置</span></span><br><span class="line">sudo mount -o loop,offset=$((1*512)) -t vfat ./sdcard.img ./mnt/</span><br></pre></td></tr></table></figure>

<h2 id="将应用程序打包进-rootfs"><a href="#将应用程序打包进-rootfs" class="headerlink" title="将应用程序打包进 rootfs"></a>将应用程序打包进 rootfs</h2><h3 id="overlay-的方式"><a href="#overlay-的方式" class="headerlink" title="overlay 的方式"></a>overlay 的方式</h3><p>在编译完应用程序后，将其拷贝到 board 对应的 overlay 目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~/github/buildroot-2024.02/board/beaglebone/rootfs_overlay$ mkdir -p usr/bin</span><br><span class="line"></span><br><span class="line">cp ~/lab/cpp/hello/hello /home/cec/github/buildroot-2024.02/board/beaglebone/rootfs_overlay</span><br></pre></td></tr></table></figure>

<p>然后配置 buildroot 中的 <strong>System configuration | Root filesystem overlay directories</strong> 为此 overlay 路径，再次编译后该应用程序便被打包进去了。</p>
<h1 id="重新认识构建过程"><a href="#重新认识构建过程" class="headerlink" title="重新认识构建过程"></a>重新认识构建过程</h1><h2 id="初始化构建环境"><a href="#初始化构建环境" class="headerlink" title="初始化构建环境"></a>初始化构建环境</h2><p>NXP 将构建初始化环境又封装了一次脚本，所以其构建命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DISTRO=fsl-imx-xwayland MACHINE=myd-imx8mm source myir-setup-release.sh -b build-xwayland</span><br></pre></td></tr></table></figure>

<p>可以先不去分析<code>myir-setup-release.sh</code>，而是看其输出的结果。</p>
<h3 id="bblayers-conf"><a href="#bblayers-conf" class="headerlink" title="bblayers.conf"></a>bblayers.conf</h3><p>首先看<code>bblayers.conf</code>，这包含了 bitbake 将要构建的层：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LCONF_VERSION = &quot;7&quot;</span><br><span class="line"></span><br><span class="line">BBPATH = &quot;$&#123;TOPDIR&#125;&quot;</span><br><span class="line">BSPDIR := &quot;$&#123;@os.path.abspath(os.path.dirname(d.getVar(&#x27;FILE&#x27;, True)) + &#x27;/../..&#x27;)&#125;&quot;</span><br><span class="line"></span><br><span class="line">BBFILES ?= &quot;&quot;</span><br><span class="line">BBLAYERS = &quot; \</span><br><span class="line"><span class="meta">  $</span><span class="bash">&#123;BSPDIR&#125;/sources/poky/meta \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/poky/meta-poky \</span></span><br><span class="line"><span class="bash">  \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-oe \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-multimedia \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-openembedded/meta-python \</span></span><br><span class="line"><span class="bash">  \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale-3rdparty \</span></span><br><span class="line"><span class="bash">  <span class="variable">$&#123;BSPDIR&#125;</span>/sources/meta-freescale-distro \</span></span><br><span class="line"><span class="bash"><span class="string">&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> i.MX Yocto Project Release layers</span></span></span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-bsp &quot;</span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-sdk &quot;</span><br><span class="line">BBLAYERS += &quot; $&#123;BSPDIR&#125;/sources/meta-myir/meta-ml &quot;</span><br><span class="line"></span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-browser&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-rust&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-gnome&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-networking&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-openembedded/meta-filesystems&quot;</span><br><span class="line">BBLAYERS += &quot;$&#123;BSPDIR&#125;/sources/meta-qt5&quot;</span><br></pre></td></tr></table></figure>

<p>为了能够比较清楚的知道层之间的优先级，需要输出其优先级来看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers show-layers</span></span><br><span class="line">NOTE: Starting bitbake server...</span><br><span class="line">layer                 path                                      priority</span><br><span class="line">==========================================================================</span><br><span class="line">meta                  ~/yocto/sources/poky/meta      5</span><br><span class="line">meta-poky             ~/yocto/sources/poky/meta-poky  5</span><br><span class="line">meta-oe               ~/yocto/sources/meta-openembedded/meta-oe  6</span><br><span class="line">meta-multimedia       ~/yocto/sources/meta-openembedded/meta-multimedia  6</span><br><span class="line">meta-python           ~/yocto/sources/meta-openembedded/meta-python  7</span><br><span class="line">meta-freescale        ~/yocto/sources/meta-freescale  5</span><br><span class="line">meta-freescale-3rdparty  ~/yocto/sources/meta-freescale-3rdparty  4</span><br><span class="line">meta-freescale-distro  ~/yocto/sources/meta-freescale-distro  4</span><br><span class="line">meta-bsp              ~/yocto/sources/meta-myir/meta-bsp  8</span><br><span class="line">meta-sdk              ~/yocto/sources/meta-myir/meta-sdk  8</span><br><span class="line">meta-ml               ~/yocto/sources/meta-myir/meta-ml  8</span><br><span class="line">meta-browser          ~/yocto/sources/meta-browser   7</span><br><span class="line">meta-rust             ~/yocto/sources/meta-rust      7</span><br><span class="line">meta-gnome            ~/yocto/sources/meta-openembedded/meta-gnome  7</span><br><span class="line">meta-networking       ~/yocto/sources/meta-openembedded/meta-networking  5</span><br><span class="line">meta-filesystems      ~/yocto/sources/meta-openembedded/meta-filesystems  6</span><br><span class="line">meta-qt5              ~/yocto/sources/meta-qt5       7</span><br></pre></td></tr></table></figure>

<p>数值越大优先级越高（可以覆盖低优先级的配置），那么可以看到在<code>meta-myir</code>层中的优先级较高，在后面需要对当前配置进行微调时，可以在这个层中进行修改。</p>
<h3 id="local-conf"><a href="#local-conf" class="headerlink" title="local.conf"></a>local.conf</h3><p><code>local.conf</code>是对构建环境变量的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat conf/local.conf</span></span><br><span class="line">MACHINE ??= &#x27;myd-imx8mm&#x27;</span><br><span class="line">DISTRO ?= &#x27;fsl-imx-xwayland&#x27;</span><br><span class="line">PACKAGE_CLASSES ?= &#x27;package_rpm&#x27;</span><br><span class="line">EXTRA_IMAGE_FEATURES ?= &quot;debug-tweaks&quot;</span><br><span class="line">USER_CLASSES ?= &quot;buildstats image-mklibs image-prelink&quot;</span><br><span class="line">PATCHRESOLVE = &quot;noop&quot;</span><br><span class="line">BB_DISKMON_DIRS ??= &quot;\</span><br><span class="line">    STOPTASKS,$&#123;TMPDIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,$&#123;DL_DIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,$&#123;SSTATE_DIR&#125;,1G,100K \</span><br><span class="line">    STOPTASKS,/tmp,100M,100K \</span><br><span class="line">    ABORT,$&#123;TMPDIR&#125;,100M,1K \</span><br><span class="line">    ABORT,$&#123;DL_DIR&#125;,100M,1K \</span><br><span class="line">    ABORT,$&#123;SSTATE_DIR&#125;,100M,1K \</span><br><span class="line">    ABORT,/tmp,10M,1K&quot;</span><br><span class="line">PACKAGECONFIG_append_pn-qemu-system-native = &quot; sdl&quot;</span><br><span class="line">CONF_VERSION = &quot;1&quot;</span><br><span class="line"></span><br><span class="line">DL_DIR ?= &quot;$&#123;BSPDIR&#125;/downloads/&quot;</span><br><span class="line">ACCEPT_FSL_EULA = &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>这里最主要的就是<code>MACHINE</code>和<code>DISTRO</code>两个环境变量：</p>
<ul>
<li><code>MACHINE</code>：主要表明了对用户空间以下的系统配置，比如 bootloader，kernel</li>
<li><code>DISTRO</code>：则是对整个发型版的全局配置，比如发行版的名字，使用 x11 还是 wayland 等</li>
</ul>
<p>除了以上二者，还有个比较重要的就是<code>image</code>。</p>
<h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p>构建完整镜像，使用<code>bitbake myir-image-full</code>即可，这里表示了与之相关的 image 就是 <code>myir-image-full</code>。</p>
<h2 id="构建的脉络"><a href="#构建的脉络" class="headerlink" title="构建的脉络"></a>构建的脉络</h2><p>基于<code>MACHINE</code>,<code>DISTRO</code>和<code>image</code>这 3 个最为重要的元素，以及所包含的 layer，便可以梳理出构建的主要脉络。</p>
<h3 id="MACHINE"><a href="#MACHINE" class="headerlink" title="MACHINE"></a>MACHINE</h3><p>通过<code>MACHINE</code>的值，便可以搜寻到其关联的配置文件<code>myd-imx8mm.conf</code>。</p>
<p>在这个文件中，便可以清楚明了的看到以下主要内容：</p>
<ul>
<li><code>bootloader</code>的配置</li>
<li>会生成的设备树</li>
<li>kernel 构建时调用的配置文件</li>
</ul>
<h3 id="DISTRO"><a href="#DISTRO" class="headerlink" title="DISTRO"></a>DISTRO</h3><p>通过<code>DISTRO</code>的值，可以搜寻到其关联的配置文件<code>fsl-imx-xwayland.conf</code>。</p>
<p>通过展开其包含的头文件，就可以清楚明了的看到其使用的是<code>wayland</code>，初始化系统使用的是<code>systemd</code>等。</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>通过<code>myir-image-full</code>可以查到其对用的 recipe 文件就是<code>myir-image-full.bb</code>。</p>
<p>可以看到它在<code>imx-image-multimedia.bb</code>的基础之上进行了文件系统的扩展。</p>
<h3 id="layer-之间的覆盖"><a href="#layer-之间的覆盖" class="headerlink" title="layer 之间的覆盖"></a>layer 之间的覆盖</h3><p>可以使用命令<code>bitbake-layers show-appends</code>来查看对原有<code>recipe</code>的附加修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果仅仅是在官方提供的构建工具下做微调，那么只要把握<code>MACHINE</code>,<code>DISTRO</code>,<code>image</code>,<code>layers</code>这 4 个核心元素，就可以顺藤摸瓜了解整个系统的配置。</p>
<p>其他的诸如变量表达式的意思、生成文件的路径、配置的增加及删除等等都是一些细枝末节的东西。只要把握重点，并通过查询文档便可以掌握这些细枝末节。</p>
<p>整个嵌入式开发的重点难点依然是在<code>bootloader</code>,<code>kernel</code>，以及用户态的业务逻辑层。</p>
<h1 id="认识-devtool"><a href="#认识-devtool" class="headerlink" title="认识 devtool"></a>认识 devtool</h1><p>简单的 recipe 可以使用 bitbake-layers 来创建，然后再手动编写。但是如果 recipe 太多时，就会比较繁琐。这个时候使用 devtool 就会更加方便。</p>
<h2 id="devtool-的工作流"><a href="#devtool-的工作流" class="headerlink" title="devtool 的工作流"></a>devtool 的工作流</h2><p>首先初始化工作环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> oe-init-build-env build/</span></span><br></pre></td></tr></table></figure>

<p>然后创建新的层：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers create-layer ../meta-mine</span></span><br></pre></td></tr></table></figure>

<p>接下来将新建的层加入构建任务中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bitbake-layers add-layer ../meta-mine</span></span><br></pre></td></tr></table></figure>

<p>然后使用<code>devtool</code>来构建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool build-image core-image-sato</span></span><br></pre></td></tr></table></figure>

<p>经过构建后，发现<code>conf</code>目录下新增了一个<code>devtool.conf</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[General]</span><br><span class="line">workspace_path = /home/cec/github/poky/build/workspace</span><br><span class="line"></span><br><span class="line">[SDK]</span><br><span class="line">target_basename = core-image-sato</span><br></pre></td></tr></table></figure>

<p>其中的<code>workspace_path</code>指定了由<code>devtool</code>所创建的沙盒工作区，可以在这里面做一些试验。</p>
<blockquote>
<p>可以看到在 bblayers.conf 中也加入了该 workspace 的路径，在用户测试完成后，可以将该路径移除。</p>
</blockquote>
<h2 id="创建新的-recipe"><a href="#创建新的-recipe" class="headerlink" title="创建新的 recipe"></a>创建新的 recipe</h2><p>下面以<code>devtool</code>来构建<a href="https://github.com/containers/bubblewrap">bubblewrap</a>。</p>
<h3 id="增加-recipe"><a href="#增加-recipe" class="headerlink" title="增加 recipe"></a>增加 recipe</h3><p>首先增加这个 recipe：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool add https://github.com/containers/bubblewrap/releases/download/v0.5.0/bubblewrap-0.5.0.tar.xz</span></span><br></pre></td></tr></table></figure>

<p>可以发现<code>devtool</code>会自动下载压缩包，然后解压缩文件，接下来会自动创建一些 recipe：</p>
<ol>
<li><p>在<code>appends</code>目录下创建<code>bubblewrap_0.5.0.bbappend</code></p>
<blockquote>
<p>这里面指定了本地解压缩源码的位置</p>
</blockquote>
</li>
<li><p>在<code>recipes</code>目录下创建<code>bubblewrap/bubblewrap_0.5.0.bb</code></p>
<blockquote>
<p>这里面指定了远端 URI 及其校验，还根据源码推测了构建系统是 autotools</p>
</blockquote>
</li>
<li><p>在<code>source</code>目录中即为 bubblewrap 的源码</p>
</li>
</ol>
<h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><p>接下来是编辑文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool edit-recipe bubblewrap</span></span><br></pre></td></tr></table></figure>

<p>可以指定其说明文件安装目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> PN 代表 packagename，在这里就是 bubblewrap。将其说明安装到 /usr/share 目录中</span></span><br><span class="line"><span class="meta">FILES_$</span><span class="bash">&#123;PN&#125; += <span class="string">&quot;/usr/share/*&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>构建命令也十分简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool build bubblewrap</span></span><br></pre></td></tr></table></figure>

<p>接下来便可以看到其配置、编译、打包的过程。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p><code>devtool</code>可以将构建的包直接部署到目标机，以便快速验证结果。</p>
<p>这里先启动<code>qemu</code>来做演示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> runqemu qemux86-64 nographic</span></span><br></pre></td></tr></table></figure>

<p>可以通过 ifconfig 看到其 ip 是 192.168.7.2，那么就将该包部署过去：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool deploy-target bubblewrap root@192.168.7.2</span></span><br></pre></td></tr></table></figure>

<p><code>bwrap</code>可执行文件便安装完成了，且可执行了。</p>
<h3 id="清除部署"><a href="#清除部署" class="headerlink" title="清除部署"></a>清除部署</h3><p>当测试完成后，便可以从目标机系统中清除该包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool undeploy-target bubblewrap root@192.168.7.2</span></span><br></pre></td></tr></table></figure>

<p>执行该命令后，可以发现<code>bwrap</code>相关文件已经清理完毕了。</p>
<h3 id="完成-recipe"><a href="#完成-recipe" class="headerlink" title="完成 recipe"></a>完成 recipe</h3><p>到目前为止还只是测试完毕，接下来就是将沙盒中的 recipe 更新到<code>meta-mine</code>中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> devtool finish -f bubblewrap ../meta-mine</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>meta-mine</code>中已经包含了<code>bubblewrap</code>相关 recipe，干净又整洁！</p>
<p>既然已经部署完成，便可以删除之前的沙盒了，为了以后再次构建，也可以仅仅在<code>bblayers.conf</code>中屏蔽这个沙盒 layer 即可。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>Buildroot 的定制化使用</title>
    <url>/2024/04/09/linux_make_yocto_buildroot/</url>
    <content><![CDATA[<p>这里记录 Buildroot 的进一步使用说明。</p>
<span id="more"></span>

<h1 id="构建过程时修改源码"><a href="#构建过程时修改源码" class="headerlink" title="构建过程时修改源码"></a>构建过程时修改源码</h1><p>Buildroot 构建的过程是下载压缩包、解压、配置、编译、安装，就算包的源是 git 这种版本管理工具，它也会克隆并压缩，然后按照之前的流程进行。</p>
<p>默认情况下，解压缩后的源码会位于 <code>output/build/&lt;package&gt;-&lt;version&gt;</code>，当使用 <code>make clean</code> 之后，该目录的内容会被清空！</p>
<p>所以，如果想修改源码再进行打包验证的话，直接在这个目录下操作是不合理的。</p>
<p>Buildroot 提供了 <code>&lt;pkg&gt;_OVERRIDE_SRCDIR</code> 机制，让 Buildroot 选择指定的源码路径。</p>
<p>默认在通过 <code>BR2_PACKAGE_OVERRIDE_FILE</code> 配置的覆盖文件是 <code>$(CONFIG_DIR)/local.mk</code>，而 <code>$(CONFIG_DIR)</code> 指的就是 <code>.config</code> 文件所在的路径。</p>
<p>所以 <code>local.mk</code> 也就是默认和 <code>.config</code> 在一个文件夹下。<code>local.mk</code> 的文件格式为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;pkg1&gt;_OVERRIDE_SRCDIR = /path/to/pkg1/sources</span><br><span class="line">&lt;pkg2&gt;_OVERRIDE_SRCDIR = /path/to/pkg2/sources</span><br></pre></td></tr></table></figure>

<p>比如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LINUX_OVERRIDE_SRCDIR = /home/bob/linux/</span><br><span class="line">BUSYBOX_OVERRIDE_SRCDIR = /home/bob/busybox/</span><br></pre></td></tr></table></figure>

<p>当指定了特定包的路径后，Buildroot 就不会走下载、解压的步骤，而是直接使用指定路径的源码。在执行编译时，buildroot 会将源码拷贝到指定目录下的 <code>&lt;package&gt;-custom</code>。</p>
<p>然后就可以使用：</p>
<ul>
<li><code>make &lt;pkg&gt;-rebuild</code> ： 重新编译</li>
<li><code>make &lt;pkg&gt;-reconfig</code> ： 重新配置</li>
<li><code>make &lt;pkg&gt;-rebuild all</code> : 重新配置并编译</li>
</ul>
<p>除此之外，对于像 UBOOT、Kernel 这种包，需要指定其配置文件，配置文件不能带有<code>_defconfig</code>。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_uboot_src.jpg?raw=true"><br>对于 Linux 而言，还需要注意配置其设备树：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmake%5D/%5BWhat%5DLinux--yocto/pic/buildroot_custom_linux_src.jpg?raw=true"></p>
<h1 id="常用的配置步骤"><a href="#常用的配置步骤" class="headerlink" title="常用的配置步骤"></a>常用的配置步骤</h1><p>使用 Buildroot 的一般配置步骤如下：</p>
<ul>
<li><p>配置 Buildroot 基本配置，比如工具链、bootloader、内核、文件系统等</p>
</li>
<li><p>配置其他组件，比如 BusyBox、Qt 等</p>
</li>
<li><p>进行文件系统定制化配置</p>
<ul>
<li><p>根据配置<code>BR2_ROOTFS_OVERLAY</code>,将需要覆盖的配置文件、应用程序按照文件系统结构放置</p>
</li>
<li><p>根据配置<code>BR2_ROOTFS_POST_BUILD_SCRIPT</code>指定的脚本，修改或删除文件</p>
</li>
<li><p>根据配置<code>BR2_ROOTFS_DEVICE_TABLE</code>来修改特定文件的权限</p>
</li>
<li><p>根据配置<code>BR2_ROOTFS_STATIC_DEVICE_TABLE</code>来增加特定的设备节点</p>
</li>
<li><p>根据配置<code>BR2_ROOTFS_USERS_TABLES</code>来添加用户</p>
</li>
<li><p>根据配置<code>BR2_ROOTFS_POST_IMAGE_SCRIPT</code>指定的脚本来生成镜像文件</p>
</li>
<li><p>根据配置<code>BR2_GLOBAL_PATCH_DIR</code>来添加对应包的补丁</p>
</li>
</ul>
</li>
</ul>
<h1 id="推荐的定制化目录"><a href="#推荐的定制化目录" class="headerlink" title="推荐的定制化目录"></a>推荐的定制化目录</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+-- board/</span><br><span class="line">| +-- &lt;company&gt;/</span><br><span class="line">|     +-- &lt;boardname&gt;/</span><br><span class="line">|         +-- linux.config</span><br><span class="line">|         +-- busybox.config</span><br><span class="line">|         +-- &lt;other configuration files&gt;</span><br><span class="line">|         +-- post_build.sh</span><br><span class="line">|         +-- post_image.sh</span><br><span class="line">|         +-- rootfs_overlay/</span><br><span class="line">|         |     +-- etc/</span><br><span class="line">|         |     +-- &lt;some files&gt;</span><br><span class="line">|         +-- patches/</span><br><span class="line">|             +-- foo/</span><br><span class="line">|             |     +-- &lt;some patches&gt;</span><br><span class="line">|             +-- libbar/</span><br><span class="line">|                 +-- &lt;some other patches&gt;</span><br><span class="line">|</span><br><span class="line">+-- configs/</span><br><span class="line">|     +-- &lt;boardname&gt;_defconfig</span><br><span class="line">|</span><br><span class="line">+-- package/</span><br><span class="line">| +-- &lt;company&gt;/</span><br><span class="line">|         +-- Config.in (if not using a br2-external tree)</span><br><span class="line">|         +-- &lt;company&gt;.mk (if not using a br2-external tree)</span><br><span class="line">|         +-- package1/</span><br><span class="line">|         |     +-- Config.in</span><br><span class="line">|         |     +-- package1.mk</span><br><span class="line">|         +-- package2/</span><br><span class="line">|             +-- Config.in</span><br><span class="line">|             +-- package2.mk</span><br><span class="line">|</span><br><span class="line">+-- Config.in (if using a br2-external tree)</span><br><span class="line">+-- external.mk (if using a br2-external tree)</span><br><span class="line">+-- external.desc (if using a br2-external tree)</span><br></pre></td></tr></table></figure>

<p>以上的目录结构既可以在 Buildroot 上建立一个分支，也可以在 Buildroot 目录之外建立。</p>
<p>如果在目录之外建立，那么在首次构建时，需要设置变量<code>BR2_EXTERNAL</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BR2_EXTERNAL=/path/to/foo menuconfig</span></span><br></pre></td></tr></table></figure>

<p>该设置会被保存在 output 目录的 <code>.br2-external.mk</code> 文件中，下次再构建就可以不用再次设置了。</p>
<p>如果要切换到新目录，就再设置一次该变量即可。也可以关闭使用外部目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make BR2_EXTERNAL= menuconfig</span></span><br></pre></td></tr></table></figure>

<h1 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h1><h2 id="Buildroot-的整体配置"><a href="#Buildroot-的整体配置" class="headerlink" title="Buildroot 的整体配置"></a>Buildroot 的整体配置</h2><p>简单的方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make savedefconfig</span><br></pre></td></tr></table></figure>

<p>将当前配置保存为文件<code>defconfig</code>，也可以存放在其他位置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make savedefconfig BR2_DEFCONFIG=&lt;path-to-defconfig&gt;</span><br></pre></td></tr></table></figure>

<p>最简单的方式还是存在<code>configs/&lt;boardname&gt;_defconfig</code></p>
<h2 id="其他软件包的配置"><a href="#其他软件包的配置" class="headerlink" title="其他软件包的配置"></a>其他软件包的配置</h2><p>对于像 U-Boot，Linux 的配置，也应该需要保存。保存的位置根据前面所述，位于<code>board/&lt;company&gt;/&lt;boardname&gt;/</code>中最好。</p>
<p>可以使用<code>make linux-menuconfig</code>来创建 linux 的配置文件。</p>
<ul>
<li><p><code>make linux-update-defconfig</code>将配置存储于<code>BR2_LINUX_KERNEL_CUSTOM_CONFIG_FILE</code>指定的路径中</p>
</li>
<li><p><code>make busybox-update-config</code>将配置存储于<code>BR2_PACKAGE_BUSYBOX_CONFIG</code>指定的路径中</p>
</li>
<li><p><code>make uboot-update-defconfig</code>将配置存储于 <code>BR2_TARGET_UBOOT_CUSTOM_CONFIG_FILE</code>指定的路径中</p>
</li>
</ul>
<h1 id="定制文件系统"><a href="#定制文件系统" class="headerlink" title="定制文件系统"></a>定制文件系统</h1><p>定制文件系统有两种方式，一种是覆盖文件系统，一种是通过预构建脚本。</p>
<h2 id="覆盖-BR2-ROOTFS-OVERLAY"><a href="#覆盖-BR2-ROOTFS-OVERLAY" class="headerlink" title="覆盖 (BR2_ROOTFS_OVERLAY)"></a>覆盖 (<code>BR2_ROOTFS_OVERLAY</code>)</h2><p>配置<code>BR2_ROOTFS_OVERLAY</code>指定了覆盖目录的路径，Buildroot 会按照该目录的路径对文件系统进行覆盖。</p>
<p>比较推荐的路径是<code>board/&lt;company&gt;/&lt;boardname&gt;/rootfs-overlay</code></p>
<h1 id="构建脚本-BR2-ROOTFS-POST-BUILD-SCRIPT"><a href="#构建脚本-BR2-ROOTFS-POST-BUILD-SCRIPT" class="headerlink" title="构建脚本(BR2_ROOTFS_POST_BUILD_SCRIPT)"></a>构建脚本(<code>BR2_ROOTFS_POST_BUILD_SCRIPT</code>)</h1><p>在 Buildroot 构建了软件但还没有打包镜像文件时，会运行该配置指定的脚本。</p>
<p>这种方式更为灵活，可以删除、编辑目标板上的文件。</p>
<p>比较推荐的路径是``board/<company>/<boardname>/post_build.sh<code>.</code></p>
<p>该脚本被调用时，传入的第一个参数，就是目标文件系统的路径。</p>
<p>除此之外，还有其他变量可以使用：</p>
<ul>
<li><p><code>BR2_CONFIG</code>：Buildroot .config 文件路径</p>
</li>
<li><p><code>CONFIG_DIR</code>：包含 .config 的目录路径</p>
</li>
<li><p><code>HOST_DIR`, `STAGING_DIR`, `TARGET_DIR</code></p>
</li>
<li><p><code>BUILD_DIR</code>：构建路径</p>
</li>
<li><p><code>BINARIES_DIR</code>：镜像文件的存放路径</p>
</li>
<li><p><code>BASE_DIR</code>：输出路径</p>
</li>
</ul>
<h1 id="设置文件权限和所有人"><a href="#设置文件权限和所有人" class="headerlink" title="设置文件权限和所有人"></a>设置文件权限和所有人</h1>]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>构建根文件系统</title>
    <url>/2024/02/27/linux_make_yocto_fs/</url>
    <content><![CDATA[<p>重新来梳理一下根文件系统编译。</p>
<span id="more"></span>

<h1 id="根文件系统里面有什么？"><a href="#根文件系统里面有什么？" class="headerlink" title="根文件系统里面有什么？"></a>根文件系统里面有什么？</h1><p>内核挂载根文件系统，可以以<code>initramfs</code>的方式，或者通过<code>root=</code>参数指定的设备来挂载，然后执行其<code>init</code>程序来进行接下来的初始化。</p>
<p>最小的根文件系统包含下面这些基本组件：</p>
<ul>
<li><code>init</code>：用于初始化系统基本环境的程序，通常会调用一系列的脚本</li>
<li><code>shell</code>：提供一个用于交互的命令行环境，以执行其他的程序</li>
<li><code>Daemons</code>：守护进程为其他程序提供基础服务</li>
<li><code>Shared libraries</code>：很多程序都会使用到共享库，所以这个是必须的</li>
<li><code>Configuration files</code>：对守护进程对应的配置文件，通常位于<code>/etc</code>目录下</li>
<li><code>Device nodes</code>：设备节点提供应用程序的访问设备驱动的通道</li>
<li><code>proc and sys</code>：提供对内核参数的检测和控制文件夹</li>
<li><code>Kernel modules</code>：内核模块会被安装于<code>/lib/modules/&lt;kernel versoin&gt;/</code>中</li>
</ul>
<h2 id="目录的分布"><a href="#目录的分布" class="headerlink" title="目录的分布"></a>目录的分布</h2><p>为满足 FHS（Filesystem Hierarchy Standard）标准，一般目录分布如下：</p>
<ul>
<li><code>/bin</code>：对所有用户都适用的基础命令</li>
<li><code>/dev/</code>：存放设备节点和其他特殊文件</li>
<li><code>/etc/</code>：系统配置文件</li>
<li><code>/lib</code>：系统基本的共享库</li>
<li><code>/proc</code>：对进程等内核参数进行交互的虚拟文件</li>
<li><code>/sbin</code>：对系统管理员所适用的基础命令</li>
<li><code>/sys</code>：描述设备何其驱动对应关系的虚拟文件</li>
<li><code>/tmp</code>：用于存放临时文件的 RAM fs</li>
<li><code>/usr</code>：更多的命令、库、管理员工具等</li>
<li><code>/var</code>：存放在运行时会被改变的文件</li>
</ul>
<p>对于 <code>proc</code>和<code>sysfs</code>是需要挂载的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount [-t vfstype] [-o options] device directory</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载存储设备时，大部分情况下不用主动指明文件系统</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 而对于 proc,sysfs 这种伪文件系统，则需要指明</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t proc proc /proc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -t sysfs sysfs /sys</span></span><br></pre></td></tr></table></figure>

<h2 id="创建staging文件夹"><a href="#创建staging文件夹" class="headerlink" title="创建staging文件夹"></a>创建<code>staging</code>文件夹</h2><p>所谓的<code>staging</code>文件夹，就是一个根文件系统的基础框架，在最开始可以创建它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir bin dev etc home lib proc sbin sys tmp usr var</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir usr/bin usr/lib usr/sbin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p var/<span class="built_in">log</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于 ARM64 lib 引用的是 lib64，其实只需要为 lib 创建软链接即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ln -s lib lib64</span></span><br></pre></td></tr></table></figure>

<p>接下来就是要考虑一些文件的权限问题了，对于一些重要文件应该限制为<code>root </code>用户才能操作。而其他程序应该运行在普通用户模式。</p>
<h2 id="目录中具有的程序"><a href="#目录中具有的程序" class="headerlink" title="目录中具有的程序"></a>目录中具有的程序</h2><h3 id="init程序"><a href="#init程序" class="headerlink" title="init程序"></a><code>init</code>程序</h3><p><code>init</code>程序是进入根文件系统后运行的第一个程序。</p>
<blockquote>
<p>对于 busybox 而言，就是<code>/sbin/init</code>，最终还是指向 busybox 这个独立可执行程序。</p>
</blockquote>
<p><code>init</code>程序首先会读取<code>/etc/inittab</code>中的配置，然后依次启动对应的程序。</p>
<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p><code>Shell</code>用户运行脚本，和用户交互等。在嵌入式系统中，有这么几个常用的<code>Shell</code>：</p>
<ul>
<li><code>bash</code>：功能强大，但是体积占用也大，一般运行于桌面系统中。</li>
<li><code>ash</code>：和<code>bash</code>兼容性很好，且体积占用小，适合于嵌入式系统。</li>
<li><code>hush</code>：用于 bootloader，占用很小的 shell。</li>
</ul>
<p>其实只要空间不紧张，嵌入式也使用<code>bash</code>就好，因为和桌面系统完全一致，避免在桌面可以正常运行的脚本在嵌入式端运行就不正常了。</p>
<h3 id="工具程序"><a href="#工具程序" class="headerlink" title="工具程序"></a>工具程序</h3><p>工具程序用于支撑其他程序的正常运行。</p>
<h2 id="BusyBox"><a href="#BusyBox" class="headerlink" title="BusyBox"></a>BusyBox</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>这些程序要是手动编译一个个放入文件系统会累死，而<code>BusyBox</code>就将这些工具精简编译到一个可执行程序中，这个程序就包含了常用的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">busybox.nosuid</span><br><span class="line">cat -&gt; /bin/busybox.nosuid</span><br><span class="line">chgrp -&gt; /bin/busybox.nosuid</span><br><span class="line">chmod -&gt; /bin/busybox.nosuid</span><br><span class="line">chown -&gt; /bin/busybox.nosuid</span><br><span class="line">cp -&gt; /bin/busybox.nosuid</span><br><span class="line">cpio -&gt; /bin/busybox.nosuid</span><br><span class="line">date -&gt; /bin/busybox.nosuid</span><br><span class="line">dd -&gt; /bin/busybox.nosuid</span><br><span class="line">df -&gt; /bin/busybox.nosuid</span><br><span class="line">dmesg -&gt; /bin/busybox.nosuid</span><br></pre></td></tr></table></figure>

<p>当用户输入<code>cat</code>时，实际上是调用了<code>busybox</code>这个可执行文件，该文件按照如下流程处理：</p>
<ul>
<li>获取<code>argv[0]</code>得到字符串<code>cat</code></li>
<li>然后根据该字符串获取到对应入口函数<code>cat_main</code></li>
<li>执行<code>cat_main</code></li>
</ul>
<h3 id="构建-BusyBox"><a href="#构建-BusyBox" class="headerlink" title="构建 BusyBox"></a>构建 BusyBox</h3><p>首选获取源码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://git.busybox.net/busybox</span></span><br></pre></td></tr></table></figure>

<p>然后切换到最新稳定版：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout 1_34_stable</span></span><br></pre></td></tr></table></figure>

<p>按照惯例，当然是先clean 一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make distclean</span></span><br></pre></td></tr></table></figure>

<p>使用其默认配置即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make defconfig</span></span><br></pre></td></tr></table></figure>

<p>然后使用<code>make menuconfig</code> 进入<code>Settings -&gt; Cross compiler prefix</code>来设置安装路径到前面的 staging 目录。</p>
<p>接下来便是编译及安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ARCH=arm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure>

<p>可以看到 staging 目录中已经安装好了，且那些文件都以软连接的形式指向了<code>busybox</code>这个可执行文件。</p>
<h2 id="根文件系统中的库"><a href="#根文件系统中的库" class="headerlink" title="根文件系统中的库"></a>根文件系统中的库</h2><p>应用程序要运行，就要依赖部分编译工具链中的库，简单粗暴的解决方式就是把这些库都拷贝到 staging 目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以 SYSROOT 存储路径，比较方便</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> SYSROOT=$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)</span></span><br></pre></td></tr></table></figure>

<p>其中<code>lib</code>文件夹存储得是共享链接库，将它们复制进去即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 -a ，不破坏其软连接</span></span><br><span class="line">cec@box:~/lab/rootfs$ cp -aR $&#123;SYSROOT&#125;/lib/** ./lib/</span><br></pre></td></tr></table></figure>

<h2 id="设备节点"><a href="#设备节点" class="headerlink" title="设备节点"></a>设备节点</h2><p>创建设备节点使用命令<code>mknod</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 依次是设备节点名称，类型，主设备号，次设备号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mknod &lt;name&gt; &lt;<span class="built_in">type</span>&gt; &lt;major&gt; &lt;minor&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>主设备号和次设备号可以在 <code>Documentation/devices.txt</code>文件中找到</p>
</blockquote>
<p>对于 BusyBox 而言，所需要的两个节点是<code>console</code>和<code>null</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> null 节点所有用户都可以读写，所以权限是 666</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mknod -m 666 dev/null c 1 3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> console 节点只允许 root 操作，所以权限是 600</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mknod -m 600 dev/console c 5 1</span></span><br></pre></td></tr></table></figure>

<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><p>内核模块也需要被安装在根文件系统中，需要被内核设置<code>INSTALL_MOD_PATH</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于前面已经设置了 ARCH 和 CROSS_COMPILE 所以这里就不用设置了</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make INSTALL_MOD_PATH=/home/cec/lab/rootfs modules_install</span></span><br></pre></td></tr></table></figure>

<p>可以看到模块都被安装到了根文件系统的<code>lib/modules/&lt;kernel_version&gt;</code>目录下了。</p>
<blockquote>
<p>但是会发现还安装了<code>source</code>和<code>build</code>文件夹，这个是嵌入式中不需要的，可以把它们删除。</p>
</blockquote>
<h1 id="创建-initramfs"><a href="#创建-initramfs" class="headerlink" title="创建 initramfs"></a>创建 initramfs</h1><p>在使用<code>initramfs</code>之前需要确保<code>CONFIG_BLK_DEV_INITRD=y</code>，以表示内核支持<code>initramfs</code>。</p>
<p>创建<code>initramfs</code>有以下 3 种方法：</p>
<ol>
<li>独立打包为<code>cpio</code>格式的文件包：这种方式最为灵活</li>
<li>将<code>initramfs</code>嵌入到内核镜像文件中</li>
<li>由内核构建系统将其编译进去</li>
</ol>
<h2 id="创建一个独立包"><a href="#创建一个独立包" class="headerlink" title="创建一个独立包"></a>创建一个独立包</h2><p>先打包到上级目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定了 GID 和 UID 都是 root</span></span><br><span class="line">cec@box:~/lab/rootfs$ find . | cpio -H newc -ov --owner root:root &gt;  ../initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>然后再进行一次压缩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~/lab/rootfs$ gzip initramfs.cpio</span><br></pre></td></tr></table></figure>

<p>最后使用工具<code>mkimage</code>来为文件加入头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~/lab$ mkimage -A arm -O linux -T ramdisk -d initramfs.cpio.gz uRamdisk</span><br><span class="line">Image Name:   </span><br><span class="line">Created:      Fri Mar  1 09:18:49 2024</span><br><span class="line">Image Type:   ARM Linux RAMDisk Image (gzip compressed)</span><br><span class="line">Data Size:    27835346 Bytes = 27182.96 KiB = 26.55 MiB</span><br><span class="line">Load Address: 00000000</span><br><span class="line">Entry Point:  00000000</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>initramfs 包体积不能太大，因为压缩包和解压后的文件都会全部存在于内存中！</strong> </p>
<blockquote>
<p><a href="https://www.lightofdawn.org/blog/?viewDetailed=00128">这篇文章</a>有讲到，<code>initramfs</code>包最好小于内存的 25%</p>
</blockquote>
<h2 id="启动独立包"><a href="#启动独立包" class="headerlink" title="启动独立包"></a>启动独立包</h2><h3 id="拷贝进-SD-卡"><a href="#拷贝进-SD-卡" class="headerlink" title="拷贝进 SD 卡"></a>拷贝进 SD 卡</h3><p>作为测试目的，我们可以将<code>uRamdisk</code>也拷贝到 SD 卡的第一分区，然后在 U-boot 中载入。</p>
<h3 id="载入到-DDR"><a href="#载入到-DDR" class="headerlink" title="载入到 DDR"></a>载入到 DDR</h3><p>然后需要将<code>initramfs</code>载入到 DDR 中，前面我们将：</p>
<ul>
<li>Image 载入到 <code>0x80200000</code></li>
<li>FDT 载入到 <code>0x80f00000</code></li>
</ul>
<p>而 FDT 目前大小只有 58KB，那么可以将<code>uRamdisk</code>载入到<code>0x81000000</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x80200000 zImage</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x80f00000 am335x-boneblack.dtb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> fatload mmc 0:1 0x81000000 uRamdisk</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指定启动的<code>init</code>程序</li>
</ol>
<p>需要在<code>bootargs</code>中加入启动程序是 shell：<code>rdinit=/bin/sh</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> setenv bootargs console=ttyO0,115200 rdinit=/bin/sh</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 bootz 启动</li>
</ol>
<p>也就是说在原来的基础上，加上<code>initramfs</code>的地址即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> $ bootz <span class="variable">$&#123;loadaddr&#125;</span> <span class="variable">$&#123;initrd_addr&#125;</span> <span class="variable">$&#123;fdt_addr&#125;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bootz 0x80200000 0x81000000 0x80f00000</span></span><br></pre></td></tr></table></figure>

<p>这个时候会发现没有工作控制流而给出警告：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/sh: can&#x27;t access tty; job control turned off</span><br></pre></td></tr></table></figure>

<h2 id="将-initramfs-嵌入内核"><a href="#将-initramfs-嵌入内核" class="headerlink" title="将 initramfs 嵌入内核"></a>将 initramfs 嵌入内核</h2><p>将<code>initramfs</code>嵌入内核非常简单：在<code>General setup -&gt; Initramfs source file(s)</code>中指定<strong>未压缩的 cpio 文件</strong>，然后再次运行 make 即可。</p>
<p>这样设置以后，便可以在 bootloader 中指定内核和设备树地址就行了。</p>
<blockquote>
<p>这里需要注意内核 + initramfs 所占用的空间，设备树需要预留足够多的空间以避免相互覆盖。</p>
<p>比如当前内核 + initramfs 就有 50MB，那么设备树的载入位置需要再往后放一点。</p>
<p>当前开发板具有 512MB 内存，那 DDR 寻址范围是 0x80000000 ~ 0xA0000000。</p>
<p>所以设备树的位置预留足够位置即可，比如放置在 0x8CA00000 处，就预留了 200MB 的空间。</p>
</blockquote>
<p>编译进内核以后，启动命令就简单了一点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/bin/sh</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure>

<h2 id="以设备列表的形式构建-initramfs"><a href="#以设备列表的形式构建-initramfs" class="headerlink" title="以设备列表的形式构建 initramfs"></a>以设备列表的形式构建 initramfs</h2><p>设备列表就是一个配置文件，用以列出文件、文件夹、设备节点、链接等等。</p>
<p>在构建内核的时候，也就会生成按照设备列表配置的 cpio 文件。</p>
<p>和上面的方式一样，在内核的<code>Initramfs source file(s)</code>处指向该配置文件。</p>
<p><code>cpio</code>文件就会在编译时创建。</p>
<p>下面是一个简单的示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> dir &lt;name&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">dir /bin 775 0 0</span><br><span class="line">dir /sys 775 0 0</span><br><span class="line">dir /tmp 775 0 0</span><br><span class="line">dir /dev 775 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> nod &lt;name&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt; &lt;dev_type&gt; &lt;maj&gt; &lt;min&gt;</span></span><br><span class="line">nod /dev/null 666 0 0 c 1 3</span><br><span class="line">nod /dev/console 600 0 0 c 5 1</span><br><span class="line">dir /home 775 0 0</span><br><span class="line">dir /proc 775 0 0</span><br><span class="line">dir /lib 775 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> slink &lt;name&gt; &lt;target&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">slink /lib/libm.so.6 libm-2.22.so 777 0 0</span><br><span class="line">slink /lib/libc.so.6 libc-2.22.so 777 0 0</span><br><span class="line">slink /lib/ld-linux-armhf.so.3 ld-2.22.so 777 0 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> file &lt;name&gt; &lt;location&gt; &lt;mode&gt; &lt;uid&gt; &lt;gid&gt;</span></span><br><span class="line">file /lib/libm-2.22.so /home/chris/rootfs/lib/libm-2.22.so 755 </span><br><span class="line">0 0</span><br><span class="line">file /lib/libc-2.22.so /home/chris/rootfs/lib/libc-2.22.so 755 </span><br><span class="line">0 0</span><br><span class="line">file /lib/ld-2.22.so /home/chris/rootfs/lib/ld-2.22.so 755 0 0</span><br></pre></td></tr></table></figure>

<p>可以使用内核文件<code>/usr/gen_initramfs_list.sh</code>来根据前面的 rootfs 生成一个配置文文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./usr/gen_initramfs_list.sh -u 1000 -g 1000 ~/lab/rootfs &gt; initramfs-device-table</span></span><br></pre></td></tr></table></figure>

<h1 id="完整启动-initramfs"><a href="#完整启动-initramfs" class="headerlink" title="完整启动 initramfs"></a>完整启动 initramfs</h1><p>前面的启动过程，会由于 initramfs 缺少文件而退出 shell，而正确的启动流程是：</p>
<ol>
<li>内核启动<code>/sbin/init</code>程序</li>
<li><code>/sbin/init</code>读取<code>/etc/inittab</code>确定启动级别及运行 shell</li>
<li>根据<code>/etc/inittab</code>中的内容找到<code>/etc/init.d/rcS</code>然后依次运行对应脚本进行环境初始化</li>
</ol>
<p>而<code>busybox</code>在其源码<code>examples/bootfloppy/etc/</code>中就提供了通用的示例，将其拷贝到我们创建的<code>rootfs</code>中是比较简单的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~/lab/rootfs$ cp -aR ../busybox/examples/bootfloppy/etc/** etc/</span><br></pre></td></tr></table></figure>

<h2 id="inittab-修改"><a href="#inittab-修改" class="headerlink" title="inittab 修改"></a>inittab 修改</h2><p>作为测试目的，对其进行简单修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动初始化脚本为 /etc/init.d/rcS</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta">#</span><span class="bash"> 虚拟终端作为 shell</span></span><br><span class="line">::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>

<h2 id="rcS-修改"><a href="#rcS-修改" class="headerlink" title="rcS 修改"></a>rcS 修改</h2><p>在 <code>rcS</code>脚本中，需要至少挂载<code>proc,sys</code>两个虚拟文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc </span><br><span class="line">mount -t sysfs sysfs /sys</span><br></pre></td></tr></table></figure>

<p>修改以后再次打包为 cpio 文件，对应的 bootargs 就可以修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br><span class="line">fatload mmc 0:1 0x8CA00000 am335x-boneblack.dtb</span><br><span class="line">setenv bootargs console=ttyO0,115200 rdinit=/sbin/init</span><br><span class="line">bootz 0x80200000 - 0x8CA00000</span><br></pre></td></tr></table></figure>

<h2 id="增加用户配置"><a href="#增加用户配置" class="headerlink" title="增加用户配置"></a>增加用户配置</h2><p><code>busybox</code>默认会支持 shadow 特性，这需要添加用户配置文件。</p>
<p>用户名及相关信息被配置于<code>/etc/passwd</code>文件中，每个用户一行，中间以冒号分开，依次是：</p>
<ul>
<li><p>用户名</p>
</li>
<li><p><code>x</code>代表密码存储于<code>/etc/shadow</code></p>
<blockquote>
<p><code>/etc/passwd</code>是所有人可读的，而<code>/etc/shadow</code>则只能是 root 用户和组可以读，以此来保证安全性。</p>
</blockquote>
</li>
<li><p>用户 ID</p>
</li>
<li><p>组 ID</p>
</li>
<li><p>注释</p>
</li>
<li><p>用户的<code>home</code>目录</p>
</li>
<li><p>用户所使用的 shell</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/sh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/false</span><br></pre></td></tr></table></figure>

<p>组名称则存储于<code>/etc/group</code>中，也是每个组一行，中间以冒号分开：</p>
<ul>
<li>组名</li>
<li>组密码，<code>x</code>代表该组没有密码</li>
<li>组 ID</li>
<li>那些用于属于该组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root:x:0:</span><br><span class="line">daemon:x:1:</span><br></pre></td></tr></table></figure>

<p><code>/etc/shadow</code> 中的示例内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root::10933:0:99999:7:::</span><br><span class="line">daemon:*:10933:0:99999:7:::</span><br></pre></td></tr></table></figure>

<p>在 rootfs 中加入这几个文件，其中 <strong>/etc/shadow</strong> 需要修改权限为 600，以便只有 root 可以打开此文件。</p>
<p>然后再编辑 <code>etc/inittab</code> 让初始启动程序为 getty 获取用户名及密码验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"><span class="meta">#</span><span class="bash"> respawn 代表当一个用户退出后，又重新启动 getty</span></span><br><span class="line">::respawn:/sbin/getty 115200 console</span><br></pre></td></tr></table></figure>

<h1 id="创建设备节点更好的方法"><a href="#创建设备节点更好的方法" class="headerlink" title="创建设备节点更好的方法"></a>创建设备节点更好的方法</h1><p><code>mknod</code>创建设备节点比较繁琐，还有其他更好的办法：</p>
<ul>
<li><code>devtmpfs</code>：这是在启动时被挂载到<code>/dev</code>的伪文件系统。内核通过它来动态的增加和删除设备节点。</li>
<li><code>mdev</code>：由 busybox 提供的工具，通过读取<code>/etc/mdev.conf</code>来达到自动挂载节点的目的</li>
<li><code>udev</code>：功能和<code>mdev</code>类似，现在属于<code>systemd</code>的一部分</li>
</ul>
<p>在实际使用中，一般是通过<code>devtmpfs</code>来自动创建节点，而<code>mdev/udev</code>来设置节点的属性。</p>
<h2 id="devtmpfs"><a href="#devtmpfs" class="headerlink" title="devtmpfs"></a><code>devtmpfs</code></h2><p>在使用<code>devtmpfs</code>之前，需要确保内核已经使能了<code>CONFIG_DEVTMPFS</code>。</p>
<blockquote>
<p>如果使能了 CONFIG_DEVTMPFS_MOUNT 内核会自动挂载该文件系统，只是不适用于 initramfs</p>
</blockquote>
<p>对于<code>initramfs</code>在启动脚本中挂载<code>devtmpfs</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t devtmpfs devtmpfs /dev</span><br></pre></td></tr></table></figure>

<h2 id="mdev"><a href="#mdev" class="headerlink" title="mdev"></a><code>mdev</code></h2><p>在使用<code>mdev</code>之前，需要在启动脚本中将其设置为接收内核发送的<code>hotplug</code>事件，然后再启动<code>mdev</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>

<p><code>mdev</code>会根据<code>/etc/mdev.conf</code>文件来配置节点的属性：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> file /etc/mdev.conf</span></span><br><span class="line">null root:root 666</span><br><span class="line">random root:root 444</span><br><span class="line">urandom root:root 444</span><br></pre></td></tr></table></figure>

<p>关于 <code>mdev</code>更多说明，参考 busybox 源码中的 <code>docs/mdev.txt</code>文件。</p>
<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>与网络配置相关的文件有：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">etc/network</span><br><span class="line">etc/network/if-pre-up.d</span><br><span class="line">etc/network/if-up.d</span><br><span class="line">etc/network/interfaces</span><br><span class="line">var/run</span><br></pre></td></tr></table></figure>

<p>其中<code>interfaces</code>中是对网络的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置 eth0 为静态 IP</span></span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">    address 192.168.1.101</span><br><span class="line">    netmask 255.255.255.0</span><br><span class="line">    network 192.168.1.0</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以这样配置，使用动态 IP</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> auto eth0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iface eth0 inet dhcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iface eth1 inet dhcp</span>    </span><br></pre></td></tr></table></figure>

<p>对于动态 IP，busybox 使用 <code>udchpcd</code>运行<code>/usr/share/udhcpc/default.script</code>来完成配置，可以拷贝<code>examples/udhcp/simple.script</code>来完成。</p>
<h2 id="字符串映射"><a href="#字符串映射" class="headerlink" title="字符串映射"></a>字符串映射</h2><p>glibc 使用 <code>name service switch（NSS）</code>来实现从名称到特定数值的转换。</p>
<p>比如从用户名转换到 UID，从服务器名称转换到端口号，从主机名称转换到 IP 地址等。</p>
<p>这些配置被存储于<code>/etc/nssswitch.conf</code>文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd:    files # 查询 UID ，就在 /etc/passwd</span><br><span class="line">group:     files</span><br><span class="line">shadow:    files</span><br><span class="line">hosts:     files dns # 查询主机就在 /etc/hosts，如果查询不到就从 DNS 查询</span><br><span class="line">networks:  files</span><br><span class="line">protocols: files</span><br><span class="line">services:  files # 查询端口号，就在 /etc/services</span><br></pre></td></tr></table></figure>

<p>这些文件完全可以在当前主机中拷贝，这些文件都是有统一格式的。</p>
<p>最后还需要安装库以便于正确执行名称查找：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/rootfs</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -a <span class="variable">$SYSROOT</span>/lib/libnss* lib</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp -a <span class="variable">$SYSROOT</span>/lib/libresolv* lib</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>编译内核</title>
    <url>/2024/02/19/linux_make_yocto_kernel/</url>
    <content><![CDATA[<p>重新来梳理一下内核编译。</p>
<blockquote>
<p>简单粗暴的选择 SOC / 开发板厂商所提供的内核是明智的。</p>
</blockquote>
<span id="more"></span>

<p>编译内核和编译 U-boot 类似，都是以下 3 个步骤：</p>
<ol>
<li>引用默认配置</li>
<li>在配置上做修改</li>
<li>编译得到镜像文件</li>
</ol>
<h1 id="内核文件分布"><a href="#内核文件分布" class="headerlink" title="内核文件分布"></a>内核文件分布</h1><ul>
<li><code>arch</code>：与不同架构相关的文件</li>
<li><code>Documentation</code>：内核相关文档，虽然有些文档很老了，但是依然是第一参考资料。</li>
<li><code>drivers</code>：设备驱动</li>
<li><code>fs</code>：文件系统</li>
<li><code>include</code>：内核头文件</li>
<li><code>init</code>：内核启动相关代码</li>
<li><code>kernel</code>：内核核心代码，包括调度、锁、定时器、电源管理、调试代码。</li>
<li><code>mm</code>：内存管理</li>
<li><code>net</code>：网络协议</li>
<li><code>scripts</code>：很有用的脚本</li>
<li><code>tools</code>：对开发和检查内核很有用的工具集</li>
</ul>
<h1 id="KConfig"><a href="#KConfig" class="headerlink" title="KConfig"></a>KConfig</h1><p>内核通过<code>Kbuild</code>来读取<code>Kconfig</code>文件进行配置。</p>
<blockquote>
<p><code>Documentation/kbuild</code>对此做了详细解释</p>
</blockquote>
<ul>
<li><p><code>ARCH</code>：指定要编译的架构</p>
<blockquote>
<p>其值就是在 <code>arch</code> 目录下的子目录名</p>
</blockquote>
</li>
<li><p><code>xxxx_defonfig</code>：默认的配置</p>
</li>
</ul>
<h2 id="选项类型"><a href="#选项类型" class="headerlink" title="选项类型"></a>选项类型</h2><p>KConfig 的配置具有以下几种类型：</p>
<ul>
<li><p><code>bool</code>：其值要么是<code>y</code>要么就是不会被定义</p>
<blockquote>
<p>CONFIG_DEVMEM=y</p>
</blockquote>
</li>
<li><p><code>tristate</code>：用于指定一个模块是被设置为模块（<code>m</code>），还是被编译进内核（<code>y</code>）</p>
</li>
<li><p><code>int</code>：10 进制的值</p>
</li>
<li><p><code>hex</code>： 16 进制的值</p>
</li>
<li><p><code>string</code>：字符串值</p>
</li>
</ul>
<h2 id="依赖与选择"><a href="#依赖与选择" class="headerlink" title="依赖与选择"></a>依赖与选择</h2><p><code>depends</code>代表当前选项依赖于其他选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config MTD_CMDLINE_PARTS</span><br><span class="line">    tristate &quot;Command line partition table parsing&quot;</span><br><span class="line">    # 当 CONFIG_MTD 被使能后，当前选项才会被显示</span><br><span class="line">    depends on MTD</span><br></pre></td></tr></table></figure>

<p><code>select</code>则是用于使能其他选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当 ARM 选项被使能时，其他 select 选项指明的选项也会被使能</span></span><br><span class="line">config ARM</span><br><span class="line">    bool</span><br><span class="line">    default y</span><br><span class="line">    select ARCH_CLOCKSOURCE_DATA</span><br><span class="line">    select ARCH_HAS_DEVMEM_IS_ALLOWED</span><br><span class="line">[…]</span><br></pre></td></tr></table></figure>

<h2 id="使用-menuconfig"><a href="#使用-menuconfig" class="headerlink" title="使用 menuconfig"></a>使用 menuconfig</h2><p>使用 menuconfig 需要确保<code>ncurses,flex,bison</code>被安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install libncurses5-dev flex bison</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后便是基于默认配置来进一步配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=&lt;arch&gt; &lt;xxx_defconfig&gt; menuconfig</span></span><br></pre></td></tr></table></figure>

<p>当开始编译内核后，会自动生成<code>include/generated/autoconf.h</code>文件，包含配置文件的宏定义，这是一个很好的用于检查的文件。</p>
<h2 id="标记自己内核的版本"><a href="#标记自己内核的版本" class="headerlink" title="标记自己内核的版本"></a>标记自己内核的版本</h2><p>可以通过修改<code>General setup -&gt; Local version</code>来为版本增加自己的后缀。</p>
<p>然后使用<code>make</code>来查看是否生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=arm kernelrelease</span></span><br></pre></td></tr></table></figure>

<p>这个输出可以与运行时的 <code>uname</code> 进行对比，以排查是否相同的内核。</p>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>内核构建系统<code>Kbuild</code>从<code>.config</code>文件中获取配置，然后进行编译。</p>
<h2 id="编译的输出类型"><a href="#编译的输出类型" class="headerlink" title="编译的输出类型"></a>编译的输出类型</h2><p>根据不同的 bootloader，其所需要一般内核压缩包是不一样的：</p>
<ul>
<li><p>U-Boot：一般可以适配<code>uImage</code>和<code>zImage</code></p>
<blockquote>
<p>$ make -j 4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-  zImage</p>
</blockquote>
</li>
<li><p>x86：<code>bzImage</code></p>
</li>
<li><p>其他的 bootloader：<code>zImage</code></p>
</li>
</ul>
<h2 id="编译输出内核文件"><a href="#编译输出内核文件" class="headerlink" title="编译输出内核文件"></a>编译输出内核文件</h2><p>编译完成后，在顶层目录会有<code>vmlinux</code>和<code>System.map</code>文件。</p>
<p><code>vmlinux</code>是内核的 ELF 二进制文件，如果使能了<code>CONFIG_DEBUG_INFO</code>，那么此文件将会包含很多调试信息，可以使用<code>kgdb</code>这种工具对内核进行调试。</p>
<p><code>System.map</code>文件包含内核完整的符号表。</p>
<ul>
<li><code>Image</code>：<code>vmlinux</code>去掉所有调试信息后的纯净的二进制文件</li>
<li><code>zImage</code>：将<code>Image</code>文件压缩后的文件</li>
<li><code>uImage</code>：<code>zImage</code>加上 64 字节的 U-boot 头</li>
</ul>
<p>在编译过程中，如果有编译错误，那么可以加上<code>V=1</code>选项来查看编译命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j 4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-</span></span><br><span class="line">gnueabihf- V=1 zImage</span><br></pre></td></tr></table></figure>

<h2 id="编译设备树"><a href="#编译设备树" class="headerlink" title="编译设备树"></a>编译设备树</h2><p>设备树编译的搜寻路径也是<code>arch/$ARCH/boot/dts/</code>，所以编译设备树指定<code>ARCH</code>变量即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=arm dtbs</span></span><br></pre></td></tr></table></figure>

<h2 id="编译模块"><a href="#编译模块" class="headerlink" title="编译模块"></a>编译模块</h2><p>编译模块和编译内核是一样的，只是指定其编译类型是模块即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j 4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- modules</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>.ko</code>的模块文件会与源码目录在一起。</p>
<p>可以设置<code>INSTALL_MOD_PATH</code>来指定安装目录，模块会安装在目录的<code>./lib/modules/&lt;kernel_version&gt;</code>文件夹中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf- \</span></span><br><span class="line"><span class="bash">INSTALL_MOD_PATH=<span class="variable">$HOME</span>/rootfs modules_install</span></span><br></pre></td></tr></table></figure>

<h2 id="清理编译输出"><a href="#清理编译输出" class="headerlink" title="清理编译输出"></a>清理编译输出</h2><p><code>make</code>根下面几种选择来进行清理：</p>
<ul>
<li><code>clean</code>：删除目标文件和其他中间文件</li>
<li><code>mrproper</code>：删除所有的中间文件，包含<code>.config</code>文件</li>
<li><code>distclean</code>：在<code>mrproper</code>的基础上，删除基本的备份文件、补丁文件等</li>
</ul>
<h2 id="编译-imx8mm-内核"><a href="#编译-imx8mm-内核" class="headerlink" title="编译 imx8mm 内核"></a>编译 imx8mm 内核</h2><p>为了简化编译，这里使用<a href="https://github.com/MYiR-Dev/myir-imx-linux">米尔科技的内核分支</a>。</p>
<p>先安装基础包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install -y libssl-dev libelf-dev</span></span><br></pre></td></tr></table></figure>

<p>首先需要将交叉编译工具链，加入当前 SHELL 的环境变量中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PATH=/home/cec/x-tools/aarch64-unknown-linux-gnu/bin:<span class="variable">$&#123;PATH&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>然后按照惯例，先清理一下中间文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make distclean</span></span><br></pre></td></tr></table></figure>

<p>配置常使用的全局变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CROSS_COMPILE=aarch64-unknown-linux-gnu-</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ARCH=arm64</span></span><br></pre></td></tr></table></figure>

<p>接下来为内核指定要编译的构架，及其使用的默认配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make myd_imx8mm_defconfig</span></span><br></pre></td></tr></table></figure>

<p>最后就是编译内核文件、模块、设备树：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make -j8 dtbs Image modules</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Image</code>文件编译后位于<code>arch/arm64/boot/Image</code></li>
<li>设备树位于<code>arch/arm64/boot/dts/myir/</code></li>
</ul>
<h2 id="编译-bbb-内核"><a href="#编译-bbb-内核" class="headerlink" title="编译 bbb 内核"></a>编译 bbb 内核</h2><p>按照以下步骤即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 清除中间文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span> </span><br><span class="line">mrproper</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=arm multi_v7_defconfig</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译内核</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-</span></span><br><span class="line">gnueabihf- zImage</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译模块</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make -j4 ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-</span></span><br><span class="line">gnueabihf- modules</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译设备树</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make ARCH=arm CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span> </span><br><span class="line">dtbs</span><br></pre></td></tr></table></figure>

<h1 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h1><h2 id="当没有文件系统时"><a href="#当没有文件系统时" class="headerlink" title="当没有文件系统时"></a>当没有文件系统时</h2><p>当仅启动了内核，而没有文件系统时，就会出现内核<code>panic</code>以表示无法挂载根文件系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ 1.886379] Kernel panic - not syncing: VFS: Unable to mount </span><br><span class="line">root fs on unknown-block(0,0)</span><br><span class="line">[ 1.895105] ---[ end Kernel panic - not syncing: VFS: Unable to </span><br><span class="line">mount root fs on unknown-block(0, 0)</span><br></pre></td></tr></table></figure>

<p>为了将系统从内核态切换到用户态，内核需要挂载根文件系统，然后执行根文件系统中的初始化程序。</p>
<p>这个是开始于执行<code>init/main.c</code>中的<code>rest_init()</code>函数，它会创建一个 PID 为 1 的进程，然后执行<code>kernel_init()</code>。</p>
<p>接着尝试执行<code>/init</code>程序，如果执行失败则会尝试执行<code>prepare_namespace()</code>函数，这个函数会读取<code>root=</code>命令行参数，挂载对应的分区，<code>root</code>命令一般如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root=/dev/&lt;disk name&gt;&lt;partition number&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者对于 emmc/sd 设备</span></span><br><span class="line">root=/dev/&lt;disk name&gt;p&lt;partition number&gt;</span><br></pre></td></tr></table></figure>

<p>挂载成功后，将会依次尝试执行<code>/sbin/init,/etc/init,/bin/init,/bin/sh</code>，其中任何一个执行成功了，后面的便不会被执行了。</p>
<blockquote>
<p>当然也可以设定<code>init=</code>参数来指定执行哪个特定的程序。</p>
</blockquote>
<h2 id="内核的命令行参数"><a href="#内核的命令行参数" class="headerlink" title="内核的命令行参数"></a>内核的命令行参数</h2><p>目标内核的命令行参数都是通过设备树中的<code>bootargs</code>属性来设定了，在<code>Documentation/kernel-parameters.txt</code>有参数的详细说明，下面是一些常用的参数：</p>
<ul>
<li><p><code>debug</code>：设置调试信息输出等级，小于该数值的调试信息将被输出</p>
</li>
<li><p><code>init=</code>：在挂载根文件系统后，所运行的<code>init</code>程序路径</p>
</li>
<li><p><code>lpj=</code>：设置<code>loops_per_jiffy</code>以降低开机测试所消耗的时间</p>
</li>
<li><p><code>panic=</code>：当内核出现 panics 时的行为</p>
<blockquote>
<p>小于 0：当出现 panic 则立即重启</p>
<p>等于 0（默认）：当出现 panic 不重启</p>
<p>大于 0：当出现 panic 时，等待多少秒后重启</p>
</blockquote>
</li>
<li><p><code>quiet</code>：除了紧急信息，其他的调试信息都不输出</p>
</li>
<li><p><code>rdinit=</code>：与<code>init=</code>一致，不过这个是针对 <code>ramdisk</code>的</p>
</li>
<li><p><code>ro</code>：以只读的方式挂载根文件系统</p>
</li>
<li><p><code>root=</code>：指定挂载根文件系统的设备</p>
</li>
<li><p><code>rootdelay=</code>：等待多少秒后才挂载根文件系统，用于等待设备初始化完成</p>
</li>
<li><p><code>rootfstype=</code>：指定根文件系统的类型，默认情况下都是自动检测的</p>
</li>
<li><p><code>rootwait</code>：一直等到设备初始化完毕以后，才挂载根文件系统</p>
</li>
<li><p><code>rw</code>：以读写的方式挂载根文件系统</p>
</li>
</ul>
<h2 id="imx8mm-内核启动"><a href="#imx8mm-内核启动" class="headerlink" title="imx8mm 内核启动"></a>imx8mm 内核启动</h2><h3 id="制作启动-SD-卡"><a href="#制作启动-SD-卡" class="headerlink" title="制作启动 SD 卡"></a>制作启动 SD 卡</h3><p>从 Uboot 中的启动命令可知：它将在 mmc 的 1 分区中寻找<code>Image</code>文件和对应的设备树。</p>
<p>并且，前面我们将由<a href="https://source.codeaurora.org/external/imx/imx-mkimage">imx-mkimage</a>打包的 bootloader 拷贝到了 SD 卡的 33K 偏移处，也就是说需要保留这部分裸数据，前面制作好的<code>flash.bin</code>有 1M 多的大小，需要考虑好这个偏移。</p>
<ol>
<li><p>由于 SD 卡是 512 字节的扇区，先用 fdisk 简单粗暴的将第一个分区的起始扇区设为 20480，这样就预留了有 10MB 的空间给 bootloader。</p>
</li>
<li><p>使用<code>sudo mkfs.vfat /dev/sdd1</code>将分区格式化为 FAT32 格式</p>
</li>
<li><p>将编译得到的<code>Image</code>和<code>myb-imx8mm-base.dtb</code>拷贝到 SD 卡分区</p>
<blockquote>
<p>这里选择 <code>myb-imx8mm-base.dtb</code>，是因为前面打包 bootloader 也是这个设备树</p>
</blockquote>
</li>
<li><p>修改 U-boot 默认环境变量<code>fdt_file</code>的值为<code>myb-imx8mm-base.dtb</code>，这样才能一一对应</p>
</li>
</ol>
<h2 id="bbb-启动"><a href="#bbb-启动" class="headerlink" title="bbb 启动"></a>bbb 启动</h2><p>将编译好的<code>zImage</code>和<code>am335x-boneblack.dtb</code>拷贝到 SD 卡中，启动 u-boot 后。</p>
<p>首先，读取内核到内存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 0:1 0x80200000 zImage</span><br></pre></td></tr></table></figure>

<p>然后，读取设备树到内存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fatload mmc 0:1 0x80f00000 am335x-boneblack.dtb</span><br></pre></td></tr></table></figure>

<p>设置终端设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenv bootargs console=ttyO0,115200</span><br></pre></td></tr></table></figure>

<p>使用 <code>bootz</code> 启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bootz 0x80200000 - 0x80f00000</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>认识交叉编译器</title>
    <url>/2024/01/17/linux_make_yocto_toolchain/</url>
    <content><![CDATA[<p>工具链的选择一般放在最开始，工具链选好以后最好就不要变动了。</p>
<blockquote>
<p>或者说要变动的话，也是所有变动，所有的源码都要重新编译一次。</p>
</blockquote>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装基本工具"><a href="#安装基本工具" class="headerlink" title="安装基本工具"></a>安装基本工具</h2><p>在使用/编译工具链时，需要安装下面这些工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install -y autoconf automake bison bzip2 cmake \</span></span><br><span class="line"><span class="bash">flex g++ gawk gcc gettext git gperf help2man libncurses5-dev libstdc++6 libtool \</span></span><br><span class="line"><span class="bash">libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils</span></span><br></pre></td></tr></table></figure>

<h2 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h2><p>虽然 Clang 发展迅猛，且也可以用来交叉编译。但目前 GNU 工具链依然是最受欢迎的选择。</p>
<p>标准的 GNU 工具链包含以下几个组成部分：</p>
<ul>
<li><p><a href="http://gnu.org/software/binutils">Binutils</a>：二进制工具的集合，包含 ld，as，addr2line，strip 等</p>
<blockquote>
<p>这在分析目标文件，对目标文件进行瘦身等非常有用</p>
</blockquote>
</li>
<li><p><a href="http://gcc.gnu.org/">GCC</a>：主要用于 c/c++ 的编译器集合</p>
</li>
<li><p>c/c++ 库：包含支持 c/c++ 标准，且具有自己的扩展</p>
</li>
</ul>
<p>对于嵌入式开发而言，需要包含两种编译器：</p>
<ol>
<li><p>Native：也就是 X86 主机上用的本地编译器，这可以在前期开发应用程序时，直接在 PC 上模拟。开发效率当然是高于直接在嵌入式板上运行。</p>
<blockquote>
<p>当然，这就需要代码做好跨平台的兼容性。</p>
</blockquote>
</li>
<li><p>Cross：进行底层（bootloader，kernel）开发或需要将应用程序在目标板上运行时，才需要进行交叉编译。</p>
</li>
</ol>
<p>其实，即使开发主机和目标板的架构一样。也应该将他们的工具链分开，因为开发主机会随着时间推移而更新其工具链，这也会造成不一致的情况。</p>
<h2 id="CPU-架构的差异与工具链"><a href="#CPU-架构的差异与工具链" class="headerlink" title="CPU 架构的差异与工具链"></a>CPU 架构的差异与工具链</h2><p>在选择工具链的时候，有下面这些因素需要考虑：</p>
<ul>
<li><p>CPU 架构：是 ARM、ARM64，还是 MIPS</p>
</li>
<li><p>CPU 所支持的大小端</p>
</li>
<li><p>CPU 是否具备硬件浮点单元：如果不具备，则只能使用软件模拟浮点运算</p>
</li>
<li><p>CPU 所对应的 ABI</p>
<blockquote>
<p>ARM 架构使用的是<code>Extended Application Binary Interface（EABI）</code>。</p>
<p>而根据 CPU 是否支持硬件浮点，又分为普通的 EABI 和带硬件浮点的 EABI：</p>
<p><code>Extended Application Binary Interface Hard-Float（EABIHF）</code></p>
</blockquote>
</li>
</ul>
<p>GNU 工具链通过名称的前缀来区分这些差异，之间用短横线区分：</p>
<blockquote>
<p> <code>CPU</code>-<code>[Vendor]</code>-<code>Kernel</code>-<code>Operating system</code>-<code>tools name</code></p>
</blockquote>
<p>比如 <code>arm-xilinx-linux-gnueabi-gcc</code>。</p>
<ul>
<li><p>CPU：指定 CPU 架构，比如<code>arm,mips,x86_64</code></p>
<blockquote>
<p>如果 CPU 支持大小端切换，那么还会加上<code>el</code>对应小端，<code>eb</code>对应大端。</p>
<p>比如 <code>mipsel</code>对应 MIPS 小端模式，<code>armeb</code>对应 ARM 大端模式</p>
</blockquote>
</li>
<li><p>Vendor：说明工具链的提供者，比如<code>buildroot,poly,unknown</code>，有些时候也没有该项</p>
</li>
<li><p>Kernel：说明是用于裸机还是带系统，比如对于 Linux 就是字符串 <code>linux</code>。</p>
</li>
<li><p>Operating system：指定 ABI，比如对于 GNU 对应 ARM 版本且带硬件浮点：<code>gnueabihf</code></p>
</li>
<li><p>tools name：就是工具名了，比如<code>gcc,g++,ldd</code></p>
</li>
</ul>
<p>如果工具链的名字信息不全（通常是 Native 编译器），那么可以通过<code>-dumpmachie</code>选项来输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> gcc -dumpmachine</span></span><br><span class="line">x86_64-linux-gnu</span><br></pre></td></tr></table></figure>

<h2 id="c-库的差异"><a href="#c-库的差异" class="headerlink" title="c 库的差异"></a>c 库的差异</h2><p>c 库有以下几个选择：</p>
<ul>
<li><a href="https://www.gnu.org/software/libc/">glibc</a>：GNU 标准 C 库，对 POSIX 支持也是最为完善的，只是体积占用比较大。</li>
<li><a href="https://musl.libc.org/">musl libc</a>：兼容性与 glibc 比较接近，但是占用体积比较小</li>
<li><a href="https://uclibc-ng.org/">uClibc-ng</a>：专用于嵌入式场景的 c 库，主要还是 uClinux 用得多</li>
<li><a href="http://www.eglibc.org/home">eglibc</a>：也是专用于嵌入式场景的 c 库，但已经好几年没有更新了</li>
</ul>
<p>所以，如果 RAM 很小，那就选 musl libc，否则还是选 glibc 是最简单粗暴的方式。</p>
<h1 id="获取工具链"><a href="#获取工具链" class="headerlink" title="获取工具链"></a>获取工具链</h1><p>工具链的获取有 3 种选择：</p>
<ol>
<li>选择已经编译好的第三方工具链<ul>
<li>SOC 厂商或开发板厂商会提供他们的工具链</li>
<li>一些开源组织（比如<a href="https://www.linaro.org/">linaro</a>）会提供他们的工具链</li>
<li>发行版也会维护交叉编译工具链</li>
</ul>
</li>
<li>选择构建工具（buildroot,yocto）提供的工具链</li>
<li>使用源码自己构建工具链</li>
</ol>
<p>一般在没有特殊需求的情况下，都会使用前两个选择。</p>
<h2 id="获取已有的工具链"><a href="#获取已有的工具链" class="headerlink" title="获取已有的工具链"></a>获取已有的工具链</h2><p>首选在 SOC 厂商网站上获取他们所提供的工具链，其次才是在<code>linaro</code>网站上获取。</p>
<p>其工具链位于<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain">arm 工具链主页</a>中，但由于网络原因，推荐使用<a href="https://mirrors.tuna.tsinghua.edu.cn/armbian-releases/_toolchain/">清华大学开源镜像站</a>。</p>
<h2 id="自己构建工具链"><a href="#自己构建工具链" class="headerlink" title="自己构建工具链"></a>自己构建工具链</h2><p>构建工具链最简单的办法是通过<a href="https://github.com/crosstool-ng/crosstool-ng">crosstool-NG</a> 来完成自动化构建。</p>
<h3 id="安装-crosstool-NG"><a href="#安装-crosstool-NG" class="headerlink" title="安装 crosstool-NG"></a>安装 crosstool-NG</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果有代理，可以在命令行使用代理来加速</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> http_proxy=<span class="string">&quot;http://xx.xx.xx.xx:port&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> https_proxy=<span class="string">&quot;http://xx.xx.xx.xx:port&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/crosstool-ng/crosstool-ng</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./bootstrap</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br></pre></td></tr></table></figure>

<h3 id="查看默认支持的工具链配置"><a href="#查看默认支持的工具链配置" class="headerlink" title="查看默认支持的工具链配置"></a>查看默认支持的工具链配置</h3><p>可以先使用<code>ct-ng list-samples</code>命令列出 Crosstool-NG 所支持的类型。</p>
<p>然后在需要构建的工具链名称前面加<code>show-</code>便可以看到针对该工具链的一些配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~/github$ ct-ng show-arm-cortex_a8-linux-gnueabi </span><br><span class="line">[G...]   arm-cortex_a8-linux-gnueabi</span><br><span class="line">    Languages       : C,C++</span><br><span class="line">    OS              : linux-6.4</span><br><span class="line">    Binutils        : binutils-2.40</span><br><span class="line">    Compiler        : gcc-13.2.0</span><br><span class="line">    C library       : glibc-2.38</span><br><span class="line">    Debug tools     : duma-2_5_21 gdb-13.2 ltrace-0.7.3 strace-6.4</span><br><span class="line">    Companion libs  : expat-2.5.0 gettext-0.21 gmp-6.2.1 isl-0.26 libelf-0.8.13 libiconv-1.16 mpc-1.2.1 mpfr-4.2.1 ncurses-6.4 zlib-1.2.13 zstd-1.5.5</span><br><span class="line">    Companion tools :</span><br></pre></td></tr></table></figure>

<h3 id="编译工具链"><a href="#编译工具链" class="headerlink" title="编译工具链"></a>编译工具链</h3><p>先选择<code>aarch64-unknown-linux-gnu</code>工具链，就和编译 uboot,kernel 选择配置文件一样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct-ng arm-cortex_a8-linux-gnueabi</span></span><br></pre></td></tr></table></figure>

<p>工具链进一步配置，这和 uboot,kernel 对配置做修改一样的操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct-ng menuconfig</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>关闭<code>Path and misc options-&gt;Render the toolchain read-only</code></p>
<blockquote>
<p>为了在后面可以在工具链库路径中加入其他库，这样在交叉编译时不会因为找不到库而编译错误</p>
</blockquote>
</li>
<li><p>在<code>Operating System -&gt; Version of linux</code>选择 5.3.18</p>
<blockquote>
<p>目前使用 5.4.x 内核，所以工具链必须低于该版本。</p>
<p>否则在加载文件系统时，就会出现错误：</p>
<blockquote>
<p>FATAL: kernel too old<br>Kernel panic - not syncing: Attempted to kill init! exitcode=0x00007f00</p>
</blockquote>
<p>因为编译出的动态库 libc.so.6 所需要的内核版本高于当前内核版本</p>
<ul>
<li>可以使用<code>file libc.so.6</code>来查看其期望的版本</li>
</ul>
</blockquote>
</li>
<li><p>选择<code>Target options-&gt;Floating point</code>为<code>hardware(FPU)</code>（64 位 arm 中无此选项）</p>
<blockquote>
<p>如果有硬件浮点的话，那么选择此项才能产生使用硬件浮点单元的汇编，以提高运行效率</p>
</blockquote>
</li>
<li><p>填入<code>Target options-&gt;Use specific FPU</code>值为<code>neon</code>（64 位 arm 中无此选项）</p>
<blockquote>
<p>设定 FPU ，以可以编译内核</p>
</blockquote>
</li>
</ul>
<p>然后开始构建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ct-ng build</span></span><br></pre></td></tr></table></figure>

<p>最终的输出位于：<code>~x-tools/arm-cortex_a8-linux-gnueabihf</code></p>
<h1 id="使用工具链"><a href="#使用工具链" class="headerlink" title="使用工具链"></a>使用工具链</h1><h2 id="加入环境变量"><a href="#加入环境变量" class="headerlink" title="加入环境变量"></a>加入环境变量</h2><p>在编译好工具链后，就需要将其路径加入<code>PATH</code>环境变量，以让当前 SHELL 可以正常使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> PATH=~/x-tools/arm-cortex_a8-linux-gnueabihf/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure>

<h2 id="查看版本和配置"><a href="#查看版本和配置" class="headerlink" title="查看版本和配置"></a>查看版本和配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arm-cortex_a8-linux-gnueabihf-gcc --version</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看编译时的配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arm-cortex_a8-linux-gnueabihf-gcc -v</span></span><br></pre></td></tr></table></figure>

<p>在查看配置时，有几个选项是值得关注的：</p>
<ul>
<li><p><code>--with-sysroot=</code>：指定默认的 sysroot 目录</p>
</li>
<li><p><code>--enable-languages=</code>：说明编译器支持的版本</p>
</li>
<li><p><code>--with-cpu=</code>：针对的 CPU</p>
<blockquote>
<p>如果想在编译时设定为其他 CPU，可以在编译时使用选项<code>-mcpu=xxx</code></p>
</blockquote>
</li>
<li><p><code>--with-float=</code>：是否支持硬件浮点</p>
</li>
<li><p><code>--enable-threads=posix</code>：是否支持 POSIX 线程</p>
</li>
</ul>
<h2 id="sysroot"><a href="#sysroot" class="headerlink" title="sysroot"></a>sysroot</h2><p><code>sysroot</code>指的是一个包含库、头文件、配置文件的一个目录。</p>
<p>这些文件就是编译时查找的头文件、库等。</p>
<p>可以使用<code>-print-sysroot</code>选项来输出该路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>lib</code>文件夹：包含了 C 语言的动态链接库，链接器等</li>
<li><code>/usr/lib/</code>：包含了 C 语言的静态链接库</li>
<li><code>/usr/include</code>：包含了以上库的头文件</li>
<li><code>/usr/bin</code>：包含了在目标板上运行的工具</li>
<li><code>/usr/share</code>：包含的是一些本地化，国际化等</li>
<li><code>sbin</code>：主要包含<code>ldconfig</code>工具，用于优化动态库的载入路径</li>
</ul>
<h2 id="工具链中的其他工具"><a href="#工具链中的其他工具" class="headerlink" title="工具链中的其他工具"></a>工具链中的其他工具</h2><p>编译出来的工具链，还有一些其他常用的工具：</p>
<ul>
<li><p><code>addr2line</code>：将执行文件中打印地址反推到源码的文件及行数。</p>
<blockquote>
<p>运行崩溃时，日志打印栈调用地址，然后通过该工具来反推源码文件及行数。定位问题很有帮助。</p>
</blockquote>
</li>
<li><p><code>ar</code>：打包目标文件为静态链接库</p>
</li>
<li><p><code>as</code>：汇编器</p>
</li>
<li><p><code>c++filt</code>：重组 c++ 和 java 符号</p>
</li>
<li><p><code>cpp</code>：c 预处理器</p>
</li>
<li><p><code>elfedit</code>：编辑 ELF 文件的头</p>
</li>
<li><p><code>g++</code>：c++ 编译前端</p>
</li>
<li><p><code>gcc</code>：c 编译前端</p>
</li>
<li><p><code>gcov</code>：代码覆盖率工具</p>
</li>
<li><p><code>gdb</code>：强大的调试器</p>
</li>
<li><p><code>gprof</code>：程序分析工具</p>
</li>
<li><p><code>ld</code>：链接器</p>
</li>
<li><p><code>nm</code>：查看目标文件的符号表</p>
</li>
<li><p><code>objcopy</code>：拷贝和转化目标文件</p>
</li>
<li><p><code>objdump</code>：查看目标文件的详细信息</p>
</li>
<li><p><code>ranlib</code>：改变静态链接库的索引以加快链接速度</p>
</li>
<li><p><code>readelf</code>：查看目标文件信息的另一个工具</p>
</li>
<li><p><code>size</code>：输出目标文件代码段、数据段等占用</p>
</li>
<li><p><code>strings</code>：显示文件中的可显示字符</p>
</li>
<li><p><code>strip</code>：去除目标文件中的调试信息</p>
</li>
</ul>
<h2 id="C-库中的组件"><a href="#C-库中的组件" class="headerlink" title="C 库中的组件"></a>C 库中的组件</h2><p>c 库由 4 部分组成来实现 POSIX API：</p>
<ul>
<li><code>libc</code>： c 库的主要部分，包含了常用的函数</li>
<li><code>libm</code>：包含数学运算的函数</li>
<li><code>libpthread</code>：包含<code>pthread</code>相关操作函数</li>
<li><code>librt</code>：实时操作函数，比如共享内存、异步 I/O</li>
</ul>
<p>其中<code>libc</code>组件是默认都会链接的，不需要在编译命令中指明，而其他 3 个在需要的时候需要指明。方式就是<code>-l</code>加上名称，名称去掉<code>lib</code>前缀。</p>
<blockquote>
<p>比如要链接数学库，就使用 -lm</p>
<p>要用实时操作函数，就使用 -lrt</p>
<p>要用多线程，就使用 -lpthread 或 -pthread</p>
</blockquote>
<p>要查看一个可执行文件的链接库，可以使用<code>readelf</code>来查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> arm-cortex_a8-linux-gnueabihf-readelf -a a.out | grep <span class="string">&quot;Shared library&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>查看运行时需要的动态链接库，可以<code>grep</code>解释器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-cortex_a8-linux-gnueabihf-readelf -a a.out | grep </span><br><span class="line">&quot;program interpreter&quot;</span><br></pre></td></tr></table></figure>

<h1 id="链接静态-动态库"><a href="#链接静态-动态库" class="headerlink" title="链接静态/动态库"></a>链接静态/动态库</h1><p>这方面的工作，就交给现代 CMake是最简单粗暴的方式。</p>
<h1 id="使用不同的构建工具"><a href="#使用不同的构建工具" class="headerlink" title="使用不同的构建工具"></a>使用不同的构建工具</h1><p>对于应用编写，无脑使用 CMake 即可。</p>
<p>但对于第三方库、bootloader、kernel、rootfs 可能使用的是 makefile、autotools 等。</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>对使用到 Makefile 的工程进行交叉编译时，大部分情况下只需要设定变量<code> CROSS_COMPILE</code>来指定工具链：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法 1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法 2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>

<p>对于像 U-boot、kernel 这种兼容多种硬件的项目，还需要设定<code>ARCH</code>变量来指定硬件内核。</p>
<h2 id="Autotools"><a href="#Autotools" class="headerlink" title="Autotools"></a>Autotools</h2><p>对于使用 Autotools 构建的项目，一般先使用<code>./configure --help</code>来查看其构建所支持的选项，然后再使用 make 来进行构建。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>其常用的选项如下：</p>
<ul>
<li><code>CC</code>：指定 C 编译器</li>
<li><code>CFLAGS</code>：指定 C 编译器的选项</li>
<li><code>CXX</code>：指定 c++ 编译器</li>
<li><code>CXXFLAGS</code>：指定 c++ 编译器的选项</li>
<li><code>LDFLAGS</code>：指定链接选项，一般是库路径</li>
<li><code>LIBS</code>：指定需要链接的库</li>
<li><code>CPPFLAGS</code>：c 和 c++ 预编译选项，比如指定头文件路径</li>
<li><code>CPP</code>：指定 c 与编译器</li>
</ul>
<h3 id="常用编译命令"><a href="#常用编译命令" class="headerlink" title="常用编译命令"></a>常用编译命令</h3><p>大部分情况下，只需要指定编译器和主机即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> host 指定代码需要运行的目标机，如果是 native 编译则不需要指定这些选项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> CC=arm-cortex_a8-linux-gnueabihf-gcc ./configure --host=arm-cortex_a8-linux-gnueabihf-gcc</span></span><br></pre></td></tr></table></figure>

<p>默认的安装目录是在<code>&lt;sysroot&gt;/usr/local/</code>如果想要改变安装路径，需要使用<code>prefix</code>选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> CC=arm-cortex_a8-linux-gnueabihf-gcc \</span></span><br><span class="line"><span class="bash">./configure --host=arm-cortex_a8-linux-gnueabihf --prefix=/usr</span></span><br></pre></td></tr></table></figure>

<p>对于交叉编译库，一般在<code>make install</code>时设置<code>DESTDIR</code>变量到<code>sysroot</code>，以正确进行交叉编译：</p>
<blockquote>
<p>要不然交叉编译时，就要指定库路径和头文件路径</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make DESTDIR=$(arm-cortex_a8-linux-gnueabihf-gcc -<span class="built_in">print</span>-</span></span><br><span class="line">sysroot) install</span><br></pre></td></tr></table></figure>

<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p><a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a> 工具提供了对包管理的支持。</p>
<p>比如查看一个库所对应的库名称，c 选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定搜寻路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc \</span></span><br><span class="line"><span class="bash">-print-sysroot)/usr/lib/pkgconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pkg-config sqlite3 --libs --cflags</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里显示编译时只要 -lsqlite3 便可以使用该库了</span></span><br></pre></td></tr></table></figure>

<p>还可以直接使用输出结果作为编译选项：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> PKG_CONFIG_LIBDIR=$(arm-cortex_a8-linux-gnueabihf-gcc \</span></span><br><span class="line"><span class="bash">-print-sysroot)/usr/lib/pkgconfig</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arm-cortex_a8-linux-gnueabihf-gcc $(pkg-config sqlite3</span> </span><br><span class="line">--cflags --libs) \</span><br><span class="line">sqlite-test.c -o sqlite-test</span><br></pre></td></tr></table></figure>

<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>对于 CMkae 的使用，参考现代 CMake即可。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>make</category>
        <category>yocto</category>
      </categories>
      <tags>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程(用户空间)内存的消耗与泄露</title>
    <url>/2024/08/16/linux_memory_consume/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>理解进程(用户空间)对内存的消耗和泄露，可以更好的监控用户空间内存。</p>
<p>通过前面的说明，可以知道用户空间获得的内存都是lazy机制，但在用户空间中的虚拟地址却是认为已经被全部分配了，那么这些地址空间是如何表示的呢？</p>
<p>同时用户空间中有很多的共享内存(比如代码段)，这些又是如何表示的呢？</p>
<ul>
<li>VSS(virtual set size)</li>
<li>RSS(resident set size)</li>
<li>PSS(proporitional set size)</li>
<li>USS(unique set size)</li>
</ul>
<h1 id="一个进程的内存表示"><a href="#一个进程的内存表示" class="headerlink" title="一个进程的内存表示"></a>一个进程的内存表示</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/vma_struct.jpg?raw=true"><br>上面这幅图就表明了一个进程所占用的虚拟内存资源的表示形式，下面进行一一说明。</p>
<p>在进程表示的结构体 <code>task_struct</code> 中包含了结构 <code>mm_struct</code> 的指针，以总体表示该进程占用的虚拟内存资源。</p>
<ul>
<li><code>pgd</code> 代表该进程的页表</li>
<li><code>struct vm_area_struct *mmap</code> 将进程整个VMA给链接起来了</li>
</ul>
<p>mmap是一个指向 <code>vm_area_struct</code> 结构的链表，每一个节点(称为VMA)都表示了该进程的<strong>合法虚拟地址空间</strong>,进程每申请一段虚拟内存都会有一个节点与之对应。</p>
<ul>
<li>虽然实际分配内存是lazy机制，但进程的VMA中已经包含了该进程所有的代码段、数据段等全部地址范围<ul>
<li>所以站在程序员(虚拟空间的角度)，一个程序在最开始运行时它就被全部加载到了内存</li>
</ul>
</li>
<li><code>vm_start,vm_end</code> 表示一段虚拟地址的起始和结束</li>
<li><code>vm_page_prot</code> 表示了这段地址的访问权限</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/vma_code.jpg?raw=true"><br>正是因为有了这些合法虚拟地址节点，内核才可以判断出：在后期的操作中，当进程写该段空间时，对产生的pagefault进行对应的处理。</p>
<ul>
<li>比如是用户<strong>首次对申请的堆进行写(其VMA权限是可读可写,但其页表是只读的)</strong> ，处理pagefault应该是申请物理地址并修改其页表<ul>
<li>minor page fault:只发生内存申请操作</li>
</ul>
</li>
<li>如果是对其只读空间(比如代码段)进行写(<strong>其VMA权限和页表都是只读的</strong>)，处理pagefault应该是杀死进程并抛出segmentatoin fault信号。</li>
<li>如果是要执行代码，刚开始代码还没有存在内存中，这时产生pagefault，内核检查这部分是<strong>可执行的权限</strong>，然后将一部分代码段从硬盘读取到内存并修改页表。<ul>
<li>major page fault：不仅要申请内存还要发生IO操作，从硬盘读</li>
</ul>
</li>
<li>如果访问的虚拟地址并没有落在任何一个VMA中，那就是一段非法地址了，内核也会kill进程并抛出segmentation fault信号</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/pagefault.jpg?raw=true"></p>
<h2 id="vma的查看"><a href="#vma的查看" class="headerlink" title="vma的查看"></a>vma的查看</h2><p>在查看进程的vma前，首先就是要知道其pid，可以通过 <code>ps -aux</code> 或 <code>pidof</code> 来找出 pid.</p>
<p>有以下3种方式查看vma：</p>
<ol>
<li>使用 <code>pmap &lt;pid&gt;</code> </li>
<li>使用 <code>cat /proc/&lt;pid&gt;/maps</code> </li>
<li>使用 <code>cat /proc/&lt;pid&gt;/smaps | more</code><ul>
<li>此种方式最为详细</li>
</ul>
</li>
</ol>
<h1 id="多个进程在内存条中的分配"><a href="#多个进程在内存条中的分配" class="headerlink" title="多个进程在内存条中的分配"></a>多个进程在内存条中的分配</h1><p>从上面的理解可以知道，每个进程的vma都表示了自己所独自占用的虚拟地址空间， <strong>但实际上只有部分被加载到了物理内存</strong> 。</p>
<p>当有多个进程时，一个物理内存上有具有多个进程加载的一部分，这些多个进程是如何瓜分内存条的呢？</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/consume/multiprocess_mem.jpg?raw=true"><br>由上图可以看出：</p>
<ol>
<li>每个进程的虚拟地址空间都认为自己独占整个系统内存资源</li>
<li>每个进程都具有一个页表，在进程切换的时候也会发生页表切换，页表的基地址会给MMU</li>
<li>页表将每个进程对应的物理地址进行映射，其中具有相同代码段的进程其物理地址是一样的，虽然虚拟地址可能不一样<ul>
<li>在多核架构上，每个核都有一个MMU可以实现一一映射，之间并不冲突</li>
</ul>
</li>
</ol>
<p>基于上图，就可以再次来看内存消耗表示的几个概念了:</p>
<ul>
<li>VSS(Virtual set size) : 指的是一个进程所消耗的虚拟地址空间。<ul>
<li>对应进程1044，其 VSS = 1 + 2 + 3 </li>
</ul>
</li>
<li>RSS(resident set size) : 指的是一个进程所真实消耗的物理内存空间<ul>
<li>对应进程1044, 其 RSS = 4 + 5 + 6</li>
</ul>
</li>
<li>PSS(proporitional set size) : 指一个进程所消耗的经过比例运算后的物理内存空间<ul>
<li>对应进程1044，其所占用的libc空间也同时被其他两个进程所使用，所以1044仅占用1/3。bash空间被另外一个进程所占用，所以1044仅占用1/2<ul>
<li>那么其所占用的 PSS = 4 / 3 + 5 / 2 + 6</li>
</ul>
</li>
<li>如果站在内存条的视角，看当前所有进程所占用的空间，那么就应该看PSS之和</li>
</ul>
</li>
<li>USS(unique set size) : 指一个进程所独占的物理内存空间<ul>
<li>对应进程1044，其 USS = 6</li>
<li>一个进程所独占的空间其中必然包含堆区，所以：<strong>我们可以通过多点采样进程的USS来观察其是否有内存泄露</strong></li>
</ul>
</li>
</ul>
<p>有以下几种方式来观察进程内存消耗：</p>
<ul>
<li>使用 <code>smem -P &lt;pid&gt;</code> 来观察其总体的消耗<ul>
<li>在实际检测一个进程是否有内存泄露时，可以通过脚本使用此命令来长时间抓取其USS并保存到文件中，最后通过matlab之类的软件拟合出一条曲线<ul>
<li>嵌入式中使用的是 <code>smemcap</code> 来获取数据然后再交由PC上分析</li>
</ul>
</li>
<li><code>smem --pie/--bar</code> 还可以以图形的方式来显示</li>
</ul>
</li>
<li>使用 <code>cat /proc/&lt;pid&gt;/smaps | more</code> 的方式来详细的观察进程的VSS,RSS,PSS.</li>
<li>使用 <code>valgrind</code> 来监控一个进程是否有内存泄露， <strong>这种方式会严重降低进程的运行速度.</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c</span><br><span class="line">valgrind --tool=memcheck --leak-check=yes ./a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用 gcc 编译代码时，使能其 <code>addresssanitizer</code> 选项。这种方式会在源代码中插入内存监控代码，进程运行速度影响不大。<br>如下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sanitizer/lsan_interface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *p1, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      p1 = <span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">      <span class="built_in">memset</span>(p1, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//check memory leak by asan</span></span><br><span class="line">      <span class="keyword">if</span>(++i &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          __lsan_do_leak_check();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>还需要加上编译选项:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g -fsanitize=address ./leak.c</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>

<h1 id="观察内核的内存泄露"><a href="#观察内核的内存泄露" class="headerlink" title="观察内核的内存泄露"></a>观察内核的内存泄露</h1><p>多个进程是共享同一份内核空间的，当进程发出系统调用陷入内核后，如果内核有内存泄露那么其 slab 和 vmalloc 的占用就会随着时间推移宏观上呈上升趋势。</p>
<p>有以下几个办法来观察内核是否有泄露：</p>
<ol>
<li>通过脚本长时间抓取 <code>cat /proc/meminfo</code> 输出中的 slab 和 vmalloc 记录并保存在文件中，最后经过 matlab之类工具进行绘图。</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>初步认识 Linux 内存管理</title>
    <url>/2024/08/05/linux_memory_hello/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="CPU-与内存-I-O"><a href="#CPU-与内存-I-O" class="headerlink" title="CPU 与内存,I/O"></a>CPU 与内存,I/O</h1><h2 id="内存空间与I-O空间的区别"><a href="#内存空间与I-O空间的区别" class="headerlink" title="内存空间与I/O空间的区别"></a>内存空间与I/O空间的区别</h2><p>I/O 空间的概念是存在于 X86 架构中的，与内存空间做区分，它通过特定的指令<code>in</code>,<code>out</code>来访问外设寄存器的地址。</p>
<p>但是在实际使用时，我们也可以将外设设计在 X86 架构的内存空间中，直接访问寄存器地址，所以 <strong>I/O空间是可选的</strong> 。</p>
<p>在大多数嵌入式微控制器中没有I/O空间，仅有内存空间。内存空间可以直接通过地址，指针来访问，程序以及其他数据都是存在于内存空间中的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">再次强调：无论是在内核态还是在用户态，CPU 看到的都是虚拟地址！</span><br><span class="line"></span><br><span class="line">无论是内存条还是寄存器的访问，内核都是通过虚拟地址去访问的，内核中所有的指针操作</span><br><span class="line">都是虚拟地址。</span><br><span class="line"></span><br><span class="line">在内核中，物理地址对于 Linux 来说就是一个整数，如下物理地址在内核中的定义：</span><br><span class="line">//file: include/linux/types.h</span><br><span class="line"><span class="meta">#</span><span class="bash">ifdef CONFIG_PHYS_ADDR_T_64BIT</span></span><br><span class="line">typedef u64 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="keyword">else</span></span></span><br><span class="line">typedef u32 phys_addr_t;</span><br><span class="line"><span class="meta">#</span><span class="bash">endif</span></span><br></pre></td></tr></table></figure>

<h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>MMU提供虚拟地址和物理地址的映射，内存访问权限保护和 Cache 缓存控制等硬件支持，<br>用户在编写实际程序时不用考虑实际物理地址有多大，以及是否会与其他程序地址冲突等等。</p>
<ul>
<li>具体MMU工作参考 <a href="https://kcmetercec.top/2023/04/06/linux_mm_hardware_mmu/">MMU基本原理</a></li>
</ul>
<h3 id="MMU操作原理"><a href="#MMU操作原理" class="headerlink" title="MMU操作原理"></a>MMU操作原理</h3><p>MMU中比较重要的两个概念：</p>
<ul>
<li>TLB(Translation Lookaside Buffer)<ul>
<li>转换旁路缓存，TLB 是 MMU 的核心部件，它缓存少量的虚拟地址与物理地址的转换关系，是转换表的Cache，因此也经常被称为”快表”。</li>
</ul>
</li>
<li>TTW(Translation Table wale)<ul>
<li>转换表漫游，当TLB中没有缓冲对应的地址转换对应关系时，需要通过对内存中转换表的访问来获得虚拟地址和物理地址的对应关系。TTW成功后，结果应写入TLB中。</li>
</ul>
</li>
</ul>
<p>MMU操作的原则都是以最快的速度来读写 CPU 所需要的数据或指令:</p>
<ol>
<li>所以它会首先访问 TLB 以保证最快的速度找到映射关系然后进行存取，如果此时打开了Cache并且Cache命中，那也会直接取Cache的数据否则取内存的数据并且更新Cache</li>
<li>如果TLB没有命中那么就会访问 TTW 找到映射关系并反过来更新 TLB。</li>
</ol>
<h3 id="MMU的权限管理"><a href="#MMU的权限管理" class="headerlink" title="MMU的权限管理"></a>MMU的权限管理</h3><p>MMU的权限管理主要包含以下两个方面：</p>
<ol>
<li>这段内存是否具有RWX权限(比如代码段只有RX权限，避免被改写)</li>
<li>这段内存是仅有内核才可访问，还是内核和用户都可访问<ul>
<li>仅有内核可访问的内存，避免用户获取到内核的数据</li>
</ul>
</li>
</ol>
<p>权限管理使用下面程序进行体验：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    access();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the value of a is %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//access.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">,* @note : 此处新建一个文件，就是让编译器在预编译、编译、汇编的过程中，无法察觉变量 a的类型，</span></span><br><span class="line"><span class="comment">,* 以保证编译通过。</span></span><br><span class="line"><span class="comment">,* 但实际上 a 的内存权限为可读，所以当执行写时，就会触发page fault</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="meltdown漏洞"><a href="#meltdown漏洞" class="headerlink" title="meltdown漏洞"></a>meltdown漏洞</h3><p>meltdown漏洞使得用户空间可以访问内核空间中的内容，详细解释参考 <a href="https://mp.weixin.qq.com/s/YjKoay39rtKQXGbWN6qfug">格友</a> 。</p>
<p>简单解释就是：</p>
<ol>
<li>用户空间先申请一个大数组，这个大数组的每个元素的大小即为内存页表的大小，这是为了每个页可以覆盖整个 cache，便于后期测试不被干扰</li>
<li>用户空间发送读取内核空间中 <strong>一个字节的请求</strong> ，一个字节的值为 0~255，假设该值为 N</li>
<li>由于CPU的分支预测执行功能，将用户空间大数组的第 N 个块进行读取操作（此时 N 的值依然存在于寄存器中）</li>
<li>虽然MMU进行了权限检查，但此时用户空间中数组的第 N 个块的部分数据已经存在于 cache 中了，此时 cache hit</li>
<li>由于读取Cache的速度要远远快于读取内存的速度，用户通过依次扫描 0~255 块的读取速度，识别出读取最快的那个块，便知道这第 N 个块代表内核地址的值为 N</li>
</ol>
<p>解决方案：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">由于这个漏洞是由硬件造成的，而执行的入口是用户空间和内核空间共用了一个页表（这样用户空间才可以通过虚拟地址去访问内核）。</span><br><span class="line">所以如果将用户空间和内核空间的页表进行分离，大家各用各的页表那么用户空间就无法通过虚拟地址访问到内核了。(无论用户空间如何访问，它都是访问自己的页表，对应自己代码的物理地址或者就干脆是没有命中的地址)</span><br><span class="line"></span><br><span class="line">但这样相当于MMU将内核空间和用户空间隔离为了两个进程一样，当用户空间调用内核空间接口函数时，在切换为特权模式的同时还要切换一次页表。同理，内核处理完成后回到用户空间还要切换一次页表。这样就会消耗很多时间，性能损耗比较大。</span><br><span class="line"></span><br><span class="line">需要注意的是：</span><br><span class="line">并不是说进程页表一丁点都不覆盖内核空间了，当进程进行正常合法的系统调用时，这部分逻辑是应该正常运行的。</span><br><span class="line">也就是说进程的页表要进程内核空间的系统调用接口部分以实现正常的访问。</span><br><span class="line">- 而进入到内核这部分代码之后，它会切换到内核页表，内核的页表便是覆盖所有空间的。当调用完成后，又切换回用户态的页表。</span><br></pre></td></tr></table></figure>

<p>实例体验:实际代码及操作位于 <a href="https://github.com/21cnbao/meltdown-example">宋宝华老师github</a></p>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><ul>
<li>在Linux系统中,进程的 <strong>虚拟4GB内存空间</strong> 被分为两个部分—用户空间和内核空间.</li>
<li>用户空间的地址一般分布为0<del>3GB(即PAGE_OFFSET),剩下的3</del>4GB为内核空间.  <ul>
<li><strong>用户进程只有通过系统调用(代表用户进程在内核态执行)等方式才可以访问到内核空间</strong>.</li>
<li>每个进程的用户空间都是完全独立，互不相干的。**<strong>用户进程各自有不同的页表</strong>。而内核空间是由内核负责映射，它并不会跟着进程改变,是固定的。</li>
<li>*<em>内核空间的虚拟地址到物理地址的映射是被所有进程共享的，内核虚拟空间独立于其他程序</em>***。</li>
</ul>
</li>
</ul>
<p>在menuconfig中 <code>Kernel Features -&gt; Memory split(..)</code> 可以选择设置 <code>CONFIG_PAGE_OFFSET</code> ，默认内核空间就是位于3G~4G空间的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:arch/arm/include/asm/memory.h</span></span><br><span class="line"><span class="comment">/* PAGE_OFFSET - the virtual address of the start of the kernel image */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET        UL(CONFIG_PAGE_OFFSET)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由上面代码也可以知道内核中可以使用 <code>PAGE_OFFSET</code> 宏来判断内核虚拟空间的起始地址</li>
</ul>
<h2 id="对物理内存条的分配"><a href="#对物理内存条的分配" class="headerlink" title="对物理内存条的分配"></a>对物理内存条的分配</h2><ul>
<li>请注意： <strong>这里说的是物理内存条，不是内存空间</strong></li>
</ul>
<p>Linux一般将内存条分为DMA_ZONE, NORMAL_ZONE, HIGH_ZONE3个区,<br><a href="https://mp.weixin.qq.com/s/5K7rlPXo2yIcoIXXgqqLfQ">阅码场</a> 上有清晰的说明,<br><a href="https://www.quora.com/In-reference-to-Linux-Kernel-what-is-the-difference-between-high-memory-and-normal-memory">quora</a> 上对此也有解释。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/%5BWhat%5DLinux--mem_IO/mem_area.jpg?raw=true"></p>
<h3 id="DMA-ZONE"><a href="#DMA-ZONE" class="headerlink" title="DMA_ZONE"></a>DMA_ZONE</h3><p>DMA_ZONE 是为特定 DMA 划分的区域，某些芯片的 DMA 控制器无法访问全部内存条(有些仅能访问有限的十几兆空间)，所以 Linux 为此类 DMA 规划一片内存.</p>
<p>当实际编写内核代码时，申请 DMA 缓存时使用 <code>GFP_DMA</code> 标记，以告知 Linux 在那片固定区域申请。</p>
<p>在内核代码中也有关于此标记的注释(提到了还可以作为紧急后备内存来使用):</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GFP_DMA exists for historical reasons and should be avoided where possible.</span><br><span class="line">The flags indicates that the caller requires that the lowest zone be</span><br><span class="line">used (ZONE_DMA or 16M on x86-64). Ideally, this would be removed but</span><br><span class="line">it would require careful auditing as some users really require it and</span><br><span class="line">others use the flag to avoid lowmem reserves in ZONE_DMA and treat the</span><br><span class="line">lowest zone as a type of emergency reserve.</span><br></pre></td></tr></table></figure>

<p>DMA_ZONE 的设置一般在构架目录下的Kconfig中设置，比如 <code>arch/arm/Kconfig</code> 具有其使能标记，但在设置前一定要搞清楚具体硬件！</p>
<h3 id="NORMAL-ZONE"><a href="#NORMAL-ZONE" class="headerlink" title="NORMAL_ZONE"></a>NORMAL_ZONE</h3><p>前面说过，在虚拟地址中3<del>4G为内核空间。 **Linux将物理内存的0</del>1G线性映射到3G~4G虚拟地址空间** ，而这1G的空间减去 DMA_ZONE 剩下的部分就是 NORMAL_ZONE。 </p>
<p>所谓的线性映射指的就是页表的简单映射关系，一般这种情况下仅仅是一个简单的偏移即可转换，内核提供了函数以相互转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note ： 在内核中物理地址都是一个数值，它能以指针操作的只有虚拟地址，</span></span><br><span class="line"><span class="comment"> ,* 所以此处物理地址都是 unsigned long 型</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">virt_to_phys</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">void</span> *address)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">phys_to_virt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意： <strong>线性映射并不是内核已经占用了内存，而是提前映射好以便后面操作,而无需使用时再来映射。</strong></p>
<h3 id="HIGH-ZONE"><a href="#HIGH-ZONE" class="headerlink" title="HIGH_ZONE"></a>HIGH_ZONE</h3><p>当实际的物理内存大于1G时，多于的部分就是HIGH_ZONE.</p>
<p>当内核空间要使用此段内存时，由于没有提前映射，则需要经过以下步骤使用：</p>
<ol>
<li>映射HIGH_ZONE到 高端页面映射区</li>
<li>使用</li>
<li>释放映射</li>
</ol>
<p>注意： 内核对HIGH_ZONE 不能使用 <code>virt_to_phys,phys_to_virt</code> 来转换，因为它们不是简单的线性映射!</p>
<p>对于用户空间而言，用户申请内存时，Linux搜寻内存的路径为： HIGH_ZONE -&gt; NORMAL_ZONE -&gt; DMA_ZONE.</p>
<h2 id="对内核虚拟空间的分配"><a href="#对内核虚拟空间的分配" class="headerlink" title="对内核虚拟空间的分配"></a>对内核虚拟空间的分配</h2><h3 id="x86-32-架构下的分配"><a href="#x86-32-架构下的分配" class="headerlink" title="x86-32 架构下的分配"></a>x86-32 架构下的分配</h3><p>Linux中1GB的虚拟内核地址空间又被划分为:</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>虚拟地址位置</th>
<th>相关代码</th>
</tr>
</thead>
<tbody><tr>
<td>保留区</td>
<td>FIXADDR_TOP ~ 4GB</td>
<td>搜索宏 FIXADDR_TOP</td>
</tr>
<tr>
<td>专用页面映射区</td>
<td>FIXADDR_START ~ FIXADDR_TOP</td>
<td>搜索宏 FIXADDR_START</td>
</tr>
<tr>
<td>高端内存映射区</td>
<td>PKMAP_BASE ~ FIXADDR_START</td>
<td>搜索宏 PKMAP_BASE</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vmalloc虚拟内存分配区</td>
<td>VMALLOC_START ~ VMALLOC_END</td>
<td>搜索宏 VMALLOC_START</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>物理内存映射区</td>
<td>3GB起始最大长度896M(对应物理内存的896M)</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">直接映射的最大896M物理内存分为两个区域：</span><br><span class="line">- 0 ~ 16M : ISA设备用作DMA申请</span><br><span class="line">- 16M ~ 896M : 常规区域</span><br></pre></td></tr></table></figure>

<ul>
<li>当系统物理内存超过4GB时，必须使用CPU的扩展分页(PAE)模式所提供的64位页目录才能取到4GB以上的物理内存。</li>
</ul>
<p>由上表可以看出：此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<br><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></p>
<h3 id="arm32-linux-下的分配"><a href="#arm32-linux-下的分配" class="headerlink" title="arm32 linux 下的分配"></a>arm32 linux 下的分配</h3><table>
<thead>
<tr>
<th>区域名称</th>
<th>虚拟地址位置</th>
<th>相关代码</th>
</tr>
</thead>
<tbody><tr>
<td>向量表</td>
<td>0xfff0000~0xfff0fff</td>
<td>文档 Documentation/arm/memory.txt</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vmalloc和ioremap区域</td>
<td>VMALLOC_START ~ VMALLOC_END -1</td>
<td>宏 VMALLOC_START</td>
</tr>
<tr>
<td>隔离区</td>
<td></td>
<td></td>
</tr>
<tr>
<td>DMA和常规区域映射区</td>
<td>PAGE_OFFSET ~ high_memory -1</td>
<td>宏 PAGE_OFFSET 以及变量 high_memory</td>
</tr>
<tr>
<td>高端内存映射区</td>
<td>PKMAP_BASE ~ PAGE_OFFSET -1</td>
<td>宏 PKMAP_BASE</td>
</tr>
<tr>
<td>内核模块</td>
<td>MODULES_VADDR ~ MODULES_END -1</td>
<td>宏 MODULES_VADDR</td>
</tr>
</tbody></table>
<p>由上表可以看出: </p>
<ul>
<li>对于arm32 来说， <strong>从内核模块开始的地方就已经是内核空间了！</strong></li>
<li>此片虚拟区域一共1G，但实际物理内存映射区不足1G(还有其他区域占用了地址空间)。<ul>
<li><strong>如果我们将vmalloc分配区设置得大一点，那么对应物理内存映射区就会小一点。对应的反应到物理内存上，那就是可映射的低端内存区变小了，相应的高端内存区就变大了。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在编译内核的时候可以选择：</span><br><span class="line">- VMSPLIT_3G : 用户空间3G，内核空间1G。内核模块范围为 3GB-16MB ~ 3GB-2MB,高端内存映射 3GB-2MB ~ 3GB</span><br><span class="line">- VMSPLIT_2G : 用户空间2G，内核空间2G。内核模块范围为 2GB-16MB ~ 2GB-2MB,高端内存映射 2GB-2MB ~ 2GB</span><br><span class="line"></span><br><span class="line">ARM系统的Linux之所以把内核模块放在16MB范围内，是因为ARM指令在32M以内是短跳转。</span><br><span class="line"></span><br><span class="line">而内核代码位于 3G~3G+6M 的位置，所以将内核模块放在3G-2M ~ 3G-16M之间的内存差异在32M以内，</span><br><span class="line">这样就实现了内核模块和内核本身的代码段之间的短跳转，以最小的开销实现函数的调用.</span><br></pre></td></tr></table></figure>

<h2 id="DMA、常规、高端内存分布"><a href="#DMA、常规、高端内存分布" class="headerlink" title="DMA、常规、高端内存分布"></a>DMA、常规、高端内存分布</h2><p>有以下4种可能的情况分布(地址由低到高)：</p>
<ul>
<li>DMA区域 | 常规区域 | 高端内存区域 <ul>
<li>内存较大，硬件DMA只能访问一部分地址，并且内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li>
</ul>
</li>
<li>DMA区域(常规区域) | 高端内存区域<ul>
<li>内存较大，硬件DMA可以访问全部地址，但内核映射不完所有的物理内存，剩下的部分就是高端内存区域</li>
</ul>
</li>
<li>DMA区域 | 常规区域<ul>
<li>内存较小，硬件DMA只能访问一部分地址，且内核可以完全映射物理内存</li>
</ul>
</li>
<li>DMA区域(常规区域)<ul>
<li>内存较小，硬件DMA可以访问全部地址，且内核可以完全映射物理内存</li>
</ul>
</li>
</ul>
<h3 id="buddy-算法"><a href="#buddy-算法" class="headerlink" title="buddy 算法"></a>buddy 算法</h3><p>DMA、常规、高端内存分布区 <strong>最底层</strong> 使用的是 <code>buddy</code> 算法进行管理，它将空闲 <strong>页</strong> 面以 2 的 n次方进行分配，而内存申请也是也 2 的 n 次方申请。</p>
<ul>
<li>buddy 在不断的拆分和合并，其空闲页面以 1,2,4,8,16… 这种形式组织起来<ul>
<li>从16个页面中取出一页后，buddy会拆分为 1,2,4,8 空闲页</li>
<li>如果原来是1,2,8的空闲，现在又释放了2页, <strong>如果这2页和原来空闲的2页内存连续</strong> ，buddy会合并为1,4,8空闲页</li>
</ul>
</li>
<li>与此同时， <strong>用户每次申请也只能是2的n次方！</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在 /proc/buddyinfo 会显示这些区域的空闲页面分布情况,依次从左到右显示 1,2,4,8,16 空闲页数量</span><br></pre></td></tr></table></figure>

<p>在内核编程时，可以使用以下函数来申请buddy页(一般不会直接使用)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief file: /include/linux/gfp.h</span></span><br><span class="line"><span class="comment"> ,* @note 此处的order就代表2的次方</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct page * <span class="title">alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_pages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="内存申请实际操作"><a href="#内存申请实际操作" class="headerlink" title="内存申请实际操作"></a>内存申请实际操作</h1><h2 id="用户空间内存动态申请"><a href="#用户空间内存动态申请" class="headerlink" title="用户空间内存动态申请"></a>用户空间内存动态申请</h2><p>用户空间的内存申请和释放使用标准的c库即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//申请</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>Linux内核总是采用按需调页(Demand Paging)，因此当malloc()返回的时候，虽然是成功返回，但是内核并没有真正给这个进程内存。这个时候如果去读申请的内存，内容全部是0，这个页面的映射是只读的。只有当写到某个页面的时候，内核才在页错误后，真正把这个页面给这个进程。</strong></p>
<h2 id="内核空间内存动态申请"><a href="#内核空间内存动态申请" class="headerlink" title="内核空间内存动态申请"></a>内核空间内存动态申请</h2><h3 id="物理内存连续申请"><a href="#物理内存连续申请" class="headerlink" title="物理内存连续申请"></a>物理内存连续申请</h3><p>函数 <code>kmalloc() 和 __get_free_pages()以及类似函数</code> 申请的区域位于 <code>DMA和常规区域的映射区</code> ，在物理上是连续的，与真实物理地址只有一个固定的偏移。</p>
<ul>
<li>kmalloc() 底层依赖于 <code>__get_free_pages()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 申请内存地址</span></span><br><span class="line"><span class="comment"> ,* @param size: 要申请的字节数</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请的内存类型</span></span><br><span class="line"><span class="comment"> ,* @note flags 一般有以下取值：</span></span><br><span class="line"><span class="comment"> ,* GFP_USER -&gt; 为用户空间页分配内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_KERNEL -&gt; 为内核空间申请内存，可能由于阻塞而导致睡眠</span></span><br><span class="line"><span class="comment"> ,* GFP_ATOMIC -&gt; 原子方式申请内存，若不存在则直接返回而不阻塞(用于中断、tasklet、内核定时器等非进程上下文环境中)</span></span><br><span class="line"><span class="comment"> ,* GFP_HIGHUSER -&gt; 从高端区域中为用户空间分配</span></span><br><span class="line"><span class="comment"> ,* GFP_NOIO -&gt; 申请期间，不允许任何 I/O 初始化</span></span><br><span class="line"><span class="comment"> ,* GFP_NOFS -&gt; 申请期间，不允许任何文件系统调用</span></span><br><span class="line"><span class="comment"> ,* GFP_NOWAIT -&gt; 若不存在空闲页则不等待</span></span><br><span class="line"><span class="comment"> ,* GFP_DMA -&gt; 从DMA区域分配内存</span></span><br><span class="line"><span class="comment"> ,* 还有其他取值请参考文件 include/linux/slab.h</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kzalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放kmalloc对应申请的内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 内存的申请管理设备，当设备被释放时内存也跟着自动释放</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kmalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 在 devm_kmalloc 的基础上申请内存并清零内存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">devm_kzalloc</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="物理内存不一定连续申请"><a href="#物理内存不一定连续申请" class="headerlink" title="物理内存不一定连续申请"></a>物理内存不一定连续申请</h3><p>函数 <code>vmalloc()</code> 申请区域位于 <code>vmalloc区域</code> ，在物理上不一定是连续的，与真实物理地址转换关系也不简单。</p>
<ul>
<li>vmalloc() 一般只为存在于软件中的(没有对应硬件访问)较大的内存分配</li>
<li>vmalloc() 效率没有 kmalloc() 高，不适合用来分配小内存<ul>
<li>在申请时会内存映射并修改页表</li>
</ul>
</li>
<li>vmalloc() <strong>不能用在原子上下文中</strong> ，因为它内存实现使用了标志为 <code>GFP_KERNEL</code> 的 kmalloc，可能会导致睡眠</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">vmalloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfree</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="slab机制提高少量字节申请效率"><a href="#slab机制提高少量字节申请效率" class="headerlink" title="slab机制提高少量字节申请效率"></a>slab机制提高少量字节申请效率</h3><p>slab机制使得内核中的小对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，大大提高分配效率。</p>
<ul>
<li>kmalloc() 就是使用 slab 机制实现的</li>
<li>使用 slab机制申请的内存与物理内存之间也是简单的线性偏移关系</li>
<li>查看 <code>/proc/slabinfo</code> 可以得到当前 slab 分配和使用情况</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 创建一个slab缓存，保留任意数据且全部大小相同的后备缓存</span></span><br><span class="line"><span class="comment"> ,* @param name: 缓存名称，最终会映射在 /proc/slabinfo 中</span></span><br><span class="line"><span class="comment"> ,* @param size: 每个数据结构的大小</span></span><br><span class="line"><span class="comment"> ,* @param aligh: 数据的对齐方式</span></span><br><span class="line"><span class="comment"> ,* @param flags: 申请标记：</span></span><br><span class="line"><span class="comment"> ,* - SLAB_POISON</span></span><br><span class="line"><span class="comment"> ,* - SLAB_RED_ZONE : </span></span><br><span class="line"><span class="comment"> ,* - SLAB_HWCACHE_ALIGH : 每个数据对象被对齐到一个缓存行</span></span><br><span class="line"><span class="comment"> ,* @param ctor: 对象的构造函数</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct kmem_cache *<span class="title">kmem_cache_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">size_t</span> align, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cache, <span class="keyword">gfp_t</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cache,<span class="keyword">void</span> *objp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 释放 slab 缓存</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">kmem_cache_t</span> *xxx_cachep;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 申请slab缓存池</span></span><br><span class="line">xxx_cachep = kmem_cache_create(<span class="string">&quot;xxx&quot;</span>, <span class="keyword">sizeof</span>(struct xxx), <span class="number">0</span>, SLAB_HWCACHE_ALIGH | SLAB_PANIC,</span><br><span class="line">                               <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//! 分配对象内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">ctx = kmem_cache_alloc(xxx_cachep, GFP_KERNEL);</span><br><span class="line"><span class="comment">//! 使用对象内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放对象内存</span></span><br><span class="line">kmem_cache_free(xxx_cachep, ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 释放slab缓存池</span></span><br><span class="line">kmem_cache_destroy(xxx_cachep);</span><br></pre></td></tr></table></figure>

<p>内存池技术也是用于分配大量小对象的后备缓存技术。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">mempool_t</span> *<span class="title">mempool_create</span><span class="params">(<span class="keyword">int</span> min_nr, <span class="keyword">mempool_alloc_t</span> *alloc_fn,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">mempool_free_t</span> *free_fn, <span class="keyword">void</span> *pool_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mempool_alloc</span><span class="params">(<span class="keyword">mempool_t</span> *pool, <span class="keyword">gfp_t</span> gfp_mask)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_free</span><span class="params">(<span class="keyword">void</span> *element, <span class="keyword">mempool_t</span> *pool)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mempool_destroy</span><span class="params">(<span class="keyword">mempool_t</span> *pool)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="设备-I-O-端口和-I-O-内存的访问"><a href="#设备-I-O-端口和-I-O-内存的访问" class="headerlink" title="设备 I/O 端口和 I/O 内存的访问"></a>设备 I/O 端口和 I/O 内存的访问</h1><p>设备通常会提供一组寄存器来控制设备,读写设备和获取设备状态,这些寄存器可能位于 I/O 空间中,也可能位于内存空间中.</p>
<ul>
<li>当位于I/O 空间时,通常被称为 <strong>I/O端口</strong>;</li>
<li>当位于内存空间时,对应的内存空间被称为 <strong>I/O内存</strong>.</li>
<li>在使用I/O区域时,需要 <strong>申请该区域</strong> ,以表明驱动要访问这片区域.</li>
</ul>
<h2 id="I-O-端口"><a href="#I-O-端口" class="headerlink" title="I/O 端口"></a>I/O 端口</h2><p>I/O 端口的具体操作流程为：</p>
<ol>
<li>申请I/O端口资源</li>
<li>使用读写函数操作I/O端口</li>
<li>释放I/O端口资源</li>
</ol>
<h3 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 向内核申请 n 个端口,这些端口从 start开始,name 参数为设备的名称</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_region(start,n,name) __request_region(&amp;ioport_resource,(start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放端口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_region(start,n) __release_region(&amp;ioport_resource, (start), (n))</span></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_region(dev,start,n,name) __devm_request_region(dev,&amp;ioport_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure>

<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//!读写一字节端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inb</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outb</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> byte, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写16位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inw</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> word, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写32位端口</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">inl</span><span class="params">(<span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outl</span><span class="params">(<span class="keyword">unsigned</span> longword, <span class="keyword">unsigned</span> port)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsb</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsw</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="comment">//!读写一串32位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outsl</span><span class="params">(<span class="keyword">unsigned</span> port, <span class="keyword">void</span> *addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="I-O-内存"><a href="#I-O-内存" class="headerlink" title="I/O 内存"></a>I/O 内存</h2><p>I/O内存的操作流程为：</p>
<ol>
<li>申请I/O内存资源</li>
<li>将资源地址映射到内核虚拟空间</li>
<li>使用读写函数操作</li>
<li>释放I/O内存资源</li>
</ol>
<h3 id="申请与释放-1"><a href="#申请与释放-1" class="headerlink" title="申请与释放"></a>申请与释放</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 申请以start为开始的,n字节的I/O内存区域，名字为name</span></span><br><span class="line"><span class="comment">//! 获得的地址为结构体类型 struct resource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request_mem_region(start,n,name) __request_region(&amp;iomem_resource, (start),(n),(name),0)</span></span><br><span class="line"><span class="comment">//! 释放申请的内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> release_mem_region(start,n) __release_region(&amp;iomem_resource, (start),(n))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! 设备资源释放后自动释放端口资源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> devm_request_mem_region(dev,start,n,name) __devm_request_region(dev,&amp;iomem_resource,(start),(n),(name))</span></span><br></pre></td></tr></table></figure>

<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从物理地址 offset处映射size字节内存到内核虚拟内存</span></span><br><span class="line"><span class="comment"> ,* @note ioremap() 与 vmalloc() 类似，也需要新建页表，但不进行内存分配行为。</span></span><br><span class="line"><span class="comment"> ,* 所映射的虚拟地址区为 vmalloc 映射区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">ioremap</span><span class="params">(<span class="keyword">phys_addr_t</span> offset, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//! 取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iounmap</span><span class="params">(<span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="comment">//! 当设备资源释放后自动取消映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">devm_ioremap</span><span class="params">(struct device *dev, <span class="keyword">resource_size_t</span> offset, <span class="keyword">resource_size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="读写操作函数"><a href="#读写操作函数" class="headerlink" title="读写操作函数"></a>读写操作函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 分别读写 8,16,32,64 位</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">u8  <span class="title">readb</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u16 <span class="title">readw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u32 <span class="title">readl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"><span class="function">u64 <span class="title">readq</span><span class="params">(<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span> _iomem *addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeb</span><span class="params">(u8  value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writew</span><span class="params">(u16 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writel</span><span class="params">(u32 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeq</span><span class="params">(u64 value, <span class="keyword">volatile</span> <span class="keyword">void</span> __iomem *addr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="将设备地址映射到用户空间"><a href="#将设备地址映射到用户空间" class="headerlink" title="将设备地址映射到用户空间"></a>将设备地址映射到用户空间</h2><p>驱动可以通过mmap()函数来给用户空间提供设备的虚拟地址，以达到间接访问的目的。</p>
<p>mmap()实现这样一个映射的过程：将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，<br>实际上会转化为对设备的访问。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">一般这样做的目的并不是为了用户空间来直接控制寄存器，因为这就破坏了分层的原则。</span><br><span class="line"></span><br><span class="line">一般就用于将内核空间申请的内存映射到用户空间，这样用户可以直接高效的参与内存读写，避免再进行一次数据搬移。</span><br><span class="line">比如：用户空间直接读写DMA收发的数据。</span><br></pre></td></tr></table></figure>

<h3 id="内存映射与VMA"><a href="#内存映射与VMA" class="headerlink" title="内存映射与VMA"></a>内存映射与VMA</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 内核 file_operatoins 中的 mmap()</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct file *, struct vm_area_struct *);</span><br><span class="line"></span><br><span class="line"><span class="comment">//! 用户空间的 mmap()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 从内核空间映射一段内存到用户空间</span></span><br><span class="line"><span class="comment"> ,* @param addr : 映射到用户空间以 addr 为起始，为NULL则自动分配</span></span><br><span class="line"><span class="comment"> ,* @param length: 映射的字节数</span></span><br><span class="line"><span class="comment"> ,* @param prot: 内存访问权限</span></span><br><span class="line"><span class="comment"> ,* - PROT_NONE : 不可访问</span></span><br><span class="line"><span class="comment"> ,* - PROT_EXEC : 可以执行</span></span><br><span class="line"><span class="comment"> ,* - PROT_READ : 可读</span></span><br><span class="line"><span class="comment"> ,* - PROT_WRITE: 可写</span></span><br><span class="line"><span class="comment"> ,* @param flags : 内存状态</span></span><br><span class="line"><span class="comment"> ,* - MAP_SHARED : 可被进程共享</span></span><br><span class="line"><span class="comment"> ,* - MAP_PRIVATE: 非共享</span></span><br><span class="line"><span class="comment"> ,* @param fd: 打开的文件索引</span></span><br><span class="line"><span class="comment"> ,* @param offset: 从内核的 offset 偏移处开始映射</span></span><br><span class="line"><span class="comment"> ,* @return 申请的地址</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief 取消映射</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当用户调用 mmap()的时候,内核会进行如下处理.</p>
<ol>
<li>在进程的虚拟空间查找一块 VMA</li>
<li>将这块VMA进行映射</li>
<li>如果设备驱动程序或者文件系统的file_operations定义了mmap()操作,则调用它</li>
<li>将这个VMA插入进程的VMA链表中</li>
</ol>
<p>驱动中的mmap()的实现机制是建立页表,并填充VMA结构体中 <code>vm_operations_struct</code> 指针.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! 用于描述一个虚拟内存区域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*The first cache line has the info for VMA tree walking.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;<span class="comment">/*Our start address within vm_mm.*/</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;<span class="comment">/*The first byte after our end address within vm_mm*/</span></span><br><span class="line">        <span class="comment">/* lnked list of VM areas per task, sorted by address*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>,*<span class="title">vm_prev</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>VMA结构体描述的虚拟地址介于 vm_start 和 vm_end之间,其 vm_ops 成员指向这个VMA的操作集, 针对VMA的操作都被包含在 vm_operations_struct 结构体中.</p>
<p>操作范例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">xxx_mmap</span><span class="params">(stuct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建页表项</span></span><br><span class="line">        <span class="keyword">if</span>(remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff, vma-&gt;vm_end -</span><br><span class="line">                           vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        vma-&gt;vm_ops = &amp;xxx_remap_vm_ops;</span><br><span class="line">        xxx_vma_open(vma);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在用户空间使用 mmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_open</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA open, virt %lx, phys %lx\n&quot;</span>, vma-&gt;vm_start, vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在用户空间使用 munmap()的时候被用到</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xxx_vma_close</span><span class="params">(struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        printk(KERN_NOTICE <span class="string">&quot;xxx VMA close.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">xxx_remap_vm_ops</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">        .open = xxx_vma_open,</span><br><span class="line">        .close = xxx_vma_close,</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="fault-函数"><a href="#fault-函数" class="headerlink" title="fault() 函数"></a>fault() 函数</h3><p>fault() 函数可以为设备提供更加灵活的内存映射途径。<br>当访问的页不在内存时，fault()会被内核自动调用。</p>
<p>当发生缺页时，流程为：</p>
<ol>
<li>找到缺页的虚拟地址所在的VMA</li>
<li>如果必要分配中间页目录表和页表</li>
<li>如果页表项对应的物理页面不存在，则调用 fault() 函数，它返回物理页面的页描述符</li>
<li>将物理页面地址填充到页表中</li>
</ol>
<h1 id="I-O内存静态映射"><a href="#I-O内存静态映射" class="headerlink" title="I/O内存静态映射"></a>I/O内存静态映射</h1><p>在将linux移植到目标电路板的过程中,有的会建立外设I/O内存物理地址到虚拟地址的静态映射,这个映射通过在与电路板对应的 map_desc 结构体数组中添加新的成员完成.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">map_desc</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">virtual</span>;  <span class="comment">//虚拟地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn;     <span class="comment">//__phys_to_pfn(phy_addr)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> length;  <span class="comment">//内存大小</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> type;     <span class="comment">//内存类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="DMA内存"><a href="#DMA内存" class="headerlink" title="DMA内存"></a>DMA内存</h1><h2 id="DMA与硬件Cache一致性"><a href="#DMA与硬件Cache一致性" class="headerlink" title="DMA与硬件Cache一致性"></a>DMA与硬件Cache一致性</h2><ol>
<li>在DMA不工作的情况下或者DMA与Cache相对应的主存没有重叠区, 那么Cache 与主存中的数据具有一致性特点.二者并不会起冲突.</li>
<li>*<strong>当DMA与Cache相对应的主存有重叠区时,当DMA更新了重叠区的内容,而Cache并没有对应的更新.此时CPU仍然使用的是陈旧的cache的数据,就会发生Cache与内存之间数据”不一致性”的错误!</strong><ul>
<li>当CPU向内存写数据时，此时也是先写到了cache，DMA传输数据到外设依然是原来陈旧的数据</li>
<li>在发生Cache与内存不一致性错误后,驱动将无法正常运行.</li>
</ul>
</li>
<li>Cache的不一致问题并不是只发生在DMA的情况下,实际上,它还存在于Cache使能和关闭的时刻.例如,对于带MMU功能的ARM处理器,在开启 <em>MMU之前需要先置Cache无效,否则在开启MMU之后,Cache里面有可能保存的还是之前的物理地址,这也会造成不一致性的错误!</em>.</li>
</ol>
<h2 id="Linux-下的DMA编程-DMA只是一种外设与内存的交互方式"><a href="#Linux-下的DMA编程-DMA只是一种外设与内存的交互方式" class="headerlink" title="Linux 下的DMA编程(DMA只是一种外设与内存的交互方式)"></a>Linux 下的DMA编程(<em>DMA只是一种外设与内存的交互方式</em>)</h2><p>内存中用于外设交互数据的一块区域称为 DMA 缓冲区, <em><strong>在设备不支持scatter/gather操作的情况下,DMA缓冲区在物理上必须上连续的.</strong></em></p>
<ul>
<li>当硬件支持 <code>IOMMU</code> 时，缓冲区也可以不连续</li>
</ul>
<h3 id="DMA区域"><a href="#DMA区域" class="headerlink" title="DMA区域"></a>DMA区域</h3><p>对于大多数现代嵌入式处理器而言,DMA操作可以在整个常规内存区域进行,因此DMA区域就直接覆盖了常规内存.</p>
<h3 id="虚拟地址-物理地址-总线地址"><a href="#虚拟地址-物理地址-总线地址" class="headerlink" title="虚拟地址,物理地址,总线地址"></a>虚拟地址,物理地址,总线地址</h3><ul>
<li>总线地址： 基于DMA硬件使用的是总线地址而不是物理地址，是从设备角度上看到的内存地址</li>
<li>物理地址：是从CPU MMU 控制器外围角度上看到的内存地址</li>
<li>虚拟地址：CPU看到的是MMU反映给它的地址</li>
</ul>
<h3 id="DMA地址掩码"><a href="#DMA地址掩码" class="headerlink" title="DMA地址掩码"></a>DMA地址掩码</h3><p>设备不一定能在所有的内存地址上执行DMA操作,在这种情况下需要设置DMA能够操作的地址总线宽度.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dma_set_mask</span><span class="params">(struct device *dev, u64 mask)</span></span></span><br></pre></td></tr></table></figure>

<p>如果DMA只能操作24位地址,那么就应该调用 <code>dma_set_mask(dev,0xffffff)</code></p>
<ul>
<li><p>此时内核会为申请增加 <code>GFP_DMA</code> 标记，以从 DMA_ZONE 中申请内存</p>
<h3 id="一致性DMA缓冲区"><a href="#一致性DMA缓冲区" class="headerlink" title="一致性DMA缓冲区"></a>一致性DMA缓冲区</h3><p>为了能够避免 <em>DMA与Cache一致性问题</em>,使用如下函数分配一个DMA一致性的内存区域:</p>
</li>
<li><p>操作此函数的过程是不用关心CMA区域设置，这个是内核底层完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  申请一致性DMA缓冲区(一般不带cache, 但如果有 cache coherent interconnect 硬件支持，则就可以带cache)</span></span><br><span class="line"><span class="comment">  note: 这段缓存区一般是连续的，但如果硬件带IOMMU,则也可以是不连续的</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="comment">//返回申请到的DMA缓冲区的虚拟地址</span></span><br><span class="line"><span class="comment">//handle 代表总线地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_coherent</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放申请的内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_coherent</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  分配一个写合并(writecombining)的DMA缓冲区</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dma_alloc_writecombine</span><span class="params">(struct device *dev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *handle, <span class="keyword">gfp_t</span> gfp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dma_free_writecombine</span><span class="params">(struct device *dev,<span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  PCI设备申请缓冲区</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pci_alloc_consistent</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">dma_addr_t</span> *dma_addrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pci_free_consisten</span><span class="params">(struct pci_dev *pdev, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *cpu_addr, <span class="keyword">dma_addr_t</span> dma_addr)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>注意</strong>:</p>
<p><code>dma_alloc_xxx()</code> 函数虽然是以 dma_alloc_开头, <strong>但是其申请的区域不一定在DMA区域里面</strong>.以32位ARM处理器为例,当conherent_dma_mask小于0xffffffff时,才会设置GFP_DMA标记,并从DMA区域去申请内存.</p>
<h3 id="流式DMA映射"><a href="#流式DMA映射" class="headerlink" title="流式DMA映射"></a>流式DMA映射</h3><p>在许多情况下缓冲区来自内核的较上层，上层很可能以普通的 kmalloc() 等方式申请内存，<br>也就是说这段内存是具有硬件cache的，这时就需要使用流式DMA。</p>
<p>流式DMA操作在本质上大多就是进行flush或invalidate Cache操作，以解决一致性问题。</p>
<ul>
<li>flush 是指将cache内容写入内存，invalidate是指让CPU再次从内存读取数据来刷新一次cache</li>
<li>如果有 <code>cache coherent interconnect</code> 硬件，则不需要关闭cache，从应用编程的角度来讲，只要按照规矩来操作即可。</li>
</ul>
<p>操作步骤为：</p>
<ol>
<li>进行流式DMA映射</li>
<li>执行DMA操作</li>
<li>取消映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一片内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多片非连续内存操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, NULL)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存的申请与释放</title>
    <url>/2024/08/13/linux_memory_overview_allocAndFree/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="buddy-算法缺陷"><a href="#buddy-算法缺陷" class="headerlink" title="buddy 算法缺陷"></a>buddy 算法缺陷</h1><h2 id="算法页面连续性缺陷"><a href="#算法页面连续性缺陷" class="headerlink" title="算法页面连续性缺陷"></a>算法页面连续性缺陷</h2><p>buddy算法虽然是动态的分离和合并，但合并的前置条件是这段物理页内存空间需要是连续的。但在申请内存的时候，确是分散的。<br>随着时间的推移，最终必然会造成很多空闲内存页分散的情况。</p>
<p>这就会造成一个问题： <strong>当DMA需要申请一个连续的物理内存空间时，虽然空闲页面远远大于此内存，但由于它们都是分散的，导致申请失败!</strong></p>
<ul>
<li>对于用户而言，虚拟地址空间连续即可，物理空间是否分散都不影响其使用，而DMA是直接对应物理内存操作的，需要其物理内存真的连续。</li>
</ul>
<h2 id="页面连续性问题解决方案"><a href="#页面连续性问题解决方案" class="headerlink" title="页面连续性问题解决方案"></a>页面连续性问题解决方案</h2><h3 id="reserved-内存"><a href="#reserved-内存" class="headerlink" title="reserved 内存"></a>reserved 内存</h3><p>为了保证 DMA 在任何时候都可以申请到连续的物理内存，所以在一开始就指定一片内存区域为保留区，仅仅用于DMA申请连续物理内存。</p>
<p>但这会导致当平时DMA不使用时，这片内存也无法用作其他用途，造成空间浪费。</p>
<h3 id="CMA-Contiguous-Memory-Allocator-连续内存分配器"><a href="#CMA-Contiguous-Memory-Allocator-连续内存分配器" class="headerlink" title="CMA(Contiguous Memory Allocator, 连续内存分配器)"></a>CMA(Contiguous Memory Allocator, 连续内存分配器)</h3><p>为了弥补 reserved 方式的不足，三星提出了CMA方式，其基本思想为：</p>
<ol>
<li><p>在物理内存分配了一片CMA区域(设备树中指定)，这片区域是物理内存连续的。</p>
</li>
<li><p>当DMA没有使用时，这片CMA区域交付给用户空间使用</p>
</li>
<li><p>当DMA要使用时，将用户空间的虚拟与物理内存对应表进行修改，也就是将这片物理内存区域移动到其他物理内存区域，空闲出 CMA 区。</p>
<ul>
<li>在这个过程中，由于应用程序的虚拟地址没有改变，所以其感知不到这个变化</li>
<li>在移动应用程序对应的物理内存时，新申请的内存是否连续对应用程序并不影响</li>
<li>由于在移动过程中需要重新修改页表，这段时间应用程序无法操作物理内存，会有短暂的卡顿。</li>
</ul>
</li>
<li><p>将CMA区交付给DMA使用。</p>
</li>
</ol>
<ul>
<li>有关reserved内存在设备树中的配置文档位于 <code>Documentation/devicetree/bindings/reserved-memory/reserved-memory.txt</code> </li>
</ul>
<p>可以在 menuconfig 中配置 cma：</p>
<ul>
<li><code>Memory Management options -&gt; Contiguous Memory Allocator</code> : 使能cma</li>
<li><code>Library routines -&gt; DMA Contiguous Mmeory Allocator</code> : 使能dma_cma</li>
</ul>
<h2 id="算法粒度问题"><a href="#算法粒度问题" class="headerlink" title="算法粒度问题"></a>算法粒度问题</h2><p>由于buddy算法的基本单位是页，而目前大部分页都是4K字节，这就导致当一个用户仅申请几个字节时，剩余的3K多字节就白白浪费了！</p>
<p>为了解决这个问题，Linux内核在buddy的基础之上进行了二次管理。</p>
<h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>在内核空间申请的内存都是不可移动的，这也会导致最终的内存碎片。虽然内存中有足够多的空间，但这些空间由于其不连续而导致申请大内存失败。</p>
<p>为此linux将内存空间又分为了可移动的、不可移动的、可回收类型，内核空间就在不可移动内存中申请空间，用户空间就在可移动内存中申请空间。这样内核就可以整理可移动的内存空间以腾出大片的连续内存。</p>
<p>但这些类型的分配都是一个动态的过程，最开始都是可移动的页面，只有在内核申请时才会从可移动页面申请一部分为不可移动内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* This array describes the order lists are fallen back to when</span></span><br><span class="line"><span class="comment"> ,* the free lists for the desirable migrate type are depleted</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> fallbacks[MIGRATE_TYPES][<span class="number">4</span>] = &#123;</span><br><span class="line">                                          [MIGRATE_UNMOVABLE]   = &#123; MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">                                          [MIGRATE_RECLAIMABLE] = &#123; MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES &#125;,</span><br><span class="line">                                          [MIGRATE_MOVABLE]     = &#123; MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES &#125;,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">                                          [MIGRATE_CMA]         = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">                                          [MIGRATE_ISOLATE]     = &#123; MIGRATE_TYPES &#125;, <span class="comment">/* Never used */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了不同类型的内存在其空间不够用时寻找内存的顺序。</p>
<ul>
<li>比如内核要申请 UNMOVABLE(不可移动) 内存时如果当前类型空间不够了，依次在RECLAIMABLE(可回收)、MOVABLE(可移动)类型中寻找。</li>
</ul>
<p>主动触发可移动页面整理:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/vm/compact_memory</span><br></pre></td></tr></table></figure>

<h1 id="buddy-算法与slab-malloc之间的关系"><a href="#buddy-算法与slab-malloc之间的关系" class="headerlink" title="buddy 算法与slab,malloc之间的关系"></a>buddy 算法与slab,malloc之间的关系</h1><p>buddy算法与slab,malloc之间的关系可以简单的以下图表示:</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/buddy_struct.jpg?raw=true"><br>从上图可以看出：</p>
<ol>
<li>buddy算法是针对整个内存条的，它将内存条进行统一的管理。 <strong>而内核态或是用户态对它来说都是客户而已！</strong><ul>
<li>也就是说：内核和用户对buddy来说都是平级的，无论是哪一方申请走了内存，另外一方都无法再申请同一处内存。</li>
</ul>
</li>
<li>在 <strong>内核空间</strong> 中 slab策略 将 buddy 的内存进行了二次管理，将从 buddy 申请的一大块内存分成很多小块给内核 kmalloc,kfree 使用<ul>
<li>slab并非是每次都要与buddy交互，这要根据内核中申请的内存大小而定。</li>
<li>并且可以看出 kmalloc 和 kfree 与 buddy 没有直接的关系，其申请与释放都是与slab交互的</li>
<li>buddy将内存条视为内存池，而slab将buddy视为内存池，所以它们在算法上是对等的</li>
</ul>
</li>
<li>在 <strong>内核空间</strong> 中，vmalloc直接与buddy进行交互，并没有二级管理<ul>
<li>所以申请的数量都是2的n次方页， <strong>所以使用vmalloc不适合申请小内存!</strong></li>
</ul>
</li>
<li>在 <strong>用户空间</strong> 中 glibc 库通过 <code>brk,mmap</code> 将buddy的内存进行了二次管理，提供给用户函数 <code>malloc,free</code> 使用<ul>
<li>glibc 也并非是每次都要与 buddy 交互，依然根据用户空间申请的内存大小而定</li>
<li>malloc,free 属于是库函数接口，不是系统调用</li>
</ul>
</li>
</ol>
<h2 id="slab机制-内核空间"><a href="#slab机制-内核空间" class="headerlink" title="slab机制(内核空间)"></a>slab机制(内核空间)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>slab先从buddy中申请一块内存，当内核空间要申请一小块内存时，slab将申请好的内存分成多个 <strong>相同的小块</strong> ，并将其中一块给予内核空间。<br>当预先申请的内存使用完后，slab再从buddy中申请一块内存来使用。</p>
<p>这一个小块，在slab中就称为一个object.</p>
<ul>
<li>使用命令 <code>sudo cat /proc/slabinfo</code> 就可以看到内核中slab的分配情况<ul>
<li>输出的前半部分，表示slab为内核中一些常用的数据分配的空间</li>
<li>输出的后半部分，表示slab为内核通用的用户提供的可以申请的内存块</li>
</ul>
</li>
</ul>
<h3 id="slab算法分类"><a href="#slab算法分类" class="headerlink" title="slab算法分类"></a>slab算法分类</h3><p>slab机制分为slab,slub,slob三种算法来实现slab机制。</p>
<h2 id="glibc-用户空间"><a href="#glibc-用户空间" class="headerlink" title="glibc(用户空间)"></a>glibc(用户空间)</h2><p>gblic从buddy先申请内存，而后提供接口给用户使用，这样可以避免频繁的系统调用，减少CPU在IO切换上的消耗，提高系统吞吐量。</p>
<h3 id="通过设置收缩阀值，提高申请内存速度"><a href="#通过设置收缩阀值，提高申请内存速度" class="headerlink" title="通过设置收缩阀值，提高申请内存速度"></a>通过设置收缩阀值，提高申请内存速度</h3><p>glibc会在释放的内存到达一定的阀值后，才将其释放给buddy内存池，下次申请大内存的时候glibc又要从buddy申请，这无疑会影响申请速度。</p>
<p>为了提高内存申请速度，可以设置glibc不释放内存给buddy，这样下次再来申请时，其速度就会快很多!</p>
<p>试验代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_SIZE (200 * 1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">start</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">end</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> timer;</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;free bytes through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//在真实写入操作时，glibc才会将此虚拟内存映射到物理内存</span></span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes again through normal mode: %ldus\n&quot;</span>, timer);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n***************\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(!mlockall(MCL_CURRENT | MCL_FUTURE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置收缩阀值为无穷大</span></span><br><span class="line">    mallopt(M_TRIM_THRESHOLD, <span class="number">-1UL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  mallopt(M_MMAP_MAX, <span class="number">0</span>);</span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">//此时的free只还给了glibc但没有还给buddy内存池</span></span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;free bytes through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;start, <span class="literal">NULL</span>);</span><br><span class="line">  buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)<span class="built_in">malloc</span>(SOME_SIZE);</span><br><span class="line">  assert(buffer != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, SOME_SIZE);</span><br><span class="line">  gettimeofday(&amp;end, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  timer = <span class="number">1000000</span> * (end.tv_sec - start.tv_sec) + end.tv_usec - start.tv_usec;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc bytes again through fast mode: %ldus\n&quot;</span>, timer);</span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内存申请的流程"><a href="#内存申请的流程" class="headerlink" title="内存申请的流程"></a>内存申请的流程</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/malloc.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/malloc_ex.jpg?raw=true"><br>由上两幅图可以看出：</p>
<ul>
<li>vmalloc 可以用于申请内存的任何位置以及映射寄存器<ul>
<li>使用 <code>sudo cat /proc/vmallocinfo | grep ioremap</code> 可以查看当前寄存器被映射的情况</li>
<li><strong>通过vmalloc申请的地址其虚拟地址连续但物理地址不一定连续</strong></li>
</ul>
</li>
<li>kmalloc 申请低端内存时，由于不需要修改页表，所以其操作简便<ul>
<li>正因为kmalloc与物理内存的简单映射关系，所以 <strong>其物理地址连续并且对应的虚拟地址也是连续的</strong></li>
</ul>
</li>
<li>高端内存映射区通过kmap对应申请高端物理内存</li>
<li>用户空间malloc则可以 <strong>申请内存条的任意位置</strong><ul>
<li><strong>通过malloc申请的地址其虚拟地址连续但物理地址不一定连续</strong></li>
</ul>
</li>
</ul>
<h2 id="malloc-申请机制"><a href="#malloc-申请机制" class="headerlink" title="malloc 申请机制"></a>malloc 申请机制</h2><p>malloc在用户使用时，其内部使用的是 lazy机制：</p>
<ol>
<li>当用户调用 <code>malloc</code> 时，malloc将其申请的虚拟地址都指向0页，并且 <strong>此页是一个只读页</strong><ul>
<li>此时用户还没有真正拥有内存，并且使用代码读取时读到的都是0</li>
</ul>
</li>
<li>当用户 <strong>真正是写时由于0页是只读页，此时发生pagefault，内核才会去分配真正的内存</strong><ul>
<li>也就是说在用户第一次写对应虚拟空间页时，内核才依次的为其分配内存。</li>
<li><strong>pagefault几乎是所有应用程序获取物理内存的途径</strong><ul>
<li>代码段、数据段、栈、堆都是一样的lazy机制</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>由此就引出两个概念：</p>
<ul>
<li>VSS(Virtual Set size)：用户调用 malloc 返回的虚拟地址空间大小</li>
<li>RSS(resident set size)：用户真正获取到的对应的物理内存空间(驻留内存)大小</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/skeleton/vss_rss.jpg?raw=true"></p>
<h3 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h3><p>既然内核给用户空间的内存都是lazy机制的，那么就完全有可能出现VSS大于真正的RSS的情况，导致用户真正写内存时内存不够用的情况。</p>
<p>此时Linux就会启动OOM(out of memory)机制， <strong>将内存打分因子最高</strong> 的应用给Kill掉以释放足够的内存。</p>
<p>在内存为1G的32位虚拟机上，按照如下流程体验：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用root身份，关闭交换空间</span></span><br><span class="line">swapoff -a</span><br><span class="line">echo 1 &gt; /proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 2000</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * SIZE);</span><br><span class="line">  assert(p != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc buffer addr = %p\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * (SIZE/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//此时才会真正分配到物理内存</span></span><br><span class="line">      p[i] = <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">if</span>((i &amp; <span class="number">0xfffff</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d MB written\n&quot;</span>, i &gt;&gt; <span class="number">18</span>);</span><br><span class="line">          usleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  pause();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现应用会被内核强制杀死,并在dmesg中也会看到相应的提示。</p>
<h3 id="打分因子"><a href="#打分因子" class="headerlink" title="打分因子"></a>打分因子</h3><p>Linux会为每个进程进行打分，每个进程的 oom score 取决于:</p>
<ul>
<li>驻留内存、pagetable和swap的使用量<ul>
<li>采用百分比乘以10(percent-times-tem):一个使用全部内存的进程得分1000，使用0字节的进程得分0</li>
</ul>
</li>
<li>root用户进程减去30分</li>
<li>oom_score_adj: oom_score 会加上 oom_score_adj 这个值</li>
<li>oom_adj: -15 ~ 15 的系数范围调整</li>
</ul>
<p>这部分规则的代码位于函数 <code>/mm/oom_kill.c/oom_badness()</code> 中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* oom_badness - heuristic function to determine which candidate task to kill</span></span><br><span class="line"><span class="comment"> ,* @p: task struct of which task we should calculate</span></span><br><span class="line"><span class="comment"> ,* @totalpages: total present RAM allowed for page allocation</span></span><br><span class="line"><span class="comment"> ,*</span></span><br><span class="line"><span class="comment"> ,* The heuristic for determining which task to kill is made to be as simple and</span></span><br><span class="line"><span class="comment"> ,* predictable as possible.  The goal is to return the highest value for the</span></span><br><span class="line"><span class="comment"> ,* task consuming the most memory to avoid subsequent oom failures.</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">oom_badness</span><span class="params">(struct task_struct *p, struct mem_cgroup *memcg,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">const</span> <span class="keyword">nodemask_t</span> *nodemask, <span class="keyword">unsigned</span> <span class="keyword">long</span> totalpages)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> points;</span><br><span class="line">  <span class="keyword">long</span> adj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oom_unkillable_task(p, memcg, nodemask))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p = find_lock_task_mm(p);</span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  adj = (<span class="keyword">long</span>)p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line">  <span class="keyword">if</span> (adj == OOM_SCORE_ADJ_MIN) &#123;</span><br><span class="line">    task_unlock(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* The baseline for the badness score is the proportion of RAM that each</span></span><br><span class="line"><span class="comment">   ,* task&#x27;s rss, pagetable and swap space use.</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  points = get_mm_rss(p-&gt;mm) + get_mm_counter(p-&gt;mm, MM_SWAPENTS) +</span><br><span class="line">    atomic_long_read(&amp;p-&gt;mm-&gt;nr_ptes) + mm_nr_pmds(p-&gt;mm);</span><br><span class="line">  task_unlock(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* Root processes get 3% bonus, just like the __vm_enough_memory()</span></span><br><span class="line"><span class="comment">   ,* implementation used by LSMs.</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  <span class="keyword">if</span> (has_capability_noaudit(p, CAP_SYS_ADMIN))</span><br><span class="line">    points -= (points * <span class="number">3</span>) / <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normalize to oom_score_adj units */</span></span><br><span class="line">  adj *= totalpages / <span class="number">1000</span>;</span><br><span class="line">  points += adj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   ,* Never return 0 for an eligible task regardless of the root bonus and</span></span><br><span class="line"><span class="comment">   ,* oom_score_adj (oom_score_adj can&#x27;t be OOM_SCORE_ADJ_MIN here).</span></span><br><span class="line"><span class="comment">   ,*/</span></span><br><span class="line">  <span class="keyword">return</span> points &gt; <span class="number">0</span> ? points : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以手动来调整每个进程的oom_score_adj或oom_adj来改变进程打分，这样可以偏向让系统首先杀死谁。</p>
<ul>
<li>在 <code>/proc/&lt;pid&gt;/</code> 下就具有这些文件</li>
</ul>
<p>安卓主动将前台进程的oom调低，将后台的进程oom调高，这样以保证可以杀死后台来给予前台更多的运行内存。</p>
<h3 id="oom调试"><a href="#oom调试" class="headerlink" title="oom调试"></a>oom调试</h3><p>将 <code>/proc/sys/vm/panic_on_oom</code> 写1，这样当出现oom时，内核会奔溃，这在调试嵌入式程序是比较有帮助的。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存与I/O交换</title>
    <url>/2024/08/17/linux_memory_overview_memio/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h1><p>计算机硬件系统中具有 cache 来缓存内存中的一部分内容以达到CPU的快速访问。</p>
<p>而在软件逻辑上，操作系统可以为硬盘中的文件做一个cache到内存，而避免频繁的IO操作以提高访问效率。</p>
<ul>
<li>之所以称为 page cache，是因为内存申请都是以页为基本单位的</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/why_pagecache.jpg?raw=true"><br>那么在Linux上读写文件的逻辑就是：</p>
<ol>
<li>当读取文件内容时，首先检查此内容是否在内存命中，如果命中则直接从内存读取，如果不命中就从硬盘读取并更新 pagecache.</li>
<li>当写文件内容时，首先将内容写入内存中，内核在合适的时候将内存的内容更新到硬盘。</li>
<li>使用 mmap 将内核中的page cache地址映射到用户空间，用户空间可以直接通过指针来访问。<ul>
<li>mmap 由于是直接的内存映射操作，所以其操作效率很高。(不需要再通过copy与内核交互)</li>
<li>代码段就是通过 mmap 的方式将其映射，并以指针的方式执行，其本质也是 page cache。</li>
</ul>
</li>
</ol>
<p>通过以下方式来观察page cache:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">清空cache</span></span><br><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line"></span><br><span class="line">\time -v python ./hello.py #注意：运行的代码需要文件关联够多，才比较容易看出效果,推荐python</span><br><span class="line"><span class="meta">#</span><span class="bash">第一次运行此命令，可以发现其产生了major page faults，代表有硬盘的文件交互</span></span><br><span class="line"></span><br><span class="line">\time -v python ./hello.py</span><br><span class="line"><span class="meta">#</span><span class="bash">第二次运行此命令，可以发现其major page faults 计数为0，代表是直接从内存读，且运行时间远短于第一次</span></span><br></pre></td></tr></table></figure>

<h2 id="page-cache-的表现形式"><a href="#page-cache-的表现形式" class="headerlink" title="page cache 的表现形式"></a>page cache 的表现形式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/pagecache_mode.jpg?raw=true"><br>由上图可以看出，page cache有两种不同的表现形式:</p>
<ul>
<li>cached : 当用户以文件的方式来进行 I/O 操作，这时对文件的 page cache 就称为cached<ul>
<li><strong>在文件系统底层会将 inode 这些元数据放入 buffers，而将文件block放入 cached</strong></li>
</ul>
</li>
<li>buffers: 当用户以设备的方式来访问分区进行I/O操作时，这时对分区的 page cache 就称为buffers</li>
</ul>
<p>在 <code>cat /proc/meminfo</code> 和 <code>free</code> 中都可以看到这两项数据报告。</p>
<h2 id="free-显示说明"><a href="#free-显示说明" class="headerlink" title="free 显示说明"></a>free 显示说明</h2><p>free 命令的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:       2063720     483316    1580404       7292       6564     170096</span><br><span class="line">-/+ buffers/cache:     306656    1757064</span><br><span class="line">Swap:       522236          0     522236</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行说明:<ul>
<li>total = <code>used + free (以buddy的角度来计算整体)</code></li>
<li>buffers = <code>以裸分区方式访问 + 文件系统的元数据所缓存的page cache</code></li>
<li>cached = <code>以文件方式访问所缓存的page cache</code></li>
</ul>
</li>
<li>第二行说明:(比较新的free命令已经取消了此行，改用 available 参数来预估系统可用的内存)<ul>
<li>used = <code>第一行used - buffers - cached</code><ul>
<li>buffers 和 cached 所使用掉的page cache是可以释放掉的</li>
</ul>
</li>
<li>free = <code>第一行free + buffers + cached</code><ul>
<li>同理，实际上还可以通过释放 buffers 和 cached 获取空间内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="file-backed-和-anonymous-page"><a href="#file-backed-和-anonymous-page" class="headerlink" title="file-backed 和 anonymous page"></a>file-backed 和 anonymous page</h1><ul>
<li>file-backed pages : 称为有文件背景的page cache，指的是在硬盘中有对应的文件，为了提高执行效率，内存读取了一段作为副本<ul>
<li>当内核需要更多的内存时，这些 file-backed pages 可以被取消映射而不会影响进程的正常执行(<strong>这个动作称为swap</strong>)<ul>
<li>当然，文件内容如果被修改了肯定是会写回到文件的</li>
</ul>
</li>
</ul>
</li>
<li>anonymous pages : 称为匿名页,指的是在运行过程中所产生的栈、堆等所占用的页面，虚拟地址空间与硬盘的文件没有映射关系<ul>
<li>这些匿名页是无法回收到硬盘对应文件中的,为了让出更多的内存就只有将硬盘一部分分区作为单独存放anonymous pages的位置， <strong>这个就是swap分区(也就是将匿名页swap到swap分区)</strong> 。<ul>
<li>windows中与之相对的概念就是 <strong>虚拟内存</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="linux内核中的swap动作"><a href="#linux内核中的swap动作" class="headerlink" title="linux内核中的swap动作"></a>linux内核中的swap动作</h2><p>linux内核使用LRU(Least Recently Used)算法来实现将 <code>file-backed</code> 和 <code>annoymous pages</code> swap到对应分区中,将最近最少使用的内存页swap出去.</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/LRU.jpg?raw=true"><br>上图来自链接:<a href="https://xuri.me/2016/08/13/lru-and-lfu-cache-algorithms.html"></a></p>
<p><strong>linux内核通过软件实现LRU算法置换内存页到硬盘，而CPU内部的硬件cache与内存之间也是通过LRU算法实现的置换，只不过这是硬件实现的。</strong></p>
<h2 id="zRAM-Swap"><a href="#zRAM-Swap" class="headerlink" title="zRAM Swap"></a>zRAM Swap</h2><p>虽然将硬盘的一个分区作为swap分区可以变相增大内存，但当进程切换的时候会导致硬盘被频繁的读写。</p>
<ul>
<li>在嵌入式系统上频繁擦写flash会导致其寿命大大降低</li>
</ul>
<p>为了改善这种情况，linux提供了zRAM 算法:</p>
<ul>
<li>将物理内存中分一小块分区作为swap分区</li>
<li>CPU将要被置换的页面 <strong>压缩</strong> 以后放入这个swap分区<ul>
<li>这样也相当于增加了一部分内存</li>
</ul>
</li>
<li>当进程要切换回来时，CPU再解压缩swap分区</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/mem_io/ZRAM.jpg?raw=true"></p>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 内存应用</title>
    <url>/2024/08/18/linux_memory_usage/</url>
    <content><![CDATA[<p>课程: 宋宝华老师的内存管理</p>
<p>理解了内存概念后再来看应用方面的知识就会比以前深入得多。</p>
<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="memory-cgroup"><a href="#memory-cgroup" class="headerlink" title="memory cgroup"></a>memory cgroup</h1><p>linux通过 cgroup 对系统中的3大资源： 内存资源，I/O资源,进程占用CPU资源。都可以为它们加入各自的组，进行对应的资源限制。</p>
<p>对内存的限制就称为memroy cgroup。</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><p>编写测试代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> mb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *buffer;</span><br><span class="line">  <span class="keyword">int</span> i ;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 2000</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span>*SIZE);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;malloc buffer : %p\n&quot;</span>, p);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>*<span class="number">1024</span>*(SIZE/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">      p[i] = <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">if</span>((i&amp;<span class="number">0xfffff</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%dMB written\n&quot;</span>, i &gt;&gt; <span class="number">18</span>);</span><br><span class="line">          usleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  pause();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭swap分区</span></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="meta">#</span><span class="bash">允许应用程序申请内存</span></span><br><span class="line">echo 1 &gt; /proc/sys/vm/overcommit_memory</span><br><span class="line"><span class="meta">#</span><span class="bash">进入memory cgroup 并创建 group</span></span><br><span class="line">cd /sys/fs/cgroup/memory/</span><br><span class="line">mkdir A</span><br><span class="line">cd A</span><br><span class="line"><span class="meta">#</span><span class="bash">限制此group可以使用的最大内存为200M</span></span><br><span class="line">echo $((200*1024*1024)) &gt; memory.limit_in_bytes</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加进程到memory group A,并运行</span></span><br><span class="line">sudo cgexec -g memory:A ./a.out</span><br><span class="line"><span class="meta">#</span><span class="bash">可以发现其申请到200M内存时就被系统<span class="built_in">kill</span>掉了</span></span><br></pre></td></tr></table></figure>

<h1 id="脏页的写回"><a href="#脏页的写回" class="headerlink" title="脏页的写回"></a>脏页的写回</h1><p>内存中脏页写回到硬盘，是由内核来完成的，它需要考虑时间和空间的维度。</p>
<ul>
<li>时间：脏页在内存中待的时间需要合适<ul>
<li>如果太长则提高了掉电丢数据的概率</li>
<li>如果太短则会由于写硬盘操作过于频繁而降低系统的处理能力</li>
</ul>
</li>
<li>空间维度：脏页在内存中所占的比例不能太高<ul>
<li>如果太高则一次写硬盘的时间太长，当其他进程需要内存时则需要等待这个操作完成</li>
</ul>
</li>
</ul>
<h2 id="时间配置"><a href="#时间配置" class="headerlink" title="时间配置"></a>时间配置</h2><ul>
<li><code>/proc/sys/vm/dirty_expire_centisecs</code> : 此文件配置当脏页存在的时间超过此值时，则会触发写回操作<ul>
<li>最终的时间计算是: <code>值 * 10ms</code></li>
</ul>
</li>
</ul>
<h2 id="空间配置"><a href="#空间配置" class="headerlink" title="空间配置"></a>空间配置</h2><ul>
<li><code>/proc/sys/vm/dirty_background_ratio</code> : 当进程写的脏页比例超过此值时，内核将触发写回操作<ul>
<li>此时有可能进程还依然在产生脏页</li>
</ul>
</li>
<li><code>/proc/sys/vm/dirty_ratio</code> : 当进程写的脏页比例超过此值时，内核将禁止进程产生脏页<ul>
<li>此时进程这部分操作就被停止了，所以 <code>dirty_ratio</code> 的值大于 <code>dirty_background_ratio</code> 的值</li>
</ul>
</li>
</ul>
<h1 id="内存回收原则"><a href="#内存回收原则" class="headerlink" title="内存回收原则"></a>内存回收原则</h1><p>正常情况下，当内存不够用时，内核会将内存中的 <code>file-backed pages</code> 和 <code>anonymous pages</code> 进行swap。</p>
<ul>
<li><code>/proc/sys/vm/min_free_kbytes</code> : 决定了内存中无论如何都要保持的最小空闲内存。<ul>
<li>这段内存是为了用于运行系统紧急处理时所需要的进程。<ul>
<li>申请紧急内存使用标志位 <code>PF_MEMALLOC</code></li>
</ul>
</li>
<li><code>min_free_kbytes = 4 * sqrt(lowmem_kbytes); //lowmem_kbytes指的是低端内存所占用的kb</code></li>
</ul>
</li>
</ul>
<p>当 <code>min_free_kbytes</code> 被确定后， <code>dma_zone</code>, <code>normal_zone</code>, 会根据此值计算它们的水位。</p>
<ul>
<li>dma_min = dma_zone_size / (dma_zone_size + normal_zone_size) * min_free_kbytes<ul>
<li>低水位: low = dma_min * 125%</li>
<li>高水位: high = dma_min * 150%</li>
</ul>
</li>
<li>normal_min = normal_zone_size / (dma_zone_size + normal_zone_size) * min_free_kbytes<ul>
<li>低水位: low = normal_min * 125%</li>
<li>高水位: high = normal_min * 150%</li>
</ul>
</li>
</ul>
<p>基于上面的公式，这样 <code>dma_zone</code> 和 <code>normal_zone</code> 都会具有 min,low,high 3个值，作用分别如下：</p>
<ul>
<li>min : 当内存到此值，内核在应用程序的进程上下文进行回收内存(direct reclaim)，会阻塞应用</li>
<li>low : 当内存到此值，内核的 <code>kswapd</code> 服务启动内存回收(reclaim),不会阻塞应用</li>
<li>high : 当内存到此值，内核停止内存回收</li>
</ul>
<p>可以看出这个工作机制和脏页写回机制类似。</p>
<p><strong>但是脏页写回的触发条件是以脏页的时间或空间为基准的，而内存回收则是以内存不够用为基准触发条件的。</strong></p>
<h1 id="swap空间触发时机"><a href="#swap空间触发时机" class="headerlink" title="swap空间触发时机"></a>swap空间触发时机</h1><p>swappiness 反映是否积极的使用swap空间(也就是swap anonymous pages)，其设定值位于 <code>/proc/sys/vm/swappiness</code> 文件中。</p>
<p>根据其取值来决定:</p>
<ul>
<li>0 : 仅在内存不足的情况下使用swap空间<ul>
<li>也就是空闲的内存和file-backed页空间之和小于zone的 high 水位之时</li>
</ul>
</li>
<li>60 : 默认值</li>
<li>100 : 积极的使用swap空间</li>
</ul>
<p>某个进程也可以通过系统调用 <code>mlockall(MCL_CURRENT | MCL_FUTURE)</code> 来禁止内核对此进程的所占用的一切内存空间进行swap，可以提高该进程在内存应用上的是实时性。</p>
<h1 id="获取进程延迟"><a href="#获取进程延迟" class="headerlink" title="获取进程延迟"></a>获取进程延迟</h1><p><code>Documentation/accounting/getdelays.c</code> 工具用于测量调度、I/O、swap、Reclaim延迟。</p>
<p>此代码是一个独立代码不是内核模块，所以可以将其直接通过gcc编译。</p>
<p>使用格式为: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">&lt;<span class="built_in">exec</span>&gt;即为可执行文件名</span></span><br><span class="line">./getdelays -d -c &lt;exec&gt;</span><br></pre></td></tr></table></figure>

<h1 id="获取系统的动态情况"><a href="#获取系统的动态情况" class="headerlink" title="获取系统的动态情况"></a>获取系统的动态情况</h1><p>vmstat 可以展现给Linux的CPU使用率、内存使用、虚拟内存交换情况、I/O读写情况等。</p>
<ul>
<li>vmstat <period> : <period> 代表每隔几秒刷新一次监控情况</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 MMU 最基本原理</title>
    <url>/2023/04/06/linux_mm_hardware_mmu/</url>
    <content><![CDATA[<p>对于内存管理知识而言，MMU基本原理是这类知识的基础，需要掌握。</p>
<span id="more"></span>

<h1 id="MMU的作用"><a href="#MMU的作用" class="headerlink" title="MMU的作用"></a>MMU的作用</h1><p>内存管理单元（Memory Management Unit）简称MMU，负责将虚拟地址映射到物理地址，并具有内存访问权限检查的功能。</p>
<p>它具有如下好处：</p>
<ul>
<li>让应用程序可以分段加载，这样可以让多个程序（程序之和大于内存）并发地在内存中运行<ul>
<li>仅将要运行的部分装入内存，其他部分用到的时候再载入。</li>
<li>当内存不够用时，将暂时不用的部分再重新调出到硬盘</li>
</ul>
</li>
<li>应用程序不用关心实际物理内存，相互虚拟地址互不干扰<ul>
<li>每个应用程序都可以在逻辑上认为自己独占内存</li>
</ul>
</li>
<li>应用程序之间的地址隔离，不能越权访问，很好的保护了程序空间</li>
</ul>
<p>而对于这些功能的满足都是基于硬件来实现的。</p>
<h1 id="地址转换概念"><a href="#地址转换概念" class="headerlink" title="地址转换概念"></a>地址转换概念</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>虚拟地址空间： 在使用了MMU之后，应用程序逻辑上可以使用的内存不与实际的物理内存大小相关。<ul>
<li>比如在32位的CPU中，逻辑上可以使用 0 ~ 0XFFFFFFFF 的内存空间，这个空间就是虚拟地址空间 <ul>
<li>需要注意的是： 这里所指的内存空间是CPU总线可以理论访问的地址范围，其中<strong>包括了I/O设备、内存条、预留空间等！</strong></li>
</ul>
</li>
<li>虚拟地址空间对应的地址就是虚拟地址(VA, Virtual Address)</li>
</ul>
</li>
<li>物理地址空间：硬件上实实在在存在的内存大小就是物理地址空间<ul>
<li>需要注意的是： 这里所指的内存空间是CPU总线可以实际访问的地址范围，其中<strong>包括了I/O设备、内存条、预留空间等！</strong><ul>
<li>物理地址空间对应的地址就是物理地址(PA, Physical Address)</li>
</ul>
</li>
</ul>
</li>
<li>变换后的虚拟地址(MVA, Modified Virtual Address): 在虚拟地址向物理地址转换中间的地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">虽然内存空间包括I/O设备、内存条等等，其加起来可能远远不及4G。但是依然需要为每个进程建立覆盖4GB的页表！！</span><br><span class="line"></span><br><span class="line">只有这样MMU才可以对每个内存访问进行无死角的监控！不然来个MMU都不认识的虚拟地址，你要人家怎么办？</span><br></pre></td></tr></table></figure>

<h2 id="地址转换概念-1"><a href="#地址转换概念-1" class="headerlink" title="地址转换概念"></a>地址转换概念</h2><p>虽然虚拟地址大于物理地址，但程序总是要在实实在在的物理地址上运行的。于是将虚拟地址空间和物理地址空间划分为<strong>同样大小</strong>的空间（也叫段或页），这样虚拟和物理之间建立映射关系。但是由于虚拟地址空间大于物理地址空间，那么虚拟地址空间分得的页多于物理地址空间，所以就会出现：</p>
<ul>
<li>几个虚拟地址空间映射页到同一个物理地址空间页<ul>
<li>多个进程使用内存的内容一致</li>
<li>多个进程分时使用相同的物理内存，物理内存对于不同进程进行置换</li>
</ul>
</li>
<li>一些虚拟地址空间页没有映射到物理地址空间页上<ul>
<li>当这些虚拟地址空间被访问时，MMU 会觉察并通知 CPU 进行重映射到物理页<ul>
<li>MMU硬件会由于没有映射到物理地址而产生 page fault，CPU 会接收此信号并做处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相互之间的视角"><a href="#相互之间的视角" class="headerlink" title="相互之间的视角"></a>相互之间的视角</h2><ol>
<li>CPU能看到的是虚拟地址(VA)<ul>
<li>无论I/O还是内存条都是虚拟地址，所以在 Linux 驱动中要访问外设硬件时，也必须经过映射</li>
</ul>
</li>
<li>cache 和 MMU 看到的是转换后的虚拟地址(MVA)，通过此值转换为PA</li>
<li>实际设备在没有IOMMU的情况下看到的是物理地址(PA)，VA 和 MVA 对其都不可见<ul>
<li>一般情况下实际设备当然只关心物理地址，人家怎么知道你虚拟地址要怎么映射？<ul>
<li>但有IOMMU就不一样了，其对应的物理地址依然可以不连续。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h1><h2 id="转换概览"><a href="#转换概览" class="headerlink" title="转换概览"></a>转换概览</h2><p>虚拟地址到物理地址转换的办法：</p>
<ul>
<li>用确定的数学公式进行转换</li>
<li>用表格存储虚拟地址对应的物理地址（ARM使用此种方式）<ul>
<li>一个条目（Entry）存储了一段虚拟地址对应的物理地址及其访问权限，或下一级页表的地址</li>
<li>许多条目组成了页表（Page table），页表可能会有多级</li>
</ul>
</li>
</ul>
<p>ARM CPU 具体转换流程：</p>
<ol>
<li>根据给定的虚拟地址找到一级页表中的条目</li>
<li>如果此条目是段描述符，则返回物理地址，转换结束</li>
<li>如果此条目是二级页表描述符，继续利用虚拟地址在二级页表中找到下一个条目</li>
<li>如果第二个条目是页描述符，则返回物理地址，转换结束</li>
<li>其他情况出错(如果有3级及以上，以此推理)</li>
</ol>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/hardware/mmu/pic/mmu_translate.jpg?raw=true"><br>在 32 位 CPU 中，虚拟地址空间达到 4GB，一级页表使用 4096 个描述符来分段，每个描述符对应 1MB 的虚拟空间。<br>也就是说，一级页表占用 MVA [31:20] 地址范围来对应每一个描述符。</p>
<ul>
<li>当使用段描述符时，对应的MVA[19:0]位就是对应物理基准地址。</li>
<li>当使用多级页表的情况下，MVA[19:0]又会从中分配出一段以代表二级页表的偏移。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">也就是说在寻找物理地址的过程中，都是通过一个页表基地址再加上 MVA 中取出一段作为偏移来层层索引到最终地址的。</span><br></pre></td></tr></table></figure>

<h2 id="一级描述符的内容"><a href="#一级描述符的内容" class="headerlink" title="一级描述符的内容"></a>一级描述符的内容</h2><p>每个描述符占用 32 位，分别描述了描述符类型，描述符地址，对应的内存权限等。</p>
<p>一级描述符低两位代表了描述符的类型。</p>
<h2 id="段-Section-描述符"><a href="#段-Section-描述符" class="headerlink" title="段(Section)描述符"></a>段(Section)描述符</h2><ul>
<li>MVA 通过其 [31:20] 位加上页表基地址首先找到其对应的段描述符，一共有4096个段描述符</li>
<li>段描述符其 [31:20] 为段的基地址，其索引到物理内存以 1M 为分段的起始地址。 </li>
<li>其剩余的 [19:0] 位对应的就是物理地址在1M空间的偏移，对应 MVA [19:0] 位（<code>4096*1MB = 4GB</code>）。</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/hardware/mmu/pic/mmu_section.jpg?raw=true"></p>
<h3 id="粗页表-Coarse-page-table-描述符"><a href="#粗页表-Coarse-page-table-描述符" class="headerlink" title="粗页表(Coarse page table)描述符"></a>粗页表(Coarse page table)描述符</h3><ul>
<li>MVA通过其 [31:20] 位加上页表基地址首先找到其对应的粗页表描述符，一共有 4096 个粗页表</li>
<li>粗页表 [31:10] 为粗页表基地址，与MVA的 [19:12] 组合，对应索引到二级页表的基地址</li>
<li>每二级页表条目为 256 个，每个条目就可以表示 4KB 的物理地址空间,对应MVA [11:0] (<code>4096*256*4KB=4GB</code>)</li>
</ul>
<h3 id="细页表-Fine-page-table-描述符"><a href="#细页表-Fine-page-table-描述符" class="headerlink" title="细页表(Fine page table)描述符"></a>细页表(Fine page table)描述符</h3><ul>
<li>MVA 通过其 [31:20] 位加上页表基地址首先找到其对应的细页表描述符，一共有4096个细页表</li>
<li>细页表 [31:12] 为细页表基地址，与 MVA [19:10] 组合，对应索引到二级页表的基地址</li>
<li>每个二级页表条目为 1024 个，每个条目可以表示1KB的物理地址空间,对应MVA [9:0] (<code>4096*1024*1KB=4GB</code>)</li>
</ul>
<h2 id="二级描述符内容"><a href="#二级描述符内容" class="headerlink" title="二级描述符内容"></a>二级描述符内容</h2><p>当一级描述符为粗页表或者为细页表时，就会需要有二级描述符，二级描述符用于描述1MB的空间，二级描述符分为如下几种：</p>
<h3 id="大页描述符"><a href="#大页描述符" class="headerlink" title="大页描述符"></a>大页描述符</h3><ul>
<li>大页描述符[31:16]为大页基地址(Large page base address)</li>
<li>其[15:0]对应64KB的物理地址空间偏移</li>
<li>在粗页表中，二级页表条目只能表示4KB的物理空间，所以有连续16个条目保存同一个大页表描述符</li>
<li>在细页表中，二级页表条目只能表示1KB的物理空间，所以有连续64个条目保存同一个大页表描述符</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/hardware/mmu/pic/mmu_large_page.jpg?raw=true"></p>
<h3 id="小页描述符"><a href="#小页描述符" class="headerlink" title="小页描述符"></a>小页描述符</h3><ul>
<li>小页描述符 [31:12] 为小页基地址(Small page base address)</li>
<li>其 [11:0] 对应4KB的物理地址空间偏移</li>
<li>在粗页表中，每个条目正好4KB，则一个条目正好对应一个小页描述符</li>
<li>在细页表中，每个条目1KB，则需要4个连续的条目表示同一个小页描述符</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/hardware/mmu/pic/mmu_small_page.jpg?raw=true"></p>
<h3 id="极小页描述符"><a href="#极小页描述符" class="headerlink" title="极小页描述符"></a>极小页描述符</h3><ul>
<li>极小页描述符 [31:10] 为极小页基地址(Tiny page base address)</li>
<li>其 [9:0] 对应1KB物理地址空间偏移</li>
<li>极小页描述符通过细页表一个条目与之一一对应</li>
</ul>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bmm%5D/hardware/mmu/pic/mmu_tiny_page.jpg?raw=true"></p>
<h1 id="多进程下的页表"><a href="#多进程下的页表" class="headerlink" title="多进程下的页表"></a>多进程下的页表</h1><p>在有操作系统的情况下，都是多个进程并发运行，而不同的进程具有不同的页表。<br>这些页表都是保存在内存中的，CPU在运行不同的进程时，都会调取对应的<strong>一级页表基地址</strong>到 MMU 的基地址寄存器，<br>接下来的转换过程便是 MMU 硬件来自动完成的过程。</p>
<p>在进程切换时，除了要修改页表基地址，一般情况下还要无效 TLB 和 Cache，具体情况需要根据硬件而定。</p>
<h1 id="内存的权限检查"><a href="#内存的权限检查" class="headerlink" title="内存的权限检查"></a>内存的权限检查</h1><p>MMU通过读取页描述符中的对应位来确定当前的访问是否具有对应的权限。</p>
<p>内存的访问权限检查可以概括为以下两点：</p>
<ol>
<li>“域”决定是否对某块内存进行权限检查</li>
<li>“AP”决定如何对某块内存进行权限检查</li>
</ol>
<p>在Linux中，可以抽象为以下两种权限：</p>
<ol>
<li>是否对该处内存具有RWX权限</li>
<li>此处内存是仅仅内核态(管理者模式)能够访问，还是内核态和用户态(用户模式)都可以访问</li>
</ol>
<h1 id="TLB的作用"><a href="#TLB的作用" class="headerlink" title="TLB的作用"></a>TLB的作用</h1><p>转译查找缓存(Translation Lookaside Buffers, TLB)就是部分页表的一个快速缓存(类似于cache)，避免每次MMU都要从主存中获取页表内容。</p>
<p>当CPU发出一个虚拟地址时，MMU首先访问TLB，如果TLB中含有对应的描述符，则直接利用此描述符进行转换和权限检查。否则MMU<br>访问主存中的页表进行转换和权限检查，并将这次获取的描述符放入TLB，以便下次使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用TLB需要保证TLB与主存的一致性，在启动MMU之前需要使无效整个TLB，启动后再打开此功能。</span><br></pre></td></tr></table></figure>

<h1 id="Linux-中的页表"><a href="#Linux-中的页表" class="headerlink" title="Linux 中的页表"></a>Linux 中的页表</h1><p>Linux 默认使用 3 级页表，以更好的节省页表对内存的消耗（尤其是 64 位处理器），其 3 级页表称作：</p>
<ul>
<li><p>页总目录PGD（Page Global Directory）</p>
</li>
<li><p>页中间目录PMD（Page Middle Derectory）</p>
</li>
<li><p>页表PT（Page Table）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
        <category>mm</category>
        <category>hardware</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下进程的创建</title>
    <url>/2024/09/02/linux_process_create/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<p>Linux 创建进程是基于 COW 实现的，现在再来深入一下。</p>
<span id="more"></span>

<h1 id="为什么需要-COW-技术"><a href="#为什么需要-COW-技术" class="headerlink" title="为什么需要 COW 技术"></a>为什么需要 COW 技术</h1><p>由于基于 COW 技术，fork() 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。</p>
<p>假设子进程运行和父进程一样的代码，那么只有在子进程写内存时才会真正的进行对应部分页表映射，这样：</p>
<ol>
<li>将传统 fork() 整个拷贝的开销均摊到了平时的操作中，降低了时间复杂度</li>
<li>极有可能子进程仅仅写一小部分内存，这样降低了物理内存的占用</li>
</ol>
<p>假设子进程启动后会运行 <code>exec()</code> 执行其他的可执行代码，那么就避免传统 fork() 大量拷贝所做的无用功。</p>
<h1 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h1><p>fork(),vfork(),__clone() 库函数调用实际上都是根据需要传入一些列的参数给 <code>clone()</code> ，在内核中由 <code>clone()</code> 去调用 <code>_do_fork()</code> :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">,*  Ok, this is the main fork-routine.</span></span><br><span class="line"><span class="comment">,*</span></span><br><span class="line"><span class="comment">,* It copies the process, and if successful kick-starts</span></span><br><span class="line"><span class="comment">,* it and waits for it to finish using the VM if required.</span></span><br><span class="line"><span class="comment">,*</span></span><br><span class="line"><span class="comment">,* args-&gt;exit_signal is expected to be checked for sanity by the caller.</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="keyword">long</span> _do_fork(struct kernel_clone_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    u64 clone_flags = args-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Determine whether and which event to report to ptracer.  When</span></span><br><span class="line"><span class="comment">     * called from kernel_thread or CLONE_UNTRACED is explicitly</span></span><br><span class="line"><span class="comment">     * requested, no event is reported; otherwise, report if the event</span></span><br><span class="line"><span class="comment">     * for the type of forking is enabled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">        trace = PTRACE_EVENT_VFORK;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (args-&gt;exit_signal != SIGCHLD)</span><br><span class="line">        trace = PTRACE_EVENT_CLONE;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">        trace = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制父进程的资源</span></span><br><span class="line">    p = copy_process(<span class="literal">NULL</span>, trace, NUMA_NO_NODE, args);</span><br><span class="line">    add_latent_entropy();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">      <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do this prior waking up the new thread - the thread pointer</span></span><br><span class="line"><span class="comment">     * might get invalid after that point, if the thread exits quickly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    trace_sched_process_fork(current, p);</span><br><span class="line"></span><br><span class="line">    pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">    nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">      put_user(nr, args-&gt;parent_tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">      p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">      init_completion(&amp;vfork);</span><br><span class="line">      get_task_struct(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* forking complete and child started to run, tell ptracer */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">      ptrace_event_pid(trace, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">        ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>copy_process</code> 在复制父进程资源时，执行了如下流程：</p>
<ul>
<li><code>dup_task_struct()</code> : 为新进程创建内核栈、thread_info、task_struct。<ul>
<li>它们的值与父进程相同，那么它们的描述符也是一样的</li>
</ul>
</li>
<li><code>task_rlimit()</code> : 检测新创建子进程后，当前用户所拥有的进程数目没有超出限制</li>
<li>子进程初始化自己的 task_struct，使得与父进程区别开来</li>
<li>拷贝父进程指向的文件、地址空间、信号处理等</li>
<li><code>alloc_pid()</code> : 为新进程分配有效的 PID</li>
<li>返回新申请的 task_struct</li>
</ul>
<h1 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h1><p>vfork() 相比 fork() 而言就是不拷贝父进程的页表，这样 vfork() 与父进程共享内存空间，就相当于一个线程了。</p>
<p>一般使用 vfork() 后会立即调用 exec() 来读取新的代码。这在性能上的节约相比 fork() 后再使用 exec() 也高不了多少。</p>
<p>但有一个特性：vfork() 之后父进程被阻塞，直到子进程调用 exit() 或执行 exec()。</p>
<p>也就是说，vfork() 在执行 exec() 之后父进程才执行，这可以保证父子进程之间的同步关系。</p>
<p>vfork() 调用相比 fork() 调用在参数中多了一些标记：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(vfork)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> =</span> &#123;</span><br><span class="line">                                     .flags        = CLONE_VFORK | CLONE_VM,</span><br><span class="line">                                     .exit_signal    = SIGCHLD,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _do_fork(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是 <code>CLONE_VFORK</code> 这个标记使得父进程会等待子进程退出或完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">    init_completion(&amp;vfork);</span><br><span class="line">    get_task_struct(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">      ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><p>线程对内核来讲也是会分配一个 task_struct，只不过这个结构会与其进程共享内存等资源，但在调度算法上并没有区别对待。</p>
<p>在用户空间使用 <code>pthread_create()</code>= 创建线程时，实际上是调用了 clone() 函数并传入一些参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">,* cloning flags:</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CSIGNAL        0x000000ff    <span class="comment">/* signal mask to be sent at exit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VM    0x00000100    <span class="comment">/* set if VM shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FS    0x00000200    <span class="comment">/* set if fs info shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_FILES    0x00000400    <span class="comment">/* set if open files shared between processes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SIGHAND    0x00000800    <span class="comment">/* set if signal handlers and blocked signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PIDFD    0x00001000    <span class="comment">/* set if a pidfd should be placed in parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PTRACE    0x00002000    <span class="comment">/* set if we want to let tracing continue on the child too */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_VFORK    0x00004000    <span class="comment">/* set if the parent wants the child to wake it up on mm_release */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT    0x00008000    <span class="comment">/* set if we want to have the same parent as the cloner */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_THREAD    0x00010000    <span class="comment">/* Same thread group? */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNS    0x00020000    <span class="comment">/* New mount namespace group */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SYSVSEM    0x00040000    <span class="comment">/* share system V SEM_UNDO semantics */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_SETTLS    0x00080000    <span class="comment">/* create a new TLS for the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_PARENT_SETTID    0x00100000    <span class="comment">/* set the TID in the parent */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_CLEARTID    0x00200000    <span class="comment">/* clear the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_DETACHED        0x00400000    <span class="comment">/* Unused, ignored */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_UNTRACED        0x00800000    <span class="comment">/* set if the tracing process can&#x27;t force CLONE_PTRACE on this clone */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_CHILD_SETTID    0x01000000    <span class="comment">/* set the TID in the child */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWCGROUP        0x02000000    <span class="comment">/* New cgroup namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUTS        0x04000000    <span class="comment">/* New utsname namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWIPC        0x08000000    <span class="comment">/* New ipc namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWUSER        0x10000000    <span class="comment">/* New user namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWPID        0x20000000    <span class="comment">/* New pid namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_NEWNET        0x40000000    <span class="comment">/* New network namespace */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLONE_IO        0x80000000    <span class="comment">/* Clone io context */</span></span></span><br><span class="line"></span><br><span class="line">clone(..., CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, ...);</span><br></pre></td></tr></table></figure>

<p>同理，内核线程的创建也会分配一个 task_struct，只是与用户空间请求创建的线程有 1 点不同：内核线程所谓的地址空间就是内核空间，它们只在内核空间运行。</p>
<ul>
<li>在调度方面来讲，内核线程并不天生比用户请求的线程高贵，大家都是同等的被调度，都可以设置各自的调度策略和优先级。</li>
</ul>
<p>与用户空间相对应最为相似的内核线程创建便是 <code>kthread_run</code> 宏，可以看到也是返回了一个 task_struct。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* kthread_run - create and wake a thread.</span></span><br><span class="line"><span class="comment">* @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment">* @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment">* @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Description: Convenient wrapper for kthread_create() followed by</span></span><br><span class="line"><span class="comment">* wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> kthread_run(threadfn, data, namefmt, ...)                 \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">    struct task_struct *__k                                       \</span></span><br><span class="line"><span class="meta">    = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (!IS_ERR(__k))                                             \</span></span><br><span class="line"><span class="meta">    wake_up_process(__k);                                       \</span></span><br><span class="line"><span class="meta">    __k;                                                          \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>终止内核线程便可以通过其返回的 task_struct 指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthread_stop</span><span class="params">(struct task_struct *k)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="进程的终结"><a href="#进程的终结" class="headerlink" title="进程的终结"></a>进程的终结</h1><p>进程的终结是通过内核 <code>do_exit()</code> 函数来完成的，其步骤如下：</p>
<ol>
<li><code>exit_signals()</code> 将 task_struct 中的标志成员设置为 <code>PF_EXITING</code></li>
<li>删除任意内核定时器，确保没有定时器在排队，也没有定时器处理程序在运行</li>
<li>如果进程记账功能是开启的，调用 <code>acct_update_integrals()</code> 输出记账信息</li>
<li><code>exit_mm()</code> 释放进程占用的 mm_struct，如果没有别的进程使用它，就彻底释放它们</li>
<li><code>exit_sem()</code> 释放信号量</li>
<li><code>exit_shm()</code> 释放共享内存</li>
<li><code>exit_files()，exit_fs()</code> 递减文件描述符和文件系统引用计数，如果计数值降为 0，那么就释放资源。</li>
<li>将退出码存入 task_struct 的 exit_code 成员，用于父进程检索退出原因</li>
<li><code>exit_notify()</code> 通知父进程，并将当前进程设置为 <code>EXIT_ZOMBIE</code> 僵死状态。</li>
<li><code>do_task_dead()</code> 切换到新的进程。</li>
</ol>
<p>在调用 <code>exit_notify()</code> 通知父进程外，还需要为此进程的子进程找到新的父进程，其会执行 <code>forget_original_parent()</code> ,<br>然后会调用 <code>find_new_reaper</code> 为子进程找到新的父进程，其搜寻的先后顺序是：</p>
<ol>
<li>在当前线程组内找个一个线程作为父进程</li>
<li>如果不行，就看哪个进程将其设置为了 subreaper 属性，如果有就将其作为父进程</li>
<li>如果还是不行，就将 init 进程设置为父进程</li>
</ol>
<p>经过上面步骤以后，该进程还保有内核栈、thread_info 和 task_struct 结构，用于向父进程提供信息。</p>
<p>在父进程通过 wait 类系统调用获取到该进程的退出状态后，进程剩余的内存也就被释放，归还给系统了。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>process</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下进程和线程的基本概念及操作</title>
    <url>/2024/08/31/linux_process_hello/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>首先需要明确的是：进程是资源分配的基本单位，线程是调度的基本单位。同一进程里的线程之间共享进程的资源。</p>
<h2 id="进程的表示"><a href="#进程的表示" class="headerlink" title="进程的表示"></a>进程的表示</h2><p>在Linux内核中，使用结构体(PCB) <code>task_struct</code> （位于 include/linux/sched.h）来表明一个进程，其中不仅包括了此进程的资源，还有其状态、优先级等参数。</p>
<p>此结构体中就包含了内存资源、文件系统路径、打开的文件资源等：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> users;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//指定了根路径以及当前路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Open file table structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * read mostly part</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;</span><br><span class="line">    <span class="keyword">bool</span> resize_in_progress;</span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> resize_wait;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * written part on a separate cache line in SMP</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> file_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> next_fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> close_on_exec_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> open_fds_init[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> full_fds_bits_init[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储打开的文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="进程的限制"><a href="#进程的限制" class="headerlink" title="进程的限制"></a>进程的限制</h2><p>系统中可以创建的进程总数是有限的，同理单个用户可以创建的进程数也是有限的。</p>
<ul>
<li>用户可以使用 <code>ulimit -u</code> 查看限制的进程数，也可以使用 <code>getrlimit(),setrlimit()</code> 来得到或设置资源</li>
<li>在<code>/proc/sys/kernel/pid_max</code>中表示了整个系统的进程限制</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getrlimit(RLIMIT_NPROC, &amp;rl) != <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not get the limit of process!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rl.rlim_cur == RLIM_INFINITY) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the maximum number of process is unlimit!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The limit number of process is %lu, and the hardware maxinum number of process is %lu\n&quot;</span>,</span><br><span class="line">           rl.rlim_cur, rl.rlim_max);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fork-bomb"><a href="#fork-bomb" class="headerlink" title="fork bomb"></a>fork bomb</h3><p>由于系统的进程是有限的，如果无限制的创建进程，那最终将导致进程被耗光，也就相当于系统资源被消耗完而出现系统死掉的现象。</p>
<blockquote>
<p> <a href="https://en.wikipedia.org/wiki/Fork_bomb">fork bomb</a> 就是基于这个原理做出来的。</p>
</blockquote>
<h3 id="android-提权漏洞"><a href="#android-提权漏洞" class="headerlink" title="android 提权漏洞"></a>android 提权漏洞</h3><p><a href="https://blog.csdn.net/feglass/article/details/46403501">提权漏洞</a> 就是因为pid会被恶意消耗完，而代码没有检查自己降权成功而导致的root权限问题。</p>
<h2 id="进程的链接"><a href="#进程的链接" class="headerlink" title="进程的链接"></a>进程的链接</h2><p>Linux内核以三种数据结构来链接进程PCB：</p>
<ul>
<li>链表 ： 用于遍历所有进程</li>
<li>树 ： 用于查看进程的继承关系<ul>
<li>使用命令 <code>pstree</code> 可以查看进程的树形结构</li>
</ul>
</li>
<li>哈希表 ： 用于快速查找出进程</li>
</ul>
<h2 id="进程的树形结构"><a href="#进程的树形结构" class="headerlink" title="进程的树形结构"></a>进程的树形结构</h2><p>进程是以树的形式创建的，也是基于这个关系使得父进程可以监控子进程。</p>
<ul>
<li>当子进程意外退出后，父进程可以获取其退出的原因并且重新启动它。</li>
</ul>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--basic/linux_process_life_cycle.jpg?raw=true"><br><strong>注意：</strong></p>
<ol>
<li>Linux的调度算法仅针对就绪态和运行态的调度!</li>
<li>内核以 <code>task_struct</code> 为单位进行调度!</li>
</ol>
<h3 id="理解僵死态"><a href="#理解僵死态" class="headerlink" title="理解僵死态"></a>理解僵死态</h3><p>僵死态就是进程已经退出， <strong>其占有的资源已经被释放，但父进程还没有清理其PCB时的一个状态</strong>。</p>
<p>当父进程清理子进程PCB后(通过 <code>waitpid</code> 实现)，那么对于该进程的所有痕迹都被清除了。</p>
<ul>
<li>只要进程一退出，其所占有的所有资源都被释放了，所以不用担心代码里面动态申请的内存还未来得及释放</li>
<li>如果父进程没有清理子进程，那么其最后的PCB就代表它的尸体存在。<ul>
<li>可以通过 <code>ps -aux</code> 命令来查看其状态。</li>
</ul>
</li>
</ul>
<p>可以通过以下代码来理解：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_CHILD_PID 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CLEAR_CHILD_PID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, i get child pid is %d\n&quot;</span>, child_pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">            <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                    WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到:</p>
<ul>
<li>当父进程使用 <code>waitpid()</code> 时，外部使用 <code>kill</code> 命令后，使用 <code>ps -aux</code> 看不到子进程的任何痕迹</li>
<li>当父进程没有使用 <code>waitpid()</code> 来清除子进程的僵死态时，使用 <code>ps -aux</code> 看到其状态是 <code>Z+</code> 。<ul>
<li>当父进程被终止后，其僵死态也消失了。</li>
</ul>
</li>
</ul>
<h3 id="理解内存泄露"><a href="#理解内存泄露" class="headerlink" title="理解内存泄露"></a>理解内存泄露</h3><p>根据上面对僵死态的理解，可以知道 <strong>只要进程退出，就会释放其所占的资源，也就没有所谓的内存泄露</strong></p>
<p>内存泄露指的是： <strong>在进程运行时</strong>其所占用的内存随着时间的推移在震荡的上升。</p>
<ul>
<li>正常的进程所占用的内存应该是在一个平均值周围震荡。</li>
</ul>
<h3 id="理解停止态"><a href="#理解停止态" class="headerlink" title="理解停止态"></a>理解停止态</h3><p>停止态用于 <strong>主动暂停进程</strong>，有点类似于给这个进程打了一个断点（此进程已经不占用CPU资源）。在需要其运行的时候，又可以让其继续运行。</p>
<ul>
<li><p>睡眠是进程没有获取到资源而 <strong>主动让出CPU</strong></p>
</li>
<li><p>在shell中可以使用 <code>Ctrl + Z</code> 来让一个进程进入停止状态，使用 <code>fg</code> 来让其再次前台运行， <code>bg</code> 进入后台运行</p>
<ul>
<li>也可以使用 <code>cpulimit</code> 命令来限制某个进程的利用率，其内部就是在让进程间歇性的进入停止态以控制其CPU利用率</li>
</ul>
</li>
</ul>
<h3 id="理解睡眠"><a href="#理解睡眠" class="headerlink" title="理解睡眠"></a>理解睡眠</h3><p>当一个进程在等待资源时便会进入睡眠态，一般情况下都会设置为浅度睡眠，只有在读写块设备这种情况才会深度睡眠。</p>
<p>睡眠的底层实现，是将 <code>task_struct</code> 放入等待队列中，然后在接收到信号或资源可用来唤醒此队列中的一个进程。</p>
<p>如下面的示例代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globalfifo_dev</span> *<span class="title">dev</span> =</span> container_of(filp-&gt;private_data,</span><br><span class="line">    struct globalfifo_dev, miscdev);</span><br><span class="line"></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (dev-&gt;current_len == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">        ret = -ERESTARTSYS;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;dev-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()的作用是在一个进程的基础上为其分裂出一个子进程，其内部是为子进程单独分配了一个 <code>task_struct</code> 的PCB。</p>
<p>此时两个进程分别通过fork()来返回，父进程中fork()返回子进程的pid，子进程中的fork()返回0。</p>
<h3 id="父进程与子进程资源-gt-fork"><a href="#父进程与子进程资源-gt-fork" class="headerlink" title="父进程与子进程资源-&gt;fork()"></a>父进程与子进程资源-&gt;fork()</h3><p>当父进程通过 fork() 创建子进程时，子进程除了拥有一个PCB外，也具有与父进程 <strong>一样的资源</strong> （内存、文件系统、文件、信号等）。</p>
<p>在接下来的过程中，父子进程可以分别单独的修改自己的资源，二者并不会冲突。 </p>
<p>在实现逻辑的过程中，<strong>内存资源</strong>的分离是基于 <strong>具有MMU支持的COW技术</strong> 来实现的。</p>
<ul>
<li>在 fork() 前，内存资源是可读可写的</li>
<li>在 fork() 后二者的内存资源都 <strong>变为只读</strong> 的，此时父子进程对应内存的虚拟地址和物理地址都是一致的</li>
<li>父或子进程的其中一个修改内存时，便会触发MMU的 pagefault</li>
<li>然后内核会为此进程访问的内存重新申请页表，让其对应到另一个物理地址</li>
<li>最后父子进程虽然虚拟地址一样，但它们对应的物理地址就不一样了，并且它们的内存资源权限又恢复为可读可写了</li>
<li>最终此进程的内存修改才正式生效（Linux 会修改 PC 指针重新到写的那部分代码，这次写才会有效）</li>
</ul>
<p>所有在内存分离时，最开始的操作是比较耗时的！</p>
<p>验证内存分离的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> val = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;fork() failed!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: val = %d\n&quot;</span>, val);</span><br><span class="line">        val *= <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: val = %d\n&quot;</span>, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, val  = %d\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父进程与子进程资源-gt-vfork"><a href="#父进程与子进程资源-gt-vfork" class="headerlink" title="父进程与子进程资源 -&gt; vfork()"></a>父进程与子进程资源 -&gt; vfork()</h3><p>当硬件中没有MMU支持时，父进程通过vfork()来创建子进程，子进程拥有一个新的PCB，此时二者是具有 <strong>完全一样的内存资源（但文件系统、文件、信号等资源是分离的）</strong> ，且 <strong>无法完成内存分离</strong> 。</p>
<ul>
<li>所以，无论是父还是子修改了内存，这些修改对于另一方是可见的</li>
<li>如果子进程没有退出，父进程是无法运行的。</li>
</ul>
<h3 id="父进程与子进程资源-gt-clone"><a href="#父进程与子进程资源-gt-clone" class="headerlink" title="父进程与子进程资源 -&gt; clone()"></a>父进程与子进程资源 -&gt; clone()</h3><p>父进程通过clone()来创建子进程，子进程拥有一个新PCB，此时二者是具有 <strong>完全一样的所有资源，也就是共享所有资源</strong> ， 那就是一个线程了!</p>
<ul>
<li>子进程的资源指针直接指向父进程的资源</li>
<li>pthread_create()的底层就是由clone()所支持的</li>
</ul>
<h2 id="孤儿"><a href="#孤儿" class="headerlink" title="孤儿"></a>孤儿</h2><h3 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLEAR_CHILD_PID 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process, my pid is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;check parent pid...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;My parent pid is %d\n&quot;</span>, getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CLEAR_CHILD_PID</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is parent process, i get child pid is %d\n&quot;</span>, child_pid);</span><br><span class="line">        <span class="keyword">if</span>(waitpid(child_pid, &amp;status, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">            <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                    WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码查看，当kill掉父进程以后，子进程的 parent pid 会变为另外一个进程的pid。</p>
<ul>
<li>此父进程有可能是init进程，也可能是具有subreaper属性的进程。<ul>
<li>这要根据子进程是否挂接在各自的链表中<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--basic/orphan.jpg?raw=true"><h3 id="subreaper"><a href="#subreaper" class="headerlink" title="subreaper"></a>subreaper</h3></li>
</ul>
</li>
</ul>
<p>subrepaer 是在3.4后引入的，当将进程设置为 repaer 时需要注意wait子进程，以回收它的PCB。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get sig_handler = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;wait signal failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">        <span class="keyword">if</span>(WCOREDUMP(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not to be a subreaper!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;childl-&gt; %d parent pid is %d\n&quot;</span>,getpid(), getppid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(signal(SIGCHLD,sig_handler) == SIG_ERR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;wait signal error:&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="根进程"><a href="#根进程" class="headerlink" title="根进程"></a>根进程</h2><p>Linux在启动的过程会创建进程0，此进程0会创建init进程1，此后所有的进程都是挂接在init进程下的。</p>
<p>进程0在完成创建init进程后，会设置自己的优先级为最低，也就是将自己退化成了idle进程。<br>当其他进程都不占有CPU时，idle进程会运行，并将CPU置为低功耗模式。<br>当接收到中断后，如果有其他进程调度便又会将CPU让给其他进程。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>由上面的 <code>clone()</code> 可以看出：在Linux中创建线程实际上在内核也会位置分配一个 <code>task_struct</code> ，但它们的资源都指向同一个地址。<br>而 <code>task_struct</code> 中具有pid，这样在创建线程的同时也创建了多个pid。</p>
<h2 id="tgid"><a href="#tgid" class="headerlink" title="tgid"></a>tgid</h2><p>为了符合操作系统中关于线程的要求：一个进程中的多个线程所访问的pid都是一致的。</p>
<p>Linux内核使用 TGID(thread group ID)，来使得上层调用 <code>getpid()</code> 时获取的pid，都是最初此进程的pid，而其他的pid被掩盖了。</p>
<ul>
<li>可以在shell中访问 <code>/proc/[pid]/task/</code> 中看到几个被掩盖的pid<ul>
<li>也可以使用 <code>top -H</code> 来查看各个线程对应的Pid</li>
</ul>
</li>
<li>在编程时，使用系统调用 <code>syscall(__NR_gettid)</code> 来获取自己真实的pid</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> syscall(__NR_gettid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, thread pid = %d, thread_self = %d\n&quot;</span>,</span><br><span class="line">       getpid(), gettid(), pthread_self());</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"><span class="comment">//pthread_self() 是用户空间库所创建的ID，内核不可见</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, man thread pid = %d,man thread_self = %d\n&quot;</span>,</span><br><span class="line">       getpid(), gettid(), pthread_self());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
        <category>memory</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下进程和线程的调度</title>
    <url>/2024/09/02/linux_process_schedule/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>kernel version</th>
<th>arch</th>
</tr>
</thead>
<tbody><tr>
<td>v5.4.0</td>
<td>arm32</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="调度的目标"><a href="#调度的目标" class="headerlink" title="调度的目标"></a>调度的目标</h1><h2 id="吞吐和响应"><a href="#吞吐和响应" class="headerlink" title="吞吐和响应"></a>吞吐和响应</h2><p>操作系统的主要目标是要在保持高的吞吐量的同时还要有高的响应速度。</p>
<ul>
<li>吞吐量：整个系统在单位时间内做的有用功越多，吞吐量就越大<ul>
<li>进程的切换，代码的局部搬移都属于无用功</li>
</ul>
</li>
<li>响应速度：当发生切换请求时，要以尽量快的完成切换，哪怕牺牲其他的任务为代价<ul>
<li>这其中就包含了进程环境切换，以及代码局部性处理的搬移（cache miss 而导致的需要读内存）</li>
</ul>
</li>
</ul>
<p>毫无疑问，这两个指标是互相矛盾的，只有选择一个侧重点。</p>
<p>在内核配置的 <code>Kernel Features -&gt; Preemption Model</code> 中可以选择调度策略：</p>
<ul>
<li>No Forced Preemption(Server): 不能被抢占</li>
<li>Voluntary Kernel Preemption(Desktop): kernel自愿让出</li>
<li>Preemptible Kernle(Low-Latency Desktop):kernel可以被抢占(嵌入式系统一般都选择此项)</li>
</ul>
<h2 id="CPU与I-O平衡"><a href="#CPU与I-O平衡" class="headerlink" title="CPU与I/O平衡"></a>CPU与I/O平衡</h2><p>进程分为两种类型：</p>
<ul>
<li>I/O消耗型：更多的是I/O操作，对CPU的占用率低<ul>
<li>在I/O操作时，一般进程会阻塞的等待，CPU会被让出去</li>
</ul>
</li>
<li>CPU消耗型：更多的操作是在CPU的运算上</li>
</ul>
<p>当以红蓝图来显示CPU的消耗如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5BPS%5D/%5BWhat%5Dps--schedule/cpu_io.jpg?raw=true"><br>由此可以看出，在调度时，我们应该 <strong>优先调度I/O消耗型</strong> ，以让其尽快响应。</p>
<ul>
<li>I/O型的进程消耗时间绝大部分是在I/O设备上，所以其对CPU的性能要求并不高<ul>
<li>ARM通过big.LITTLE架构来组成4小核和4大核，让小核来做I/O任务，大核做运算任务<ul>
<li>虽然小核处理能力弱，但其功耗低。而且从宏观上看其性能依然是8核的性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>Linux的优先级从0~139，数值越低优先级越高。</p>
<ul>
<li>在内核中，设置的值便与优先级一一对应</li>
<li>在用户空间中，设置的RT值通过公式 <code>99 - priority</code> 来计算真实的优先级(所以在用户空间中，设置的RT值越小优先级反而越低)，而设置的 NICE 值则又是<code>100+20+priority</code>而得到的（这种情况也是 NICE 值越低，优先级越高）。</li>
</ul>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><p>其中0<del>99使用RT策略，100</del>139使用NICE策略。</p>
<ul>
<li>关于内核、用户空间、top命令中的优先级显示，参看<a href="https://mp.weixin.qq.com/s/44Gamu17Vkl77OGV2KkRmQ">此文章</a></li>
</ul>
<table>
<thead>
<tr>
<th>用户</th>
<th>内核</th>
<th>Top</th>
</tr>
</thead>
<tbody><tr>
<td>RT 50</td>
<td>49(99-RT)</td>
<td>-51(-1-RT)</td>
</tr>
<tr>
<td>RT99</td>
<td>0</td>
<td>rt</td>
</tr>
<tr>
<td>NICE 5</td>
<td>125</td>
<td>25(20+NICE)</td>
</tr>
</tbody></table>
<p>通过上表也可以看出：</p>
<ol>
<li><p>使用 Top 看到的优先级，数值越小优先级越高</p>
</li>
<li><p>使用 Top 看到的优先级如果小于0 或 rt 则是 RT 策略，否则就是 NICE 策略</p>
</li>
</ol>
<h3 id="RT策略"><a href="#RT策略" class="headerlink" title="RT策略"></a>RT策略</h3><p>RT策略分为 SCHED_FIFO 和 SCHED_RR:</p>
<ul>
<li>SCHED_FIFO:霸占CPU，除非自己主动让出<ul>
<li>在不同优先级的情况下，高优先级的对象先运行， <strong>并且要等待此对象主动释放CPU，其他对象才能依次运行</strong><ul>
<li>在同优先级下，也是要等待主动释放，所以才称为FIFO(first in first out)策略</li>
</ul>
</li>
</ul>
</li>
<li>SCHED_RR:高优先级的对象先运行，同等优先级轮转<ul>
<li>在不同优先级的情况下，高优先级的对象先运行， <strong>并且要等待此对象主动释放CPU，其他对象才能依次运行</strong><ul>
<li>在同优先级下，对象轮转运行，所以才称为RR(round-robin)策略</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看出，SCHED_FIFO和SCHED_RR在不同优先级的情况下策略是一样的，区别是在同等优先级的情况下。</p>
<h3 id="NICE策略"><a href="#NICE策略" class="headerlink" title="NICE策略"></a>NICE策略</h3><ul>
<li>不同优先级下，高优先级 <strong>可以抢占低优先级运行</strong> ，但 <strong>高优先级不会霸占CPU，而是会被调度器主动剥夺CPU使用权用于低优先级运行</strong><ul>
<li>虽然是轮转运行，但高优先级可以获得的时间片比低优先级要多</li>
</ul>
</li>
<li>nice值在 -20 ~ +19 对应优先级的 100 ~ 139<ul>
<li>nice值越高其优先级越低，运行的时间片越少</li>
<li>默认新建进程的Nice值为0</li>
</ul>
</li>
</ul>
<h2 id="策略补丁"><a href="#策略补丁" class="headerlink" title="策略补丁"></a>策略补丁</h2><h3 id="RT门限"><a href="#RT门限" class="headerlink" title="RT门限"></a>RT门限</h3><p>根据RT策略来讲如果 RT 里面的线程没有主动让出CPU，那 NICE 策略的进程就无法运行。<br>为此，linux 在 2.6 以后设置了 RT 门限，以设置 RT 策略的进程只能在一个周期里运行确定的时间。</p>
<p>在 <code>/proc/sys/kernel/</code> 下的 <code>sched_rt_period_us,sched_rt_runtime_us</code> 来设置 period和runtime。</p>
<ul>
<li>也就是是在period的时间里，RT进程只能最多运行runtime时间。</li>
<li>可以通过命令 <code>chrt -f -a -p &lt;prio&gt; &lt;pid&gt;</code> 来改变进程的优先级</li>
</ul>
<h3 id="CFS-完全公平调度-NICE策略优化"><a href="#CFS-完全公平调度-NICE策略优化" class="headerlink" title="CFS :完全公平调度(NICE策略优化)"></a>CFS :完全公平调度(NICE策略优化)</h3><ul>
<li><p>NICE策略下的进程都具有一个权重</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ,* Nice levels are multiplicative, with a gentle 10% change for every</span></span><br><span class="line"><span class="comment"> ,* nice level changed. I.e. when a CPU-bound task goes from nice 0 to</span></span><br><span class="line"><span class="comment"> ,* nice 1, it will get ~10% less CPU time than another CPU-bound task</span></span><br><span class="line"><span class="comment"> ,* that remained on nice 0.</span></span><br><span class="line"><span class="comment"> ,*</span></span><br><span class="line"><span class="comment"> ,* The &quot;10% effect&quot; is relative and cumulative: from _any_ nice level,</span></span><br><span class="line"><span class="comment"> ,* if you go up 1 level, it&#x27;s -10% CPU usage, if you go down 1 level</span></span><br><span class="line"><span class="comment"> ,* it&#x27;s +10% CPU usage. (to achieve that we use a multiplier of 1.25.</span></span><br><span class="line"><span class="comment"> ,* If a task goes up by ~10% and another task goes down by ~10% then</span></span><br><span class="line"><span class="comment"> ,* the relative distance between them is ~25%.)</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>虚拟运行时间通过公式计算： <code>vtime = ptime * 1024 / weight</code> (NICE值越大，权重越小，虚拟运行时间越高)</p>
<ul>
<li>ptime : 实际运行时间</li>
<li>weight : 权重</li>
<li>1024: 对应NICE为0的权重</li>
</ul>
</li>
<li><p>将此虚拟运行时间挂在一颗红黑树上</p>
</li>
<li><p>linux首先运行红黑树上值最小的节点，当节点运行其ptime会继续增加</p>
<ul>
<li>所有随着时间推移，该节点将不会是最小的节点</li>
</ul>
</li>
</ul>
<p>基于以上这个逻辑， <strong>I/O型的ptime就比较小，所有它就会被优先调度</strong> ，这就满足了优先运行I/O型进程的初衷。</p>
<ul>
<li>可以通过 <code>renice -n &lt;nice_value&gt; -g &lt;pid&gt;</code> 来修改进程的nice值</li>
<li>可以通过 <code>nice &lt;nice_value&gt; &lt;process&gt;</code> 来启动一个进程并设置nice</li>
</ul>
<h2 id="设置API"><a href="#设置API" class="headerlink" title="设置API"></a>设置API</h2><table>
<thead>
<tr>
<th>System Call</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>nice()</td>
<td>设置进程的nice值</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>设置调度策略</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>获取调度策略</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>设置RT策略优先级</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td>获取RT策略优先级</td>
</tr>
<tr>
<td>sched_get_priority_max()</td>
<td>得到RT策略最高优先级</td>
</tr>
<tr>
<td>sched_get_priority_min()</td>
<td>得到RT策略最低优先级</td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>得到RR策略时间片参数</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>设置进程关系</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>获取进程关系</td>
</tr>
<tr>
<td>sched_yield()</td>
<td>主动让出CPU</td>
</tr>
</tbody></table>
<p>在pthread库支持下，又封装了一次系统调用，通过 <code>pthread_attr_xxxx</code> 来实现设置。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>负载均衡是指：尽量让CPU各个核心都均摊处理任务，不能出现1核有难7核围观的情况。</p>
<ul>
<li>每个核的处理调度都是以 <code>task_struct</code> 为基本单位的</li>
<li>核与核之间是通过 push 和 pull 操作来实现任务分配的，在实际运行时一个 <code>task_struct</code> 会在多个核间动态转移<ul>
<li>通过命令 <code>cat /proc/cpuinfo</code> 获取cpu相关具体信息</li>
<li>也可以在 <code>top</code> 命令中按下 <code>1</code> 来获取cpu负载</li>
</ul>
</li>
</ul>
<h2 id="关于运行时间"><a href="#关于运行时间" class="headerlink" title="关于运行时间"></a>关于运行时间</h2><p>一个代码运行时间包括：</p>
<ul>
<li>real time: 用户所感受的运行时间</li>
<li>user time: 代码在user space 运行时间</li>
<li>kernel time: 代码陷入内核的运行时间，也就是计算通过系统调用所花费的时间</li>
</ul>
<p>可以使用命令 <code>time &lt;exec&gt;</code> 来统计一个程序的时间，这个时间的计算依据是根据 <strong>资源为单位</strong> 计算的：</p>
<ul>
<li>当一个程序 fork() 出一个进程，那么一共就有两个进程，对应两个 <code>task_struct</code> 的同时也对应两份资源，所以通过 time 来计算的real time 和 user time 是一致的</li>
<li>当一个程序 create() 出一个线程，那么一共对应两个 <code>task_struct</code> 但只有一份资源，那么在多核上跑时，通过 time 计算的 user time 是 real time 的两倍</li>
<li>在路径 <code>/proc/&lt;pid&gt;/task/</code> 下可以查看具体的 <code>task_struct</code> 信息</li>
</ul>
<p>通过以下实例可以验证:</p>
<ul>
<li>共享一份资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> syscall(__NR_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, thread pid = %d, thread_self = %d\n&quot;</span>,</span><br><span class="line">         getpid(), gettid(), pthread_self());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">  <span class="comment">//pthread_self() 是用户空间库所创建的ID，内核不可见</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;process pid = %d, man thread pid = %d,man thread_self = %d\n&quot;</span>,</span><br><span class="line">         getpid(), gettid(), pthread_self());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      perror(<span class="string">&quot;create thread failed:&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个 <code>task_struct</code> 对应一份资源</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get sig_handler = %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;wait signal failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated normally!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exit status = %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child was terminated by signal %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WCOREDUMP</span></span><br><span class="line">        <span class="keyword">if</span>(WCOREDUMP(status)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The child produced a core dump!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFSTOPPED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The chiild process was stopped by delivery of a signal %d\n&quot;</span>,</span><br><span class="line">                WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFCONTINUED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child process was resumed by delivery of SIGCONT\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not to be a subreaper!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> child_pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(child_pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//printf(&quot;childl-&gt; %d parent pid is %d\n&quot;,getpid(), getppid());</span></span><br><span class="line">            <span class="comment">//sleep(1);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//if(signal(SIGCHLD,sig_handler) == SIG_ERR)</span></span><br><span class="line">            <span class="comment">//&#123;</span></span><br><span class="line">                <span class="comment">//perror(&quot;wait signal error:&quot;);</span></span><br><span class="line">            <span class="comment">//&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同策略下的负载均衡"><a href="#不同策略下的负载均衡" class="headerlink" title="不同策略下的负载均衡"></a>不同策略下的负载均衡</h2><ul>
<li>RT策略下的负载均衡就按照其优先级依次分配到几个核心</li>
<li>NICE策略下的负载均衡是在系统tick时动态分配到核心上</li>
<li>当一个核心空闲时，也会主动pull任务</li>
<li>当有上层调用，最终新建了 <code>task_struct</code> 后，内核也会根据CPU的负载情况主动分配到空闲核心上</li>
</ul>
<h2 id="主动修改负载"><a href="#主动修改负载" class="headerlink" title="主动修改负载"></a>主动修改负载</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setaffinity_np</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getaffinity_np</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">size_t</span> cpusetsize, <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_setaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> cpusetsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *mask)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sched_getaffinity</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">size_t</span> cpusetsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">cpu_set_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mask 即为CPU掩码，比如03(16进制)，代表运行于核心0和核心1</span></span><br><span class="line">taskset -a -p &lt;mask&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h2 id="中断负载均衡"><a href="#中断负载均衡" class="headerlink" title="中断负载均衡"></a>中断负载均衡</h2><p>除了 <code>task_struct</code> 任务会消耗CPU外，中断和软中断的执行也会消耗CPU，为了能够让多个核能够处理中断所以有时需要做负载均衡(比如将网卡多个fifo均衡到多个核上以提高吞吐量)。</p>
<ul>
<li>其优先级为 中断 &gt; 软中断 &gt; 调度</li>
<li>通过命令 <code>cat /proc/interrupts</code> 可以查看硬中断全局概览</li>
<li>通过命令 <code>cat /proc/softirqs</code> 查看软中断概览</li>
<li>通过命令 <code>cat /proc/irq/&lt;num&gt;/smp_affinity</code> 查看对应 <num> 中断目前的均衡设置，然后以 <code>echo &lt;mask&gt; /proc/irq/&lt;num&gt;/smp_affinity</code> 来设置新的值</li>
</ul>
<h3 id="软中断负载均衡"><a href="#软中断负载均衡" class="headerlink" title="软中断负载均衡"></a>软中断负载均衡</h3><p>当一个核中断发生后，其对应的软中断也必须由此核调用，但如果处理量太大则可以将此核的处理任务再次均分到其他核以快速处理提高吞吐量。</p>
<ul>
<li>在网络上通过 <code>echo &lt;mask&gt; &gt; /sys/class/net/eth1/queues/rx-0/rps_cpus</code> 来打开此功能</li>
</ul>
<h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>将 <code>task_struct</code> 进行分组为多个 group，Linux 再以 group 为单位对其进行均衡。</p>
<h3 id="创建group操作流程"><a href="#创建group操作流程" class="headerlink" title="创建group操作流程"></a>创建group操作流程</h3><ul>
<li>进入路径 <code>/sys/fs/cgroup/</code></li>
<li>新建组名文件 <code>mkdir &lt;group name&gt;</code><ul>
<li>进入文件后发现有 <code>cgroup.procs</code> 用于存储组类成员的pid， <code>cpu.max</code> 存储此组的权重<ul>
<li>修改权重可以修改此组的CPU占用率,越大占用率越高</li>
</ul>
</li>
</ul>
</li>
<li>使用 <code>echo &lt;pid&gt; &gt; cgroup.procs</code> 加入成员到组</li>
</ul>
<h3 id="限制cpu使用率-配额-操作流程"><a href="#限制cpu使用率-配额-操作流程" class="headerlink" title="限制cpu使用率(配额)操作流程"></a>限制cpu使用率(配额)操作流程</h3><ul>
<li>基于上面的基础上，进入此组，先 <code>cat cpu.cfs_periods_us</code> 查看设置的 period 时间</li>
<li>然后 <code>echo &lt;value&gt; cpu.cfs_quota_us</code> 来设置其在period中的占空比<ul>
<li>当 <code>cfs_quota_us</code> 的值大于 <code>cfs_periods_us</code> 时，内核会分配多于的CPU来处理此任务</li>
</ul>
</li>
</ul>
<h1 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h1><p>硬实时操作系统需要：无论当前系统在做什么事，调度器 <strong>都可以在要求的时间内完成任务切换，这一切都是可以预期的。</strong></p>
<p>而Linux内核在中断，软中断，spinlock等情况下都无法完成调度切换，这个时间是无法预期的，所以其是一个软实时系统。<br>也就是说，系统只保证尽快的完成切换而已。</p>
<h2 id="实时补丁"><a href="#实时补丁" class="headerlink" title="实时补丁"></a>实时补丁</h2><p>在 <a href="https://wiki.linuxfoundation.org/realtime/start"></a> 给出了实时补丁（需要手动merge到代码中,然后在menuconfig 中配置）。</p>
<p>此补丁做了如下改动：</p>
<ul>
<li>将中断和软中断都修改为线程</li>
<li>将不可调度锁修改为可调度锁</li>
</ul>
<p>这样系统在任何时候都是可以调度的，以此来提高切换速度。</p>
<blockquote>
<p>但由于 Linux 存在内存申请的 Lazy 机制等等，所以仍然无法做到硬实时。</p>
</blockquote>
<p>替代方案： rt thread + linux</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>process</category>
        <category>overview</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>输出 Linux 中所有的 task</title>
    <url>/2023/04/11/linux_ps_chore_print_tasks/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>进程或线程对于 kernel 来说，都是 <code>task_struct</code> 结构体来描述，所以这里指的是输出所有的 task。</p>
<span id="more"></span>

<h1 id="task-struct-的双向链表"><a href="#task-struct-的双向链表" class="headerlink" title="task_struct 的双向链表"></a>task_struct 的双向链表</h1><p>还是继续来看，<code>task_struct</code>的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">     * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>        <span class="title">thread_info</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>            rt_priority;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>        <span class="title">sched_info</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">tasks</span>;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体中就具有双向链表节点<code>tasks</code>，所以通过它就将所有的 task 都链接了起来，那么问题来了：这个链表的头在哪里？</p>
<h2 id="0-号进程"><a href="#0-号进程" class="headerlink" title="0 号进程"></a>0 号进程</h2><p>Linux kernel 会以全局变量的方式创建 0 号进程”swapper“，该进程在启动后才会去创建 PID 为 1 的”init”进程，所以该进程便是所有 tasks 的头节点，可以通过它来遍历所有的 task。</p>
<blockquote>
<p>由于是全局变量，所以该进程是不能被杀死或停止的。</p>
</blockquote>
<p><code>swapper</code>进程的精妙之处在于，它的优先级是最低的，当整个系统没有 task 在运行时，便会运行该进程，该进程可以管理一些资源，且可以让 CPU 进入浅度睡眠以省电。</p>
<p>0 号进程的定义位于<code>init/init_task.c</code>中。</p>
<h2 id="内核模块来输出-tasks"><a href="#内核模块来输出-tasks" class="headerlink" title="内核模块来输出 tasks"></a>内核模块来输出 tasks</h2><p>模块代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pr_fmt(fmt) <span class="meta-string">&quot;tasks:&quot;</span> fmt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_tasks</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">current_entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>* <span class="title">next_entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;pid = %d, name = %s\n&quot;</span>,</span><br><span class="line">            task_pid_nr(&amp;init_task),</span><br><span class="line">            init_task.comm);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(current_entry, next_entry,</span><br><span class="line">                             &amp;(init_task.tasks), tasks) &#123;</span><br><span class="line">        pr_info(<span class="string">&quot;pid = %d, name = %s\n&quot;</span>,</span><br><span class="line">                task_pid_nr(current_entry),</span><br><span class="line">                current_entry-&gt;comm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">tasks_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    print_tasks();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(tasks_init);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">tasks_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pr_info(<span class="string">&quot;Bye!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(tasks_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kcmetercec &lt;kcmeter.cec@gmail.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple demo which prints tasks&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;print tasks demo&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;ver1.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对应的 Makefile 如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KVERS = <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line"></span><br><span class="line">obj-m += print_tasks.o</span><br><span class="line"></span><br><span class="line">EXTRA_CFLAGS = -std=gnu99</span><br><span class="line"></span><br><span class="line"><span class="section">build: kernel_modules</span></span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(KVERS)</span>/build M=<span class="variable">$(CURDIR)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C /lib/modules/<span class="variable">$(KVERS)</span>/build M=<span class="variable">$(CURDIR)</span> clean</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>前面以双向链表的方式组织 tasks 是为了遍历所有的 tasks，而如果要快速通过 PID 来找到一个 tasks 就不能用遍历的方式，而是要使用哈希表的方式，这样时间复杂度就由 O（n）降低到了 O（1）。</p>
<h2 id="认识-Linux-中的哈希表实现"><a href="#认识-Linux-中的哈希表实现" class="headerlink" title="认识 Linux 中的哈希表实现"></a>认识 Linux 中的哈希表实现</h2><h3 id="节点的定义"><a href="#节点的定义" class="headerlink" title="节点的定义"></a>节点的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>头节点只包含一个指针，是为了在哈希表中节省内存（相比双向链表而言）。</p>
<h3 id="节点的定义和初始化"><a href="#节点的定义和初始化" class="headerlink" title="节点的定义和初始化"></a>节点的定义和初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLIST_HEAD(name) struct hlist_head name = &#123;  .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">INIT_HLIST_NODE</span><span class="params">(struct hlist_node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	h-&gt;pprev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_unhashed - Has node been removed from list and reinitialized?</span></span><br><span class="line"><span class="comment"> * @h: Node to be checked</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Not that not all removal functions will leave a node in unhashed</span></span><br><span class="line"><span class="comment"> * state.  For example, hlist_nulls_del_init_rcu() does leave the</span></span><br><span class="line"><span class="comment"> * node in unhashed state, but hlist_nulls_del() does not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_unhashed</span><span class="params">(<span class="keyword">const</span> struct hlist_node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !h-&gt;pprev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_unhashed_lockless - Version of hlist_unhashed for lockless use</span></span><br><span class="line"><span class="comment"> * @h: Node to be checked</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This variant of hlist_unhashed() must be used in lockless contexts</span></span><br><span class="line"><span class="comment"> * to avoid potential load-tearing.  The READ_ONCE() is paired with the</span></span><br><span class="line"><span class="comment"> * various WRITE_ONCE() in hlist helpers that are defined below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_unhashed_lockless</span><span class="params">(<span class="keyword">const</span> struct hlist_node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !READ_ONCE(h-&gt;pprev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当头节点指向的下一个节点为 NULL 时，则代表当前链表为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hlist_empty</span><span class="params">(<span class="keyword">const</span> struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !READ_ONCE(h-&gt;first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除当前节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __hlist_del(struct hlist_node *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(*pprev, next);</span><br><span class="line">	<span class="keyword">if</span> (next)</span><br><span class="line">		WRITE_ONCE(next-&gt;pprev, pprev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前节点，并将后继和前驱节点设定为特定值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_del</span><span class="params">(struct hlist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	__hlist_del(n);</span><br><span class="line">	n-&gt;next = LIST_POISON1;</span><br><span class="line">	n-&gt;pprev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前节点，并将后继和前驱节点设定为 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_del_init</span><span class="params">(struct hlist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!hlist_unhashed(n)) &#123;</span><br><span class="line">		__hlist_del(n);</span><br><span class="line">		INIT_HLIST_NODE(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点 n 增加到头节点 h 的后面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_head</span><span class="params">(struct hlist_node *n, struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span> =</span> h-&gt;first;</span><br><span class="line">	WRITE_ONCE(n-&gt;next, first);</span><br><span class="line">	<span class="keyword">if</span> (first)</span><br><span class="line">		WRITE_ONCE(first-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">	WRITE_ONCE(h-&gt;first, n);</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, &amp;h-&gt;first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点 n 增加到节点 next 的前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_before</span><span class="params">(struct hlist_node *n,</span></span></span><br><span class="line"><span class="params"><span class="function">				    struct hlist_node *next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, next-&gt;pprev);</span><br><span class="line">	WRITE_ONCE(n-&gt;next, next);</span><br><span class="line">	WRITE_ONCE(next-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">	WRITE_ONCE(*(n-&gt;pprev), n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将节点 n 增加到节点 prev 的后面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_behind</span><span class="params">(struct hlist_node *n,</span></span></span><br><span class="line"><span class="params"><span class="function">				    struct hlist_node *prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WRITE_ONCE(n-&gt;next, prev-&gt;next);</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, n);</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, &amp;prev-&gt;next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n-&gt;next)</span><br><span class="line">		WRITE_ONCE(n-&gt;next-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个环形的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_add_fake</span><span class="params">(struct hlist_node *n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查是否是环形链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">hlist_fake</span><span class="params">(struct hlist_node *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h-&gt;pprev == &amp;h-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查当前链表是否只含有一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">hlist_is_singular_node</span><span class="params">(struct hlist_node *n, struct hlist_head *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !n-&gt;next &amp;&amp; n-&gt;pprev == &amp;h-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表 old 移动到新的 new</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">hlist_move_list</span><span class="params">(struct hlist_head *old,</span></span></span><br><span class="line"><span class="params"><span class="function">				   struct hlist_head *<span class="keyword">new</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">new</span>-&gt;first = old-&gt;first;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">new</span>-&gt;first)</span><br><span class="line">		<span class="keyword">new</span>-&gt;first-&gt;pprev = &amp;<span class="keyword">new</span>-&gt;first;</span><br><span class="line">	old-&gt;first = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据节点反推结构体地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr,type,member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正向遍历链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;first; pos ; pos = pos-&gt;next)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方式正向遍历链表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_safe(pos, n, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;first; pos &amp;&amp; (&#123; n = pos-&gt;next; 1; &#125;); \</span></span><br><span class="line"><span class="meta">	     pos = n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全的方式获取结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_entry_safe(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	(&#123; typeof(ptr) ____ptr = (ptr); \</span></span><br><span class="line"><span class="meta">	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全的方式从头遍历结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry(pos, head, member)				\</span></span><br><span class="line"><span class="meta">	for (pos = hlist_entry_safe((head)-&gt;first, typeof(*(pos)), member);\</span></span><br><span class="line"><span class="meta">	     pos;							\</span></span><br><span class="line"><span class="meta">	     pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全的方式继续遍历结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_continue(pos, member)			\</span></span><br><span class="line"><span class="meta">	for (pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member);\</span></span><br><span class="line"><span class="meta">	     pos;							\</span></span><br><span class="line"><span class="meta">	     pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全的方式从当前位置遍历结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_from(pos, member)				\</span></span><br><span class="line"><span class="meta">	for (; pos;							\</span></span><br><span class="line"><span class="meta">	     pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 安全的方式继续遍历结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hlist_for_each_entry_safe(pos, n, head, member) 		\</span></span><br><span class="line"><span class="meta">	for (pos = hlist_entry_safe((head)-&gt;first, typeof(*pos), member);\</span></span><br><span class="line"><span class="meta">	     pos &amp;&amp; (&#123; n = pos-&gt;member.next; 1; &#125;);			\</span></span><br><span class="line"><span class="meta">	     pos = hlist_entry_safe(n, typeof(*pos), member))</span></span><br></pre></td></tr></table></figure>

<p>以上的 hlist 其实是一个单链表，为了高效操作插入和删除的操作，所以使用了 <code>pprev</code> 二级指针来指向前一个节点。</p>
<h2 id="根据-pid-找到-task-struct"><a href="#根据-pid-找到-task-struct" class="headerlink" title="根据 pid 找到 task_struct"></a>根据 pid 找到 task_struct</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct task_struct *<span class="title">find_get_task_by_vpid</span><span class="params">(<span class="keyword">pid_t</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	task = find_task_by_vpid(nr);</span><br><span class="line">	<span class="keyword">if</span> (task)</span><br><span class="line">		get_task_struct(task);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be called under rcu_read_lock().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct task_struct *<span class="title">find_task_by_pid_ns</span><span class="params">(<span class="keyword">pid_t</span> nr, struct pid_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	RCU_LOCKDEP_WARN(!rcu_read_lock_held(),</span><br><span class="line">			 <span class="string">&quot;find_task_by_pid_ns() needs rcu_read_lock() protection&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct task_struct *<span class="title">find_task_by_vpid</span><span class="params">(<span class="keyword">pid_t</span> vnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> find_task_by_pid_ns(vnr, task_active_pid_ns(current));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct pid *<span class="title">find_pid_ns</span><span class="params">(<span class="keyword">int</span> nr, struct pid_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> idr_find(&amp;ns-&gt;idr, nr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * idr_find() - Return pointer for given ID.</span></span><br><span class="line"><span class="comment"> * @idr: IDR handle.</span></span><br><span class="line"><span class="comment"> * @id: Pointer ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Looks up the pointer associated with this ID.  A %NULL pointer may</span></span><br><span class="line"><span class="comment"> * indicate that @id is not allocated or that the %NULL pointer was</span></span><br><span class="line"><span class="comment"> * associated with this ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can be called under rcu_read_lock(), given that the leaf</span></span><br><span class="line"><span class="comment"> * pointers lifetimes are correctly managed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: The pointer associated with this ID.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">idr_find</span><span class="params">(<span class="keyword">const</span> struct idr *idr, <span class="keyword">unsigned</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> radix_tree_lookup(&amp;idr-&gt;idr_rt, id - idr-&gt;idr_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct task_struct *<span class="title">pid_task</span><span class="params">(struct pid *pid, <span class="keyword">enum</span> pid_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">result</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (pid) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">		first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">					      lockdep_tasklist_lock_is_held());</span><br><span class="line">		<span class="keyword">if</span> (first)</span><br><span class="line">			result = hlist_entry(first, struct task_struct, pid_links[(type)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>linux</category>
        <category>ps</category>
        <category>chore</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 进程的名称最长是多少个字符？</title>
    <url>/2023/04/10/linux_ps_chore_process_name_length/</url>
    <content><![CDATA[<ul>
<li>kernel version : v6.1.x (lts)</li>
</ul>
<p>Linux 在运行可执行文件时，可以显示多长的进程名称？</p>
<span id="more"></span>

<h1 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h1><p>进程或线程在内核中都由结构体<code>task_struct</code>来表示，在该结构体中具有一个字符串数组用于存放该运行进程的名称：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Define the task command name length as enum, then it can be visible to</span></span><br><span class="line"><span class="comment"> * BPF programs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	TASK_COMM_LEN = <span class="number">16</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * executable name, excluding path.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">	 * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">	 * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出：进程的最长名字是 15 个字符（最后再加上一个字符串结束符）。</p>
<h2 id="proc-lt-pid-gt-stat"><a href="#proc-lt-pid-gt-stat" class="headerlink" title="/proc/&lt;pid&gt;/stat"></a>/proc/&lt;pid&gt;/stat</h2><p>每个进程的名称可以在<code>/proc/&lt;pid&gt;/stat</code>和<code>/proc/&lt;pid&gt;/status</code>中查看。</p>
<p>比如现在随便写一个测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并给它取一个较长的名字：<code>0123456789abcdefABCDEF</code>，包含除结束字符串外的 22 个字符。</p>
<p>启动该进程后，在<code>/proc</code>对应的文件夹下查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~$ cat /proc/1317/stat</span><br><span class="line">1317 (0123456789abcde) S 1226 1317 ......</span><br><span class="line">cec@box:~$ cat /proc/1317/status</span><br><span class="line">Name:   0123456789abcde</span><br><span class="line">Umask:  0002</span><br><span class="line">State:  S (sleeping)</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>那可以看到，其名称的确是被限制到了 15 个字符。</p>
<h2 id="对应内核的代码"><a href="#对应内核的代码" class="headerlink" title="对应内核的代码"></a>对应内核的代码</h2><p>当对<code>/proc/&lt;pid&gt;/stat</code>和<code>/proc/&lt;pid&gt;/status</code>进行查看时，对应代码位于<code>/fs/proc/array.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">proc_pid_status</span><span class="params">(struct seq_file *m, struct pid_namespace *ns,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct pid *pid, struct task_struct *task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> get_task_mm(task);</span><br><span class="line"></span><br><span class="line">	seq_puts(m, <span class="string">&quot;Name:\t&quot;</span>);</span><br><span class="line">	proc_task_name(m, task, <span class="literal">true</span>);</span><br><span class="line">	seq_putc(m, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_task_stat</span><span class="params">(struct seq_file *m, struct pid_namespace *ns,</span></span></span><br><span class="line"><span class="params"><span class="function">			struct pid *pid, struct task_struct *task, <span class="keyword">int</span> whole)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">	seq_put_decimal_ull(m, <span class="string">&quot;&quot;</span>, pid_nr_ns(pid, ns));</span><br><span class="line">	seq_puts(m, <span class="string">&quot; (&quot;</span>);</span><br><span class="line">	proc_task_name(m, task, <span class="literal">false</span>);</span><br><span class="line">	seq_puts(m, <span class="string">&quot;) &quot;</span>);</span><br><span class="line">	seq_putc(m, state);</span><br><span class="line">	seq_put_decimal_ll(m, <span class="string">&quot; &quot;</span>, ppid);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 task 名称，都是调用的 <code>proc_task_name</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *__get_task_comm(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_size, struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">	task_lock(tsk);</span><br><span class="line">	<span class="comment">/* Always NUL terminated and zero-padded */</span></span><br><span class="line">	strscpy_pad(buf, tsk-&gt;comm, buf_size);</span><br><span class="line">	task_unlock(tsk);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__get_task_comm);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_task_name</span><span class="params">(struct seq_file *m, struct task_struct *p, <span class="keyword">bool</span> escape)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> tcomm[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Test before PF_KTHREAD because all workqueue worker threads are</span></span><br><span class="line"><span class="comment">	 * kernel threads.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; PF_WQ_WORKER)</span><br><span class="line">		wq_worker_comm(tcomm, <span class="keyword">sizeof</span>(tcomm), p);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;flags &amp; PF_KTHREAD)</span><br><span class="line">		get_kthread_comm(tcomm, <span class="keyword">sizeof</span>(tcomm), p);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__get_task_comm(tcomm, <span class="keyword">sizeof</span>(tcomm), p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (escape)</span><br><span class="line">		seq_escape_str(m, tcomm, ESCAPE_SPACE | ESCAPE_SPECIAL, <span class="string">&quot;\n\\&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		seq_printf(m, <span class="string">&quot;%.64s&quot;</span>, tcomm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于用户态进程并不属于工作队列和内核线程，所以就会运行函数<code>__get_task_comm</code>，该函数就是将 task_struct 中的 comm 数组的内容拷贝过来，这样就能够一一对应了。</p>
<h1 id="全名称显示"><a href="#全名称显示" class="headerlink" title="全名称显示"></a>全名称显示</h1><p>当使用 <code>ps -aux</code> 时，却可以显示完整的进程名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~$ ps -aux | grep &quot;0123456&quot;</span><br><span class="line">cec         1317  0.0  0.0   5888  1512 pts/1    S+   22:45   0:00 ./0123456789abcdefABCDEF</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这是因为，<code>ps -aux</code>获取名称是通过<code>/proc/&lt;pid&gt;/cmdline</code>来获取的，也就是说它显示的是进程的输入命令行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@box:~$ cat /proc/1317/cmdline</span><br><span class="line">./0123456789abcdefABCDEF</span><br></pre></td></tr></table></figure>

<p>该文件对应的内核代码是位于<code>/fs/proc/base.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">proc_pid_cmdline_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">				     <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="keyword">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	BUG_ON(*pos &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	tsk = get_proc_task(file_inode(file));</span><br><span class="line">	<span class="keyword">if</span> (!tsk)</span><br><span class="line">		<span class="keyword">return</span> -ESRCH;</span><br><span class="line">	ret = get_task_cmdline(tsk, buf, count, pos);</span><br><span class="line">	put_task_struct(tsk);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		*pos += ret;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数最终会从<code>mm_struct</code>中获取 arg list，而<code>mm_struct</code>又是<code>task_struct</code>的成员，所以说<code>task_struct</code>封装了进程的资源。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>ps</category>
        <category>chore</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IIO库操作</title>
    <url>/2023/09/03/linux_usage_iio_overview/</url>
    <content><![CDATA[<p><a href="https://wiki.analog.com/resources/tools-software/linux-software/libiio">libiio</a> 提供了统一的接口来操作位于iio子系统下的设备。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Boperations%5D/%5BWhat%5DLinux--IIO/libiio_struct.jpg?raw=true"><br>由上图可以看出:</p>
<ul>
<li>libiio 具有 <code>local backend</code> 和 <code>network backend</code> 两种后端<ul>
<li><code>local backend</code> 用于与本地的 <code>sysfs</code> 中的文件交互</li>
<li><code>network backend</code> 通过 <code>iiod</code> 服务器运作，可以通过网络连接将测试数据发送到其他平台上</li>
</ul>
</li>
</ul>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ul>
<li>在<a href="https://github.com/analogdevicesinc/libiio">github</a> 下载最新稳定版代码</li>
<li>编写工具链配置文件 <code>toolchain.cmake</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定编译器设定文件以及取消掉不必要的编译选项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一次cmake生成基础文件</span></span><br><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake ../</span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二次才是重新配置选项</span></span><br><span class="line">cmake-gui -DCMAKE_TOOLCHAIN_FILE=../toolchain.cmake ../</span><br><span class="line"></span><br><span class="line">make all</span><br><span class="line">make install DESTDIR=/home/cec/iio</span><br></pre></td></tr></table></figure>

<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>参考<a href="http://analogdevicesinc.github.io/libiio/">官方手册</a> 做简单整理。</p>
<p><a href="./api_struct.jpg"></a></p>
<p>API由以下4部分组成:</p>
<ul>
<li>iio_channel : 代表一个设备上的一个通道</li>
<li>iio_device : 代表一个具体的设备实例，一个 <code>iio_device</code> 可能会包含多个 <code>iio_channel</code></li>
<li>iio_buffer : 针对设备的缓存，一个 <code>iio_device</code> 对应一个 <code>iio_buffer</code></li>
<li>iio_context : 可能包含多个 <code>iio_device</code> </li>
</ul>
<p>iio 设备在sysfs中可以读写的文件名为: <code>&lt;in/out&gt;_&lt;channel&gt;_&lt;attr&gt;</code> 。</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><h3 id="创建与消除"><a href="#创建与消除" class="headerlink" title="创建与消除"></a>创建与消除</h3><p>一般一个进程创建一个 <code>iio_context</code> 对象，以代表对 IIO 设备的打包使用：</p>
<ul>
<li>在创建 <code>context</code> 就会遍历 <code>iio:device</code> 以集合设备</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief Create a context from local IIO devices (Linux only)</span></span><br><span class="line"><span class="comment"> ,* @Returns</span></span><br><span class="line"><span class="comment"> ,* On success, A pointer to an iio_context structure</span></span><br><span class="line"><span class="comment"> ,* On failure, NULL is returned and errno is set appropriately</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">__api struct iio_context* <span class="title">iio_create_local_context</span> 	<span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief Create a context from the network.</span></span><br><span class="line"><span class="comment"> ,* @param host:	Hostname, IPv4 or IPv6 address where the IIO Daemon is running </span></span><br><span class="line"><span class="comment"> ,* @Returns</span></span><br><span class="line"><span class="comment"> ,* On success, a pointer to an iio_context structure</span></span><br><span class="line"><span class="comment"> ,* On failure, NULL is returned and errno is set appropriately</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">__api struct iio_context* <span class="title">iio_create_network_context</span> 	<span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *  host)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief Destroy the given context. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">__api <span class="keyword">void</span> <span class="title">iio_context_destroy</span> 	<span class="params">(struct iio_context * ctx)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="与设备的关系"><a href="#与设备的关系" class="headerlink" title="与设备的关系"></a>与设备的关系</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief Enumerate the devices found in the given context.</span></span><br><span class="line"><span class="comment"> ,* @ret : The number of devices found </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iio_context_get_devices_count</span> 	<span class="params">(<span class="keyword">const</span> struct iio_context * ctx)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief Get the device present at the given index.</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_device* <span class="title">iio_context_get_device</span> 	<span class="params">(<span class="keyword">const</span> struct iio_context *  	ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">unsigned</span> <span class="keyword">int</span>  	index)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief :Retrieve the device ID (e.g. iio:device0) </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_device_get_id</span> 	<span class="params">(<span class="keyword">const</span> struct iio_device *  	dev)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Retrieve the device name (e.g. xadc) </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_device_get_name</span> 	<span class="params">(<span class="keyword">const</span> struct iio_device *  	dev)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Try to find a device structure by its name of ID.</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_device* <span class="title">iio_context_find_device</span> 	<span class="params">(<span class="keyword">const</span> struct iio_context *  	ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">const</span> <span class="keyword">char</span> *  	name)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h3><p>注意: <strong>两个channels可以具有相同的ID，分别代表输入和输出！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Enumerate the channels of the given device. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iio_device_get_channels_count</span> 	<span class="params">(<span class="keyword">const</span> struct iio_device *  	dev)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Get the channel present at the given index. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_channel* <span class="title">iio_device_get_channel</span> 	<span class="params">(<span class="keyword">const</span> struct iio_device *  	dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                <span class="keyword">unsigned</span> <span class="keyword">int</span>  	index)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Try to find a channel structure by its name of ID.</span></span><br><span class="line"><span class="comment"> ,* @param output:	True if the searched channel is output, False otherwise </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function">struct iio_channel* <span class="title">iio_device_find_channel</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_device *  	dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">const</span> <span class="keyword">char</span> *  	name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">bool</span>  	output</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  )</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Return True if the given channel is an output channel. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iio_channel_is_output</span> 	<span class="params">(<span class="keyword">const</span> struct iio_channel *  	chn)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Retrieve the channel ID (e.g. voltage0) </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_channel_get_id</span> 	<span class="params">(<span class="keyword">const</span> struct iio_channel * chn)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Retrieve the channel name (e.g. vccint) </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_channel_get_name</span> 	<span class="params">(<span class="keyword">const</span> struct iio_channel *  chn)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Enumerate the device-specific attributes of the given device. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iio_device_get_attrs_count</span><span class="params">(<span class="keyword">const</span> struct iio_device *  	dev)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Get the device-specific attribute present at the given index. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_device_get_attr</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_device *  	dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">unsigned</span> <span class="keyword">int</span>  	index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">iio_channel_get_attrs_count</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_channel *  chn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_channel_get_attr</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_channel *  	chn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">unsigned</span> <span class="keyword">int</span>  	index </span></span></span><br><span class="line"><span class="params"><span class="function">                                      )</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @brief : Try to find a device-specific attribute by its name. </span></span><br><span class="line"><span class="comment"> ,* @<span class="doctag">NOTE:</span> This function is useful to detect the presence of an attribute. It can also be used to retrieve the name of an attribute a * s a pointer to a static string from a dynamically allocated string. </span></span><br><span class="line"><span class="comment"> ,*/</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_device_find_attr</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_device *  	dev,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="keyword">const</span> <span class="keyword">char</span> *  	name </span></span></span><br><span class="line"><span class="params"><span class="function">                                      )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">iio_channel_find_attr</span> 	<span class="params">( 	<span class="keyword">const</span> struct iio_channel *  	chn,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">const</span> <span class="keyword">char</span> *  	name </span></span></span><br><span class="line"><span class="params"><span class="function">                                        )</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="参数的读写"><a href="#参数的读写" class="headerlink" title="参数的读写"></a>参数的读写</h2><ul>
<li>读取设备参数<ul>
<li>iio_device_attr_read()</li>
<li>iio_device_attr_read_all()</li>
<li>iio_device_attr_read_bool()</li>
<li>iio_device_attr_read_longlong()</li>
<li>iio_device_attr_read_double()</li>
</ul>
</li>
<li>读取通道参数<ul>
<li>iio_channel_attr_read()</li>
<li>iio_channel_attr_read_all()</li>
<li>iio_channel_attr_read_bool()</li>
<li>iio_channel_attr_read_longlong()</li>
<li>iio_channel_attr_read_double()</li>
</ul>
</li>
<li>读取调试参数:并不是每个设备都有debugfs<ul>
<li>iio_device_debug_attr_read()</li>
<li>iio_device_debug_attr_read_all()</li>
<li>iio_device_debug_attr_read_bool()</li>
<li>iio_device_debug_attr_read_longlong()</li>
<li>iio_device_debug_attr_read_double()</li>
<li>iio_device_get_debug_attrs_count() : 获取debug参数数目</li>
<li>iio_device_get_debug_attr(): 得到attr</li>
<li>iio_device_find_debug_attr(): 寻找attr</li>
</ul>
</li>
<li>写设备参数<ul>
<li>iio_device_attr_write()</li>
<li>iio_device_attr_write_all()</li>
<li>iio_device_attr_write_bool()</li>
<li>iio_device_attr_write_longlong()</li>
<li>iio_device_attr_write_double()</li>
</ul>
</li>
<li>写通道参数<ul>
<li>iio_channel_attr_write()</li>
<li>iio_channel_attr_write_all()</li>
<li>iio_channel_attr_write_bool()</li>
<li>iio_channel_attr_write_longlong()</li>
<li>iio_channel_attr_write_double()</li>
</ul>
</li>
<li>写调试参数:并不是每个设备都有debugfs<ul>
<li>iio_device_debug_attr_write()</li>
<li>iio_device_debug_attr_write_all()</li>
<li>iio_device_debug_attr_write_bool()</li>
<li>iio_device_debug_attr_write_longlong()</li>
<li>iio_device_debug_attr_write_double()</li>
</ul>
</li>
<li>寄存器的直接读写:并不是每个设备都有<ul>
<li>iio_device_reg_read()</li>
<li>iio_device_reg_write()</li>
</ul>
</li>
</ul>
<h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><ul>
<li>iio_device_is_trigger() : 检查设备是否可以使用触发</li>
<li>iio_device_get_trigger(): 是否已经绑定触发</li>
<li>iio_device_set_trigger(): 绑定触发或解绑</li>
</ul>
<h2 id="获取采样的值"><a href="#获取采样的值" class="headerlink" title="获取采样的值"></a>获取采样的值</h2><p>在 <code>libiio</code> 中使用 <code>iio_buffer</code> 来获取或设置设备的值。</p>
<ul>
<li>在使用buffer之前需要先使能或关闭对应的采样通道:<ul>
<li>iio_channel_enable()  / iio_channel_disable()</li>
<li>iio_channel_is_scan_element() : 检查此通道是否可用于buffer</li>
</ul>
</li>
<li>然后再创建buffer<ul>
<li> iio_device_create_buffer()</li>
<li> iio_buffer_destroy() : 不使用时关闭</li>
</ul>
</li>
<li>当为输入通道时，还需要刷新依次缓存<ul>
<li> iio_buffer_refill()</li>
</ul>
</li>
</ul>
<h3 id="缓存的操作"><a href="#缓存的操作" class="headerlink" title="缓存的操作"></a>缓存的操作</h3><ul>
<li>向缓存写数据:</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> iio_buf_size = iio_buffer_end(buffer) - iio_buffer_start(buffer);</span><br><span class="line"><span class="keyword">size_t</span> count = MAX(<span class="keyword">sizeof</span>(samples_buffer), iio_buf_size);</span><br><span class="line"><span class="built_in">memcpy</span>(iio_buffer_start(buffer), samples_buffer, count);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ,* @note : 当申请的缓存时环形队列时并且kernel中支持环形队列,缓存的值会自动更新到kernel</span></span><br><span class="line"><span class="comment"> ,* 否则上层需要使用 iio_buffer_push() 来主动发送缓存到kernel</span></span><br><span class="line"><span class="comment"> ,*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>回调: 当缓存读入数据或缓存发送时需要填入数据，都会触发回调</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sample_cb</span><span class="params">(<span class="keyword">const</span> struct iio_channel *chn, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> bytes, <span class="keyword">void</span> *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Use &quot;src&quot; to read or write a sample for this channel */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  iio_buffer_foreach_sample(buffer, sample_cb, <span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>循环的读写</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">void</span> *ptr = iio_buffer_first(buffer, channel);</span><br><span class="line">     ptr &lt; iio_buffer_end(buffer);</span><br><span class="line">     ptr += iio_buffer_step(buffer)) &#123;</span><br><span class="line">  <span class="comment">/* Use &quot;ptr&quot; to read or write a sample for this channel */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h2><p>使用 <code>iio_library_get_version()</code> 来获取版本号进行区分，以使用对应的功能。</p>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>基本思路如下:</p>
<ul>
<li>创建一个context</li>
<li>找寻设备</li>
<li>获取通道</li>
<li>进行读写</li>
</ul>
<p>以气压计 ms5611 为例:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_context</span> * <span class="title">context</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_device</span>  * <span class="title">baro</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_channel</span> * <span class="title">mb_temp</span>;</span></span><br><span class="line"></span><br><span class="line">context = iio_create_local_context();</span><br><span class="line">assert(context != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">baro = iio_context_find_device(context, <span class="string">&quot;ms5611&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(baro == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can not find ms5611!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ms5611 has %d channels\n&quot;</span>, iio_device_get_channels_count(baro));</span><br><span class="line">mb_temp = iio_device_find_channel(baro,</span><br><span class="line">                                         <span class="string">&quot;temp&quot;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> f_temp_val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(iio_channel_attr_read_double(mb_temp, <span class="string">&quot;input&quot;</span>, &amp;f_temp_val))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is = %f\n&quot;</span>, f_temp_val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
        <category>usage</category>
        <category>iio</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux framebuffer logo的显示</title>
    <url>/2025/02/27/logo/</url>
    <content><![CDATA[<p>整理logo显示的理论。</p>
<span id="more"></span>

<h1 id="logo的格式"><a href="#logo的格式" class="headerlink" title="logo的格式"></a>logo的格式</h1><h2 id="pnm-portable-any-map"><a href="#pnm-portable-any-map" class="headerlink" title="pnm(portable any map)"></a>pnm(portable any map)</h2><p>查看网上的说明，一般我们需要将事先准备好的 logo 图片转换为 pnm 格式，比如:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bmptopnm logo.bmp &gt; logo.pnm</span><br></pre></td></tr></table></figure>

<p>工具 <code>bmptopnm</code> 会根据bmp的分辨率转换为对应格式:</p>
<ul>
<li>当只有黑白色时，输出PBM格式</li>
<li>当有黑白灰时，输出PGM格式</li>
<li>其他情况会输出PPM格式</li>
</ul>
<p><strong>注意:</strong> 部分bmp图片含有带透明的 delta 部分，此时 <code>bmptopnm</code> 将会报错。</p>
<p>三种格式其实都大同小异，以可以显示彩色的ppm(Portable Pixel Map)为格式说明：</p>
<ol>
<li>开头是ASCII码 <code>P6</code> 以表示文件格式为 ppm，后面一般跟一个换行符</li>
<li>接着下一行是ASCII码表示的宽度和高度，中间以空白分隔，行尾加换行符</li>
<li>接着下一行是 <strong>原色的最大值</strong> ，以ASCII表示，最大为65536, 行尾加换行符</li>
<li>接着便是图像内容，以 <strong>二进制表示</strong> ， 从左到右，从上到下。<ul>
<li>每一个像素以rgb表示，其中的三原色分别占1或2字节</li>
</ul>
</li>
</ol>
<p>如下图所示:</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--frameBuffer/pic/pnm_vim.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BLinux%5D/%5Bdriver%5D/%5BWhat%5DLinux--frameBuffer/pic/pnm_hex.jpg?raw=true"></p>
<h2 id="颜色压缩和ASCII输出"><a href="#颜色压缩和ASCII输出" class="headerlink" title="颜色压缩和ASCII输出"></a>颜色压缩和ASCII输出</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnmquant 224 logo.pnm &gt; logo224.pnm</span><br></pre></td></tr></table></figure>

<p>此工具检查原始的pnm文件中颜色的种数，然后将其进行量化为仅有224种颜色的格式。</p>
<ul>
<li>为什么会是224种颜色? 猜测这个是linux内部存储配色表的大小限制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pnmtoplainpnm logo224.pnm &gt; logo_linux_clut224.ppm</span><br></pre></td></tr></table></figure>

<p>此工具将 224 种色的 pnm 图片转换为简易的 <code>plainppm</code> 。</p>
<p>plainppm格式比原先的ppm格式更易于阅读，不同之处在于:</p>
<ul>
<li>一个文件仅表示一张图片</li>
<li>图片标识由 <code>P6</code> 变为 <code>P3</code> </li>
<li>以ASCII的形式显示图片的内容（原来是二进制形式）</li>
<li>每个像素之间以空格分隔，一行不超过70个ASCII字符</li>
</ul>
<p>如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">P3</span><br><span class="line"><span class="meta">#</span><span class="bash"> feep.ppm</span></span><br><span class="line">4 4</span><br><span class="line">15</span><br><span class="line"> 0  0  0    0  0  0    0  0  0   15  0 15</span><br><span class="line"> 0  0  0    0 15  7    0  0  0    0  0  0</span><br><span class="line"> 0  0  0    0  0  0    0 15  7    0  0  0</span><br><span class="line">15  0 15    0  0  0    0  0  0    0  0  0</span><br></pre></td></tr></table></figure>

<h1 id="logo的生成"><a href="#logo的生成" class="headerlink" title="logo的生成"></a>logo的生成</h1><p>前面生成的 ppm 文件将会放在 <code>drivers/video/logo/</code> 文件夹下，此Makefile会在构建过程中调用工具 <code>pnmtologo</code> 进行转换。</p>
<p>工具源码位于 <code>scripts/pnmtologo.c</code> ，它会将生成对应名称的 c 文件，通过查看 build 目录下的文件可以看到输出文件格式。</p>
<ul>
<li>以伪彩色的形式保存图片，包含颜色索引、配色表、图片描述结构体。</li>
<li>索引中的值减去32就为颜色表中其对应的颜色。<ul>
<li><strong>对于224色来说，颜色表每3字节代表一个像素。</strong></li>
</ul>
</li>
</ul>
<p>此源码中有宏:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINUX_LOGO_COLORS 224</span></span><br></pre></td></tr></table></figure>

<p>这也佐证了为什么 linux 会限制使用 224 色作为 logo。</p>
<ul>
<li>如果要增加色彩的分辨率，增加此值即可。</li>
</ul>
<h1 id="logo的显示"><a href="#logo的显示" class="headerlink" title="logo的显示"></a>logo的显示</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>在进行logo显示前，需要 frambuffer 驱动加载且液晶已完成初始化。</p>
<p>选中以下选项:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Device Drivers -&gt; Graphics support -&gt; Bootup logo -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure>

<h2 id="刷图"><a href="#刷图" class="headerlink" title="刷图"></a>刷图</h2><p>进行刷新logo的核心函数就是 <code>fb_prepare_logo, fb_show_logo_line</code> .</p>
<p>按照上面编译后的格式，只需要通过索引减去32取颜色显示即可，但linux要兼容众多设备，需要考虑更多情况。<br>如果是为了简便，完全可以在使用 <code>fb_find_logo</code> 之后，便自己实现缓存的填充即可。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>driver</category>
        <category>framebuffer</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab 的选择与循环</title>
    <url>/2023/09/07/matlab_hello_if_loop/</url>
    <content><![CDATA[<p>认识 Matlab 中的选择和循环。</p>
<span id="more"></span>

<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h2><p>关系运算符与 c/c++ 大同小异，唯一需要注意的是不等于的运算符是 <code>~=</code>。</p>
<p>同样的，逻辑运算符中的非，也是<code>~</code>。</p>
<p>关于异或，需要使用函数<code>xor()</code>。</p>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if 条件表达式</span><br><span class="line">    语句</span><br><span class="line">else</span><br><span class="line">    语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if 条件1</span><br><span class="line">    语句1</span><br><span class="line">elseif 条件2</span><br><span class="line">    语句2</span><br><span class="line">elseif 条件3</span><br><span class="line">    语句3</span><br><span class="line">else</span><br><span class="line">    语句4</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">switch 表达式</span><br><span class="line">    case 情况1 表达式</span><br><span class="line">        语句1</span><br><span class="line">    case 情况2 表达式</span><br><span class="line">        语句2</span><br><span class="line">    case 情况3 表达式</span><br><span class="line">        语句3</span><br><span class="line">    otherwise</span><br><span class="line">        语句4</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>case 也可以把几种情况包含在一起：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">switch 表达式</span><br><span class="line">    case &#123;情况1 表达式, 情况2 表达式&#125;</span><br><span class="line">        语句1</span><br><span class="line">    case 情况3 表达式</span><br><span class="line">        语句3</span><br><span class="line">    otherwise</span><br><span class="line">        语句4</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="menu-函数"><a href="#menu-函数" class="headerlink" title="menu() 函数"></a><code>menu()</code> 函数</h2><p><code>menu</code> 函数显示带有多个选项按钮的图形窗口，供用户选择，返回选择的索引。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mypick = menu(<span class="string">&#x27;Pick a pizza&#x27;</span>, <span class="string">&#x27;Cheese&#x27;</span>, <span class="string">&#x27;Shroom&#x27;</span>, <span class="string">&#x27;Sausage&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="is-函数"><a href="#is-函数" class="headerlink" title="is 函数"></a><code>is</code> 函数</h2><p>is 相关函数用于判断内容是否为真，常常会与<code>if</code>语句使用：</p>
<ul>
<li><p><code>isletter()</code>：判断内容是否是字母</p>
</li>
<li><p><code>isempty()</code>：判断变量是否为空</p>
</li>
<li><p><code>iskeywork()</code>：名称是否是 MATLAB 关键词</p>
</li>
</ul>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for loopvar = range</span><br><span class="line">    语句</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>最简单的方式就是使用冒号运算来指定范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 : 5</span><br><span class="line">    fprintf(&#x27; %d\n&#x27;, i);</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">while 条件</span><br><span class="line">	语句</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>matlab</category>
        <category>hello</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Matlab</title>
    <url>/2023/09/03/matlab_hello_overview/</url>
    <content><![CDATA[<p>建立对 Matlab 的最基本的认识。</p>
<span id="more"></span>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>matlab 中的变量名和 c/c++ 一样，都是以字母开头，后跟字母、数值、下划线，同样会区分大小写。</p>
<blockquote>
<p>可以通过内置函数 <code>namelengthmax()</code> 来获取变量的最大长度。</p>
</blockquote>
<p>与变量相关的常用命令：</p>
<ul>
<li><code>who</code> : 显示当前已经定义了的变量名称</li>
<li><code>whos</code> : 显示当前已经定义了的变量的详细信息</li>
<li><code>clear</code> : 清除所有变量，也可以使用 <code>clear &lt;var_name&gt;</code> 来清除指定变量</li>
</ul>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="format-函数"><a href="#format-函数" class="headerlink" title="format 函数"></a>format 函数</h2><p><code>format</code> 命令可以指定表达式的输出格式，默认的输出小数位数为 4，相当于<code>format short</code>。</p>
<ul>
<li><p><code>format long</code> : 设置浮点数显示小数位数为 15 位</p>
</li>
<li><p><code>format short</code> : 设置浮点数显示小数位数为 4 位</p>
</li>
<li><p><code>format loose</code> : 命令行输出之间有空行</p>
</li>
<li><p><code>format compact</code> : 命令行输出之间没有空行</p>
</li>
</ul>
<h2 id="表达式续行"><a href="#表达式续行" class="headerlink" title="表达式续行"></a>表达式续行</h2><p>当表达式一行太长，可以在尾部输入 3 个或更多的点来延续到下一行。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Matlab 的运算符与 c/c++ 一致，但还有：</p>
<ul>
<li>\ : 反向除法，比如 5\10 = 2</li>
<li>^ : 幂运算</li>
</ul>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>Matlab 中的常量有：</p>
<ul>
<li>pi : 3.141592653…</li>
<li>i / j : 虚数</li>
<li>inf : 无穷大</li>
<li>NaN : 不是一个数</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>在 Matlab 中变量的类型被称为类（classes）。</p>
<ul>
<li>对于浮点数、实数有单精度（single）和双精度（double）</li>
<li>对于整数，有 int8,int16,int32 等</li>
<li>对于字符，就是 char 类型。<strong>字符和字符串都使用单引号</strong></li>
<li>逻辑类型使用 true/false 来表示</li>
</ul>
<p>以上类型基本上和 c/c++ 一致。</p>
<p>整数的类型可以通过函数 <code>intmin()</code> 和 <code>intmax()</code> 来查询。</p>
<p>默认的变量类型就是 <code>double</code>，有很多函数可以将值进行类型转换：</p>
<ul>
<li>int32(val) : 将值 val 的输出转为 int32 类型</li>
</ul>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>函数 <code>rand()</code> 用于产生 0 到 1 范围内的实数。</p>
<p>要产生一个范围从 low 到 high 的实数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">low = <span class="number">3</span>;</span><br><span class="line">high = <span class="number">5</span>;</span><br><span class="line">v = <span class="built_in">rand</span>() * (high - low) + low;</span><br></pre></td></tr></table></figure>

<p>要产生随机整数，一般配合 <code>round()</code> 函数使用来取整：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 产生 0 ~ 10 的整数</span></span><br><span class="line"><span class="built_in">round</span>(<span class="built_in">rand</span>() * <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h1 id="字符和编码"><a href="#字符和编码" class="headerlink" title="字符和编码"></a>字符和编码</h1><p>在 Matlab 中字符用<strong>单引号</strong>引用，同理也可以使用 <code>int32(&#39;a&#39;)</code> 这种方式对类型进行转换。</p>
<p>可以对字符串进行批量操作：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 将会得到 bcde</span></span><br><span class="line">char(<span class="string">&#x27;abcd&#x27;</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h1 id="向量和矩阵"><a href="#向量和矩阵" class="headerlink" title="向量和矩阵"></a>向量和矩阵</h1><p>向量和矩阵都是用来存储具有<strong>相同类型的</strong>值的集合。</p>
<p>向量可以是行向量和列向量，如果一个向量有 n 个元素，行向量就是 $1<em>n$，列向量就是$n</em>1$。相当于一维数组。</p>
<p>矩阵则是二维向量，是行向量和列向量的组合。相当于二维数组。</p>
<h2 id="创建及修改行向量"><a href="#创建及修改行向量" class="headerlink" title="创建及修改行向量"></a>创建及修改行向量</h2><p>最直接的方法是使用方括号创建，数值之间使用空格或逗号隔离：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">v = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>如果元素的值是有规律的，则可以使用冒号操作符：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 创建 1~5 的行向量，step = 1</span></span><br><span class="line">v = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line"><span class="comment">%% 创建 1~9 的行向量，step = 2</span></span><br><span class="line">v = <span class="number">1</span>:<span class="number">2</span>:<span class="number">9</span>;</span><br></pre></td></tr></table></figure>

<p><code>linspace()</code>函数也可以创建：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 创建 3~5 的行向量，共 5 个元素</span></span><br><span class="line">ls = <span class="built_in">linspace</span>(<span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>也可以使用已经存在的向量拼接为新的向量：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vv = [v vec];</span><br></pre></td></tr></table></figure>

<p>访问元素使用向量名加括号访问，括号中是元素索引（索引从 1 开始）：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = vv(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>同样也可以使用冒号来选择一个范围的索引：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = vv(<span class="number">3</span>:<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>还可以使用方括号包含索引的方式：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">v = vv([<span class="number">1</span> <span class="number">4</span> <span class="number">7</span>]);</span><br></pre></td></tr></table></figure>

<p>当然也可以对向量元素值进行更改：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vv(<span class="number">3</span>) = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>如果上述索引超出了原来的范围，则会对内容进行扩充。</p>
<p>可以使用空向量对元素进行删除：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vv(<span class="number">3</span>)=[];</span><br></pre></td></tr></table></figure>

<h2 id="创建列向量"><a href="#创建列向量" class="headerlink" title="创建列向量"></a>创建列向量</h2><p>创建列向量的直接方法是使用方括号中的分号将值分开：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>但由于它不能使用行向量的冒号操作符，并不那么方便。更为通用的办法是先创建行向量，然后通过矩阵转置来创建列向量：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">c = <span class="number">1</span>:<span class="number">4</span>;</span><br><span class="line">r = c&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="创建及修改矩阵"><a href="#创建及修改矩阵" class="headerlink" title="创建及修改矩阵"></a>创建及修改矩阵</h2><p>创建矩阵就是创建行列向量：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>不同行也可以用 enter 键来分隔：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>同样也可以使用冒号来迭代：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat = [<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>也可以通过函数 <code>rand()</code>创建随机数矩阵：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 创建 2 行 2 列的随机数矩阵，元素值在 0~1 范围内</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建 2 行 3 列的随机数矩阵，元素值在 0~1 范围内</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">2</span>， <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>还可以通过函数 <code>zeros</code>创建全 0 矩阵：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 3x3</span></span><br><span class="line"><span class="built_in">zeros</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">%% 2x4</span></span><br><span class="line"><span class="built_in">zeros</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>定位矩阵就是在括号中给出行列的索引即可：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>也可以指定一个范围：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat(<span class="number">1</span>:<span class="number">2</span>,<span class="number">2</span>:<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>也可以用冒号代表一整行或一整列：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 获取第一行整个列，也就是获取整个第一行</span></span><br><span class="line">mat(<span class="number">1</span>,:);</span><br><span class="line"><span class="comment">%% 获取第二列整行，也就是获取整个第二列</span></span><br><span class="line">mat(:,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>如果只使用单个索引，则是使用列的方式来查找：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line"><span class="comment">%% 得到 1</span></span><br><span class="line">mat(<span class="number">1</span>);</span><br><span class="line"><span class="comment">%% 得到 4</span></span><br><span class="line">mat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">%% 得到 2</span></span><br><span class="line">mat(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>修改矩阵元素也是通过索引的方式：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat = [<span class="number">2</span>:<span class="number">4</span>; <span class="number">3</span>:<span class="number">5</span>];</span><br><span class="line"><span class="comment">%% 将第 1 行第 2 列的元素修改为 11</span></span><br><span class="line">mat(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">11</span>;</span><br><span class="line"><span class="comment">%% 修改第二行的元素值为 5~7</span></span><br><span class="line">mat(<span class="number">2</span>,:)=<span class="number">5</span>:<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>扩展矩阵时，需要根据矩阵的行或列长度来扩展：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 增加第 4 列</span></span><br><span class="line">mat(:,<span class="number">4</span>) = [<span class="number">9</span> <span class="number">2</span>]&#x27;;</span><br><span class="line"><span class="comment">%% 增加第 4 行</span></span><br><span class="line">mat(<span class="number">4</span>,:) = <span class="number">2</span>:<span class="number">2</span>:<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>同样也可以通过空向量删除一整行或一整列：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat(:,<span class="number">4</span>) = [];</span><br></pre></td></tr></table></figure>

<h2 id="维度"><a href="#维度" class="headerlink" title="维度"></a>维度</h2><ul>
<li><p><code>length()</code>返回向量元素的个数，对于矩阵则返回行数或列数中的较大值</p>
</li>
<li><p><code>size()</code>返回矩阵的行数和列数。</p>
</li>
<li><p><code>numel()</code>返回数组中所有元素的个数</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 返回矩阵行列并存储于行向量中</span></span><br><span class="line">[r c]=<span class="built_in">size</span>(mat);</span><br></pre></td></tr></table></figure>

<p>内置表达式<code>end</code>对于向量表示最后一个元素，对于矩阵则表示最后一行或最后一列：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mat=[<span class="number">1</span>:<span class="number">3</span>;<span class="number">4</span>:<span class="number">6</span>]&#x27;;</span><br><span class="line"><span class="comment">%% 返回最后一行第一列的元素</span></span><br><span class="line">mat(<span class="keyword">end</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">%% 返回最后一列第二行的元素</span></span><br><span class="line">mat(<span class="number">2</span>,<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>除了矩阵的转置，还有一些内置函数可以改变矩阵的维度或格局：</p>
<ul>
<li><code>reshape()</code>:改变矩阵的维数</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 产生一个 3 行 4 列的矩阵</span></span><br><span class="line">mat = <span class="built_in">rand</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">%% 重新排列维 2 行 6 列的矩阵</span></span><br><span class="line">v = <span class="built_in">reshape</span>(mat, <span class="number">2</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>fliplr()</code> 将矩阵左右翻转</li>
<li><code>flipud()</code> 将矩阵上下翻转</li>
<li><code>rot90()</code> 将矩阵逆时针选择 90 度</li>
<li><code>repmat()</code> 将矩阵复制成更大的矩阵</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 复制矩阵 v 为两行一列的更大矩阵</span></span><br><span class="line"><span class="built_in">repmat</span>(v, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>matlab</category>
        <category>hello</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Matlab 脚本</title>
    <url>/2023/09/05/matlab_hello_script/</url>
    <content><![CDATA[<p>初步认识 Matlab 脚本。</p>
<span id="more"></span>

<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><p><code>input()</code>就是最简单的输入函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 从终端获取输入并赋值给变量 rad</span></span><br><span class="line">rad = input(<span class="string">&#x27;Enter the radius: &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将输入以字符串的形式赋值给 letter，用户也可以在输入参数中加入引号，而不用在后面加入参数 &#x27;s&#x27;</span></span><br><span class="line">letter = input(<span class="string">&#x27;Enter string: &#x27;</span>, <span class="string">&#x27;s&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><ul>
<li><code>disp()</code>：输出字符串、表达式、变量的结果</li>
<li><code>fprintf()</code>：和 c/c++ 一样，格式化的输出</li>
</ul>
<p>方便之处在于，它们可以直接输出向量和矩阵：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vec = <span class="number">2</span>:<span class="number">5</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;%d&#x27;</span>, vec);</span><br><span class="line">fprintf(<span class="string">&#x27;%d %d %d %d&#x27;</span>, vec);</span><br></pre></td></tr></table></figure>

<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><h2 id="plot-函数"><a href="#plot-函数" class="headerlink" title="plot 函数"></a>plot 函数</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">x = <span class="number">11</span>;</span><br><span class="line">y = <span class="number">48</span>;</span><br><span class="line"><span class="comment">% 以红色的 * 绘制点</span></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;r*&#x27;</span>);</span><br><span class="line"><span class="comment">% 改变坐标的范围，前两个是 x 轴的最小和最大值，后两个是 y 轴的最小和最大</span></span><br><span class="line">axis([<span class="number">9</span> <span class="number">12</span> <span class="number">35</span> <span class="number">55</span>]);</span><br><span class="line"><span class="comment">% 加入 x y 轴的注释</span></span><br><span class="line">xlabel(<span class="string">&#x27;Time&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Temperature&#x27;</span>);</span><br><span class="line"><span class="comment">% 添加标题</span></span><br><span class="line">title(<span class="string">&#x27;Time and Temp&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>关于图形的定制有：</p>
<ul>
<li><p>颜色</p>
<ul>
<li><p><code>b</code> blue（蓝色）</p>
</li>
<li><p><code>c</code> cyan（青色）</p>
</li>
<li><p><code>g</code> green（绿色）</p>
</li>
<li><p><code>k</code> black（黑色）</p>
</li>
<li><p><code>m</code> magenta（品红）</p>
</li>
<li><p><code>r</code> red（红色）</p>
</li>
<li><p><code>y</code> yellow（黄色）</p>
</li>
</ul>
</li>
<li><p>点的标记</p>
<ul>
<li><p><code>o</code> circle（圆）</p>
</li>
<li><p><code>d</code> diamond（菱形）</p>
</li>
<li><p><code>p</code> pentagram（五角星）</p>
</li>
<li><p><code>+</code> plus（加号）</p>
</li>
<li><p><code>.</code> point（点）</p>
</li>
<li><p><code>s</code> square（平方）</p>
</li>
<li><p><code>*</code> star（星号）</p>
</li>
<li><p><code>v</code> down trangle（下三角）</p>
</li>
<li><p><code>&lt;</code> left triangle （左三角）</p>
</li>
<li><p><code>&gt;</code> right trangle（右三角）</p>
</li>
<li><p><code>^</code> up trangle（上三角）</p>
</li>
<li><p><code>x</code> x-mark（x 标记）</p>
</li>
</ul>
</li>
<li><p>连线的线型</p>
<ul>
<li><p><code>--</code> dashed（短线）</p>
</li>
<li><p><code>-.</code> dash dot（短线点）</p>
</li>
<li><p><code>:</code> dotted（虚线）</p>
</li>
<li><p><code>-</code> solid（实现）</p>
</li>
</ul>
</li>
<li><p>辅助函数</p>
<ul>
<li><p><code>clf</code> 清除图像窗口</p>
</li>
<li><p><code>figure</code> 创建一个新的空图形窗口</p>
</li>
<li><p><code>hold on</code>,<code>hold off</code> 在两个命令中，绘制多个曲线到同一张图</p>
</li>
<li><p><code>legend</code> 将图中曲线按照画图顺序给与字符串说明</p>
</li>
<li><p><code>grid on</code>,<code>grid off</code> 在两个命令中的图像显示网格</p>
</li>
</ul>
</li>
</ul>
<h2 id="bar-柱状图"><a href="#bar-柱状图" class="headerlink" title="bar 柱状图"></a>bar 柱状图</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">y1 = [<span class="number">2</span> <span class="number">11</span> <span class="number">6</span> <span class="number">9</span> <span class="number">3</span>];</span><br><span class="line">y2 = [<span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">bar(y1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(y1,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(y2, <span class="string">&#x27;ko&#x27;</span>);</span><br><span class="line">grid on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h1><h2 id="save-向文件写数据"><a href="#save-向文件写数据" class="headerlink" title="save() 向文件写数据"></a>save() 向文件写数据</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 以 ASCII 的格式存储矩阵数据</span></span><br><span class="line"></span><br><span class="line">mymat = <span class="built_in">rand</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">save(<span class="string">&#x27;testfile.dat&#x27;</span>, <span class="string">&#x27;mymat&#x27;</span>, <span class="string">&#x27;-ascii&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 加上 -append 就是以附加的形式写入</span></span><br><span class="line">save(<span class="string">&#x27;testfile.dat&#x27;</span>, <span class="string">&#x27;mymat&#x27;</span>, <span class="string">&#x27;-ascii&#x27;</span>, <span class="string">&#x27;-append&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="load-从文件读取"><a href="#load-从文件读取" class="headerlink" title="load() 从文件读取"></a>load() 从文件读取</h2><p>load 函数仅能读出列数相同的文件。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mymat = load(<span class="string">&#x27;testfile.dat&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="返回单个值的用户自定义函数"><a href="#返回单个值的用户自定义函数" class="headerlink" title="返回单个值的用户自定义函数"></a>返回单个值的用户自定义函数</h1><p>一般是将每个函数都单独保存在一个 M 文件中，并且函数名和 M 文件名一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function outputargument = functionname(argument1, [argument2], ...)</span><br><span class="line"><span class="meta">%</span><span class="bash"> Comment describing the <span class="keyword">function</span></span></span><br><span class="line">Statements here;</span><br></pre></td></tr></table></figure>

<p>比如下面这个函数（函数名一般使用小写字母）：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span> = <span class="title">calcarea</span><span class="params">(rad)</span></span></span><br><span class="line"><span class="comment">% This function calculates the area of a circle</span></span><br><span class="line">area = <span class="built_in">pi</span> * rad * rad;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>type</code> 命令输出脚本内容，<code>help</code> 命令输出函数说明。</p>
<p>在命令行和脚本中直接调用函数即可。</p>
]]></content>
      <categories>
        <category>matlab</category>
        <category>hello</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab 的向量化代码</title>
    <url>/2023/09/10/matlab_hello_vector/</url>
    <content><![CDATA[<p>向量化代码可以降低使用循环的必要性。</p>
<span id="more"></span>

<h1 id="向量和矩阵的运算"><a href="#向量和矩阵的运算" class="headerlink" title="向量和矩阵的运算"></a>向量和矩阵的运算</h1><p>假设要将矩阵的元素都乘以一个值，使用<code>for</code>循环可以这样写：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vec = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">[r,c] = <span class="built_in">size</span>(vec);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row = <span class="number">1</span>:r</span><br><span class="line">    <span class="keyword">for</span> column = <span class="number">1</span>:c</span><br><span class="line">        vec(row, column) = vec(row, column) * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>但更为简洁的方式是使用点乘：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vec = vec .* <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>对于向量之间的运算也是如此：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">r1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">r2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">rc = r1 .* r2;</span><br></pre></td></tr></table></figure>

<p>同样的，对于函数来说也是如此，传入向量相当于一个<code>for</code>循环将向量依次传入函数：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span> = <span class="title">calcarea</span><span class="params">(rad)</span></span></span><br><span class="line"><span class="comment">% This function calculates the area of a circl</span></span><br><span class="line"><span class="comment">% 注意这里得使用点乘</span></span><br><span class="line">area = <span class="built_in">pi</span> * rad .* rad;</span><br></pre></td></tr></table></figure>

<h1 id="逻辑向量"><a href="#逻辑向量" class="headerlink" title="逻辑向量"></a>逻辑向量</h1><p>假设要对向量的元素进行逐个判断，那也可以使用向量运算：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vec = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">% 逐个判断向量元素是否大于 5，并将输出结果赋值到变量 ret</span></span><br><span class="line">ret = vec &gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">% 通过逻辑索引，获取向量中元素值大于 5 的元素</span></span><br><span class="line">vec(ret);</span><br></pre></td></tr></table></figure>

<p>matlab 提供了一些内置的逻辑函数：</p>
<ul>
<li><p><code>any()</code>：如果向量中的存在非零的元素，返回真，否则返回假</p>
</li>
<li><p><code>all()</code>：向量中所有元素都是非零的，才返回真，否则返回假</p>
</li>
<li><p><code>find()</code>：返回满足条件的向量中元素的索引</p>
</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">vec = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">find</span>(vec &gt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>matlab 也有对矩阵进行逐元素的“或”和“与”操作的操作符，和 c/c++ 一致，对应于<code>|</code>和<code>&amp;</code>。</p>
<h1 id="计时函数"><a href="#计时函数" class="headerlink" title="计时函数"></a>计时函数</h1><ul>
<li><p><code>tic</code>：启动定时器开始计时</p>
</li>
<li><p><code>toc</code>：计算计时器结果并输出</p>
</li>
</ul>
<p>使用以上两个函数就可以计算出一段代码运行花了多长时间。</p>
]]></content>
      <categories>
        <category>matlab</category>
        <category>hello</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络编程基础 API</title>
    <url>/2022/06/07/net_base_api/</url>
    <content><![CDATA[<p>熟悉网络编程基础 API，理解与 TCP/IP 协议栈的关系。</p>
<span id="more"></span>

<h1 id="socket-地址"><a href="#socket-地址" class="headerlink" title="socket 地址"></a>socket 地址</h1><h2 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h2><p>根据数据存储顺序分为大端字节序（ big endian）和小端字节序（little endian），下面代码可以判断字节序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0x12345678</span>;</span><br><span class="line">  <span class="keyword">char</span> *byte = (<span class="keyword">char</span> *)&amp;num;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*byte == <span class="number">0x78</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s little endian\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s big endian\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了计算机通信数据正确，那必然要约定一致的字节序：</p>
<ul>
<li>主机字节序：目前大多 CPU 使用小端字节序，所以又被称为主机字节序</li>
<li>网络字节序：网络通信规定为大端字节序，也就是说发送和接收方都需要以大端字节序发送和接收</li>
</ul>
<p><strong>注意：</strong> 即使同一台机器上运行的由不同语言编写的进程，也有可能是不同字节序，所以需要有良好的编程习惯。</p>
<ul>
<li>JAVA 虚拟机统一采用大端字节序</li>
</ul>
<blockquote>
<p>当然，如果通信双方以字符串的方式来交互，那在传输数据的过程中，也不需要注意大小端问题。</p>
</blockquote>
<p>Linux 提供了如下函数完成主机字节序和网络字节序的转换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用以上函数的场景有：</p>
<ol>
<li>设置 IP 地址时，使用 32 位转换</li>
<li>设置端口号时，使用 16 位转换</li>
<li>发送格式化数据时，使用对应转换</li>
</ol>
<h2 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h2><p><code>sockaddr</code> 表示 socket 地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="keyword">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sa_family</code> 表示地址族，这个与协议族有对应关系：</p>
<table>
<thead>
<tr>
<th>协议族</th>
<th>地址族</th>
<th>描述</th>
<th>sa_data 含义</th>
</tr>
</thead>
<tbody><tr>
<td>PF_UNIX</td>
<td>AF_UNIX</td>
<td>UNIX 本地域协议族</td>
<td>文件路径名，最长 108 字节</td>
</tr>
<tr>
<td>PF_INET</td>
<td>AF_INET</td>
<td>TCP/IPv4 协议族</td>
<td>16 位端口号和 32 位地址</td>
</tr>
<tr>
<td>PF_INET6</td>
<td>AF_INET6</td>
<td>TCP/IPV6 协议族</td>
<td>16 位端口号，32 位流标识，128 位地址，32 位范围 ID</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Protocol families.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_LOCAL    1    <span class="comment">/* Local to host (pipes and file-domain).  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_UNIX        PF_LOCAL <span class="comment">/* POSIX name for PF_LOCAL.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET        2    <span class="comment">/* IP protocol family.  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET6    10    <span class="comment">/* IP version 6.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Address families.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_UNIX        PF_UNIX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET        PF_INET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET6    PF_INET6</span></span><br></pre></td></tr></table></figure>

<p>从上面定义可以看出它们的值是一样的，只是为了更好编码规范，需要根据当前对象使用对应的宏。</p>
<p>仅仅用 <code>sockaddr</code> 中的 <code>sa_data</code> 并不能完全容纳多种协议族的地址值，Linux 为此定义了 <code>sockaddr_storage</code> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Structure large enough to hold any socket address (with the historical exception of AF_UNIX).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ss_aligntype    unsigned long int</span></span><br><span class="line"><span class="comment">//这里就等于 128 - sizeof(unsigned shrot int) - sizeof(unsigned long int)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SS_PADSIZE                                             \</span></span><br><span class="line"><span class="meta">(_SS_SIZE - __SOCKADDR_COMMON_SIZE - sizeof (__ss_aligntype))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">__SOCKADDR_COMMON (ss_);    <span class="comment">/* Address family, etc.  */</span></span><br><span class="line"><span class="keyword">char</span> __ss_padding[_SS_PADSIZE];</span><br><span class="line">__ss_aligntype __ss_align;    <span class="comment">/* Force desired alignment.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="专用-socket-地址"><a href="#专用-socket-地址" class="headerlink" title="专用 socket 地址"></a>专用 socket 地址</h2><p>上面的通用地址结构体是以字节的方式格式化存储地址，这并不便于代码操作。</p>
<p>所以 Linux 为各个协议族提供了专门的 socket 地址结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    __SOCKADDR_COMMON(sa_prefix)            \</span></span><br><span class="line"><span class="meta">sa_family_t sa_prefix##family</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sun_);</span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];        <span class="comment">/* Path name.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uint8_t</span>    __u6_addr8[<span class="number">16</span>];</span><br><span class="line">    &#125; __in6_u;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> s6_addr            __in6_u.__u6_addr8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin_port;            <span class="comment">/* Port number.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>        <span class="comment">/* Internet address.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</span><br><span class="line">                           __SOCKADDR_COMMON_SIZE -</span><br><span class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</span><br><span class="line">                           <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ditto, for IPv6.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __SOCKADDR_COMMON (sin6_);</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;    <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;    <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>    <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;    <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样在编程设置地址参数时就可以使用这些结构体，最后在调用对应函数时强制转换为 <code>sockaddr</code> 即可。</p>
<h2 id="IP-地址转换函数"><a href="#IP-地址转换函数" class="headerlink" title="IP 地址转换函数"></a>IP 地址转换函数</h2><p>为了提高编程的可读性，Linux 提供了字符串方式地址到二进制地址的相互转换函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将以字符串表示的 IPv4 地址转换为网络字节序的整数并存储于 inp 中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="comment">//将以字符串表示的 IPv4 地址转换为网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将网络字节序的整数地址转换为字符串表示的 IPv4 地址</span></span><br><span class="line"><span class="comment">//此函数返回指向静态内存，所以其不可重入</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以字符串表示的 IPv4 或 IPv6 地址转换为网络字节序，并存储于对应的地址结构体中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//将网络字节序的整数地址转换为字符串表示的 IPv4 或 IPv6 地址，size 指定转换的大小</span></span><br><span class="line"><span class="comment">//IPv4 大小至少为 INET_ADDRSTRLEN</span></span><br><span class="line"><span class="comment">//IPv6 大小至少为 INET6_ADDRSTRLEN</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="创建-socket"><a href="#创建-socket" class="headerlink" title="创建 socket"></a>创建 socket</h1><p>Linux 提供了 <code>socket</code> 函数来创建一个 socket 对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>domain</code> 指定底层协议族<ul>
<li><code>AF_INET</code> 表示 IPv4， <code>AF_INET6</code> 表示 IPv6， <code>AF_UNIX,AF_LOCAL</code> 表示 UNIX 本地协议族</li>
</ul>
</li>
<li><code>type</code> 指定服务类型，对于 <code>TCP</code> 协议则设置为 <code>SOCK_STREAM</code> (流服务)，对于 <code>UDP</code> 协议则设置为 <code>SOCK_DGRAM</code> （数据报服务）<ul>
<li>以上参数可以与 <code>SOCK_NONBLOCK</code> （非阻塞）和 <code>SOCK_CLOEXEC</code> （用 fork 调用创建子进程时，子进程关闭该 socket）相与</li>
</ul>
</li>
<li><code>protocol</code> 表示具体的协议，一般前两个值都已经决定了协议的唯一性，一般设 0 表示使用默认协议。</li>
</ul>
<h1 id="命名-socket"><a href="#命名-socket" class="headerlink" title="命名 socket"></a>命名 socket</h1><p>将一个 socket 与 socket 地址绑定称为给 socket 命名。</p>
<p>在服务器程序中，通常要命名 socket，只有命名后客户端才能知道如何连接它。<br>而在客户端中，通常不需要命名，采用系统自动分配的地址即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 addr 所指的地址分配给未命名的 sockfd 文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">       <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="监听-socket"><a href="#监听-socket" class="headerlink" title="监听 socket"></a>监听 socket</h1><p>将 socket 命名之后，需要创建一个监听队列存放待处理的客户端连接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个以 sockfd 对应的最大长度为 backlog 的监听队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>backlog</code> 表示处于完全连接状态的 socket 的上限，半连接的上限由 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定。</p>
<p><strong>需要注意的是：backlog 代表可连接最大长度减一</strong>，比如 backlog 设置为 5，代表最多可以连接 6 个客户端。</p>
<p>使用 <code>telnet</code> 连接下面代码的服务端，并用 <code>netstat -nt | grep &lt;port&gt;</code> 的方式查看状态便可验证：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s : &lt;port&gt; &lt;backlog&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> backlog = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//设置地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sockaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockaddr.sin_family = AF_INET;</span><br><span class="line">    sockaddr.sin_port = htons(port);</span><br><span class="line">    sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//新建 socket，类型是 IPv4 TCP</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(sockaddr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create socket failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//socket 命名</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;sockaddr, <span class="keyword">sizeof</span>(sockaddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t bind socket and addr:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始监听</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, backlog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h1><p>所谓的接受连接，是指从监听队列中取出一个 client 连接的节点，然后处理。</p>
<ul>
<li>accept 不会判断当前连接处于何种状态（比如客户端异常断开）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从 sockfd 对应的监听队列中取出一个监听 socket 赋值给 addr</span></span><br><span class="line"><span class="comment">//返回一个新连接 socket 的标识</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h1><p>客户端通过 <code>connect</code> 来主动发起连接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 sockfd 与 addr 指向的地址进行连接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h1><p>关闭连接可以使用 <code>close</code> 和 <code>shutdown</code> :</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 fd 引用计数减一，只有当计数为 0 时才真正关闭连接，在父子进程中需要注意</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//立即以 how 的方式关闭 sockfd（不管引用计数）</span></span><br><span class="line"><span class="comment">//how : SHUT_RD -&gt; 关闭读 SHUT_WR -&gt; 关闭写 SHUT_RDWR -&gt; 全关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="TCP-数据读写"><a href="#TCP-数据读写" class="headerlink" title="TCP 数据读写"></a>TCP 数据读写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要明白的是：由于 TCP 是流数据通信，很可能 <code>recv()</code> 所返回的实际读取长度小于需求的长度，所以需要多次调用 <code>recv()</code> 才能得到完整的数据。</p>
<blockquote>
<p>当 <code>recv()</code>返回 0 时，代表对方已经关闭了连接</p>
</blockquote>
<p>flags 常用的取值如下（这些逻辑可以通过逻辑或组合起来）：</p>
<table>
<thead>
<tr>
<th>选项名</th>
<th>含义</th>
<th>send</th>
<th>recv</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_CONFIRM</td>
<td>仅用 SOCK_DGRAM,SOCK_RAW 类型，指示数据链路层协议持续监听对方回应，直到得到答复</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>不查看路由表，直接将数据发送给本地局域网内的主机</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>非阻塞操作</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>内核超时等待更多数据写入发送缓存后一次性发送，提高传输效率</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>读操作仅在读取到指定数量的字节后才返回</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>读取数据，但不清除读缓存</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>紧急数据的读写</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>往读端关闭的管道或 socket 连接中写入数据时，不会引发 SIGPIPE</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<h2 id="UDP-数据读写"><a href="#UDP-数据读写" class="headerlink" title="UDP 数据读写"></a>UDP 数据读写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">               struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由于 UDP 没有连接的概念，所以在其发送和接收函数中需要包含与其通信的地址信息。</p>
<h2 id="通用数据读写"><a href="#通用数据读写" class="headerlink" title="通用数据读写"></a>通用数据读写</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">    <span class="keyword">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">    <span class="keyword">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">    <span class="keyword">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">    <span class="keyword">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通用数据读写函数既可以用于 TCP 也可以用于 UDP，这两个函数使用分散聚合模式来实现多段内存的读写：</p>
<ul>
<li><code>struct iovec</code> 代表一块内存</li>
<li><code>msg_iov</code> 指向多段内存数组地址， <code>msg_iovlen</code> 指定数组长度</li>
<li><code>msg_name,msg_namelen</code> 分别表示对端的 socket 地址和长度，对于 TCP 而言设置为 NULL </li>
<li><code>flags</code> 设定与前面的数据读写标记一致</li>
</ul>
<h1 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h1><p>当有带外标记（紧急）数据到达时，内核会产生异常事件或 <code>SIGURG</code> 信号，然后用户程序通过 <code>sockatmark</code> 判断下一个数据是否是带外数据，然后通过 <code>MSG_OOB</code> 标记接收数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>为了理解带外标记，现在运行服务端，然后 PC 发送普通数据和带外数据来观察服务端的输出。</p>
<p>服务端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind socket and address failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m waiting for client...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//accept</span></span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">if</span> ((client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connected to client ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">    inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> recv_len;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RECV_BUF_SIZE   (30)</span></span><br><span class="line">    <span class="keyword">char</span> recv_buf[RECV_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, RECV_BUF_SIZE);</span><br><span class="line">    recv_len = recv(client_fd, recv_buf, RECV_BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1.received %ld bytes : %s\n&quot;</span>, recv_len, recv_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, RECV_BUF_SIZE);</span><br><span class="line">    recv_len = recv(client_fd, recv_buf, RECV_BUF_SIZE - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">    <span class="keyword">if</span>(recv_len &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;recv failed:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2.received %ld bytes : %s\n&quot;</span>, recv_len, recv_buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, RECV_BUF_SIZE);</span><br><span class="line">    recv_len = recv(client_fd, recv_buf, RECV_BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3.received %ld bytes : %s\n&quot;</span>, recv_len, recv_buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(client_fd);</span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;hostname&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host_info</span> =</span> gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    assert(host_info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have found the ip address of host %s is:\n&quot;</span>, host_info-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, host_info-&gt;h_addrtype == AF_INET ? <span class="string">&quot;ipv4&quot;</span> : <span class="string">&quot;ipv6&quot;</span>,inet_ntoa(*(struct in_addr *)host_info-&gt;h_addr_list[i]));</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (host_info-&gt;h_addr_list[i]);</span><br><span class="line"></span><br><span class="line">    socket_addr.sin_addr.s_addr = *(<span class="keyword">uint32_t</span> *)host_info-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//connect</span></span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect to server failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    send(socket_fd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    send(socket_fd, oob_data, <span class="built_in">strlen</span>(oob_data), MSG_OOB);</span><br><span class="line">    send(socket_fd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务端启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./oob_server 65123</span></span><br><span class="line">I&#x27;m waiting for client...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 客户端连接</span></span><br><span class="line">./oob_client lab.local 65123</span><br><span class="line">I have found the ip address of host lab.local is:</span><br><span class="line">ipv4: 192.168.11.67</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端接收</span></span><br><span class="line">connected to client ip: 192.168.11.52, port: 13298</span><br><span class="line">1.received 5 bytes : 123ab</span><br><span class="line">2.received 1 bytes : c</span><br><span class="line">3.received 3 bytes : 123</span><br></pre></td></tr></table></figure>

<p>可以看到：虽然客户端发送的带外数据是 “abc” ，但是只有最后一个字符 “c” 被当做带外数据。且服务器对正常数据的接收将被带外数据截断，也就是无法通过一个 <code>recv</code> 全部读出。</p>
<p>同时 Wireshark 抓取的信息如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter5/catch_oob.jpg?raw=true"><br>其过程如下：</p>
<ol>
<li>握手：客户端首先与服务器进行 3 次握手</li>
<li>发送普通数据“123”</li>
<li>发送紧急数据“abc123”，此时<code>URG</code>标志位置位，且紧急指针的值为 3，也就是说<code>c</code>为紧急数据</li>
<li>客户端发送断开数据报</li>
<li>服务器应答普通数据</li>
<li>服务器应答紧急数据</li>
<li>服务器应答结束报文</li>
<li>客户端返回应答，最终便断开了连接</li>
</ol>
<h1 id="地址信息"><a href="#地址信息" class="headerlink" title="地址信息"></a>地址信息</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取本端 socket 地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line"><span class="comment">//获取对端 socket 地址</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h1><p>以下函数用于获取和设置 <code>socket</code> 文件描述符属性的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//level 设定协议栈哪一层选项，optname 设置具体选项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<strong>对服务端而言，需要在 <code>listen</code> 之前设置 socket。对于客户端而言，需要在 <code>connect</code> 之前设置 socket。</strong></p>
<p>下面根据协议栈的 Level 来说明常用的设置。</p>
<h2 id="SOL-SOCKET-通用-socket-选项，与协议无关"><a href="#SOL-SOCKET-通用-socket-选项，与协议无关" class="headerlink" title="SOL_SOCKET(通用 socket 选项，与协议无关)"></a>SOL_SOCKET(通用 socket 选项，与协议无关)</h2><ul>
<li><p>SO_DEBUG： 打开调试信息</p>
</li>
<li><p>SO_REUSEADDR： 重用本地地址（而不是让 TCP 连接处于 <code>TIME_WAIT</code> 状态，等待很久后才能重用此地址）</p>
<ul>
<li>也可以通过修改 <code>/proc/sys/net/ipv4/tcp_tw_reuse</code> 达到同样的需求<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;Can&#x27;t set socket:&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>SO_TYPE：获取 socket 类型</p>
</li>
<li><p>SO_ERROR： 获取并清除 socket 错误状态</p>
</li>
<li><p>SO_DONTROUTE： 不查看路由表，直接将数据发送给本地局域网内的主机，与 send 函数的 <code>MSG_DONTROUTE</code> 效果一样</p>
</li>
<li><p>SO_RCVBUF：TCP 接收缓冲区大小</p>
<ul>
<li>也可以设置 <code>/proc/sys/net/ipv4/tcp_rmem</code></li>
</ul>
</li>
<li><p>SO_SNDBUF： TCP 发送缓冲区大小</p>
<ul>
<li>也可以设置 <code>/proc/sys/net/ipv4/tcp_wmem</code></li>
</ul>
</li>
<li><p>SO_KEEPALIVE：发送周期性保活报文以维持连接</p>
<ul>
<li>关于 keepalive 的理解参考<a href="https://holmeshe.me/network-essentials-setsockopt-SO_KEEPALIVE/">此链接</a></li>
</ul>
</li>
<li><p>SO_OOBINLINE：将带外数据存放于普通数据缓存中，用户使用普通读取方式获取</p>
</li>
<li><p>SO_LINGER：若有数据待发送，则延迟关闭，通过 <code>linger</code> 结构体配置是立即关闭，还是发送残留数据后关闭</p>
</li>
<li><p>SO_RCVLOWAT： TCP 接收缓存区低水位标记，当缓存数据大于低水位时，应用程序便可以读取</p>
</li>
<li><p>SO_SNDLOWAT：TCP 发送缓存区低水位标记，当空闲数据大于低水位时，应用程序便可以发送</p>
</li>
<li><p>SO_RCVTIMEO： 接收数据超时</p>
</li>
<li><p>SO_SNDTIMEO：发送数据超时</p>
</li>
</ul>
<p>下面通过实例理解 TCP 接收和发送缓冲区大小设置。</p>
<p>服务端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE (1024)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt; &lt;recv buffer size&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> recvbuf = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(recvbuf);</span><br><span class="line"></span><br><span class="line">    setsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="keyword">sizeof</span>(recvbuf));</span><br><span class="line">    getsockopt(socket_fd, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, (<span class="keyword">socklen_t</span> *)&amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I want to set recv buf is %d, actually recv buf is %d\n&quot;</span>,</span><br><span class="line">    atoi(argv[<span class="number">2</span>]), recvbuf);</span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind socket and address failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m waiting for client...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//accept</span></span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">if</span> ((client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connected to client ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">    inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">    <span class="keyword">while</span> (recv(client_fd, buffer, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(client_fd);</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE (4096)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;hostname&gt; &lt;port&gt; &lt;send buffer size&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host_info</span> =</span> gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    assert(host_info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have found the ip address of host %s is:\n&quot;</span>, host_info-&gt;h_name);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, host_info-&gt;h_addrtype == AF_INET ? <span class="string">&quot;ipv4&quot;</span> : <span class="string">&quot;ipv6&quot;</span>,</span><br><span class="line">        inet_ntoa(*(struct in_addr *)host_info-&gt;h_addr_list[i]));</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (host_info-&gt;h_addr_list[i]);</span><br><span class="line"></span><br><span class="line">    socket_addr.sin_addr.s_addr = *(<span class="keyword">uint32_t</span> *)host_info-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sendbuf = atoi(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(sendbuf);</span><br><span class="line"></span><br><span class="line">    setsockopt(socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="keyword">sizeof</span>(sendbuf));</span><br><span class="line">    getsockopt(socket_fd, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, &amp;len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I want to set send buf is %d, actually it is %d\n&quot;</span>,</span><br><span class="line">    atoi(argv[<span class="number">3</span>]), sendbuf);</span><br><span class="line">    <span class="comment">//connect</span></span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect to server failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;a&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">    send(socket_fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">服务端启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./size_server 54321 50</span></span><br><span class="line">I want to set recv buf is 50, actually recv buf is 2304</span><br><span class="line">I&#x27;m waiting for client...</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">客户端启动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out lab.local 54321 50</span></span><br><span class="line">I have found the ip address of host lab.local is:</span><br><span class="line">ipv4: 192.168.11.67</span><br><span class="line">I want to set send buf is 50, actually it is 4608</span><br></pre></td></tr></table></figure>

<p>可以看到接收缓冲区大小会被限制，系统会主动增加这些值。</p>
<p>通过 Wireshark 抓取：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter5/catch_send_recv_buffer.jpg?raw=true"><br>分析其流程如下：</p>
<ol>
<li>握手<ul>
<li>客户端发送的窗口大小是 64240，扩大因子是 128</li>
<li>服务端返回的窗口大小是 1152，扩大因子是 1</li>
</ul>
</li>
<li>发送：在这个过程中，客户端会分段多次发送数据，等待服务端读取数据后再次发送</li>
<li>断开：这次断开是 4 次挥手，服务端先返回应答，然后再返回对于<code>FIN</code>数据报的应答 <ul>
<li>客户端发送<code>FIN</code>数据报的时候也顺带发送了最后的数据</li>
</ul>
</li>
</ol>
<h2 id="IPPROTO-IP-IPv4-选项）"><a href="#IPPROTO-IP-IPv4-选项）" class="headerlink" title="IPPROTO_IP(IPv4 选项）"></a>IPPROTO_IP(IPv4 选项）</h2><ul>
<li>IP_TOS：服务类型，用于设置最大延迟、最大吞吐等</li>
<li>IP_TTL：存活时间，最多可以中转多少个路由器</li>
</ul>
<h2 id="IPPROTO-IPV6-IPv6-选项"><a href="#IPPROTO-IPV6-IPv6-选项" class="headerlink" title="IPPROTO_IPV6(IPv6 选项)"></a>IPPROTO_IPV6(IPv6 选项)</h2><ul>
<li>IPV6_NEXTHOP: 下一跳 IP 地址</li>
<li>IPV6_RECVPKTINFO：接收分组信息</li>
<li>IPV6_DONTFRAG：禁止分片</li>
<li>IPV6_RECVTCLASS：接收通信类型</li>
</ul>
<h2 id="IPPROTO-TCP-TCP-选项"><a href="#IPPROTO-TCP-TCP-选项" class="headerlink" title="IPPROTO_TCP(TCP 选项)"></a>IPPROTO_TCP(TCP 选项)</h2><ul>
<li>TCP_MAXSEG: TCP 最大报文段大小</li>
<li>TCP_NODELAY: 禁止 Nagle 算法</li>
</ul>
<h1 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h1><p>socket 地址指的是 IP 地址和端口号的集合，但这两个信息都是数值。</p>
<p>如果能够通过字符串的形式转换一次，客户端的访问将比较方便。</p>
<ul>
<li>其中 IP 地址对应<strong>主机名</strong> ，端口号对应<strong>服务名</strong></li>
<li>服务端修改 IP 地址后并不会影响客户端。</li>
</ul>
<p>在局域网中，如果没有架设 DNS，则可以通过在服务端和客户端安装 <code>avahi-daemon</code> 通过 <code>hostname.local</code> 的方式访问。</p>
<h2 id="gethostbyname-gethostbyaddr"><a href="#gethostbyname-gethostbyaddr" class="headerlink" title="gethostbyname, gethostbyaddr"></a>gethostbyname, gethostbyaddr</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>  *h_name;            <span class="comment">/* official name of host */</span></span><br><span class="line">    <span class="keyword">char</span> **h_aliases;         <span class="comment">/* alias list */</span></span><br><span class="line">    <span class="keyword">int</span>    h_addrtype;        <span class="comment">/* host address type */</span></span><br><span class="line">    <span class="keyword">int</span>    h_length;          <span class="comment">/* length of address */</span></span><br><span class="line">    <span class="keyword">char</span> **h_addr_list;       <span class="comment">/* list of addresses */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据主机名称获取主机的完整信息</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span>       <span class="comment">/* for AF_INET */</span></span></span><br><span class="line"><span class="comment">//根据 IP 地址获取主机的完整信息</span></span><br><span class="line"><span class="function">struct hostent *<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>gethostbyname</code> 函数首先在本地的 <code>/etc/hosts</code> 文件中查找主机，如果没有找到再去访问 DNS 服务器。</p>
<p><strong>需要注意的是</strong>: <code>h_addr_list</code> 是以网络字节序存放的字节数组，而不是字符串！要以字符串显示需要使用 <code>inet_ntoa</code> 函数。</p>
<h2 id="getservbyname-getservbyport"><a href="#getservbyname-getservbyport" class="headerlink" title="getservbyname, getservbyport"></a>getservbyname, getservbyport</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>  *s_name;       <span class="comment">/* official service name */</span></span><br><span class="line">    <span class="keyword">char</span> **s_aliases;    <span class="comment">/* alias list */</span></span><br><span class="line">    <span class="keyword">int</span>    s_port;       <span class="comment">/* port number */</span></span><br><span class="line">    <span class="keyword">char</span>  *s_proto;      <span class="comment">/* protocol to use */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据名称获取某个服务的完整信息</span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br><span class="line"><span class="comment">//根据端口号获取某个服务的完整信息</span></span><br><span class="line"><span class="function">struct servent *<span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *proto)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上的转换关系都是通过读取 <code>/etc/services</code> 文件来获取服务信息的。</p>
<h2 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>              ai_flags;</span><br><span class="line">    <span class="keyword">int</span>              ai_family;</span><br><span class="line">    <span class="keyword">int</span>              ai_socktype;</span><br><span class="line">    <span class="keyword">int</span>              ai_protocol;</span><br><span class="line">    <span class="keyword">socklen_t</span>        ai_addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> *<span class="title">ai_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span>            *ai_canonname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai_next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过主机名和服务名获得 IP 地址和端口号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *node, <span class="keyword">const</span> <span class="keyword">char</span> *service,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">const</span> struct addrinfo *hints,</span></span></span><br><span class="line"><span class="params"><span class="function">              struct addrinfo **res)</span></span>;</span><br><span class="line"><span class="comment">//res 资源是在函数内被申请，所以需要主动释放</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo *res)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 socket 地址同时获得以字符串表示的主机名和服务名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr *sa, <span class="keyword">socklen_t</span> salen,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">char</span> *host, <span class="keyword">socklen_t</span> hostlen,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">char</span> *serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Wireshark 观察访问 Internet 上的 Web 服务器</title>
    <url>/2022/06/07/net_base_http/</url>
    <content><![CDATA[<p>使用 Wireshark 来抓取整个流程，以粗浅的理解 TCP/IP。</p>
<span id="more"></span>

<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter4/http_exercise.jpg?raw=true"><br>如上图所示，访问端运行 <code>wget</code> 程序，通过代理上的 <code>squid</code> 程序中转，访问 <code>www.baidu.com</code> 的首页 <code>index.html</code> 文档。</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="squid-代理服务器"><a href="#squid-代理服务器" class="headerlink" title="squid 代理服务器"></a>squid 代理服务器</h2><p>在使用 apt 安装好 squid 后，在 <code>/etc/squid/squid.conf</code> 中添加以下两行，以允许局域网访问该代理：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acl localnet src 192.168.11.0/24</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这一行在文件中就有，只是需要修改一下</span></span><br><span class="line">http_access allow all</span><br></pre></td></tr></table></figure>

<p>然后再启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service squid restart</span><br></pre></td></tr></table></figure>

<p>删除 ARP 对网关的缓存，以观察到 ARP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo arp -d 192.168.11.1</span><br></pre></td></tr></table></figure>

<h2 id="客户端到代理"><a href="#客户端到代理" class="headerlink" title="客户端到代理"></a>客户端到代理</h2><p>客户端需要先使用 WSL 设置代理服务器（squid 的端口是 3128）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=192.168.11.67:3128</span><br></pre></td></tr></table></figure>
<p>然后开始发送请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --header=&quot;Connection: close&quot; http://www.baidu.com/index.html</span><br></pre></td></tr></table></figure>

<h1 id="抓取"><a href="#抓取" class="headerlink" title="抓取"></a>抓取</h1><p>使用 Wireshark 抓取整个通信过程：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter4/http_proxy_catch.jpg?raw=true"><br>可以观察到其流程如下。</p>
<ol>
<li>握手：既然是 firefox 要经过服务器代理访问百度，那么首先就需要与代理服务器建立连接（TCP 3 次握手）。</li>
<li>ARP：客户端发送 HTTP 请求后，由于访问的不是局域网地址，所以根据路由表设定，需要走网关出去。那么代理服务器就需要先使用 ARP 来获取网关的 MAC 地址。</li>
<li>数据传输：代理服务器在获取到数据后，通过 3 个 TCP 报文将内容返回给客户端</li>
<li>断开：当代理服务器发送完数据后，服务器主动断开连接</li>
</ol>
<ul>
<li>服务器首先主动发送 FIN TCP 报文</li>
<li>客户端应答服务端所传输的 3 个 TCP 数据报文</li>
<li>然后客户端再是对服务端的 FIN ACK 应答报文</li>
<li>最后服务端返回一个应答，表示双方便断开连接了</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux I/O 复用</title>
    <url>/2022/06/11/net_base_io%20multiplexing/</url>
    <content><![CDATA[<p>I/O 复用虽然能同时监听多个文件描述符， <strong>但它本身是阻塞的</strong> 。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每个文件描述符，这使得服务器程序看起来像是串行工作的。要实现并发，只能使用多进程或多线程等编程手段。</p>
<span id="more"></span>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>监听文件描述符上的可读、可写和异常事件。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* According to POSIX.1-2001, POSIX.1-2008 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span>    tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @par nfds : 被监听文件描述符数值最大值加 1（因为文件描述符从 0 开始），这个参数用于向内核传递范围，提高 select 性能</span></span><br><span class="line"><span class="comment">* @par readfds,writefds,exceptfds : 指向可读、可写、异常事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">* @par timeout : 超时时间，当设置为 NULL 时，表示一直阻塞</span></span><br><span class="line"><span class="comment">* @ret 成功时返回就绪文件描述符总数，失败返回 -1 并设置 errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">         fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>fd_set</code> 是一个整型数组，每一位代表文件描述符，linux 提供了对应的宏来操作这些位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除 set 上的某一位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//检查 set 上某一位是否被设置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//设置 set 上的某一位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//清除 set 上的所有位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="就绪条件"><a href="#就绪条件" class="headerlink" title="就绪条件"></a>就绪条件</h2><p>在网络编程中，下列情况下 socket 可读：</p>
<ul>
<li>socket 对应的内核接收缓存区中的字节数大于或等于低水位标记 <code>SO_RCVLOWAT</code> </li>
<li>socket 通信的对方关闭连接，此时读操作返回 0</li>
<li>监听 socket 上有新的连接请求</li>
<li>socket 上有未处理的错误，此时通过 <code>getsockopt()</code> 来读取和清除该错误</li>
</ul>
<p>在网络编程中，下列情况下 socket 可写：</p>
<ul>
<li>socket 对应的内核发送缓冲区中可用字节数大于或等于低水位标记 <code>SO_SNDLOWAT</code> </li>
<li>socket 的写操作被关闭。对写操作被关闭的 socket 执行写操作将触发一个 <code>SIGPIPE</code> 信号</li>
<li>socket 使用非阻塞 connect 连接成功或者失败后</li>
<li>socket 上有未处理的错误，此时通过 <code>getsockopt()</code> 来读取和清除该错误</li>
</ul>
<p>在网络编程中，select能处理的异常情况只有一种：socket 上接收到带外数据</p>
<h2 id="处理带外数据"><a href="#处理带外数据" class="headerlink" title="处理带外数据"></a>处理带外数据</h2><p>socket 上接收到普通数据和带外数据都将使 select 返回，但 socket 处于不同的就绪状态：前者处于可读状态，后者处于异常状态。</p>
<p>下面的代码是客户端发送普通和异常数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;hostname&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host_info</span> =</span> gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    assert(host_info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have found the ip address of host %s is:\n&quot;</span>, host_info-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, host_info-&gt;h_addrtype == AF_INET ? <span class="string">&quot;ipv4&quot;</span> : <span class="string">&quot;ipv6&quot;</span>,</span><br><span class="line">        inet_ntoa(*(struct in_addr *)host_info-&gt;h_addr_list[i]));</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (host_info-&gt;h_addr_list[i]);</span><br><span class="line"></span><br><span class="line">    socket_addr.sin_addr.s_addr = *(<span class="keyword">uint32_t</span> *)host_info-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connect</span></span><br><span class="line">    <span class="keyword">if</span> (connect(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect to server failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    send(socket_fd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line">    send(socket_fd, oob_data, <span class="built_in">strlen</span>(oob_data), MSG_OOB);</span><br><span class="line">    send(socket_fd, normal_data, <span class="built_in">strlen</span>(normal_data), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<p>下面代码是服务端通过 select 来接收普通和异常数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket!&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind socket failed!&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen socket failed!&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client: ip -&gt; %s, port -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    fd_set exception_fds;</span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        FD_SET(client_fd, &amp;read_fds);</span><br><span class="line">        FD_SET(client_fd, &amp;exception_fds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (select(client_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select failed:&quot;</span>);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> error3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fd, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (( ret = recv(client_fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;recv failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> error3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;socket has been closed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> error2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I have got normal data: %s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(client_fd, &amp;exception_fds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = recv(client_fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;read oob data failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> error3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;socket has been closed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> error2;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I have got oob data: %s\n&quot;</span>, buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">error3:</span><br><span class="line">    close(client_fd);</span><br><span class="line">error2:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">error1:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> WSL 运行服务端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./server 54321</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在 WSL 上运行客户端</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./client localhost 54321</span></span><br><span class="line">I have found the ip address of host localhost is:</span><br><span class="line">ipv4: 127.0.0.1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">最终服务端接收</span></span><br><span class="line">client: ip -&gt; 127.0.0.1, port -&gt; 50294</span><br><span class="line">I have got normal data: 123ab</span><br><span class="line">I have got oob data: c</span><br><span class="line">I have got normal data: 123</span><br><span class="line">socket has been closed.</span><br></pre></td></tr></table></figure>

<p>从服务端代码可以看出，每次接收到数据后，<code>select()</code>都需要重新设置一次，它就像是有健忘症一样……</p>
<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll 与 select 在使用上类似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>event 类型有：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>数据（包括普通数据和优先数据）可读</td>
</tr>
<tr>
<td>POLLRDNORM</td>
<td>普通数据可读</td>
</tr>
<tr>
<td>POLLRDBAND</td>
<td>优先级带数据可读</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>高优先级数据可读，比如 TCP 带外数据</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>数据（包括普通数据和优先数据）可写</td>
</tr>
<tr>
<td>POLLWRNORM</td>
<td>普通数据可写</td>
</tr>
<tr>
<td>POLLWRBAND</td>
<td>优先级带数据可写</td>
</tr>
<tr>
<td>POLLRDHUP</td>
<td>TCP 连接被对方关闭或对方关闭了写操作</td>
</tr>
<tr>
<td>POLLERR</td>
<td>错误</td>
</tr>
<tr>
<td>POLLHUP</td>
<td>挂起</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td>文件描述符没有打开</td>
</tr>
</tbody></table>
<p>虽然 poll 和 select 类似，但是当有事件发生时，内核修改的是 pollfd 的 <code>revents</code>成员变量，而不会修改原来的<code>events</code>成员变量。</p>
<p>所以其下次再来调用时，可以不用再次修改 pollfd，编程接口相对更为友好。</p>
<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p>epoll 则与 select、poll 有以下差异：</p>
<ul>
<li>epoll 使用一组函数来完成任务</li>
<li>epoll 把用户关心的文件描述符上的事件放在内核里的一个事件表中，而无须像 select 和 poll 每次调用都需要重复传入参数</li>
</ul>
<blockquote>
<p>既然不需要重复传入参数，那 epoll 的操作效率是比 select 和 poll 的效率高的</p>
</blockquote>
<h2 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h2><p>epoll 需要使用一个额外的文件描述符来唯一标识内核中的事件表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//size 提示内核事件表需要多大</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数返回的文件描述符将用作其他所有 epoll 系统调用的第一个参数，以指定要访问的内核事件表。</p>
<p>操作内核事件表，使用下面这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;</span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>op 参数指定对 fd 的操作类型：</p>
<ul>
<li>EPOLL_CTL_ADD：往事件表中注册 fd 上的事件</li>
<li>EPOLL_CTL_MOD：修改 fd 上的注册事件  </li>
<li>EPOLL_CTL_DEL：删除 fd 上的注册事件</li>
</ul>
<p>event 结构中的 <code>events</code> 成员描述事件类型，与 <code>poll</code> 事件类型基本相同，只是宏名称前需要加 ‘E’ 。</p>
<p>除此之外，epoll 还有两个额外的事件类型 <code>EPOLLET</code> 和 <code>EPOLLONESHOT</code>。</p>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><p>epoll_wait 函数在一段超时时间内等待一组文件描述符上的事件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当 epoll_wait 检测到事件，就将所有就绪事件从内核事件表中复制到参数 <code>events</code> 指向的数组中。<br>也就是说，<code>events</code> 指向的数组中全部都是就绪事件，而不需要像 <code>select</code> 和 <code>poll</code> 再来二次判断了。</p>
<p>它们的差异如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//poll 查询谁就绪了</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll 返回后直接处理</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h2><p>epoll 对文件描述符操作有两种模式：</p>
<ul>
<li>LT（Level Trigger, 电平触发）：默认此工作模式，相当于效率比较高的 poll<ul>
<li>事件发生时，如果应用程序不处理，这些事件会被保持</li>
</ul>
</li>
<li>ET（Edge Trigger，边沿触发）：此模式是 epoll 的高效工作模式<ul>
<li>事件发生时，应用程序应立即处理，否则下次调用 <code>epoll_wait</code> 后此事件将被清空</li>
</ul>
</li>
</ul>
<p>以上模式和中断的电平触发和边沿触发的概念类似。</p>
<p><strong>需要注意的是：</strong> 当使用 ET 模式时，对应的文件描述符需要设置为非阻塞的方式。<br>因为 ET 模式下，当事件触发后，需要一次性读出所有数据。所以需要非阻塞的返回来判断是否已经读空了。</p>
<p>下面是服务端以两种模式工作的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_LT  0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER (1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE      (10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置为非阻塞模式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_opt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_opt = old_opt | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加 fd 的读事件到 epoll</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_LT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">(struct epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当服务器检查到客户端连接，就将其加入 epoll，模式为电平触发</span></span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            <span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            addfd(epollfd, connfd, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于是电平触发方式，只要该 socket 中还有数据，则该事件还会被触发</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                close(sockfd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes, the contents are: %s\n&quot;</span>, ret, buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;something is wrong.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(struct epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">            <span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">            addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">            <span class="comment">// 由于是边沿触发模式，所以需要一次性将当前缓存的内容都读出来</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;event trigger once!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line">                <span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 以下两个标记都表示数据已经读取完毕了</span></span><br><span class="line">                    <span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes, the contents are: %s\n&quot;</span>, ret, buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;something is wrong.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(server_addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(server_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(server_fd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(MAX_EVENT_NUMBER);</span><br><span class="line">    assert(epoll_fd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_LT</span></span><br><span class="line">    addfd(epoll_fd, server_fd, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    addfd(epoll_fd, server_fd, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            perror(<span class="string">&quot;epoll failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error1;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_LT</span></span><br><span class="line">        lt(events, ret, epoll_fd, server_fd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        et(events, ret, epoll_fd, server_fd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">error1:</span><br><span class="line">    close(server_fd);</span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 telnet 作为客户端测试，发送大于 10 字节的数据，可以看出：</p>
<ul>
<li>在电平触发模式下，如果数据没有读完，电平触发会一直保持，所以服务端可以每次触发发生时只读一次</li>
<li>在边沿触发模式下，触发只会出现一次，所以服务端在触发发生后，需要确保一次性读完 socket 中的内容才行，这样子也是效率最高的做法。</li>
<li>在有 epoll 做 I/O 扫描的情况下，文件描述符需要设置为非阻塞模式，这样可以避免读取的数据大于缓存存储时，阻塞了程序流程</li>
</ul>
<h2 id="EPOLLONESHOT-事件"><a href="#EPOLLONESHOT-事件" class="headerlink" title="EPOLLONESHOT 事件"></a>EPOLLONESHOT 事件</h2><p>在 ET 模式下，如果一个线程在读取完某个 socket 上的数据后开始处理，而在处理过程中此 socket 上又有新数据可读，但此时由另外一个线程来读取这些新数据。</p>
<p>这就出现了两个线程同时操作同一个 socket 的问题，为了一个 socket 在连接任一时刻都只被一个线程处理，可以使用 EPOLLONESHOT 事件实现。</p>
<p><code>EPOLLONESHOT</code> 使得操作系统最多触发一次其上注册的一个可读、可写或异常事件。</p>
<p>这样就可以将一个 socket 与一个单独的线程绑定， <strong>当线程处理完此事件后，需要重置其 <code>EPOLLONESHOT</code> 事件。</strong></p>
<blockquote>
<p>这样才能确保 socket 可以再次发出事件并被其他的线程处理。</p>
</blockquote>
<p>下面是使用例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER    (5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE         (10)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epollfd;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_opt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_opt = old_opt | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETFL, new_opt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = ((struct fds *)arg)-&gt;sockfd;</span><br><span class="line">    <span class="keyword">int</span> epollfd = ((struct fds *)arg)-&gt;epollfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            close(sockfd);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed the connection!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当数据读完后，需要重新设置 ONESHOT 标记</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">                reset_oneshot(epollfd, sockfd);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;read laster\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf[ret] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread: %lu, get contents: %s\n&quot;</span>, pthread_self(), buf);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread: %lu done.\n&quot;</span>, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> server_fd = socket(server_addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(server_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(server_fd, (struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(server_fd, MAX_EVENT_NUMBER);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(MAX_EVENT_NUMBER);</span><br><span class="line">    assert(epoll_fd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    addfd(epoll_fd, server_fd, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sockfd == server_fd) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(server_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">                addfd(epoll_fd, connfd, <span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread;</span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">fds</span> <span class="title">new_fds</span>;</span></span><br><span class="line"></span><br><span class="line">                new_fds.epollfd = epoll_fd;</span><br><span class="line">                new_fds.sockfd = sockfd;</span><br><span class="line"></span><br><span class="line">                pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="keyword">void</span> *)&amp;new_fds);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;something is wrong\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(server_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的 <code>sleep()</code> 是为了模拟该线程正在对此事件进行处理，可以通过多个 <code>telnet</code> 客户端来给服务端发送数据。</p>
<p>可以看到：每个 <code>telent</code> 都有对应的唯一一个处理线程，在处理时间内发送新数据，原来的线程会继续处理。</p>
<h1 id="三组-I-O-复用函数的比较"><a href="#三组-I-O-复用函数的比较" class="headerlink" title="三组 I/O 复用函数的比较"></a>三组 I/O 复用函数的比较</h1><table>
<thead>
<tr>
<th>系统调用</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>事件集合</td>
<td>用户通过 3 个参数分别传入可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈就绪事件。导致用户每次调用都要重置这 3 个参数</td>
<td>统一处理所有事件类型，因此只需一个事件集参数。用户通过 events 传入事件，内核通过修改 revents 反馈就绪事件</td>
<td>内核通过事件表管理事件。所以每次调用 epoll_wait 时不用反复传入用户感兴趣的事件。 epoll_wait 参数 events 仅用来反馈就绪事件</td>
</tr>
<tr>
<td>应用程序索引就绪文件描述符的事件复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>一般有最大值限制</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>工作模式</td>
<td>LT</td>
<td>LT</td>
<td>LT，ET</td>
</tr>
<tr>
<td>内核实现和工作效率</td>
<td>采用轮询方式来检测就绪事件，事件复杂度为 O(n)</td>
<td>采用轮询方式检测就绪事件，事件复杂度为 O(n)</td>
<td>采用回调方式检测就绪事件，算法事件复杂度为 O(1)</td>
</tr>
</tbody></table>
<h1 id="非阻塞-connect"><a href="#非阻塞-connect" class="headerlink" title="非阻塞 connect"></a>非阻塞 connect</h1><p>一个客户端为了能够同时发起多个连接，可以以非阻塞的方式调用 <code>connect()</code> ：</p>
<ul>
<li>将 socket 设置为非阻塞状态，然后调用 <code>connect()</code> </li>
<li>使用 <code>select()</code> , <code>poll()</code> 等来监听这些  socket  上的可写事件</li>
<li>当 <code>select()</code> , <code>poll()</code> 返回时，调用 <code>getsockopt()</code> 来读取错误码判断连接是否成功（选项为 SO_ERROR，层级为 SOL_SOCKET）<ul>
<li>当错误码为 0 时代表连接成功</li>
</ul>
</li>
</ul>
<p><strong>目前这种方式并不适用于所有系统</strong></p>
<p>如下示例代码，使用 poll 来并发检查 connect 状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONNECT_NUM (5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_opt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_opt = old_opt | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETFL, new_opt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;hostname&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host_info</span> =</span> gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    assert(host_info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have found the ip address of host %s is:\n&quot;</span>, host_info-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, host_info-&gt;h_addrtype == AF_INET ? <span class="string">&quot;ipv4&quot;</span> : <span class="string">&quot;ipv6&quot;</span>,</span><br><span class="line">        inet_ntoa(*(struct in_addr *)host_info-&gt;h_addr_list[i]));</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (host_info-&gt;h_addr_list[i]);</span><br><span class="line"></span><br><span class="line">    socket_addr.sin_addr.s_addr = *(<span class="keyword">uint32_t</span> *)host_info-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_fd[CONNECT_NUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fdset</span>[<span class="title">CONNECT_NUM</span>];</span></span><br><span class="line">    <span class="keyword">int</span> socket_opt;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONNECT_NUM; i++) &#123;</span><br><span class="line">        socket_fd[i] = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">        socket_opt = set_nonblocking(socket_fd[i]);</span><br><span class="line"></span><br><span class="line">        ret = connect(socket_fd[i], (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately!\n&quot;</span>);</span><br><span class="line">            <span class="comment">//如果已经连接成功，则恢复默认设置</span></span><br><span class="line">            fcntl(socket_fd[i], F_SETFL, socket_opt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>((ret != EINPROGRESS) &amp;&amp; (errno != EINPROGRESS)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;connect failed!\n&quot;</span>);</span><br><span class="line">            close(socket_fd[i]);</span><br><span class="line">            ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONNECT_NUM; i++) &#123;</span><br><span class="line">        fdset[i].fd = socket_fd[i];</span><br><span class="line">        fdset[i].events = POLLOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 poll 检测是否有写事件</span></span><br><span class="line">    <span class="keyword">if</span> (poll(fdset, CONNECT_NUM, <span class="number">-1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;poll failed:&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> error1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONNECT_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdset[i].revents &amp; POLLOUT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getsockopt(fdset[i].fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;gesockopt failed:&quot;</span>);</span><br><span class="line">                close(fdset[i].fd);</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;connection failed: %d\n&quot;</span>, error);</span><br><span class="line">                close(fdset[i].fd);</span><br><span class="line">                ret = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发生了写事件，并且返回为 0，则代表已经连接成功</span></span><br><span class="line">            <span class="comment">// 然后需要将文件属性恢复到以前的默认值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;socket %d connection succedded!\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">            fcntl(fdset[i].fd, F_SETFL, socket_opt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">error1:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONNECT_NUM; i++) &#123;</span><br><span class="line">        close(socket_fd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h1><p>使用 I/O 复用实现服务器同时处理网络连接和用户输入。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端实现两个功能：</p>
<ol>
<li>从标准输入读入用户数据，并发送至服务器</li>
<li>接收服务器的数据并打印至终端</li>
</ol>
<p>对于客户端来说，有用户输入和 socket 输入，并有 socket 输出和终端输出，所以可以用 I/O 复用函数来监听两个输入，然后对应输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECV_BUF_SIZE   (250)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;hostname&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host_info</span> =</span> gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    assert(host_info);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have found the ip address of host %s is:\n&quot;</span>, host_info-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %s\n&quot;</span>, host_info-&gt;h_addrtype == AF_INET ? <span class="string">&quot;ipv4&quot;</span> : <span class="string">&quot;ipv6&quot;</span>,</span><br><span class="line">        inet_ntoa(*(struct in_addr *)host_info-&gt;h_addr_list[i]));</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (host_info-&gt;h_addr_list[i]);</span><br><span class="line"></span><br><span class="line">    socket_addr.sin_addr.s_addr = *(<span class="keyword">uint32_t</span> *)host_info-&gt;h_addr_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(socket_addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(socket_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = connect(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fd</span>[2];</span></span><br><span class="line">    <span class="keyword">char</span> recv_buf[RECV_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 socket 和标准输入是否有输入事件</span></span><br><span class="line">        poll_fd[<span class="number">0</span>].fd = socket_fd;</span><br><span class="line">        poll_fd[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">        poll_fd[<span class="number">1</span>].fd = STDIN_FILENO;</span><br><span class="line">        poll_fd[<span class="number">1</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">        poll(poll_fd, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poll_fd[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, RECV_BUF_SIZE);</span><br><span class="line">            <span class="comment">// 如果是 socket 有输入，则发出到标准输出</span></span><br><span class="line">            recv(socket_fd, recv_buf, RECV_BUF_SIZE, MSG_DONTWAIT);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, recv_buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(poll_fd[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 如果是标准输入有输入，则发送给服务端</span></span><br><span class="line">            <span class="keyword">char</span> *buf = fgets(recv_buf, RECV_BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">if</span> (buf) &#123;</span><br><span class="line">                send(socket_fd, recv_buf, <span class="built_in">strlen</span>(recv_buf), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;something is wrong:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端主要功能是接收数据，并将数据发送给每个登录到该服务器上的除数据发送者的客户端，可以使用 I/O 复用函数来监听连接和数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXIMUM_CLIENT_NUM  (5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXIMUM_RECV_BUF    (250)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> client_cnt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> client_fds[MAXIMUM_CLIENT_NUM];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> buf[MAXIMUM_RECV_BUF];</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">poll_fd</span>[<span class="title">MAXIMUM_CLIENT_NUM</span> + 1];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">client_add</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (client_cnt &lt; MAXIMUM_CLIENT_NUM - <span class="number">1</span>) &#123;</span><br><span class="line">        client_fds[++client_cnt] = fd;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">client_del</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (client_cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; client_cnt + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_fds[i] == fd) &#123;</span><br><span class="line">                client_fds[i] = client_fds[client_cnt];</span><br><span class="line">                client_fds[client_cnt] = <span class="number">-1</span>;</span><br><span class="line">                client_cnt -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXIMUM_CLIENT_NUM; ++i) &#123;</span><br><span class="line">        client_fds[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(socket_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    ret = bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m waiting for client.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        poll_fd[<span class="number">0</span>].fd = socket_fd;</span><br><span class="line">        poll_fd[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; client_cnt + <span class="number">2</span>; i++) &#123;</span><br><span class="line">            poll_fd[i].fd = client_fds[i - <span class="number">1</span>];</span><br><span class="line">            poll_fd[i].events = POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        poll(poll_fd, client_cnt + <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; client_cnt + <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (poll_fd[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (poll_fd[i].fd == socket_fd) &#123;</span><br><span class="line">                    <span class="comment">//accept</span></span><br><span class="line">                    <span class="keyword">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                    <span class="keyword">socklen_t</span>     addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                    <span class="keyword">if</span> ((client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;accept failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (client_add(client_fd) == <span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client fd buffer is full!\n&quot;</span>);</span><br><span class="line">                        close(client_fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> recv_size = recv(poll_fd[i].fd, buf, MAXIMUM_RECV_BUF, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (recv_size == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;close one client!\n&quot;</span>);</span><br><span class="line">                        client_del(poll_fd[i].fd);</span><br><span class="line">                        close(poll_fd[i].fd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; client_cnt + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (poll_fd[i].fd != client_fds[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                                send(client_fds[j - <span class="number">1</span>], buf, recv_size, <span class="number">0</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="同时处理-TCP-和-UDP-服务"><a href="#同时处理-TCP-和-UDP-服务" class="headerlink" title="同时处理 TCP 和 UDP 服务"></a>同时处理 TCP 和 UDP 服务</h1><p>由于一个 socket 只能绑定一个地址（IP 地址和端口号），对于同一个服务器来说如果要同时监听多个端口（提供不同的服务类型），那么就必须创建多个 socket 对应绑定不同的端口号，然后使用 I/O 复用技术监听这多个端口号。</p>
<p>即使是同一个端口，如果服务器要同时处理该端口上的 TCP 和 UDP 请求，也需要创建两个不同的 socket。一个用于流式，一个用于数据报式，并且将它们绑定到同一个端口上。</p>
<p>如下示例则是服务器同时处理同一端口上的 TCP 和 UDP 请求：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER (1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE  (512)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE  (1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_opt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_opt = old_opt | O_NONBLOCK;</span><br><span class="line">    fcntl(fd, F_SETFL, new_opt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_tcp = socket(addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(socket_tcp &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(socket_tcp, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(socket_tcp, <span class="number">5</span>);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> socket_udp = socket(addr.sin_family, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    assert(socket_udp &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(socket_udp, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epollfd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    addfd(epollfd, socket_tcp);</span><br><span class="line">    addfd(epollfd, socket_udp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll wait failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> (sockfd == socket_tcp) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                <span class="keyword">int</span> client_fd = accept(socket_tcp, (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line">                assert(client_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tcp client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">                addfd(epollfd, client_fd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sockfd == socket_udp) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">                <span class="built_in">memset</span>(buf, <span class="number">0</span>, UDP_BUFFER_SIZE);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">                ret = recvfrom(socket_udp, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                (struct sockaddr *)&amp;client_addr, &amp;addr_len);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;udp client: %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">                <span class="comment">// UDP 发送什么，就回传什么</span></span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sendto(socket_udp, buf, ret, <span class="number">0</span>, (struct sockaddr *)&amp;client_addr, addr_len);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(buf, <span class="number">0</span>, UDP_BUFFER_SIZE);</span><br><span class="line">                    ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 回传</span></span><br><span class="line">                        send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;something is wrong\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(socket_tcp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端使用 <code>telnet</code> 测试 TCP 连接， <code>nc</code> 测试 UDP 连接。</p>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 高级 I/O 函数</title>
    <url>/2022/06/09/net_base_io/</url>
    <content><![CDATA[<p>Linux 提供的高级 IO 函数，虽然不常用，但能提供优异的性能。</p>
<span id="more"></span>

<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h1><p>管道具有如下特点：</p>
<ol>
<li>半双工通信，数据流是单向的</li>
<li>管道只能用于两个有亲缘关系进程间通信，一般是父子进程间通信</li>
</ol>
<blockquote>
<p>FIFO 突破了第二点限制，socket 突破了以上两点限制。</p>
</blockquote>
<p>shell 用经常使用管道来将一个命令的输出作为下一个命令的输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat abc.txt | grep &quot;123&quot;</span><br></pre></td></tr></table></figure>

<h2 id="数据流方式"><a href="#数据流方式" class="headerlink" title="数据流方式"></a>数据流方式</h2><p>pipe 有两种数据流方式：</p>
<ol>
<li>数据在一个进程内在用户空间交互</li>
<li>数据经过了内核 pipe 进行交互</li>
</ol>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter6/pipe_two_ways.jpg?raw=true">在实际使用中，用得最多的是父子进程间的通信</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter6/pipe_fork.jpg?raw=true"></p>
<ul>
<li>当写端的被关闭时，读端读取时将会返回0</li>
<li>当读端被关闭时，写端写入时将会返回 -1 ,此时 <code>errno</code> 的值为 <code>EPIPE</code> ，还会接受到信号 <code>SIGPIPE</code></li>
<li>宏 <code>PIPE_BUF</code> 指定了内核 pipe 的大小(字节)，可以通过 <code>pathconf</code> 或 <code>fpathconf</code> 来设置此值</li>
</ul>
<p>其 API 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建两个pipe</span></span><br><span class="line"><span class="comment"> * @param fd: 包含两个元素的数组</span></span><br><span class="line"><span class="comment"> * @note fd[0] 代表当前进程读端，fd[1]代表当前进程写端。</span></span><br><span class="line"><span class="comment"> * 当只使用其中一个描述符时，需要关掉另一个描述符</span></span><br><span class="line"><span class="comment"> * @ret 0 : 创建成功 -1 : 创建失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_LEN  (20)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_LEN];</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;Hello world!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFER_LEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一对读写管道</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = pipe(fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not create pipe:&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can not fork process:&quot;</span>);</span><br><span class="line">        ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> quick_out;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭父进程的读通道</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> ((ret = write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Can not write data to pipe:&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> quick_out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭子进程的写通道</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ret = read(fd[<span class="number">0</span>], buf, BUFFER_LEN)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Can not read data from pipe!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> quick_out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process received data: %s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quick_out:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair"></a>socketpair</h2><p>对于 socket 而言，创建 pipe 最合理的方式是使用<code>socketpair()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span>          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>socketpair()</code>参数列表前 3 个与 <code>socket()</code>一样，只是其<code>domain</code>只能是<code>AF_UNIX</code></li>
<li><code>socketpair()</code>创建的描述符都是双向的</li>
</ul>
<h1 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到一个文件描述符副本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span>              <span class="comment">/* Obtain O_* constant definitions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup3</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>dup</code> 得到文件描述符副本，副本和原文件描述符指向同一个文件。</p>
<p>dup 的关键在于： <strong>返回当前可用的最小描述符</strong></p>
<p>比如先关闭标准输出，然后立即调用 dup，此时 dup 返回最小描述符则是 1。<br>也就是说 1 和当前文件描述符指向同一个文件，那么调用 <code>printf</code> 时，内容也就写入文件了。</p>
<p>看下面示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;./output&quot;</span>, O_CREAT | O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;create file failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This message is before dup\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">int</span> ret_fd = dup(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This message is after dup\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dup return fd is %d\n&quot;</span>, ret_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会将<code>dup()</code>后的<code>printf</code>内容，输出到 output 文件中。</p>
<h1 id="readv-和-writev"><a href="#readv-和-writev" class="headerlink" title="readv 和 writev"></a>readv 和 writev</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>  *iov_base;    <span class="comment">/* Starting address */</span></span><br><span class="line">    <span class="keyword">size_t</span> iov_len;     <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从 fd 读取内容到分散的 iov 指向的内存中</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 iov 指向的分散的内存写入到 fd 中 </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">preadv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwritev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与<code>recvmsg(),sendmsg()</code>类似。</p>
<h1 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从 in_fd 的 offset 处拷贝 count 字节到 out_fd 中</span></span><br><span class="line"><span class="comment">//in_fd 对象必须能支持 mmap 类操作，out_fd 可以是任意文件</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span> *offset, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sendfile 是零拷贝函数，因为是在内核中完成文件内容的复制，就没有用户空间到内核空间这一层的拷贝了。</p>
<ul>
<li>显然这样的操作效率更高</li>
</ul>
<p>下面验证服务端将一个文件发送给客户端，服务端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt; &lt;filepath&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind socket and address failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m waiting for client...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//accept</span></span><br><span class="line">    <span class="keyword">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">if</span> ((client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connected to client ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">    inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send file %s to client\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_fd = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span></span><br><span class="line">    fstat(file_fd, &amp;file_stat);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sendfile(client_fd, file_fd, <span class="literal">NULL</span>, file_stat.st_size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendfile failed:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(client_fd);</span><br><span class="line">    close(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>telnet</code> 连接服务端后便可以获取到该文件了</p>
<h1 id="mmap-和-munmap"><a href="#mmap-和-munmap" class="headerlink" title="mmap 和 munmap"></a>mmap 和 munmap</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 fd 的 offset 处开始的内存映射 length 字节到 addr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>prot 设置内存段的访问权限：</p>
<ul>
<li>PROT_READ : 可读</li>
<li>PROT_WRITE: 可写</li>
<li>PROT_EXEC: 可执行</li>
<li>PROT_NONE: 不能被访问</li>
</ul>
<p>flags 控制内存段内容被修改后程序的行为：</p>
<ul>
<li>MAP_SHARED: 共享内存，对内存的修改被映射到文件中</li>
<li>MAP_PRIVATE: 私有内存，对内存的修改不会被映射到文件中</li>
<li>MAP_ANONYMOUS: 这段内存不是从文件映射来的，内容被初始化为全 0</li>
<li>MAP_FIXED: 内存段必须位于 addr 参数指定的地址处，start 必须与内存页对齐</li>
<li>MAP_HUGETLB: 按照大内存页面来分配内存空间</li>
</ul>
<h1 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将 fd_in 从 off_in 处拷贝 len 字节到 fd_out 的 off_out 处</span></span><br><span class="line"><span class="comment">// fd_in 和 fd_out 中必须至少有一个是管道文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span> *off_in, <span class="keyword">int</span> fd_out,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">loff_t</span> *off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>此函数也是直接在内核操作，属于零拷贝高效率操作。</p>
<p>flags 控制数据如何移动：</p>
<ul>
<li>SPLICE_F_MOVE : 内核尝试按整页移动数据</li>
<li>SPLICE_F_NONBLOCK : 以非阻塞的形式操作</li>
<li>SPLICE_F_MORE: 提示内核后续还会读取更多数据</li>
</ul>
<h1 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//复制两个管道文件描述符之间的数据，不消耗数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">int</span> fd_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对文件描述符控制</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 定时器</title>
    <url>/2022/06/13/net_base_linux_timer/</url>
    <content><![CDATA[<p>理解在用户空间中使用定时器。</p>
<p>Linux 提供了 3 种定时方法：</p>
<ol>
<li>socket 选项 SO_RECVTIMEO 和 SO_SNDTIMEO</li>
<li>SIGALRM 信号</li>
<li>I/O 复用系统调用的超时参数</li>
</ol>
<span id="more"></span>

<h1 id="socket-选项-SO-RECVTIMEO-和-SO-SNDTIMEO"><a href="#socket-选项-SO-RECVTIMEO-和-SO-SNDTIMEO" class="headerlink" title="socket 选项 SO_RECVTIMEO 和 SO_SNDTIMEO"></a>socket 选项 SO_RECVTIMEO 和 SO_SNDTIMEO</h1><p>SO_RECVTIMEO 和 SO_SNDTIMEO 分别对应设置接收和发送超时。</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>有效选项</th>
<th>系统调用超时后的行为</th>
</tr>
</thead>
<tbody><tr>
<td>send</td>
<td>SO_SNDTIMEO</td>
<td>返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK</td>
</tr>
<tr>
<td>sendmsg</td>
<td>SO_SNDTIMEO</td>
<td>返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK</td>
</tr>
<tr>
<td>recv</td>
<td>SO_RCVTIMEO</td>
<td>返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK</td>
</tr>
<tr>
<td>recvmsg</td>
<td>SO_RCVTIMEO</td>
<td>返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK</td>
</tr>
<tr>
<td>accept</td>
<td>SO_RCVTIMEO</td>
<td>返回 -1，errno 的值为 EAGAIN 或 EWOULDBLOCK</td>
</tr>
<tr>
<td>connect</td>
<td>SO_SNDTIMEO</td>
<td>返回 -1，errno 的值为 EINPROGRESS</td>
</tr>
</tbody></table>
<p>如下所示为 socket 使用<code>connect</code> 超时的设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;ip&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock_fd = socket(address.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sock_fd &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超时时间为 5 s</span></span><br><span class="line">    timeout.tv_sec = <span class="number">5</span>;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(timeout);</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(sock_fd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = connect(sock_fd, (struct sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;connecting timeout\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        perror(<span class="string">&quot;connect failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="SIGALRM-信号"><a href="#SIGALRM-信号" class="headerlink" title="SIGALRM 信号"></a>SIGALRM 信号</h1><p><code>SIGALRM</code>和<code>setitimer</code>使用，可以实现高效的定时机制。</p>
<p>比如下面这段代码就使用实时定时器实现每隔 10ms 输出一次字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span><span class="params">(*pfunc)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerSet</span><span class="params">(<span class="keyword">uint64_t</span> microsecond)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">its</span>;</span></span><br><span class="line"></span><br><span class="line">    its.it_value.tv_sec = microsecond / <span class="number">1000000</span>;</span><br><span class="line">    its.it_value.tv_usec = microsecond % <span class="number">1000000</span>;</span><br><span class="line">    its.it_interval.tv_sec = its.it_value.tv_sec;</span><br><span class="line">    its.it_interval.tv_usec = its.it_value.tv_usec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setitimer(ITIMER_REAL, &amp;its, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer failed: &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerStart</span><span class="params">(<span class="keyword">uint64_t</span> microsecond, <span class="keyword">void</span>(*func)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    pfunc = func;</span><br><span class="line"></span><br><span class="line">    TimerSet(microsecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerStop</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stop time!\n&quot;</span>);</span><br><span class="line">    TimerSet(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stop_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TimerHandler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;received sig: %d\n&quot;</span>, sig);</span><br><span class="line">    <span class="keyword">if</span> (pfunc) &#123;</span><br><span class="line">        pfunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UserFunc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (++stop_cnt &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        stop_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        TimerStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGALRM, TimerHandler) == SIG_ERR) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t bind signal:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimerStart(<span class="number">500000</span>, UserFunc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 服务器程序规范</title>
    <url>/2022/06/10/net_base_norm/</url>
    <content><![CDATA[<p>Linux 服务器程序有一些基本的规范：</p>
<ul>
<li>Linux 服务器程序以守护进程的方式运行</li>
<li>Linux 服务器程序通常有一套日志系统，一般在 <code>var/log</code> 目录下有自己的日志目录<ul>
<li>如果是使用 c++ 的话，那记录日志使用 <a href="https://github.com/gabime/spdlog">spdlog</a> 是个很好的选择</li>
</ul>
</li>
<li>Linux 服务器程序一般会创建一个用户来运行自己的程序</li>
<li>Linux 服务器程序的配置文件存放在<code>/etc</code>目录下</li>
<li>Linux 服务器程序在启动后会在<code>/var/run</code>目录中生成一个 PID 文件，以记录进程 PID</li>
<li>Linux 服务器进程需要考虑系统资源和限制，以预测自身能够承受多大负荷</li>
</ul>
<span id="more"></span>

<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="Linux-系统日志"><a href="#Linux-系统日志" class="headerlink" title="Linux 系统日志"></a>Linux 系统日志</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter7/log_struct.jpg?raw=true"><br>Linux 提供了 <code>rsyslogd</code> 守护进程来处理系统日志，它既能够接收用户进程输出日志，又可以接收内核日志。</p>
<ul>
<li>用户进程调用 <code>syslog()</code> 函数生成日志，该函数将日志输出到 <code>AF_UNIX</code> 类型的文件 <code>/dev/log</code> 中, <code>rsyslogd</code> 监听 <code>/dev/log</code> 将内存输出至 <code>/var/log/</code><ul>
<li>进程日志的存放位置由 <code>/etc/rsyslog.d/*.conf</code> 文件指定</li>
</ul>
</li>
<li>内核日志由 <code>printk</code> 等函数打印到内核环形缓存，其内容被映射到 <code>/proc/kmsg</code> , <code>rsyslogd</code> 读取该文件后存储日志<ul>
<li>内核日志被存放于 <code>/var/log/kern.log</code>   </li>
</ul>
</li>
</ul>
<h2 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// openlog 和 closelog 是可选函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ident, <span class="keyword">int</span> option, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有打印等级符合 mask 的日志才被存储</span></span><br><span class="line"><span class="comment">//等级的 mask 由宏 LOG_MASK(priority) 获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> mask)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>priority</code> 指定日志级别，默认值是 <code>LOG_USER</code> ，可选值有：</p>
<ul>
<li><code>LOG_EMERG</code> ： 系统不可用</li>
<li><code>LOG_ALERT</code> ：报警，需要立即采取动作</li>
<li><code>LOG_CRIT</code> ：严重情况</li>
<li><code>LOG_ERR</code> ：错误</li>
<li><code>LOG_WARNING</code> ：警告</li>
<li><code>LOG_NOTICE</code> ：通知</li>
<li><code>LOG_INFO</code> ：信息</li>
<li><code>LOG_DEBUG</code> ：调试</li>
</ul>
<p><code>openlog()</code> 可以在日志中添加附加信息：</p>
<ul>
<li><code>ident</code> : 指定的字符串将被附加到日志之后，当设置为 NULL，则为程序名称</li>
<li><code>option</code> : 指定打印行为，比如是否包含 PID，是否延迟打开日志等</li>
<li><code>facility</code> : 说明输出日志的程序属于哪种类别</li>
</ul>
<p><code>setlogmask()</code> 设置日志的打印级别，这样在不用的应用场景可以屏蔽一些冗余输出。</p>
<h1 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h1><h2 id="UID-EUID-GID-EGID"><a href="#UID-EUID-GID-EGID" class="headerlink" title="UID,EUID,GID,EGID"></a>UID,EUID,GID,EGID</h2><p>UID : 运行该进程的用户 ID</p>
<p>EUID : 该程序所有者的真实用户 ID,当该程序权限设置了 <code>set-user-id</code> 标志后，运行该程序的用户就可以以文件所有者的权限来执行</p>
<ul>
<li>比如 <code>su</code> 程序就具有 <code>set-user-id</code> 标志，这样才能够修改自身密码</li>
</ul>
<blockquote>
<p>GID（运行该进程的组 ID），EGID（程序所有者的组 ID）同理</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取真实用户 ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取有效用户 ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取真实组 ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取有效组 ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置真实用户 ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="comment">//设置有效用户 ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="comment">//设置真实组 ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="comment">//设置有效组 ID</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p>以下代码将以 <code>root</code> 身份启动的进程切换为以普通用户身份运行：</p>
<ul>
<li>以 <code>root</code> 身份运行该代码即可查看效果<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">(<span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//确保目标用户不是 root</span></span><br><span class="line">    <span class="keyword">if</span> ((user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error:Can&#x27;t change to root!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前用户是普通用户，则不用切换</span></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((setgid(gp_id) &lt; <span class="number">0</span>) || (setuid(user_id) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Change id error:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before switch, uid = %d, gid = %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line"></span><br><span class="line">    switch_to_user(<span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after switch, uid = %d, gid = %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="进程关系"><a href="#进程关系" class="headerlink" title="进程关系"></a>进程关系</h1><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程都归属于一个组，所以进程包含进程 ID（PID）和进程组 ID（PGID）。</p>
<p>当一个进程的 PID 等于 PGID 时，此进程便是该进程组的首领进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//获取父进程 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取组 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">//设置组 ID,将 PID 为 pid 的进程的 PGID 设置为 pgid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>一些有关联的进程组将形成一个会话(session)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个会话</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//得到会话 ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用此函数后：</p>
<ul>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员</li>
<li>新建一个进程组，其 PGID 与调用进程的 PID 一致，也就是调用进程也是该组的首领</li>
<li>调用进程将脱离终端</li>
</ul>
<p>可以使用命令 <code>ps -o pid,ppid,pgid,sid,comm | less</code> 来查看几个 ID 的值。</p>
<h1 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h1><p>linux 资源限制使用如下函数读取和设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="comment">//软限制，建议限制，若超过此时，系统可能会终止其运行</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="comment">//硬限制，软限制的上限，普通程序可以减小，只有 root 可以增大</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resource 指定资源类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prlimit</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *new_limit,</span></span></span><br><span class="line"><span class="params"><span class="function">          struct rlimit *old_limit)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>resource</code> 有些重要设置：</p>
<ul>
<li><code>RLIMIT_AS</code> : 虚拟内存总限制，超过将产生 <code>ENOMEM</code> 错误</li>
<li><code>RLIMIT_CORE</code> : 核心转储文件大小限制</li>
<li><code>RLIMIT_CPU</code> : CPU 时间限制</li>
<li><code>RLIMIT_DATA</code> : 数据段限制（data,bss,堆）</li>
<li><code>RLIMIT_NOFILE</code> : 文件描述符数量限制，超过将产生 <code>EMFILE</code> 错误</li>
<li><code>RLIMIT_FSIZE</code> : 文件大小限制，超过将产生 <code>EFBIG</code> 错误</li>
<li><code>RLIMIT_NPROC</code> : 用户能创建的进程数限制，超过将产生 <code>EAGAIN</code> 错误</li>
<li><code>RLIMIT_SIGPENDING</code> : 用户能够挂起的信号数量限制</li>
<li><code>RLIMIT_STACK</code> : 进程栈内存限制，超过将产生 <code>SIGSEGV</code> 信号</li>
</ul>
<h1 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h1><p>一些服务程序需要修改工作目录和逻辑根目录：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//得到当前工作目录绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//切换工作目录到 path 指定的目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="comment">//改变进程逻辑根目录，而当前工作目录并不会切换，所以一般还会在后面加上 chdir(&quot;/&quot;) 函数以切换工作目录</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h1><p>linux 提供了 <code>daemon</code> 函数完成将当前进程切换为守护进程的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当 nochdir 为 0 时，工作目录将被设置为 “/” 根目录，否则继续使用当前目录</span></span><br><span class="line"><span class="comment">//当 noclose 为 0 时，标准输入、标准输出、标准错误输出都会被重定向到 /dev/null 文件，否则依然使用原来设备</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其目的就是为了让当前进程脱离 shell 并且其输出不会出现在终端之上。</p>
<p>下面的代码演示如何将一个进程以守护进程的方式运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程，并关闭父进程，使得程序在后台运行</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Can&#x27;t fork:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置文件权限掩码，当进程创建新文件时，文件的权限将是 mode &amp; 0777</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新会话，本进程即为进程组的首领，其 PID，PGID，SID 一致</span></span><br><span class="line">    <span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line">    <span class="keyword">if</span>(sid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsid() error:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换工作目录到根目录</span></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭标准输入、输出，标准错误输出</span></span><br><span class="line">    close(STDIN_FILENO);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    close(STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向标准输入、输出，标准错误到 /dev/null</span></span><br><span class="line">    open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">    open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (daemonize() == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;change to background failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;can you see this message? \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能服务器程序框架</title>
    <url>/2022/06/11/net_base_server_framework/</url>
    <content><![CDATA[<p>理解服务器是如何区分 I/O 密集型和 CPU 密集型任务的。</p>
<span id="more"></span>

<h1 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h1><h2 id="C-S-（客户端-服务器）模型"><a href="#C-S-（客户端-服务器）模型" class="headerlink" title="C/S （客户端/服务器）模型"></a>C/S （客户端/服务器）模型</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/struct_cs.jpg?raw=true"><br>虽然 TCP/IP 协议并没有客户端和服务器的概念，节点之间都是对等的。但由于资源的集中性，最常用的便是 C/S 模型：所有的客户端都通过访问服务器来获取所需资源。</p>
<p>C/S 模型实现起来简单，但其缺点是：当访问量过大时，所有的客户端得到的响应速度都可能慢下来。</p>
<h2 id="P2P-（点对点）模型"><a href="#P2P-（点对点）模型" class="headerlink" title="P2P （点对点）模型"></a>P2P （点对点）模型</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/p2p_view.jpg?raw=true"><br>P2P（Peer to Peer, 点对点）模型，使得每台机器在消耗服务的同时，也给别人提供服务，所有主机回归对等的地位。</p>
<p>P2P 模型使得资源能够充分、自由地共享，但当用户之间传输的请求过多时，网络的负载将加重。</p>
<p>实际使用的 P2P 模型通常都会带有一个专门的发现服务器，此服务器主要提供查找服务，使得每个客户都能尽快地找到自己需要的资源。</p>
<h1 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/program_struct.jpg?raw=true"><br>如上图，服务器各个部件的含义和功能如下表：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>单个服务器程序</th>
<th>服务器机群</th>
</tr>
</thead>
<tbody><tr>
<td>I/O 处理单元</td>
<td>处理客户连接，读写网络数据</td>
<td>作为接入服务器，实现负载均衡</td>
</tr>
<tr>
<td>逻辑单元</td>
<td>业务进程或线程</td>
<td>逻辑服务器</td>
</tr>
<tr>
<td>网络存储单元</td>
<td>本地数据库、文件或缓存</td>
<td>数据库服务器</td>
</tr>
<tr>
<td>请求队列</td>
<td>各单元之间的通信方式</td>
<td>各服务器之间的永久 TCP 连接</td>
</tr>
</tbody></table>
<p>I/O 处理单元用于管理服务器和客户端之间的连接，主要职责：</p>
<ul>
<li>等待并接收新的客户连接</li>
<li>接收客户数据和将服务器响应数据返回给客户端<ul>
<li>数据收发也可能在逻辑单元中执行</li>
</ul>
</li>
<li>对于机群来说，I/O 处理单元就是一个专门的接入服务器，实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来服务客户。</li>
</ul>
<p>逻辑单元通常是一个进程或线程，它分析并处理客户数据，然后将结果传递给 I/O 处理单元或直接发送给客户端。对机群来说，一个逻辑单元就是一台逻辑服务器。</p>
<p>网络存储单元可以是数据库、缓存、文件、服务器，但不是所有的服务都需要存储功能。</p>
<p>请求队列是各个单元之间通信方式的抽象。请求队列通常被实现为池的一部分。对于服务机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的 TCP 连接。</p>
<h1 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h1><p>I/O 分为阻塞和非阻塞，非阻塞只有在事件已经发生的情况下操作才能提高程序效率（否则就是不断的查询，也消耗 CPU 资源），需要配合 I/O 复用和 SIGIO 信号。</p>
<ul>
<li>I/O 复用函数有 select、poll、epoll_wait，它们本身是阻塞的，但它们具有同时监听多个 I/O 事件的能力</li>
<li>将 SIGIO 信号与宿主进程绑定，当事件发生时，对应的信号处理函数被触发，就可以对相应目标文件执行非阻塞 I/O 操作了</li>
</ul>
<p>阻塞 I/O、I/O 复用和 SIGIO 都是同步 I/O 模型，<strong>因为它们都是在 I/O 事件发生之后再执行相应的读写操作，读写操作真正发生在用户空间。</strong></p>
<p>对异步 I/O 而言，用户可以提前将 I/O 操作的缓存告知内核，内核待时机一到便执行相应的 I/O 操作，然后通知用户空间操作完成，<strong>读写操作真正发生在内核空间。</strong></p>
<h1 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h1><p>服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。</p>
<p>对应事件有两种高效处理模式： Reactor 和 Proactor。</p>
<ul>
<li>同步 I/O 模型通常用于实现 Reactor 模式</li>
<li>异步 I/O 模型通常用于实现 Proactor 模式</li>
</ul>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>Reactor 模式要求主线程（I/O 处理单元）只负责监听文件描述符上是否有事件发生，有的话就将该事件通知工作线程（逻辑单元）。除此之外，主线程不做其他工作。读写数据、接收新连接以及处理客户请求都在工作线程中完成。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/reactor_overview.jpg?raw=true"><br>使用同步 I/O 模型实现 Reactor 模式的工作流程是：</p>
<ol>
<li>主线程向 I/O 复用函数注册 socket 上的读就绪事件</li>
<li>主线程调用 I/O 复用函数等待 socket 上有数据可读</li>
<li>当 socket 上有数据可读时， I/O 复用函数通知主线程，主线程将 socket 可读事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据并处理请求，然后往 I/O 复用函数注册写就绪事件（如果需要返回数据的话）</li>
<li>主线程调用 I/O 复用函数等待 socket 可写</li>
<li>当 socket 可写时，I/O 复用函数通知主线程，主线程将 socket 可写事件放入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果</li>
</ol>
<p>主线程的主要目的就是监听 socket 是否可读可写，然后将对应事件放入请求队列，相当于是 I/O 密集型任务。</p>
<p>工作线程是不用关心 socket 当前是否可读可写的，只要它被唤醒了，那只需要根据事件类型执行相应操作即可，相当于是 CPU 密集型任务。</p>
<p>这种模式就充分利用了 IO 密集型的快速响应特点，也使得处理用户请求的吞吐量上去了。</p>
<h2 id="Proactor-模式"><a href="#Proactor-模式" class="headerlink" title="Proactor 模式"></a>Proactor 模式</h2><p>Proactor 模式将所有的 I/O 操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑，这种方式看起来更加优雅。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/proactor_overview.jpg?raw=true"><br>使用异步 I/O 模型实现 Proactor 模式的工作流程是：</p>
<ol>
<li>主线程调用异步 I/O 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑</li>
<li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用异步写函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑</li>
<li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理。</li>
</ol>
<p>可以看到，这种模式下复用 I/O 仅仅用于监听连接请求，工作线程仅仅用于处理业务，而读写则是由内核来完成。</p>
<h2 id="模拟-Proactor-模式"><a href="#模拟-Proactor-模式" class="headerlink" title="模拟 Proactor 模式"></a>模拟 Proactor 模式</h2><p>同步 I/O 模拟 Proactor 模式的原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知完成事件。</p>
<blockquote>
<p>也就是把原来工作线程需要完成的读写工作，移交给了主线程，工作线程就只管处理业务逻辑了。</p>
</blockquote>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/simulate_proactor.jpg?raw=true"><br>工作流程如下：</p>
<ol>
<li>主线程向 I/O 复用函数注册读就绪事件</li>
<li>主线程等待 socket 上有数据可读</li>
<li>当 socket 上有数据可读时， I/O 复用函数通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后向 I/O 复用函数注册写就绪事件</li>
<li>主线程等待 socket 可写</li>
<li>当 socket 可写时， I/O 复用通知主线程。主线程往 socket 写入服务器处理客户请求的结果。</li>
</ol>
<p>可以看到，无论是 reactor 还是 proactor 模式，其主要目的就是为了工作线程不能因为 IO 而被阻塞，它应该尽可能快的完成用户请求。所以 IO 等待处理都由 IO 处理线程或者内核来完成。</p>
<h1 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h1><p>对于服务器而言，并发模式是指 I/O 处理单元和多个逻辑单元之间协调完成任务的方法。</p>
<p>主要有两种并发编程模式：半同步/半异步（half-sync/half-async）模式和领导者/追随者（Leader/Followers）模式。</p>
<h2 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h2><ul>
<li>同步：程序完全按照代码序列的顺序执行</li>
<li>异步：程序的执行需要由系统事件来驱动，比如中断、信号等</li>
</ul>
<p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程，显然异步的吞吐量和 I/O 响应速度都更好。</p>
<p>在对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，一般同时使用同步线程和异步线程的方式，称为<strong>半同步/半异步模式</strong>。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/sync_async_mode.jpg?raw=true"><br>如上图所示，半同步/半异步模式中，同步线程用于处理业务逻辑，异步线程处理 I/O 事件。异步线程监听到客户请求后，将其封装为请求对象并插入请求队列。请求队列通知某个同步模式下的工作线程。</p>
<p>半同步/半异步模式加上几种 I/O 模型，就存在多种变体。其中一种就是<strong>半同步/半反应堆（half-sync/half-reactive）模式</strong>。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/sync_reactive_mode.jpg?raw=true"><br>如上图所示，其工作流程如下：</p>
<ol>
<li>只有一个主线程作为异步 I/O 线程，首先监听所有 socket 上的事件</li>
<li>当 socket 上有可读事件时，代表有新连接，主线程接受该连接后，向 I/O 复用函数注册读写事件</li>
<li>如果连接的 socket 上有读写事件，主线程将<strong>该连接 socket 插入请求队列中</strong></li>
<li>工作线程通过竞争（比如申请互斥锁）的方式获取该 socket 后处理（只有空闲线程才可能获取到）。</li>
</ol>
<p>插入请求队列中的是 socket，也就是说这种处理模式是 Reactor 模式，也就像需要工作线程自己完成读写操作。</p>
<p>半同步/半反应堆模式存在如下缺点：</p>
<ul>
<li>主线程和工作线程共享请求队列：由于共享队列，在主线程和工作线程在操作队列时需要加锁互斥，白白耗费 CPU 时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多而工作线程较少，则会堆积很多任务对象在请求队列中，服务器的响应速度就会很慢。<ul>
<li>假设暴力的增加工作线程的数量，那么多个线程的切换也将耗费大量的 CPU 时间。</li>
</ul>
</li>
</ul>
<p>为此一个优化方案如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/async_advance.jpg?raw=true"></p>
<ul>
<li>主线程只管监听 socket，对 socket 的连接和读写检查由工作线程来完成</li>
<li>主线程可以通过管道的方式向工作线程派发 socket</li>
</ul>
<p>这样子一个工作线程就可以并发的处理多个客户请求，此时的主线程和工作线程都是异步模式。</p>
<h2 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h2><p>领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p>
<p>在任意时间点，程序都仅有一个领导者线程，它负责监听 I/O 事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。</p>
<p>当前领导者如果检测到 I/O 事件，首先要从线程池中推选出新的领导者线程，新领导者等待新的 I/O 事件，原来的领导者处理 I/O 事件。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/master_slave.jpg?raw=true"><br>领导者/追随者模式包含如下几个组建：句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。</p>
<h3 id="句柄集"><a href="#句柄集" class="headerlink" title="句柄集"></a>句柄集</h3><p>句柄（Handle）用于表示 I/O 资源，在 Linux 下就对应一个文件描述符。</p>
<p>句柄与<code>EventHandler</code>进行绑定，也就是该句柄及其对应的处理方式。</p>
<p>句柄集使用 <code>wait_for_event</code> 方法监听众多句柄，并将就绪事件通知给领导者线程。</p>
<p>领导者调用绑定到 Handle 上的事件处理器来处理事件（多态），领导者调用句柄集中的 <code>register_handle</code> 方法实现 Handle 和事件处理器的绑定。</p>
<h3 id="线程集"><a href="#线程集" class="headerlink" title="线程集"></a>线程集</h3><p>线程集管理所有工作线程（包括领导者线程和追随者线程），它负责各线程之间的同步以及新领导者线程的推选。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/thread_con.jpg?raw=true"><br>如上图所示，线程集中的线程在任一时间必处于如下三种状态之一：</p>
<ul>
<li>Leader：线程当前处于领导者身份，负责等待句柄集上的 I/O 事件</li>
<li>Processing：线程正在处理事件。领导者检测到 I/O 事件之后，可以转移到 Processing 状态来处理事件，并调用 <code>promote_new_leader()</code> 方法推选新的领导者。也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。<ul>
<li>当处于 Processing 状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接变为追随者。</li>
</ul>
</li>
<li>Follower：线程当前处于追随者身份，通过调用线程集的 <code>join()</code> 方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</li>
</ul>
<p>领导者线程推选新的领导者和追随者等待成为新的领导者，这两个操作都将修改线程集，所以线程集提供了一个 <code>Synchronizer</code> 来同步这两个操作，避免竞态。</p>
<h3 id="事件处理器和具体的事件处理器"><a href="#事件处理器和具体的事件处理器" class="headerlink" title="事件处理器和具体的事件处理器"></a>事件处理器和具体的事件处理器</h3><p>事件处理器包含一个或多个回调函数 <code>handle_event()</code> ，用于处理事件对应的业务逻辑。</p>
<p>事件处理器在使用前需要被绑定到某个句柄上，当句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。</p>
<p>具体的事件处理器是事件处理器的派生类，它们必须重新实现基类的 <code>handle_event</code> 方法，以处理特定的任务。</p>
<p>最终领导者/追随者模式流程如下图：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter8/leader_follower_overview.jpg?raw=true"><br>可以看到：由于领导者线程自己监听 I/O 并处理客户请求，所以不会像半同步/半反应堆模式那样在线程之间传递数据。但它仅支持一个事件源集合，所以无法让每个工作线程独立地管理多个客户连接。</p>
<h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><p>逻辑单元内部的一种高效编程方法就是：有限状态机（finite state machine）。</p>
<p>有限状态机就是根据数据的类型，进行相应的处理，并且根据当前处理的状态在各个状态之间转移的机制。</p>
<ul>
<li>对于 c/c++ 来说，通常使用 <code>switch</code> 实现多种状态的散转</li>
</ul>
<h1 id="提高服务器性能"><a href="#提高服务器性能" class="headerlink" title="提高服务器性能"></a>提高服务器性能</h1><h2 id="池"><a href="#池" class="headerlink" title="池"></a>池</h2><p>池（pool）是一组资源的集合，在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。</p>
<ul>
<li>当处理客户请求时，客户如果需要池含有的资源，那么直接获取即可，无需动态分配</li>
<li>当不需要资源时，可以将资源放回池中</li>
</ul>
<p>这种机制避免了申请和释放资源操作的系统调用，避免服务器对内核的频繁访问，提高效率。</p>
<p>池资源的预先分配原则是：先分配一些资源，当剩余资源不够用时再申请一大块资源放入池中。</p>
<p>常见的池有内存池、进程池、线程池、连接池：</p>
<ul>
<li>内存池通常用于 socket 的接收和发送缓存</li>
<li>进程池和线程池用于处理用户请求，需要的时候直接从池中取得执行实体，而不用动态调用 <code>fork()</code> 或 <code>pthread_create()</code> </li>
<li>连接池通常用于服务器或服务器机群的内部永久连接。<ul>
<li>比如服务端需要向内部数据库获取数据，那么可以从连接池中取得连接实体即可</li>
</ul>
</li>
</ul>
<h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><p>在用户态中内存的复制和用户态到内核态内存的复制都是比较耗时的，在设计是应该尽量避免低效的内存拷贝。</p>
<h2 id="上下文切换和锁"><a href="#上下文切换和锁" class="headerlink" title="上下文切换和锁"></a>上下文切换和锁</h2><p>进程和线程的切换从业务逻辑上来讲属于无用功，要根据当前 CPU 数量来合理的配置进程和线程数。</p>
<ul>
<li>频繁的切换除了上下文的开销，还有 cache miss 开销，对于进程而言还有页表建立的开销</li>
<li>对于工作线程，是 CPU 密集型任务时，为了能够处理多个客户端，协程是个不错的选择</li>
</ul>
<p>要尽量避免锁的存在，等待获取锁时系统的吞吐量会下降。</p>
<ul>
<li>半同步/半异步模式是一种比较合理的解决方案。</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 信号</title>
    <url>/2022/06/12/net_base_signal/</url>
    <content><![CDATA[<p>理解进程可能会收到的信号，以及捕捉该信号。</p>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>信号可以由用户、系统或进程发送给目标进程，信号可以由如下条件产生：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符串来给它发信号。比如 Ctrl+C 会发送中断信号。</li>
<li>系统异常，比如非法访问内存</li>
<li>系统状态变化，比如 alarm 定时器到期引起 SIGALRM 信号</li>
<li>运行 kill 命令或调用 <code>kill()</code> 函数</li>
</ul>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>一个进程给其他进程发送信号使用 kill 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">//将信号 sig 发送给 pid 进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>pid 的取值如下：</p>
<table>
<thead>
<tr>
<th>pid 参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>pid &gt; 0</td>
<td>信号发送给 PID 为 pid 的进程</td>
</tr>
<tr>
<td>pid = 0</td>
<td>信号发送给本进程组内的其他进程</td>
</tr>
<tr>
<td>pid = -1</td>
<td>信号发送给除 init 进程外的所有进程，但发送者需要拥有对目标进程发送信号的权限</td>
</tr>
<tr>
<td>pid &lt; -1</td>
<td>信号发送给组 ID 为 -pid 的进程组中的所有成员</td>
</tr>
</tbody></table>
<h2 id="信号处理方式"><a href="#信号处理方式" class="headerlink" title="信号处理方式"></a>信号处理方式</h2><p>目标进程可以定义个回调函数来处理接收到的信号，信号原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入信号类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong> 此函数应该是可重入的，否则很容易引发一些竞态条件！</p>
<p>目标进程也可以使用宏传入 <code>signal()</code> 函数： </p>
<ul>
<li><code>SIG_DFL</code> ：使用默认处理方式，可以结束进程（Term）、忽略信号（Ign）、结束并生成核心转储文件（Core）、暂停进程（Stop）、继续进程（Cont）</li>
<li><code>SIG_IGN</code> ：忽略目标信号</li>
</ul>
<h2 id="Linux-标准信号"><a href="#Linux-标准信号" class="headerlink" title="Linux 标准信号"></a>Linux 标准信号</h2><table>
<thead>
<tr>
<th>信号</th>
<th>起源</th>
<th>默认行为</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIGHUP</td>
<td>POSIX</td>
<td>Term</td>
<td>控制终端挂起</td>
</tr>
<tr>
<td>SIGINT</td>
<td>ANSI</td>
<td>Term</td>
<td>键盘输入以中断进程（Ctrl + C）</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>POSIX</td>
<td>Core</td>
<td>键盘输入使进程退出（Ctrl + \）</td>
</tr>
<tr>
<td>SIGILL</td>
<td>ANSI</td>
<td>Core</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGTRAP</td>
<td>POSIX</td>
<td>Core</td>
<td>断点陷进，用于调试</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>ANSI</td>
<td>Core</td>
<td>进程调用 =abort= 函数时生成该信号</td>
</tr>
<tr>
<td>SIGIOT</td>
<td>4.2BSD</td>
<td>Core</td>
<td>和 =SIGABRT= 相同</td>
</tr>
<tr>
<td>SIGBUS</td>
<td>4.2BSD</td>
<td>Core</td>
<td>总线错误，错误的内存访问</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>ANSI</td>
<td>Core</td>
<td>浮点异常</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>POSIX</td>
<td>Term</td>
<td>终止一个进程，该信号不可被捕获或忽略</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>POSIX</td>
<td>Term</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>ANSI</td>
<td>Core</td>
<td>非法内存段引用</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>POSIX</td>
<td>Term</td>
<td>用户自定义信号2</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>POSIX</td>
<td>Term</td>
<td>往读端被关闭的管道或者 socket 的连接中写数据</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>POSIX</td>
<td>Term</td>
<td>由 =alarm= 或 =setitimer= 设置的实时闹钟超时引起</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>ANSI</td>
<td>Term</td>
<td>终止进程。kill 命令默认发送的信号就是 SIGTERM</td>
</tr>
<tr>
<td>SIGSTKFLT</td>
<td>linux</td>
<td>Term</td>
<td>早期的 Linux 使用该信号来报告数学协处理器栈错误</td>
</tr>
<tr>
<td>SIGCLD</td>
<td>System V</td>
<td>Ign</td>
<td>和 =SIGCHLD= 相同</td>
</tr>
<tr>
<td>SIGCHILD</td>
<td>POSIX</td>
<td>Ign</td>
<td>子进程状态发生变化（退出或暂停）</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>POSIX</td>
<td>Cont</td>
<td>启动被暂停的进程（Ctrl+Q)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>POSIX</td>
<td>Stop</td>
<td>暂停进程（Ctrl + S）。该信号不可被捕获或忽略</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>POSIX</td>
<td>Stop</td>
<td>挂起进程（Ctrl + Z）</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>POSIX</td>
<td>Stop</td>
<td>后台进程试图从终端读取输入</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>POSIX</td>
<td>Stop</td>
<td>后台进程试图向终端输出内容</td>
</tr>
<tr>
<td>SIGURG</td>
<td>4.2BSD</td>
<td>Ign</td>
<td>socket 连接上接收到紧急数据</td>
</tr>
<tr>
<td>SIGXCPU</td>
<td>4.2BSD</td>
<td>Core</td>
<td>进程的 CPU 使用时间超过其软限制</td>
</tr>
<tr>
<td>SIGXFSZ</td>
<td>4.2BSD</td>
<td>Core</td>
<td>文件尺寸超过其软限制</td>
</tr>
<tr>
<td>SIGVTALRM</td>
<td>4.2BSD</td>
<td>Term</td>
<td>与 =SIGALRM= 类似，但它只统计进程用户空间代码的运行时间</td>
</tr>
<tr>
<td>SIGPROF</td>
<td>4.2BSD</td>
<td>Term</td>
<td>与 =SIGALRM= 类似，同时统计用户代码和内核的运行时间</td>
</tr>
<tr>
<td>SIGWINCH</td>
<td>4.3BSD</td>
<td>Ign</td>
<td>终端窗口大小发送变化</td>
</tr>
<tr>
<td>SIGPOLL</td>
<td>System V</td>
<td>Term</td>
<td>与 =SIGIO= 类似</td>
</tr>
<tr>
<td>SIGIO</td>
<td>4.2BSD</td>
<td>Term</td>
<td>IO 就绪事件</td>
</tr>
<tr>
<td>SIGPWR</td>
<td>System V</td>
<td>Term</td>
<td>对于使用 UPS 系统时电池电量过低时发出</td>
</tr>
<tr>
<td>SIGSYS</td>
<td>POSIX</td>
<td>Core</td>
<td>非法系统调用</td>
</tr>
<tr>
<td>SIGUNUSED</td>
<td></td>
<td>Core</td>
<td>保留，通常和 =SIGSYS= 效果相同</td>
</tr>
</tbody></table>
<h2 id="Linux-中断系统调用"><a href="#Linux-中断系统调用" class="headerlink" title="Linux 中断系统调用"></a>Linux 中断系统调用</h2><p>如果程序在执行系统调用时处于阻塞状态，此时接收到信号，并且设置了信号处理函数，那么此系统调用将被中断，errno 被设置为 EINTR。</p>
<ul>
<li>对于默认行为是暂停进程的信号，如果没有设置信号处理函数，也可以中断某些系统调用。</li>
</ul>
<p>可以使用 <code>sigaction()</code> 函数为信号设置 <code>SA_RESTART</code> 标志以重启被中断的系统调用。</p>
<h1 id="信号函数"><a href="#信号函数" class="headerlink" title="信号函数"></a>信号函数</h1><h2 id="signal-系统调用"><a href="#signal-系统调用" class="headerlink" title="signal 系统调用"></a>signal 系统调用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为信号 signum 设置对应的处理函数</span></span><br><span class="line"><span class="comment">//返回前一次调用 signal 函数时传入的函数指针或是 sig 对应的默认处理函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="sigaction-系统调用"><a href="#sigaction-系统调用" class="headerlink" title="sigaction 系统调用"></a>sigaction 系统调用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);<span class="comment">//信号处理函数</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;<span class="comment">//信号掩码，指定哪些信号不能发送给本进程</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;<span class="comment">//设置接收到信号时的行为</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为信号 signum 设置新的 act 处理方式，并返回 oldact 老的处理方式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act,</span></span></span><br><span class="line"><span class="params"><span class="function">            struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="信号集"><a href="#信号集" class="headerlink" title="信号集"></a>信号集</h1><p>信号集用来表示一组信号。</p>
<h2 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//设置所有信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="comment">//添加信号到信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//删除信号到信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//测试 signum 是否在信号集中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="进程信号掩码"><a href="#进程信号掩码" class="headerlink" title="进程信号掩码"></a>进程信号掩码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 设置或查看进程的信号掩码</span></span><br><span class="line"><span class="comment"> * @par set :设置新的信号掩码</span></span><br><span class="line"><span class="comment"> * @par oldset: 原来的信号掩码</span></span><br><span class="line"><span class="comment"> * @par how：指定设置进程信号掩码的方式，可以有以下值</span></span><br><span class="line"><span class="comment"> * SIG_BLOCK : 新进程信号掩码是其当前值和 set 指定信号集的并集</span></span><br><span class="line"><span class="comment"> * SIG_UNBLOCK：新的进程信号掩码是其当前值移除 set 信号集的结果</span></span><br><span class="line"><span class="comment"> * SIG_SETMASK：直接将进程信号掩码设置为 set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="被挂起的信号"><a href="#被挂起的信号" class="headerlink" title="被挂起的信号"></a>被挂起的信号</h2><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，<br>则操作系统将该信号设置为进程的一个被挂起的信号。</p>
<p><strong>如果进程取消对被挂起信号的屏蔽，则它能立即被进程接收到。</strong></p>
<p><code>sigpending()</code> 函数可以获得进程当前被挂起的信号集：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a>统一事件源</h1><p>信号处理函数与程序主循环是两条不同的执行路线，并且信号处理函数要尽快的执行完以确保新的信号到来可以及时响应。</p>
<p>很明显，信号处理函数是 I/O 密集型任务，那么就不应该让此函数来进行数据的处理。</p>
<p>典型的解决方案是：信号处理逻辑放在主循环中，当信号处理函数被触发时，它通过管道将信号发送给主循环。</p>
<blockquote>
<p>这种处理方式就有点类似于中断中的顶半和底半处理。</p>
</blockquote>
<p>主循环通过 I/O 复用来统一监听信号时间和其他的 I/O 事件，这就被称为统一事件源。</p>
<p>可以通过 <code>telnet</code> 测试以下代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER (1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_nonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_opt = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_opt = old_opt | O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    fcntl(fd, F_SETFL, new_opt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以边沿触发的方式加入文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_fd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    set_nonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是为了不破坏全局的 errno</span></span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">int</span> msg = sig;</span><br><span class="line">    <span class="comment">// 向 pipe 写入该消息的值</span></span><br><span class="line">    send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    errno = save_errno;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sig %d received!\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定信号处理函数</span></span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    <span class="comment">// 当进程被打断后，系统调用可以继续运行</span></span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号处理</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigaction(sig, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> server_sock = socket(server_addr.sin_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(server_sock &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = bind(server_sock, (<span class="keyword">const</span> struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(server_sock, <span class="number">5</span>);</span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENT_NUMBER</span>];</span></span><br><span class="line">    <span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">5</span>);</span><br><span class="line">    assert(epoll_fd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    add_fd(epoll_fd, server_sock);</span><br><span class="line"></span><br><span class="line">    ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">    assert(ret = <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    set_nonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 监控读信号</span></span><br><span class="line">    add_fd(epoll_fd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加接受的信号</span></span><br><span class="line">    addsig(SIGINT);</span><br><span class="line">    addsig(SIGHUP);</span><br><span class="line">    addsig(SIGCHLD);</span><br><span class="line">    addsig(SIGTERM);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">        <span class="keyword">int</span> number = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sock_fd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sock_fd == server_sock) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> client_addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">                <span class="keyword">int</span> connfd = accept(server_sock, (struct sockaddr *)&amp;client_addr,</span><br><span class="line">                &amp;client_addr_len);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;client : %s -&gt; %d\n&quot;</span>, inet_ntoa(client_addr.sin_addr),ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">                add_fd(epoll_fd, connfd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((sock_fd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="keyword">int</span> sig;</span><br><span class="line">                <span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">                ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 遍历读取到的信号</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">                            <span class="keyword">case</span> SIGCHLD:</span><br><span class="line">                            <span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;continue\n&quot;</span>);</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> SIGTERM:</span><br><span class="line">                            <span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">                                stop_server = <span class="literal">true</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;exit server\n&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> recv_buf[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 由于工作在 ET 模式，所以需要一次性全部读出</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">                    ret = recv(sock_fd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;read empty!\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                        close(sock_fd);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client: %s\n&quot;</span>, recv_buf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(server_sock);</span><br><span class="line">    close(pipefd[<span class="number">1</span>]);</span><br><span class="line">    close(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="网络编程相关信号"><a href="#网络编程相关信号" class="headerlink" title="网络编程相关信号"></a>网络编程相关信号</h1><h2 id="SIGHUP"><a href="#SIGHUP" class="headerlink" title="SIGHUP"></a>SIGHUP</h2><p>当挂起进程的控制终端时，SIGHUP 信号将被触发。</p>
<p>对于没有控制终端的网络后台程序而言，它们通常利用 SIGHUP 信号来强制服务器重读配置文件。</p>
<p>比如 <code>xinetd</code> 超级服务程序，在接收到 SIGHUP 信号后将循环读取 <code>/etc/xinetd.d</code> 目录下每个配置文件，检测配置文件的变化，根据它们的内容来控制子服务程序。</p>
<h2 id="SIGPIPE"><a href="#SIGPIPE" class="headerlink" title="SIGPIPE"></a>SIGPIPE</h2><p>向读端关闭的管道或 socket 连接中写数据将引发 SIGPIPE 信号，此时 errno 也会为 EPIPE。</p>
<p><strong>代码需要显示的捕获或者忽略此信号，否则程序接收到 SIGPIPE 信号的默认行为便是结束进程。</strong></p>
<p>当 <code>send()</code> 函数使用 <code>MSG_NOSIGNAL</code> 标志来禁止写操作触发 SIGPIPE 信号时，应该使用 <code>send()</code> 返回的 errno 来判断管道或 socket 读端已经关闭。</p>
<p>也可以使用 I/O 复用函数来检测管道和 socket 连接的读端是否已经关闭，以 poll 为例：</p>
<ul>
<li>当管道的读端关闭时，写端文件描述符上的 POLLHUP 事件将被触发</li>
<li>当 socket 连接被对方关闭时，socket 上的 POLLRDHUP 事件将被触发</li>
</ul>
<h2 id="SIGURG"><a href="#SIGURG" class="headerlink" title="SIGURG"></a>SIGURG</h2><p>除了可以通过<code>select()</code>读取带外信号，还可以通过接收 SIGURG 信号来接收带外数据。</p>
<p>如下服务端代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE (1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> client_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到信号后，便读取内容</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">    <span class="keyword">int</span> ret = recv(client_fd, buffer, BUF_SIZE - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got %d bytes of oob data: %s\n&quot;</span>, ret, buffer);</span><br><span class="line"></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add_sig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span> (*sig_handler)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line"></span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="keyword">int</span> ret = sigaction(sig, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">socket_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;socket_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(socket_addr));</span><br><span class="line">    socket_addr.sin_family = AF_INET;</span><br><span class="line">    socket_addr.sin_port = htons(port);</span><br><span class="line">    socket_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket</span></span><br><span class="line">    <span class="keyword">int</span> socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;can&#x27;t create socket:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">const</span> struct sockaddr *)&amp;socket_addr, <span class="keyword">sizeof</span>(socket_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind socket and address failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//listen</span></span><br><span class="line">    <span class="keyword">if</span> (listen(socket_fd, <span class="number">5</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen failed!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m waiting for client...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//accept</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span>     addr_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="keyword">if</span> ((client_fd = accept(socket_fd, (struct sockaddr *)&amp;client_addr, &amp;addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept failed:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connected to client ip: %s, port: %d\n&quot;</span>,</span><br><span class="line">    inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));</span><br><span class="line"></span><br><span class="line">    add_sig(SIGURG, sig_urg);</span><br><span class="line">    <span class="comment">//设置 socket 的宿主进程或进程组</span></span><br><span class="line">    fcntl(client_fd, F_SETOWN, getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> recv_len;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RECV_BUF_SIZE   (30)</span></span><br><span class="line">    <span class="keyword">char</span> recv_buf[RECV_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, RECV_BUF_SIZE);</span><br><span class="line">        recv_len = recv(client_fd, recv_buf, RECV_BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (recv_len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received %ld bytes : %s\n&quot;</span>, recv_len, recv_buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(client_fd);</span><br><span class="line">    close(socket_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Wireshark 观察 TCP 协议</title>
    <url>/2022/06/05/net_base_tcp/</url>
    <content><![CDATA[<p>正是 TCP 优秀的容错能力，才能够保证可靠的数据传输，不得不了解。</p>
<span id="more"></span>

<h1 id="TCP-服务的特点"><a href="#TCP-服务的特点" class="headerlink" title="TCP 服务的特点"></a>TCP 服务的特点</h1><p>TCP 相对于 UDP 具有如下特点：</p>
<ul>
<li>面向连接：TCP 通信前必须先建立连接，由于 TCP 是全双工的，完成数据交换后，通信双方都必须断开连接以释放系统资源。<ul>
<li>由于 TCP 协议是一对一的，所以无法用于广播和多播，这种情况下应该使用 UDP。</li>
</ul>
</li>
<li>字节流：发送端的写操作次数和接收端执行的读操作次数之间没有任何数量关系，而 UDP 则是严格对应的。<ul>
<li>在发送端，TCP 模块发出的 TCP 报文的个数和应用程序执行的写操作次数之间没有固定的数量关系。</li>
<li>在接收端，应用程序执行的读操作次数和 TCP 模块接收到的 TCP 报文个数之间也没有固定的数量关系。</li>
</ul>
</li>
<li>可靠传输<ul>
<li>应答机制：每个 TCP 报文段都必须得到接收方的应答</li>
<li>超时重传：发送端发出一个 TCP 报文后启动定时器，如果超时未收到应答，将重发报文。</li>
<li>数据整理：由于 IP 数据报到达目的地有可能重复和乱序，所以 TCP 协议还会进行重排和整理（UDP 则不会处理这些问题，而将问题丢给应用层）</li>
</ul>
</li>
</ul>
<h1 id="TCP-头部结构"><a href="#TCP-头部结构" class="headerlink" title="TCP 头部结构"></a>TCP 头部结构</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/tcp_header.jpg?raw=true"></p>
<h2 id="固定部分"><a href="#固定部分" class="headerlink" title="固定部分"></a>固定部分</h2><ul>
<li>端口号：说明源和目的端口（知名的服务使用的端口号定义在<code>/etc/services</code>文件中）</li>
<li>序列号：最开始该值位某个随机值 ISN（Initial Sequence Number，初始序号值），后续的 TCP 报文段中该值未为 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移</li>
<li>确认应答号：对发送方来的 TCP 报文段的响应，该值是收到的 TCP 报文段的序号值加 1</li>
<li>数据偏移：一共占 4 位，2 的 4 次方最大表示 15，该值要乘以 4 字节表示头部长度，这也表示 TCP 头部最长是 60 字节</li>
<li>控制位：一共占 6 位，包含下面几项<ul>
<li>URG 标志：紧急指针（urgent pointer）是否有效</li>
<li>ACK 标志：确认号是否有效。携带 ACK 标志的 TCP 报文段为确认报文段</li>
<li>PSH 标志：提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为后续数据腾出空间</li>
<li>RST 标志：要求对方重新建立连接。称携带 RST 标志的 TCP 报文段为复位报文段</li>
<li>SYN 标志：请求建立一个连接。称携带 SYN 标志的 TCP 报文段为同步报文段</li>
<li>FIN 标志：通知对方本端要关闭连接了。称携带 FIN 标志的 TCP 报文段为结束报文段</li>
</ul>
</li>
<li>16 位窗口大小：告诉对方本端的 TCP 接收缓冲区还能容纳多少字节数据，对方就可以控制发送数据的速度</li>
<li>16 位校验和：发送端填充 CRC 结果，接收端进行校验。这个校验包含头部和数据</li>
<li>16 位紧急指针：表示相对当前序列号的偏移</li>
</ul>
<h2 id="头部选项"><a href="#头部选项" class="headerlink" title="头部选项"></a>头部选项</h2><p>前面固定部分是 20 字节，所以头部选项部分最多为 40 字节：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/tcp_opt.jpg?raw=true"><br>kind 说明选项的类型，length 说明选项的<strong>总长度</strong>，如果有第三个字段，则是选项的具体信息。</p>
<ul>
<li>kind = 0： 选项表结束选项</li>
<li>kind = 1：空操作，一般用于将 TCP 选项总长度填充为 4 字节对齐</li>
<li>kind = 2：最大报文段长度。在 TCP 连接初始化时，双方使用此选项确定最大报文段长度（Max Segment Size, MSS）。TCP 模块通常将 MSS 设置为（MTU - 40)字节。<ul>
<li>一般情况下 TCP 和 IP 头部都不包含选项字段，那么它们头部长度之和就是 40 字节。这种情况下，就不会产生 IP 分片。对以太网而言，MSS 值就是 1460。</li>
</ul>
</li>
<li>kind = 3：是窗口扩大因子选项。在 TCP 连接初始化时，双方使用该选项协商接收通告窗口扩大因子。<ul>
<li>实际的窗口大小是：TCP 头部固定部分的窗口大小左移扩大因子位（比如头部设置窗口大小是 1000，扩大因子是 2，那么实际窗口大小是 4000 字节）</li>
<li>扩大因子取值是 0~14， <code>/proc/sys/net/ipv4/tcp_window_scaling</code> 设置此扩大因子</li>
</ul>
</li>
<li>kind = 4：是选择性确认（Selective Acknowledgment，SACK）选项。<ul>
<li>当 TCP 报文段丢失时，如果没有使能选择性确认，那么发送端会发送该丢失报文段及其后续所有报文段。但如果使能了选择性确认，则只重传丢失的部分。</li>
<li><code>/proc/sys/net/ipv4/tcp_sack</code> 设置此选项</li>
</ul>
</li>
<li>kind = 5：是 SACK 实际工作选项。用于告诉发送方本端已经收到并缓存的数据块，从而让发送端可以检查哪些数据块被丢失。<ul>
<li>“块左边沿”表示不连续块的第一个数据序号，“块又边沿”表示不连续块最后一个数据序号<strong>的下一个序号</strong></li>
<li>表示边沿之间的数据没有收到，一对边沿占用 8 字节，那么最多包含 4 对边沿</li>
</ul>
</li>
<li>kind = 8：是时间戳选项。提供较为准确的计算通信双方之间的回路时间（Round Trip Time,RTT）的方法，用于流量控制。<ul>
<li><code>/proc/sys/net/ipv4/tcp_timestamps</code> 来启动和关闭时间戳选项</li>
</ul>
</li>
</ul>
<h2 id="观察-TCP-头部"><a href="#观察-TCP-头部" class="headerlink" title="观察 TCP 头部"></a>观察 TCP 头部</h2><p>现在仅简单的抓取一个 TCP 同步报文，来查看其头部内容：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_header_sync.jpg?raw=true"></p>
<ul>
<li>源端口号是 11249，目的端口号是 22</li>
<li>序列号是 4275860736，由于不是应答报文，所以应答序列号为 0</li>
<li>数据偏移的值为 8，那就是说头部长度是 32 字节。而固定部分的长度是 20 字节，也就是说可选项部分长度为 12 字节</li>
<li>控制位中的 SYN 位为 1，代表这是一个同步报文段</li>
<li>窗口的大小是 64240</li>
<li>选项部分，分为以下几个段：<ul>
<li>kind 值为 2，代表说明最大报文段长度为 1460 字节（1500 减去 IP 和 TCP 头部长度）</li>
<li>kind 值为 1，作为对齐填充</li>
<li>kind 值为 3，指定窗口扩大因子为 8 ，也就是乘以 256。前面的窗口大小为 64240，那就是说实际窗口大小可以到 16445440 字节</li>
<li>kind 值为 1，作为对齐填充</li>
<li>kind 值为 1，作为对齐填充</li>
<li>kind 值为 4，表示允许选择性确认（SACK） </li>
</ul>
</li>
</ul>
<h1 id="TCP-连接的建立和关闭"><a href="#TCP-连接的建立和关闭" class="headerlink" title="TCP 连接的建立和关闭"></a>TCP 连接的建立和关闭</h1><h2 id="使用-Wireshark-观察"><a href="#使用-Wireshark-观察" class="headerlink" title="使用 Wireshark 观察"></a>使用 Wireshark 观察</h2><p>使用 telnet 来登录本地的 linux 服务器，抓取分为连接和断开。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_connect.jpg?raw=true"></p>
<ol>
<li>主机先发送同步 TCP 报文到服务端，其序列号是 2217727829</li>
<li>服务端返回 TCP 同步报文，其序列号是 2182764074，而应答序列号就是 2217727830（2217727829 + 1） <ul>
<li>其控制位除了 SYN 外还有 ACK 位被置位，表示这是对同步报文的应答报文</li>
</ul>
</li>
<li>主机再次返回应答报文（ACK 位置位），其序列号是 2217727830，应答序列号是 2182764075（2182764074 + 1）</li>
</ol>
<p>经过以上 3 个步骤，便建立了连接，也就是 TCP 的三次握手</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_disconnect.jpg?raw=true"></p>
<ol>
<li>主机发送 TCP 报文段，其序列号是 2217727888，且控制位 FIN 被置位，表示要结束连接</li>
<li>服务端应答结束报文段，其序列号是 2182764151，应答序列号是 2217727889（2217727888 + 1），其控制位 FIN 和 ACK 被置位，表示这是对结束报文段的应答</li>
<li>主机返回应答，其序列号是 2217727889，应答序列号是 2182764152，仅有 ACK 位被置位。这条报文段发出后，主机便主动断开了连接</li>
</ol>
<p>这就是 TCP 的 3 次挥手。</p>
<p>有些断开时会使 TCP 的 4 次挥手，这是因为当使用延迟确认特性时，服务端在返回应答结束报文段之前，还会返回一个应答。</p>
<h2 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h2><p>由于 TCP 连接是全双工的，它允许其中一个通道关闭，称为半关闭（half close）。</p>
<p>比如当客户端关闭向服务器的写通道时（以后只接受从服务端发送的数据，称之为仅使用读通道），服务器的 <code>read()</code> 返回为 0。</p>
<ul>
<li>一般使用 <code>shutdown()</code> 函数实现半关闭。</li>
</ul>
<h2 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h2><p>当 TCP 多次重连无效后，便会通知应用程序连接超时。</p>
<ul>
<li><code>/proc/sys/net/ipv4/tcp_syn_retries</code> 设置重连的次数。</li>
</ul>
<p>下面可以进行实验：<br>先将服务器的应答包过滤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -I INPUT -p tcp --syn -i enp4s0 -j DROP</span><br></pre></td></tr></table></figure>

<p>然后再来进行 telnet 连接，抓取到的流程如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_reconnect.jpg?raw=true"><br>客户端一共尝试了 5 次发送同步报文与服务端取得连接，每次等待的时间都在加长。</p>
<h1 id="TCP-的状态转移"><a href="#TCP-的状态转移" class="headerlink" title="TCP 的状态转移"></a>TCP 的状态转移</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/tcp_stat.jpg?raw=true"><br>上图表示 TCP 的状态转移，实线表示客户端连接的状态转移，虚线表示服务器连接的状态转移。</p>
<h2 id="服务器的状态转移"><a href="#服务器的状态转移" class="headerlink" title="服务器的状态转移"></a>服务器的状态转移</h2><p>服务器通过 <code>listen()</code> 进入 <code>LISTEN</code> 状态，被动等待客户端的连接，所以称为被动打开。</p>
<p>服务器一旦监听到某个连接请求（收到同步报文），就将该连接放入内核等待队列中，并向客户端发送带 SYN 标志的确认报文段，此时处于 <code>SYN_RCVD</code> 状态。</p>
<p>当服务器接受到客户端的确认报文段（三次握手完成），则该连接转移到 <code>ESTABLISHED</code> 状态，双方能够进行双向数据传输。</p>
<p>当客户端通过 <code>close()</code> 或 <code>shutdown()</code> 主动关闭连接时，服务器通过返回确认报文段使连接进入 <code>CLOSE_WAIT</code> 状态，等待服务器应用程序关闭连接。</p>
<p>当服务器发送结束报文段后，状态转移到 <code>LAST_ACK</code> 状态，等待客户端对结束报文段的确认。确认完成后（三次）连接就关闭了。</p>
<p>可以看到连接和关闭都是由客户端主动发起的，服务器接收到请求后便会返回确认并进行状态转移，当客户端再次返回确认时，操作便完成了。</p>
<h2 id="客户端的状态转移"><a href="#客户端的状态转移" class="headerlink" title="客户端的状态转移"></a>客户端的状态转移</h2><p>客户端通过 <code>connect()</code> 主动与服务器建立连接，此调用首先会发送一个同步报文段，连接进入 <code>SYN_SENT</code> 状态，然后：</p>
<ul>
<li>如果 <code>connect()</code> 连接的目标端口不存在或该端口被处于 <code>TIME_WAIT</code> 状态的连接所占用，服务器将给客户端发送一个复位报文段， <code>connect()</code> 返回失败</li>
<li>如果目标端口存在，但 <code>connect()</code> 在超时时间内未收到服务器的确认报文段，则 <code>connect()</code> 返回失败</li>
</ul>
<p>当 <code>connect()</code> 调用失败后，连接进入 <code>CLOSED</code> 状态。如果客户端收到服务器的确认，则 <code>connect()</code> 发送 ACK 报文段后进入 <code>ESTABLISHED</code> 状态。</p>
<p>当客户端主动执行关闭时，向服务器发送一个结束报文段，同时连接进入 <code>FIN_WAIT_1</code> 状态。</p>
<p>若客户端此时收到服务器专门用于确认目的的确认报文段，连接状态转移到 <code>FIN_WAIT_2</code> 状态，此时服务器处于 <code>CLOSE_WAIT</code> 状态。</p>
<p>当服务器发送结束报文段，客户端将返回确认并进入 <code>TIME_WAIT</code> 状态。</p>
<ul>
<li>若服务器直接返回带确认信息的结束报文段，那么将直接从 <code>FIN_WAIT_1</code> 状态进入 <code>TIME_WAIT</code> 状态。<blockquote>
<p>如果先进入 <code>FIN_WAIT_2</code>再进入<code>TIME_WAIT</code>状态，则是 4 次挥手<br>如果直接从 <code>FIN_WAIT_1</code>进入<code>TIME_WAIT</code>，则是 3 次挥手</p>
</blockquote>
</li>
</ul>
<p>连接停留在 <code>FIN_WAIT_2</code> 状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行退出了。<br>此时客户端连接由内核来接管，称为孤儿连接。</p>
<ul>
<li>通过 <code>/proc/sys/net/ipv4/tcp_max_orphans</code> 指定内核能接管孤儿连接数目</li>
<li>通过 <code>/proc/sys/net/ipv4/tcp_fin_timeout</code> 指定孤儿连接在内核中的生存时间</li>
</ul>
<h2 id="关于-TIME-WAIT-状态"><a href="#关于-TIME-WAIT-状态" class="headerlink" title="关于 TIME_WAIT 状态"></a>关于 TIME_WAIT 状态</h2><p>客户端在收到服务器的结束报文段（FIN，ACK）后，并没有直接进入 <code>CLOSED</code> 状态，而是进入到 <code>TIME_WAIT</code> 状态。</p>
<p>在这个状态下，客户端连接要等待 2MSL（Maximum Segment Life， 报文最大生存时间），才能完全关闭。</p>
<ul>
<li>标准文档建议值是 2min</li>
</ul>
<p><code>TIME_WAIT</code> 状态用于：</p>
<ul>
<li>可靠的终止 TCP 连接：为了确保服务器已正常的收到了最后的确认报文段（ACK），所以客户端需要足够的时间等待。<ul>
<li>假设 ACK 被丢失，那么服务器将会重发 (FIN,ACK) ，客户端才好来处理，否则服务器就会出现超时等待错误</li>
</ul>
</li>
<li>保证让迟来的 TCP 报文段有足够的时间被识别并丢弃<ul>
<li>在 <code>TIME_WAIT</code> 这段时间内，应用程序无法再新建相同端口的连接。这样可以保证，在 <code>TIME_WAIT</code> 时间内，将原来连接的 TCP 报文丢弃掉，避免随后新建的相同端口的连接接收到原来连接的数据而造成莫名其妙的错误。</li>
</ul>
</li>
</ul>
<p>所以当端口处在 <code>TIME_WAIT</code> 状态时，系统是会禁止应用程序再来建立相同端口的连接的，返回 <code>Address already in use</code> 错误。</p>
<ul>
<li>在编程中，可以使用 <code>SO_REUSEADDR</code> 来规避此错误</li>
</ul>
<p>一般客户端使用系统随机分配的端口，不会出现此冲突，但服务器是会出现的，所以服务端会设置<code>SO_REUSEADDR</code>选项。</p>
<h1 id="复位报文段"><a href="#复位报文段" class="headerlink" title="复位报文段"></a>复位报文段</h1><p>某些情况下，TCP 连接的一端会向另一端发送带 RST 标志的复位报文段，通知对方关闭连接或重新建立连接。</p>
<p>以下 3 种情况都会产生复位报文段。</p>
<h2 id="访问不存在的端口"><a href="#访问不存在的端口" class="headerlink" title="访问不存在的端口"></a>访问不存在的端口</h2><p>当客户端访问服务器上一个不存在的端口时，服务器将给它发送一个复位报文段。</p>
<p>假设访问服务端未监听的一个端口：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_rst.jpg?raw=true"><br>客户端通过<code>telnet</code>向服务器 789 端口请求连接。</p>
<p>可以看到，服务端返回了复位报文段，并且次报文段中的接收窗口长度为 0，也就是说客户端不能回应这个报文段。</p>
<blockquote>
<p>返回报文中的<code>RST</code>和<code>ACK</code>标记都置位了，表示这是一个复位应答报文</p>
</blockquote>
<h2 id="异常终止连接"><a href="#异常终止连接" class="headerlink" title="异常终止连接"></a>异常终止连接</h2><p>TCP 一方还可以主动发送复位报文段，来终止连接，对方发送端所有排队等待发送的数据都将被丢弃。</p>
<ul>
<li>通过 socket 选项 <code>SO_LINGER</code> 来发送复位报文段。</li>
</ul>
<h2 id="处理半打开连接"><a href="#处理半打开连接" class="headerlink" title="处理半打开连接"></a>处理半打开连接</h2><p>半打开状态：服务器（或客户端）关闭或异常终止了连接，但对方没有接收到结束报文段，也就是说对方还维持着原来的连接。</p>
<p>处于半打开状态的连接，就是半打开连接。</p>
<p>如果半打开连接的进程往 socket 写入数据，对方则会返回一个复位报文段。</p>
<h1 id="TCP-交互数据流"><a href="#TCP-交互数据流" class="headerlink" title="TCP 交互数据流"></a>TCP 交互数据流</h1><p>TCP 所携带的应用程序数据按照长度分为两种：</p>
<ul>
<li>交互数据：仅包含很少的字节，对实时性要求高。比如 telnet、ssh 等</li>
<li>成块数据：长度通常为 TCP 报文段允许的最大数据长度，对传输效率要求高。比如 ftp 。</li>
</ul>
<p>对于交互数据，会在双方交互数据的过程中产生大量的 TCP 包（发送的少字节数据，以及对应包的应答），这可能会导致拥塞发生。</p>
<p>使用 Nagle 算法解决该问题：</p>
<blockquote>
<p>Nagle 算法要求一个 TCP 连接的通信双方在任意时刻都最多只能发送一个未被确认的 TCP 报文段，在该 TCP 报文段的确认到达之前不能发送其他 TCP 报文段。</p>
<p>另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个 TCP 报文段将它们全部发出。</p>
<p>这样就极大的减少了网络上的微小 TCP 报文段的数量。<br>该算法的另一个优点在于其自适应性：确认到达得越快，数据也就发送得越快。</p>
</blockquote>
<p>在局域网中，我们可以<code>telnet</code>到服务端，然后使用<code>ls</code>命令。抓取这个交互过程：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_telnet.jpg?raw=true"><br>其中<code>192.168.11.67</code>是服务端，可以看到：服务端返回应答给客户端时，同时也携带了返回的数据。</p>
<p>这个就是延迟确认，将先返回 ACK 再返回数据合并到了一次返回数据报中以提高网络带宽的传输效率。</p>
<blockquote>
<p>因为数据和 ACK 标记本来就是在 TCP 报文段的两个不同的区域，二者并不冲突。 </p>
</blockquote>
<h1 id="TCP-成块数据流"><a href="#TCP-成块数据流" class="headerlink" title="TCP 成块数据流"></a>TCP 成块数据流</h1><p>成块数据流每次发送的数据大小与最开始连接的 3 次握手有关，每次发送的字节数必然不会超过这个值。</p>
<p>成块数据流的应答与接收端窗口大小有关，如果下一次发送数据大小将使得窗口被填满或溢出，那么接收方必然会返回一次应答。</p>
<p>接收方一般会在多次接收到发送方数据后，才返回一次应答，以确认多个块数据流，这样子也可以提高效率。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter3/catch_tcp_ftp.jpg?raw=true"><br>比如上面通过 FTP 来传输大文件，客户端在接受了很多个包以后才返回一次确认报文段：</p>
<ul>
<li>在握手时，就规定了最大传输 TCP 数据长度是 1460，所以服务端每次传输就是 1460 字节</li>
<li>服务端传输序列号是 3207549805，后面客户端应答序列号是 3207579005，相差 29200 字节，也就是 20 * 1460 字节，通过查看抓取的内容，这段时间服务端确实返回了 20 个 TCP 报文段，完全符合预期。</li>
</ul>
<h1 id="带外数据"><a href="#带外数据" class="headerlink" title="带外数据"></a>带外数据</h1><p>有些传输层协议具有带外（Out of Band,OOB)数据的概念，用于迅速通告对方本端发生的重要事件。</p>
<p>TCP 利用头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式，利用传输普通数据的连接来传输紧急数据（带外数据），这种紧急数据具有最高的优先级可以被优先发送出去。</p>
<p>TCP 发送带外数据的过程如下：</p>
<p>假设一个进程已经往某个 TCP 连接的发送缓冲区写入了 N 字节的普通数据并等待发送。</p>
<p>在数据被发送前，该进程又向这个连接写入了 “abc” 3 字节的带外数据，此时 TCP 报文段头部将被设置 URG 标志，其紧急指针被设置为指向最后一个带外数据的下一字节。</p>
<ul>
<li>紧急指针的值减去当前报文段的序号值，就可以得到紧急数据的位置偏移</li>
</ul>
<p>如果 TCP 模块以多个 TCP 报文段来发送 TCP 发送缓存中的内容，则每个 TCP 报文段都将设置 URG 标志，并且紧急指针指向同一个位置，但只有一个 TCP 报文段真正携带带外数据。</p>
<p>对应的 TCP 接收端只有在接收到紧急指针标志时才检查紧急指针，根据紧急指针所指的位置确定带外数据的位置并将它读入一个特殊的缓存。</p>
<ul>
<li>该缓存只有 1 字节，如果上层应用程序没有及时将带外数据读出，则会被后续的带外数据覆盖。</li>
</ul>
<p>如果给 TCP 连接设置了 SO_OOBINLINE 选项，则带外数据将和普通数据一样被 TCP 模块存放在 TCP 接收缓存中。这时通过紧急指针来识别带外数据。</p>
<h1 id="TCP-超时重传"><a href="#TCP-超时重传" class="headerlink" title="TCP 超时重传"></a>TCP 超时重传</h1><p>TCP 服务必须能够重传超时时间内未收到确认的 TCP 报文段，所以 TCP 模块为每个 TCP 报文段都维护一个重传定时器，定时器在 TCP 报文段第一次被发送时启动。</p>
<p>如果超时时间内未收到接收方的应答，TCP 模块将重传 TCP 报文段并重置定时器。</p>
<p>当超过一定重传次数后，由 IP 和 ARP 接管来查询对端 MAC 地址，直到最后放弃连接。</p>
<p><code>/proc/sys/net/ipv4/tcp_retries1</code> 指定在底层 IP 接管之前 TCP 最少执行的重传次数</p>
<p><code>/proc/sys/net/ipv4/tcp_retries2</code> 指定连接放弃前 TCP 最多可以执行的重传次数。</p>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>拥塞控制是指：提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。</p>
<p>拥塞控制由 4 个部分组成：慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。</p>
<p>Linux 下有 reno、vegas、cubic 等算法，部分或全部实现了拥塞控制的 4 个部分。</p>
<ul>
<li><code>/proc/sys/net/ipv4/tcp_congestion_control</code> 来选择拥塞算法</li>
</ul>
<p>拥塞控制最终控制向网络一次写入 TCP 报文段的数量，称为 SWND（Send Window，发送窗口）。</p>
<p>这些 TCP 报文段数据部分最大长度为 SMSS(Sender Maximum Segement Size，发送者最大段大小），其值一般等于 MSS。</p>
<p>SWND 太小会引起网络延迟，太大容易导致网络拥塞。最终 SWND 是取 RWND（接收通告窗口）和 CWND(拥塞窗口）的最小值。</p>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Wireshark 观察 ARP 协议</title>
    <url>/2022/06/01/net_basic_arp/</url>
    <content><![CDATA[<p>ARP 协议（处于数据链路层）的工作原理是：</p>
<ol>
<li>当前主机以广播的形式发送 ARP 请求，请求包中包含目标机器的 ip 地址</li>
<li>目标机收到请求后，会返回 ARP 应答，应答包中包含目标机器的 MAC 地址</li>
</ol>
<span id="more"></span>

<h1 id="ARP-报文格式"><a href="#ARP-报文格式" class="headerlink" title="ARP 报文格式"></a>ARP 报文格式</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/arp_format.jpg?raw=true"></p>
<ul>
<li>硬件类型：定义物理地址的类型，1 表示 MAC 地址</li>
<li>协议类型：要映射的协议地址类型， 0x800 表示 IP 地址</li>
<li>硬件和协议地址长度：分别表示后面发送的物理地址和 IP 地址长度，单位为字节<ul>
<li>对于 MAC 地址来说就是 6 字节，对 IPv4 来说就是 4 字节</li>
</ul>
</li>
<li>操作：指出 ARP 类报文类型<ul>
<li>ARP 请求：1</li>
<li>ARP 应答：2</li>
<li>RARP 请求：3</li>
<li>RARP 应答：4</li>
</ul>
</li>
<li>发送端及接收端的物理地址和 IP 地址：对于最开始 ARP 请求来说，主机并不知道目标机的物理地址<ul>
<li>目标机在匹配 IP 地址与自己相符后，会将自己的物理地址填充到 ARP 应答包后返回</li>
</ul>
</li>
</ul>
<p>ARP 包的长度为 28 字节，这对于数据链路层来说是属于数据部分。</p>
<ul>
<li>有时候会要求该部分最小为 46 字节，所以会增加填充字节（填充内容为 0）。</li>
</ul>
<p>该 ARP 包最终还需要封装为以太网帧才可以发送，以太网帧格式如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/ethernet_frame_format.jpg?raw=true"></p>
<ul>
<li>类型：表示数据的<a href="https://en.wikipedia.org/wiki/EtherType">类型</a>，以便于接收方分包。<ul>
<li>0x800 代表数据报为 IP</li>
<li>0x806 代表数据报为 ARP</li>
</ul>
</li>
</ul>
<p>那么假设 ARP 包填充到 46 字节，那么最终以太网帧长度就是 64 字节。</p>
<h1 id="ARP-的缓存"><a href="#ARP-的缓存" class="headerlink" title="ARP 的缓存"></a>ARP 的缓存</h1><p>ARP 维护了一个缓存来保存最近访问的机器 IP 地址和物理地址的映射关系（cache 真是个提高效率的好东西）。</p>
<p>ARP 常用命令如下：</p>
<ul>
<li><code>arp -a</code> : 查看缓存的映射关系</li>
<li><code>arp -d &lt;ip&gt;</code> : 删除对应 ip 的缓存项</li>
<li><code>arp -s &lt;ip&gt; &lt;mac&gt;</code> : 添加 ip 和物理地址映射关系</li>
</ul>
<h1 id="查看-ARP-通信过程"><a href="#查看-ARP-通信过程" class="headerlink" title="查看 ARP 通信过程"></a>查看 ARP 通信过程</h1><p>通过观察主机（192.168.11.44）访问 Linux 目标机（192.168.11.67）来查看 ARP 通信过程。</p>
<h2 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h2><p>首先要删除其 ARP 缓存，不然无法抓取到 ARP 请求报文：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo arp -d 192.168.11.67</span><br></pre></td></tr></table></figure>

<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>在主机使用<code>ping</code>命令，即可触发 ARP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping 192.168.11.67</span><br></pre></td></tr></table></figure>

<p>如下所示：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_overview.jpg?raw=true">可以看到，wireshark 已经抓到了主机发送的 ARP 请求，已经目标机的 ARP 返回。</p>
<h2 id="ARP-请求"><a href="#ARP-请求" class="headerlink" title="ARP 请求"></a>ARP 请求</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_arp_request.jpg?raw=true">从捕获的信息可以看出：</p>
<ol>
<li>ARP 请求就是 28 字节的内容加上以太网帧一共 46 字节（图中显示的 42 字节是没有计算 CRC 的长度），也就是说 ARP 请求没有填充多余的数据</li>
<li>由于请求并不知道目的端的物理地址，所以在以太网帧中填充<code>ff</code>，而在 ARP 帧中填充 <code>00</code></li>
<li>由于数据类型是 ARP，所以以太网帧中的类型值就是 0x0806</li>
<li>对于 ARP 帧的解析 wireshark 已经分离了各个部分并做了详细的说明</li>
</ol>
<h2 id="ARP-应答"><a href="#ARP-应答" class="headerlink" title="ARP 应答"></a>ARP 应答</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_arp_ack.jpg?raw=true">从捕获的信息可以看出：</p>
<ol>
<li>ARP 应答以太网帧返回长度是 64 字节，也就是说 ARP 应答的内容是填充到了 46 字节。</li>
<li>由于这是应答，所以此时的目的和源的内容就做了一次对调，应答机填充了自己的 MAC 地址</li>
<li>同时在 ARP 包中的操作字段值为 2，也表示这是一个 ARP 应答</li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Wireshark 观察 DNS 协议</title>
    <url>/2022/06/01/net_basic_dns/</url>
    <content><![CDATA[<p>DNS 服务器是多个按层级分布的服务器系统，每个服务器负责对应的域名到 IP 地址的映射关系。</p>
<span id="more"></span>

<h1 id="DNS报文格式"><a href="#DNS报文格式" class="headerlink" title="DNS报文格式"></a>DNS报文格式</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/dns_format.jpg?raw=true"></p>
<ul>
<li>16 位标识：标记一对 DNS 查询和应答，以区分 DNS 应答所对应的是哪个 DNS 查询</li>
<li>16 位标志：协商具体的通信方式和反馈通信状态，16 位依次是<ul>
<li>QR（1 位）：0 表示是查询报文，1 表示是应答报文</li>
<li>opcode（4 位）：查询和应答的类型，0 表示标准查询，1 表示反向查询（从 IP 反推出域名），2 表示请求服务器状态</li>
<li>AA（1 位）：授权应答，仅用于应答报文，1 表示域名服务器是授权服务器</li>
<li>TC（1 位）：截断标志，仅用于 DNS 报文使用 UDP 服务时使用，1 表示 DNS 报文超过 512 字节并被截断</li>
<li>RD（1 位）：递归查询标志，1 表示递归查询，DNS 服务器向其它 DNS 服务器查询，直到找到结果并返回给客户端。0 表示迭代查询，目标 DNS 无法解析某个主机名，则将它自己知道的其他 DNS 服务器的 IP 地址返回给客户端</li>
<li>RA（1 位）：允许递归标志，仅用于应答报文，1 表示 DNS 服务器支持递归查询</li>
<li>zero（3 位）：保留，设置为 0</li>
<li>rcode（4 位）：应答状态，0 表示无错误，3 表示域名不存在</li>
</ul>
</li>
<li>接下来的 4 个字段分别表示最后 4 个字段的长度，这些长度很据查询报文和应答报文都不一样</li>
</ul>
<p>查询报文包含 1 个查询问题，而应答、授权、额外信息为 0。<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/dns_request.jpg?raw=true"></p>
<ul>
<li>查询名是以一定格式封装的要查询的主机域名</li>
<li>查询类型表示如何执行查询操作：<ul>
<li>类型 A ：值为 1，表示获取目标主机的 IP 地址</li>
<li>类型 CNAME：值为 5，表示获取目标主机的别名</li>
<li>类型 PTR：值为 12，表示反向查询</li>
</ul>
</li>
<li>查询类值为 1，表示获取 IP 地址</li>
</ul>
<p>应答报文资源个数至少为 1，而授权、额外资源个数可以为 0，应答、授权字段和额外信息字段都使用资源记录（Resource Record，RR）格式。</p>
<p>资源记录格式如下：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/dns_rr.jpg?raw=true"></p>
<ul>
<li>32 位域名：资源的名字，和查询报文中的名字一样</li>
<li>16 位类型和类：与查询报文中的字段一样</li>
<li>32 位生存时间：该查询记录结果可被本地客户端缓存多长时间，单位为秒</li>
<li>16 为资源数据长度和资源数据：内容与字段有关，对于类型 A，资源数据就是 IPv4 地址，长度就为 4（以字节为单位）</li>
</ul>
<h1 id="linux-中的-DNS-配置"><a href="#linux-中的-DNS-配置" class="headerlink" title="linux 中的 DNS 配置"></a>linux 中的 DNS 配置</h1><p>linux 使用 <code>/etc/resolv.conf</code> 文件存放 DNS 服务器 IP 地址，可以使用 <code>systemd-resolve --status</code> 命令查看当前正在使用的 DNS 服务器地址。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用以下命令查询域名对应的 IP 地址</span></span><br><span class="line">host -t A &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h1 id="查看-DNS-报文"><a href="#查看-DNS-报文" class="headerlink" title="查看 DNS 报文"></a>查看 DNS 报文</h1><p>查看 DNS 报文，还是使用最简单的<code>ping</code>工具来完成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<p>Wireshark 只观察 DNS 包即可：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_overview.jpg?raw=true"></p>
<h2 id="DNS-请求"><a href="#DNS-请求" class="headerlink" title="DNS 请求"></a>DNS 请求</h2><p>可以看到一共抓到了 3 次 DNS 请求，下面依次来分析每次有何不同。</p>
<h3 id="第一次请求"><a href="#第一次请求" class="headerlink" title="第一次请求"></a>第一次请求</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_request_1st.jpg?raw=true"><br>结合 16 进制结果以及 Wireshark 的说明来分析：</p>
<ol>
<li>以太网帧的类型值是 0x86dd，也就是说其打包的上层协议是 IPv6</li>
<li>既然是 IPv6，那么其源和目的 IP 地址就是 16 进制格式的地址，且其打包的上层协议是 UDP（17）</li>
<li>UDP 中指出目标的端口就是 53，这也是 DNS 服务所使用的端口</li>
<li>DNS 协议拆分如下</li>
</ol>
<ul>
<li>16 位标识是 0x2508</li>
<li>16 位标志是 0x100，也就是第 8 位为 1，代表要进行递归查询</li>
<li>16 位问题个数为 1，而应答、授权、额外信息为 0</li>
<li>其问题的内容就是 <code>www.baidu.com</code></li>
<li>查询的类型为 A（1），代表要获取域名对应的 IPv4 地址</li>
<li>查询的类值为 1，代表是 IP 地址</li>
</ul>
<h3 id="第二次请求"><a href="#第二次请求" class="headerlink" title="第二次请求"></a>第二次请求</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_request_2nd.jpg?raw=true"><br>第二次请求与第一次请求不同之处在于：</p>
<ol>
<li>16 位标识是 0x1780</li>
<li>查询的类型为 AAAA（28），也就是 IPv6 地址</li>
</ol>
<h3 id="第三次请求"><a href="#第三次请求" class="headerlink" title="第三次请求"></a>第三次请求</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_request_3rd.jpg?raw=true"><br>第三次请求相比较前两次不同之处在于：</p>
<ol>
<li>DNS 16 位标识值是 0x2508</li>
<li>以太网帧的类型值是 0x800，也就是说其打包的上层协议是 IPv4，所以其目的及源地址都是 IPv4 格式</li>
</ol>
<h2 id="DNS-返回"><a href="#DNS-返回" class="headerlink" title="DNS 返回"></a>DNS 返回</h2><p>有了 3 次请求，也就有了 3 次返回。</p>
<h3 id="第一次返回"><a href="#第一次返回" class="headerlink" title="第一次返回"></a>第一次返回</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_response_1st.jpg?raw=true"><br>结合 16 进制结果以及 Wireshark 的说明来分析：</p>
<ol>
<li>以太网帧的类型值是 0x800，也就是说其打包的上层协议是 IPv4</li>
<li>而 IPv4 的内容正好对应第三次请求的目的地址和源地址，只是方向对调了一下</li>
<li>对 DNS 应答拆分如下：</li>
</ol>
<ul>
<li>16 位标识值是 0x2508，也就对应了第三次请求</li>
<li>16 位标志值是 0x8180，代表了这是个应答</li>
<li>16 位应答资源个数为 3，那就是说有 3 个回答</li>
<li>第一个回答的内容是<code>www.baidu.com</code>，且其类型为 CNAME（5），代表该回答是个别名。其生存时间是 21 秒。 资源内容（CNAME 的值）是<code>www.a.shifen.com</code></li>
<li>第二个回答的内容是<code>www.a.shifen.com</code>，且其类型为 A（1），代表值为 IP 地址<code>39.156.66.18</code></li>
<li>第三个回答的内容是<code>www.a.shifen.com</code>，且其类型为 A（1），代表值为 IP 地址<code>39.156.66.14</code></li>
</ul>
<h3 id="第二次返回"><a href="#第二次返回" class="headerlink" title="第二次返回"></a>第二次返回</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_response_2nd.jpg?raw=true"><br>第二次返回与第一次返回不同的是：</p>
<ol>
<li>以太网帧的类型值是 0x86dd，也就是说其打包的上层协议是 IPv6，IPv6 中的地址也是以 IPv6 的格式来表示了</li>
<li>UDP 的 16 位标识是 0x1780，也就对应第二次请求</li>
<li>返回的 DNS 中包含 2 个资源回答，1 个授权回答</li>
</ol>
<ul>
<li>第一个回答<code>www.baidu.com</code>，是 CNAME 类型，其内容是<code>www.a.shifen.com</code></li>
<li>第二个回答<code>www.a.shifen.com</code>，也是 CNAME 类型，其内容是<code>www.wshifen.com</code></li>
</ul>
<h3 id="第三次返回"><a href="#第三次返回" class="headerlink" title="第三次返回"></a>第三次返回</h3><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter1/catch_dns_response_3rd.jpg?raw=true"><br>第三次返回与前两次不同的是：</p>
<ol>
<li>以太网帧的类型值是 0x86dd，也就是说其打包的上层协议是 IPv6，IPv6 中的地址也是以 IPv6 的格式来表示了</li>
<li>此次 DNS 应答中也有 3 次资源应答，前两次都是 CNAME，第三次对<code>www.wshifen.com</code>的内容给出了对应的地址<code>103.235.46.39</code></li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Wireshark 观察 IP 协议</title>
    <url>/2022/06/01/net_basic_ip/</url>
    <content><![CDATA[<p>IP 协议是位于网络层的核心协议，需要理解。</p>
<span id="more"></span>

<h1 id="IP-服务的特点"><a href="#IP-服务的特点" class="headerlink" title="IP 服务的特点"></a>IP 服务的特点</h1><p>IP 协议的特点是：</p>
<ol>
<li>无状态（stateless）：IP 数据报的发送、传输和接收都是相互独立的，没有上下文关系。<ul>
<li>也就是说接收端无法识别 IP 数据报的先后顺序，也无法区分是否接收到了重复的数据报，这些数据报交由上层协议处理（IP 报中的标识是用于分片和重组，无法区分多个完整数据报的先后顺序）</li>
</ul>
</li>
<li>无连接（connectionless）：每次发送数据报都必须明确指定对方的 IP 地址</li>
<li>不可靠：IP 协议不能保证 IP 数据报准确地到达接收端，这需要上层协议来处理</li>
</ol>
<h1 id="回顾-IPv4-头部"><a href="#回顾-IPv4-头部" class="headerlink" title="回顾 IPv4 头部"></a>回顾 IPv4 头部</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter2/ipv4_header.jpg?raw=true"></p>
<ul>
<li>4 位版本号：对 IPv4 来说，其值为 4</li>
<li>4 位头部长度：表示头有多少个 4 字节，4 位最大就是 15，那么 IPv4 头部最长只能到 60 字节</li>
<li>8 位服务类型：由 3 位优先权字段，4 位 TOS 字段，1 位保留字段组成。4 位 TOS 分别表示：最小延时，最大吞吐量，最高可靠性，最小费用。<ul>
<li>TOS 中的 4 位服务质量字段中，最多有 1 位能置 1（像 ssh,telnet 这种服务就选最小延时，对 ftp 这样的服务就选最大吞吐量）</li>
</ul>
</li>
<li>16 位总长度：指整个 IP 数据报的长度，那么 IP 数据报最大为 65535 字节。<ul>
<li>但由于 MTU 有限制，超过 MTU 限制的都将被分片传输。</li>
</ul>
</li>
<li>16 位标识：唯一标识每个发送的数据报（初值随机，每发送一个数据报值就加 1）<ul>
<li>如果一个数据报被分片传输，那么分片具有相同的标识值</li>
</ul>
</li>
<li>3 位标志：第二位置位表示禁止分片，第三位表示更多分片（分片传输的最后一个分片将其设 0，以表示最后的分片，其他分片都要将其置位）</li>
<li>13 位分片偏移：相对原始 IP 数据报开始处的偏移。<ul>
<li>实际的偏移值是该值乘 8 后得到，所以除了最后一个 IP 分片外，每个 IP 分片的数据长度都是 8 的整数倍</li>
</ul>
<ul>
<li>8 位生存时间：数据报到达目的端之前允许通过的路由器个数，每经过一个路由器该值就被路由器减 1（减到 0 时就会被路由器丢弃）</li>
<li>8 位协议：表示上层数据报的协议。<code>/etc/protocols</code>文件定义了该值</li>
<li>16 位头校验和：接收端对其进行 CRC16 算法以检验数据是否损坏</li>
<li>32 位源和目的地址：IPv4 的源和目的地址</li>
<li>可选字段：前面长度是 20 字节，所以该字段最多可以有 40 字节。<ul>
<li>记录路由（record route）：将数据报途径的路由器的 IP 地址填入可选字段，跟踪数据传递路径</li>
<li>时间戳（timestamp）：路由器将数据报被转发的时间填入可选字段，测量数据传输时间</li>
<li>松散源路由选择（loose source routing）：指定路由器 IP 地址列表，数据报发送必须经过所有路由器</li>
<li>严格源路由选择（stric source routing）：指定路由器 IP 地址列表，数据报发送<strong>只能</strong>经过所选路由</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="观察-IPv4-头部"><a href="#观察-IPv4-头部" class="headerlink" title="观察 IPv4 头部"></a>观察 IPv4 头部</h2><p>使用<code>ping</code>工具来抓取<code>IPv4</code>:</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter2/catch_ip_header.jpg?raw=true"><br>通过图片结果一一分析：</p>
<ul>
<li>4 位版本号的值为 4，代表此包为 IPv4</li>
<li>4 位头部长度值为 5，代表头长度为 4 x 5 = 20 字节</li>
<li>8 位服务类型的值为 0</li>
<li>16 位总长度的值为 60，就是说整个 IPv4 包长度为 60 字节</li>
<li>16 位标识值为 0x791f</li>
<li>3 位标记的值为 0</li>
<li>13 位分片偏移为 0，代表这是第一个分包</li>
<li>8 位生存时间为 64，表示最多经过 64 个路由器便被抛弃</li>
<li>8 位协议值为 1，表示上层协议为 ICMP</li>
<li>最后便是校验和为 0x00，还有源地址和目的地址</li>
</ul>
<h1 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h1><h2 id="分片原理"><a href="#分片原理" class="headerlink" title="分片原理"></a>分片原理</h2><p>当 IP 数据包超过帧 MTU 时，可能会被发送端或中转路由器分片，最终被接收端内核的 IP 模块重组。</p>
<p>IP 的分片和重组主要依靠：标识、标志和片偏移完成。</p>
<ul>
<li>同一个数据报的 IP 头部具有相同的标识值，不同的片偏移。除了最后一个分片外，其他分片标志都是可分片。</li>
</ul>
<p>对于以太网而言，MTU 是 1500 字节，那么除开 IP 头部以外（20 字节），IP 数据内容最多是 1480 字节。</p>
<p>所以当数据包超过 1480 字节时，IP 数据报就应该分片。</p>
<ul>
<li>实际上在 IP 中的数据包还包括了上层协议的头部，所以实际上真正的用户数据比这个还要少</li>
</ul>
<h2 id="抓取分包"><a href="#抓取分包" class="headerlink" title="抓取分包"></a>抓取分包</h2><p>以使用 ping 一个本地地址来查看 IP 分包细节：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定发送数据数是 1473 字节，而 icmp 回显和应答头长度是 8 字节，所以刚好是 1501 字节</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> windows 下使用 -l 命令设定发送的字节大小</span></span><br><span class="line">ping 192.168.11.67 -s 1473</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter2/catch_ip_fragment.jpg?raw=true"></p>
<ul>
<li>从接受到的数据长度及提示信息就可以说明已经发生了 IP 分片。<ul>
<li>第一片长度是 1518，就是以太网帧的 18 字节包裹和 1500 字节的整个 IPv4 长度，除去 IPv4 头的 20 字节，内容就是 1480 字节</li>
<li>第二片长度是 39，就是以太网帧的 18 字节包裹和 21 字节的整个 IPv4 长度，除去 IPv4 头的 20 字节，内容就是 1 字节</li>
<li>第一片和第二片的标识都是 0x7972，代表它们是同一个数据报</li>
<li>第一片 IP 分片的 MF 位标志置位，第二片 IP 分片的 MF 位标志为 0，代表它为最后一个 IP 分包</li>
<li>第一片 IP 分片的偏移为 0，第二片 IP 分片的偏移为 185 x 8 = 1480</li>
</ul>
</li>
</ul>
<p>目的端经过以上信息就可以把 IP 分片重组成一个完整的数据报了。</p>
<h1 id="IP-路由"><a href="#IP-路由" class="headerlink" title="IP 路由"></a>IP 路由</h1><p>对于网络层而言，一个网络包应该怎样由源端发往目的端，首先需要了解的便是路由表。</p>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><p>在 Linux 命令行，执行 <code>route</code> 命令即可查看本机的路由表，比如下面是 WSL 输出的路由表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cec@LAPTOP-14LL83CU:~$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line"><span class="meta">#</span><span class="bash"> 默认路由，走网关</span></span><br><span class="line">default         LAPTOP-14LL83CU 0.0.0.0         UG    0      0        0 eth0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地局域网可以直接发送到目标机</span></span><br><span class="line">172.26.128.0    0.0.0.0         255.255.240.0   U     0      0        0 eth0</span><br></pre></td></tr></table></figure>

<ul>
<li>Destination：目标网络或主机</li>
<li>Gateway：网关地址</li>
<li>Genmask：网络掩码</li>
<li>Flags：路由标志<ul>
<li>U：该路由项是活动的</li>
<li>H：该路由项的目标是一台主机</li>
<li>G：该路由项的目标是网关</li>
<li>D：该路由项是由重定向生成的</li>
<li>M：该路由项被重定向修改过</li>
</ul>
</li>
<li>Metric：路由距离，到达指定网络所需的中转数</li>
<li>Ref：路由项被引用的次数</li>
<li>Use：路由项被使用的次数</li>
<li>Iface：该路由项对应的输出网卡接口</li>
</ul>
<p>IP 路由机制分为 3 个步骤：</p>
<ol>
<li>查找路由表中和数据报的目标 IP 地址完全匹配的主机 IP 地址，如果找到就使用该路由项</li>
<li>查找路由表中和数据报的目标 IP 地址具有相同网络 ID 的网络 IP 地址，如果找到就使用该路由项</li>
<li>选择默认路由项，也就是跳转到网关</li>
</ol>
<p>可以看出，其查找过程是由严格到宽松。</p>
<p>WSL 的 IP 是 <code>172.26.128.135</code>，对于上面<code>route</code>的输出结果表示，当在<code>172.26.128.135</code>这个网段时，就可以直接发送到目标机。否则就需要走网关转发出去。</p>
<h2 id="路由表更新"><a href="#路由表更新" class="headerlink" title="路由表更新"></a>路由表更新</h2><p>可以使用 <code>route add</code> , <code>route del</code> 来手动添加和删除路由表项，也可以通过 BGP(Border Gateway Protocol，边际网关协议）、RIP（Routing Information Protocol，路由协议）等自动更新路由表。</p>
<h2 id="IP-模块的工作流程"><a href="#IP-模块的工作流程" class="headerlink" title="IP 模块的工作流程"></a>IP 模块的工作流程</h2><p>当 IP 数据报不处于本地局域网时，就需要通过网关转发出去， IP 模块的转发逻辑图如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter2/ip_module.jpg?raw=true"><br>数据链路层在 Linux 中位于网络驱动部分，当接收到数据包时，数据链路层从中提取出网络层并发送给 IP 模块。</p>
<p>IP 在对网络层数据校验无误后，就分析其头部信息。</p>
<p>如果该 IP 数据报头部设置了源站选路选项，IP 模块便调用数据报转发子模块。</p>
<p>如果该 IP 数据报的头部中目标 IP 地址是本机 IP 地址或广播地址，IP 模块就根据数据报头部的协议字段派发给对应的传输层。</p>
<p>如果与本机 IP 地址不一样也不是广播地址，则也调用数据报转发子模块。</p>
<p>数据报转发子模块将首先检测系统是否允许转发，不允许就丢弃数据报，允许就将数据转发给 IP 数据报输出子模块。</p>
<p>IP 模块实现数据报路由的核心数据结构是路由表，同一类型的 IP 数据报将被发往相同的下一跳路由器。</p>
<p>IP 输出队列中存放所有等待发送的 IP 数据报，除了要转发的 IP 数据报外，还有上层数据的 IP 数据报。</p>
<p>路由协议和 route 命令来更新路由表。</p>
<h2 id="IP-转发使能"><a href="#IP-转发使能" class="headerlink" title="IP 转发使能"></a>IP 转发使能</h2><p>主机是否支持 IP 转发与 <code>/proc/sys/net/ipv4/ip_forward</code> 的值有关，为 1 则代表允许转发。</p>
<p>执行数据报转发时，执行如下步骤：</p>
<ol>
<li>若 TTL 为 0，则丢弃该数据报</li>
<li>如果头部设置了严格源路由选择选项，如果目标 IP 与本机 IP 不一致，则发送 ICMP 源站选路失败报文给发送端</li>
<li>如果有必要，给源端发送一个 ICMP 重定向报文，告诉它一个更合理的下一跳路由器</li>
<li>将 TTL 减 1</li>
<li>处理 IP 头部选项</li>
<li>根据当前 MTU 查看是否需要对 IP 执行分片操作。</li>
</ol>
<h1 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BgoodBook%5D/%5BWhat%5DgoodBook--Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/chapter2/icmp_redir.jpg?raw=true"><br>ICP 重定向报文的类型值是 5，代码字段为 1 时代表主机重定向。</p>
<p>此报文包含：</p>
<ul>
<li>引起重定向的 IP 数据报的源端 IP 地址</li>
<li>应该使用的路由器的 IP 地址</li>
</ul>
<p>主机根据以上信息断定引起重定向的 IP 数据报应该使用哪个路由器来转发，并且更新路由表。</p>
<ul>
<li><code>/proc/sys/net/ipv4/conf/all/send_redirects</code> 指定是否可以发送 ICMP 重定向报文</li>
<li><code>/proc/sys/net/ipv4/conf/all/accept_redirects</code> 指定是否可以接受 ICMP 重定向报文</li>
</ul>
<p>一般主机接收 ICMP 重定向报文，而路由器发送 ICMP 重定向报文。</p>
]]></content>
      <categories>
        <category>network</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 fmt</title>
    <url>/2024/10/21/professional_cpp_fmt/</url>
    <content><![CDATA[<p>虽然 C++20 已经提供了 <code>std::format</code> 这种格式化库，但直到 C++23 才支持 <code>std::print</code> 这种便利库。</p>
<p>又由于目前 gcc 对 C++23 支持还不完整，尤其是在嵌入式上。所以仍然是需要以 <a href="https://github.com/fmtlib/fmt">fmt 库</a> 为基本使用工具。</p>
<span id="more"></span>

<h1 id="包含-fmt-库"><a href="#包含-fmt-库" class="headerlink" title="包含 fmt 库"></a>包含 fmt 库</h1><p><a href="https://fmt.dev/11.0/get-started/">Get Started</a>中已经详细的描述了如何包含 fmt 到项目中去，为了增加项目的独立性，个人更倾向于使用<code>FetchContent</code>或<code>Embedded</code>的方式包含该库。</p>
<p>除了上面说的方法，还有一个简单粗暴的办法：</p>
<ol>
<li><p>下载源码，将文件夹<code>inculde/fmt</code>和<code>src</code>拷贝至项目中</p>
</li>
<li><p>将<code>fmt/core.h</code>，<code>fmt/format.h</code>，<code>fmt/forat-inl.h</code>，<code>src/format.cc</code>添加至编译文件中</p>
</li>
<li><p>将<code>fmt</code>路径添加到项目包含路径中</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">对于 Visual Studio，为了能够顺利编译 fmt 库。</span><br><span class="line"></span><br><span class="line">需要在&quot;属性&quot;-&gt; &quot;C/C++&quot; -&gt; &quot;命令行&quot; -&gt; &quot;附加选项&quot; 中添加 `/utf-8` 指定编码方式</span><br></pre></td></tr></table></figure>

<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><code>fmt::format</code>和<code>fmt::print</code>语法一致，在字符串中使用花括号<code>&#123;&#125;</code>表示格式化输出部分，如果想输出花括号，则使用两个花括号<code>&#123;&#123;&#125;&#125;</code>。</p>
<p>替换字段<code>&#123;&#125;</code>的语法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">replacement_field ::= &quot;&#123;&quot; [arg_id] [&quot;:&quot; (format_spec | chrono_format_spec)] &quot;&#125;&quot;</span><br><span class="line">arg_id            ::= integer | identifier</span><br><span class="line">integer           ::= digit+</span><br><span class="line">digit             ::= &quot;0&quot;...&quot;9&quot;</span><br><span class="line">identifier        ::= id_start id_continue*</span><br><span class="line">id_start          ::= &quot;a&quot;...&quot;z&quot; | &quot;A&quot;...&quot;Z&quot; | &quot;_&quot;</span><br><span class="line">id_continue       ::= id_start | digit</span><br></pre></td></tr></table></figure>

<h2 id="arg-id"><a href="#arg-id" class="headerlink" title="arg_id"></a>arg_id</h2><p><code>arg_id</code>指的是要输出部分对应后面输入参数的顺序，默认为<code>0~9</code>这样的顺序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::<span class="built_in">println</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;\n&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">fmt::<span class="built_in">println</span>(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&#123;2&#125;\n&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;a, b, c&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;a, b, c&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;2&#125;, &#123;1&#125;, &#123;0&#125;&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;c, b, a&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&#123;0&#125;&quot;</span>, <span class="string">&quot;abra&quot;</span>, <span class="string">&quot;cad&quot;</span>);  <span class="comment">// arguments&#x27; indices can be repeated</span></span><br><span class="line"><span class="comment">// Result: &quot;abracadabra&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果在<code>arg_id</code>后需要增加其他描述，那需要以冒号<code>:</code>分隔<code>arg_id</code>和<code>format_spec</code>。</p>
<h2 id="format-spec"><a href="#format-spec" class="headerlink" title="format_spec"></a>format_spec</h2><p><code>format_spec</code>描述参数的表示方式，包含长度、对其、空白填充、精度、进制等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">format_spec ::= [[fill]align][sign][&quot;#&quot;][&quot;0&quot;][width][&quot;.&quot; precision][&quot;L&quot;][type]</span><br><span class="line">fill        ::= &lt;a character other than &#x27;&#123;&#x27; or &#x27;&#125;&#x27;&gt;</span><br><span class="line">align       ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;^&quot;</span><br><span class="line">sign        ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width       ::= integer | &quot;&#123;&quot; [arg_id] &quot;&#125;&quot;</span><br><span class="line">precision   ::= integer | &quot;&#123;&quot; [arg_id] &quot;&#125;&quot;</span><br><span class="line">type        ::= &quot;a&quot; | &quot;A&quot; | &quot;b&quot; | &quot;B&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; |</span><br><span class="line">                &quot;g&quot; | &quot;G&quot; | &quot;o&quot; | &quot;p&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;?&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>fill</code>表示填充的字符，除了花括号以外，其他字符都可以使用（需要指定宽度才有意义）</p>
</li>
<li><p><code>align</code>指定对齐方式（需要指定宽度才有意义）：</p>
<ul>
<li><p><code>&lt;</code>：左对齐，默认值</p>
</li>
<li><p><code>&gt;</code>：右对齐，对于数值而言，它是默认值</p>
</li>
<li><p><code>^</code>：居中对齐</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::format(<span class="string">&quot;&#123;:&lt;30&#125;&quot;</span>, <span class="string">&quot;left aligned&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;left aligned                  &quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:&gt;30&#125;&quot;</span>, <span class="string">&quot;right aligned&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;                 right aligned&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:^30&#125;&quot;</span>, <span class="string">&quot;centered&quot;</span>);</span><br><span class="line"><span class="comment">// Result: &quot;           centered           &quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:*^30&#125;&quot;</span>, <span class="string">&quot;centered&quot;</span>);  <span class="comment">// use &#x27;*&#x27; as a fill char</span></span><br><span class="line"><span class="comment">// Result: &quot;***********centered***********&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宽度也可以设置为参数</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:&lt;&#123;&#125;&#125;&quot;</span>, <span class="string">&quot;left aligned&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="comment">// Result: &quot;left aligned </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sign</code>仅在浮点数或有符号整数有效：</p>
<ul>
<li><p><code>+</code>：在数值为非负时加上<code>+</code>号，在数值为负数时加上<code>-</code>号</p>
</li>
<li><p><code>-</code>：只有在数字为负数时，才加上<code>-</code>号，它是默认值</p>
</li>
<li><p><code> </code>：在数值为非负数时，加上空格，在数值为负数时加上<code>-</code>号</p>
</li>
</ul>
</li>
<li><p><code>#</code>用于对显示格式的切换，仅对整数和浮点数合法：</p>
<ul>
<li>对于<code>#b or #B</code>二进制、<code>#o</code>8进制、<code>#x or #X</code>16进制，会输出对应的前缀</li>
</ul>
</li>
<li><p><code>width</code>指定显示的最小位数，如果在<code>width</code>前面加<code>0</code>，则会在符号和数值之间填充0.</p>
<ul>
<li>当使用对齐方式时，前面加<code>0</code>的方式就会被忽略</li>
</ul>
</li>
<li><p><code>precision</code>指定小数精度：</p>
<ul>
<li><p>对于<code>f or F</code>显示格式，指定小数点后面的位数</p>
</li>
<li><p>对于<code>g or G</code>显示格式，指定除小数点外的位数之和</p>
</li>
</ul>
</li>
<li><p><code>type</code>用于指定具体显示格式：</p>
<ul>
<li><p>对于字符串有：</p>
<ul>
<li><p><code>s</code>：字符串显示，默认值</p>
</li>
<li><p><code>?</code>：调试显示，字符串被引号包含，且里面的特殊字符将不会被转义</p>
</li>
</ul>
</li>
<li><p>对于字符有：</p>
<ul>
<li><p><code>c</code>：字符显示，默认值</p>
</li>
<li><p><code>?</code>：调试显示，字符被引号包含，且特殊字符不会被转义</p>
</li>
</ul>
</li>
<li><p>对于整数有：</p>
<ul>
<li><p><code>b</code>或<code>B</code>：以二进制显示，如果加上<code>#</code>则会分别加上<code>0b</code>和<code>0B</code>前缀</p>
</li>
<li><p><code>c</code>：以字符显示</p>
</li>
<li><p><code>d</code>：以十进制显示</p>
</li>
<li><p><code>o</code>：以八进制显示</p>
</li>
<li><p><code>x</code>或<code>X</code>：以 16 进制显示，如果加上<code>#</code>则会分别加上<code>0x</code>和<code>0X</code>前缀</p>
</li>
</ul>
</li>
<li><p>对于浮点数有：</p>
<ul>
<li><p><code>a</code>或<code>A</code>：以 16 进制显示浮点数</p>
</li>
<li><p><code>e</code>或<code>E</code>：以科学计数法表示浮点数</p>
</li>
<li><p><code>f</code>或<code>F</code>：以固定精度显示浮点数</p>
</li>
<li><p><code>g</code>或<code>G</code>：对浮点数进行四舍五入</p>
</li>
</ul>
</li>
<li><p>对于指针有：<code>fmt::print(&quot;&#123;:p&#125;&quot;, fmt::ptr(p));</code></p>
<ul>
<li><code>p</code>：以 16 进制的方式显示指针，默认值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fmt::format(<span class="string">&quot;&#123;:.&#123;&#125;f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Result: &quot;3.1&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:+f&#125;; &#123;:+f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show it always</span></span><br><span class="line"><span class="comment">// Result: &quot;+3.140000; -3.140000&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;: f&#125;; &#123;: f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show a space for positive numbers</span></span><br><span class="line"><span class="comment">// Result: &quot; 3.140000; -3.140000&quot;</span></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:-f&#125;; &#123;:-f&#125;&quot;</span>, <span class="number">3.14</span>, <span class="number">-3.14</span>);  <span class="comment">// show only the minus -- same as &#x27;&#123;:f&#125;; &#123;:f&#125;&#x27;</span></span><br><span class="line"><span class="comment">// Result: &quot;3.140000; -3.140000&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;int: &#123;0:d&#125;;  hex: &#123;0:x&#125;;  oct: &#123;0:o&#125;; bin: &#123;0:b&#125;&quot;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// Result: &quot;int: 42;  hex: 2a;  oct: 52; bin: 101010&quot;</span></span><br><span class="line"><span class="comment">// with 0x or 0 or 0b as prefix:</span></span><br><span class="line">fmt::format(<span class="string">&quot;int: &#123;0:d&#125;;  hex: &#123;0:#x&#125;;  oct: &#123;0:#o&#125;;  bin: &#123;0:#b&#125;&quot;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// Result: &quot;int: 42;  hex: 0x2a;  oct: 052;  bin: 0b101010&quot;</span></span><br><span class="line"></span><br><span class="line">fmt::format(<span class="string">&quot;&#123;:#04x&#125;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// Result: &quot;0x00&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
        <category>professional</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>在 win10 中编译 KDE Qt5.15</title>
    <url>/2022/08/11/qtmake_win_compile/</url>
    <content><![CDATA[<p>Qt 5.15 是 Qt5 系列的最后一个 LTS，但是在 Qt 5.15.2 之后，需要付费用户才能获取其官方源码了。</p>
<p>而 KDE 是基于 Qt5 开发的，所以他们宣布<a href="https://community.kde.org/Qt5PatchCollection">以开源的方式继续维护 5.15 分支</a>，直到 KDE 切换到 Qt6 分支。</p>
<p>这对于我们普通用户来讲就是福音了，我们可以编译 KDE 维护的 5.15 。</p>
<span id="more"></span>

<h1 id="编译前的准备"><a href="#编译前的准备" class="headerlink" title="编译前的准备"></a>编译前的准备</h1><h2 id="安装编译需要的工具"><a href="#安装编译需要的工具" class="headerlink" title="安装编译需要的工具"></a>安装编译需要的工具</h2><p>为了完成编译，需要安装的工具有：</p>
<ol>
<li><a href="https://visualstudio.microsoft.com/zh-hans/">Visual Studio 2022</a>，安装 c++ 以及通用平台组件即可</li>
<li><a href="https://www.python.org/">Python</a></li>
<li><a href="https://strawberryperl.com/">strawberryperl</a></li>
<li><a href="https://www.ruby-lang.org/en/">ruby</a></li>
</ol>
<p>以上工具，基本上按照提示即可完成安装。</p>
<h2 id="获取分支源码"><a href="#获取分支源码" class="headerlink" title="获取分支源码"></a>获取分支源码</h2><blockquote>
<p>获取源码要开代理，速度才快。</p>
</blockquote>
<p>在 <a href="https://invent.kde.org/qt/qt/qt5">KDE Qt 库</a>获取源码，并切换到<code>kde/5.15</code>分支：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --progress --verbose --branch kde/5.15 https://invent.kde.org/qt/qt/qt5.git qt-kde-5.15-LTS</span><br></pre></td></tr></table></figure>

<p>然后获取其子模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd qt-kde-5.15-LTS</span><br><span class="line">git submodule update --init --recursive --progress</span><br></pre></td></tr></table></figure>

<p>当然，子模块也需要切换到<code>kde/5.15</code>分支：</p>
<blockquote>
<p>以下这个脚本，是我在 WSL 下完成运行的，对 Windows 脚本不太熟悉……</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">QT_SUBDIRS=$(ls -F | grep / | grep qt)</span><br><span class="line"></span><br><span class="line">echo &quot;Git module sub-directories to switch to kde/5.15 branch: $QT_SUBDIRS&quot;</span><br><span class="line"></span><br><span class="line">for SUBDIR in $QT_SUBDIRS ; do</span><br><span class="line"></span><br><span class="line">	echo &quot;Branching $SUBDIR to kde/5.15...&quot;</span><br><span class="line">	cd $SUBDIR</span><br><span class="line">	git checkout kde/5.15 || true</span><br><span class="line">	cd ..</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>这里的<code>qtwebengine</code>没有切换成功，因为其分支名称不叫这个，但我目前没有使用这个模块，所以就没有管它。</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>假设目前编译 X86 编码的库，那么就在“开始”中打开命令行窗口<code>x86 Native Tools Command Prompt for VS 2022</code>，然后切换到源码目录下。</p>
<p>然后就开始配置并编译吧：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置</span></span><br><span class="line">configure <span class="literal">-confirm</span><span class="literal">-license</span> <span class="literal">-opensource</span> <span class="literal">-debug</span> <span class="literal">-qt</span><span class="literal">-sqlite</span> <span class="literal">-qt</span><span class="literal">-zlib</span> <span class="literal">-qt</span><span class="literal">-libpng</span> <span class="literal">-qt</span><span class="literal">-libjpeg</span> <span class="literal">-nomake</span> tests <span class="literal">-no</span><span class="literal">-compile</span><span class="literal">-examples</span> <span class="literal">-nomake</span> examples</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">nmake</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">nmake install</span><br></pre></td></tr></table></figure>

<p>编译完成后，可以在源码目录<code>qtbase/bin</code>下运行一下<code>qmake --version</code>来验证是否编译成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\github\qt-kde-5.15-LTS\qtbase\bin&gt;qmake --version</span><br><span class="line">QMake version 3.1</span><br><span class="line">Using Qt version 5.15.5 in C:/Qt/Qt-5.15.5/lib</span><br></pre></td></tr></table></figure>

<h1 id="QtCreator-使用编译好的库"><a href="#QtCreator-使用编译好的库" class="headerlink" title="QtCreator 使用编译好的库"></a>QtCreator 使用编译好的库</h1><p>安装最新的<a href="https://github.com/qt-creator/qt-creator">QtCreator</a>，目前我用的是 8.0.0。</p>
<p>进入<code>编辑--preferences</code>中选择<code>Kit</code>选项卡，在<code>Qt Versions</code>中选择安装好的<code>qmake</code>路径：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BMake%5D/compile/pic/qt_versions.jpg?raw=true"><br>然后进入<code>Kits</code>中选择当前 Qt 库的版本，选项 MSVC 编译器，和 CDB 调试器：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BMake%5D/compile/pic/qt_kits.jpg?raw=true"><br>如果没有 CDB 调试器的话，可以进入<a href="https://developer.microsoft.com/zh-cn/windows/downloads/windows-sdk/">Windows SDK</a>安装下载器，然后选择安装调试器：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BMake%5D/compile/pic/win10_sdk.jpg?raw=true"></p>
<p>以上，便大功告成了！</p>
]]></content>
      <categories>
        <category>Qt</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>如何高效的绘制动态曲线？</title>
    <url>/2022/03/02/qtquick_curve_performance/</url>
    <content><![CDATA[<p>QtQuick 提供的 <a href="https://doc.qt.io/qt-5/qtcharts-index.html">QtChart</a> 可以满足在 Qml 中高效绘制动态曲线，但由于它是 GPL 协议，故应用场景有限。</p>
<span id="more"></span>

<h1 id="Canvas-绘图"><a href="#Canvas-绘图" class="headerlink" title="Canvas 绘图"></a>Canvas 绘图</h1><p>Qml 中提供了 Canvas 组件，可以直接使用 js 进行绘制，比如下面几行代码，便可以绘制多条动态曲线：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Canvas &#123;</span><br><span class="line">    <span class="attr">id</span>: curve_dis</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    property <span class="keyword">var</span> curve_data : []</span><br><span class="line"></span><br><span class="line">    <span class="attr">onPaint</span>: &#123;</span><br><span class="line">        <span class="keyword">var</span> ctx = getContext(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">        ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> config = &#123;</span><br><span class="line">            <span class="attr">vertical</span>:height,</span><br><span class="line">            <span class="attr">points</span>: curve_data,</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&quot;Gold&quot;</span>,</span><br><span class="line">            <span class="attr">ref</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">div</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">pixel</span>: <span class="number">60</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        MeasCurve.drawCurve(ctx, config);</span><br><span class="line"></span><br><span class="line">        config.ref = <span class="number">20</span>;</span><br><span class="line">        MeasCurve.drawCurve(ctx, config);</span><br><span class="line"></span><br><span class="line">        config.ref = -<span class="number">20</span>;</span><br><span class="line">        MeasCurve.drawCurve(ctx, config);</span><br><span class="line"></span><br><span class="line">        config.ref = <span class="number">30</span>;</span><br><span class="line">        MeasCurve.drawCurve(ctx, config);</span><br><span class="line"></span><br><span class="line">        config.ref = -<span class="number">30</span>;</span><br><span class="line">        MeasCurve.drawCurve(ctx, config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCurve</span>(<span class="params">ctx, config</span>) </span>&#123;</span><br><span class="line">    ctx.strokeStyle = config.color;</span><br><span class="line">    ctx.lineWidth = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> verical_size = config.vertical;</span><br><span class="line">    <span class="keyword">var</span> points_array = config.points;</span><br><span class="line">    <span class="keyword">var</span> ref_lev = config.ref;</span><br><span class="line">    <span class="keyword">var</span> div_val = config.div;</span><br><span class="line">    <span class="keyword">var</span> pixel_size = config.pixel;</span><br><span class="line">    <span class="keyword">var</span> points_len = config.points.length;</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(<span class="number">0</span>,</span><br><span class="line">    getPointY(verical_size, points_array[<span class="number">0</span>],</span><br><span class="line">              ref_lev, div_val, pixel_size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; points_len; ++i) &#123;</span><br><span class="line">        ctx.lineTo(i,</span><br><span class="line">        getPointY(verical_size, points_array[i],</span><br><span class="line">        ref_lev, div_val, pixel_size));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其显示效果如下：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BQuick%5D/usage/pic/qml_curve.jpg?raw=true"><br>但由于其在实际运行过程中，是由 CPU 来解析脚本再来执行，<strong>其运行效率极为低下</strong> 。</p>
<h1 id="其它的选择"><a href="#其它的选择" class="headerlink" title="其它的选择"></a>其它的选择</h1><p>为了能够高效的显示动态曲线，目前有以下几种选择方式：</p>
<ul>
<li>QQuickPaintedItem ：通过继承 QQuickPaintedItem 来重载其 <code>paint</code> 函数，使用 QPainter 完成图形绘制。</li>
<li>QOpenGLWindow : 通过继承自 QOpenGLWindow 来直接调用 OpenGL API 完成图形绘制</li>
<li>QQuickFrameBufferObject ：实现 <code>QQuickFramebufferObject::Renderer</code> 类来完成图形绘制</li>
</ul>
<blockquote>
<p>Qml Shape 也是个高效组件，但是它无法用来显示动态曲线</p>
</blockquote>
<p>QPainter 其使用 CPU 来渲染无法很好的利用 GPU，虽然比起 Canvas 好得多，但也不够高效。</p>
<p>OpenGL 相关 API 不是太好懂，编写起来比较吃力……</p>
<h1 id="QNanoPainter"><a href="#QNanoPainter" class="headerlink" title="QNanoPainter"></a>QNanoPainter</h1><p><a href="https://github.com/QUItCoding/qnanopainter">QNanoPainter</a> 则很好的解决上面的问题：</p>
<ol>
<li>基于 <a href="https://github.com/memononen/nanovg">NanoVG</a> 实现了自己的 QNanoPainter，以尽量以 GPU 直接渲染</li>
<li>提供 Canvas API，可以很好的将 Qml API 重构</li>
</ol>
<p>对于上面显示的曲线，对应的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NanoCurvePainter::DrawLines</span><span class="params">(<span class="keyword">float</span> ref, QNanoPainter* painter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curve_data_.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">setStrokeStyle</span>(<span class="built_in">QNanoColor</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">    painter-&gt;<span class="built_in">setLineWidth</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">beginPath</span>();</span><br><span class="line">    painter-&gt;<span class="built_in">moveTo</span>(<span class="number">0</span>,</span><br><span class="line">                   <span class="built_in">GetPointY</span>(ref, curve_data_.<span class="built_in">at</span>(<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; curve_data_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        painter-&gt;<span class="built_in">lineTo</span>(i,</span><br><span class="line">                   <span class="built_in">GetPointY</span>(ref, curve_data_.<span class="built_in">at</span>(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    painter-&gt;<span class="built_in">stroke</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NanoCurvePainter::paint</span><span class="params">(QNanoPainter* painter)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DrawLines</span>(<span class="number">0</span>, painter);</span><br><span class="line">    <span class="built_in">DrawLines</span>(<span class="number">20</span>, painter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawLines</span>(<span class="number">-20</span>, painter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawLines</span>(<span class="number">30</span>, painter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawLines</span>(<span class="number">-30</span>, painter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，相比 Canvas 绘图，QNanoPainter 消耗 CPU 为前者的 ⅓ 。</p>
]]></content>
      <categories>
        <category>Qt</category>
        <category>QtQuick</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 Qml 实现 TabWidget？</title>
    <url>/2022/02/14/qtquick_impl_tabwidget/</url>
    <content><![CDATA[<p>QWidget 中就具有类 <a href="https://doc.qt.io/qt-5/qtabwidget.html">QTabWidget</a> 以 Table 的方式来切换各个窗口，但是在 QtQuick 中并没有一个叫 TabWidget 的组件。</p>
<p>与之较为接近的便是 <a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-tabbar.html">TabBar</a> 这个组件，但其没有提供子窗口的动态增加和删除。</p>
<blockquote>
<p>这里主要关注同类型窗口的动态创建</p>
</blockquote>
<span id="more"></span>

<h1 id="如何创建和删除显示组件？"><a href="#如何创建和删除显示组件？" class="headerlink" title="如何创建和删除显示组件？"></a>如何创建和删除显示组件？</h1><p>在 Qml 中，显示组件都继承自 <code>Item</code> 组件，也就是说需要找到一个可以动态创建组件的方法。</p>
<p>最开始我想到的是 <a href="https://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html">createObject()</a> 这种 API，但始终觉得这种 API 在陈述性语言中的用法是不优雅的。</p>
<p>可以人为控制组件的添加和删除，且目前以 TabWidget 的方式来显示，以后也有可能以其他方式来显示。</p>
<p>这不就是 Model-View-Delegate 的显示方式吗？</p>
<ol>
<li>控制 Model 的添加和删除</li>
<li>Delegate 根据 model 数量来动态的添加和删除</li>
<li>View 以一定的方式来显示多个 Delegate</li>
</ol>
<p>而动态的创建 <code>Item</code> 类组件的最合适方式，就是使用 <a href="https://doc.qt.io/qt-5/qml-qtquick-repeater.html">Repeater</a>。</p>
<h1 id="如何删除指定的窗口？"><a href="#如何删除指定的窗口？" class="headerlink" title="如何删除指定的窗口？"></a>如何删除指定的窗口？</h1><p>使用 Repeater 最简单的方式就是使用整数值作为其 Model，但这样子其 Model 值只能有顺序的增加和减小。</p>
<p>而我们需要选中哪一个窗口，就删除哪一个窗口，所以需要将 index 和 Model 的数值分离，以字符串的形式来表示 Model。</p>
<p>既然要灵活的修改，那么使用 <a href="https://doc.qt.io/qt-5/qml-qtqml-models-listmodel.html">ListModel</a> 是不二之选，因为它已经提供了相关方法。</p>
<h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>有了以上思考，那么代码就自然而然地出来了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Layouts <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">Window &#123;</span><br><span class="line">    property int page_cnt: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attr">height</span>: <span class="number">480</span></span><br><span class="line"></span><br><span class="line">    ListModel &#123;</span><br><span class="line">        <span class="attr">id</span>: tabModel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        <span class="attr">id</span>: button</span><br><span class="line">        <span class="attr">width</span>: <span class="number">100</span></span><br><span class="line">        <span class="attr">height</span>: <span class="number">100</span></span><br><span class="line">        anchors.top: parent.top</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;add&quot;</span></span><br><span class="line">        <span class="attr">onClicked</span>: &#123;</span><br><span class="line">            tabModel.append(&#123;<span class="attr">text</span>: page_cnt&#125;);</span><br><span class="line">            page_cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Button &#123;</span><br><span class="line">        <span class="attr">id</span>: button2</span><br><span class="line">        <span class="attr">width</span>: <span class="number">100</span></span><br><span class="line">        <span class="attr">height</span>: <span class="number">100</span></span><br><span class="line">        <span class="attr">x</span>: <span class="number">200</span></span><br><span class="line">        anchors.top: parent.top</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;sub&quot;</span></span><br><span class="line">        <span class="attr">onClicked</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span> (tabBar.count &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;remove index &quot;</span> + tabBar.currentIndex);</span><br><span class="line">                tabModel.remove(tabBar.currentIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TabBar &#123;</span><br><span class="line">        <span class="attr">id</span>: tabBar</span><br><span class="line">        anchors.top: button.bottom</span><br><span class="line">        anchors.bottom: parent.bottom</span><br><span class="line">        anchors.left: parent.left</span><br><span class="line">        anchors.right: parent.right</span><br><span class="line"></span><br><span class="line">        Repeater &#123;</span><br><span class="line">            <span class="attr">id</span>: tabBtnRepeater</span><br><span class="line">            <span class="attr">model</span> : tabModel</span><br><span class="line"></span><br><span class="line">            TabButton &#123;</span><br><span class="line">                <span class="attr">id</span>: tabButton</span><br><span class="line">                <span class="attr">width</span>: parent.width / parent.count</span><br><span class="line">                <span class="attr">text</span>: <span class="string">&quot;table&quot;</span> + modelData</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="attr">onItemAdded</span>: &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;table add :&quot;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="attr">onItemRemoved</span>: &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;table remove:&quot;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StackLayout &#123;</span><br><span class="line">        <span class="attr">width</span>: parent.width</span><br><span class="line">        <span class="attr">height</span>: parent.height / <span class="number">2</span></span><br><span class="line">        anchors.bottom: tabBar.bottom</span><br><span class="line">        anchors.horizontalCenter: parent.horizontalCenter</span><br><span class="line"></span><br><span class="line">        <span class="attr">currentIndex</span>: tabBar.currentIndex</span><br><span class="line"></span><br><span class="line">        Repeater &#123;</span><br><span class="line">            <span class="attr">id</span>: itemRepeater</span><br><span class="line"></span><br><span class="line">            <span class="attr">model</span>: tabModel</span><br><span class="line"></span><br><span class="line">            Item &#123;</span><br><span class="line">                Text &#123;</span><br><span class="line">                    <span class="attr">text</span>: <span class="string">&quot;page&quot;</span> + modelData</span><br><span class="line">                    anchors.centerIn: parent</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="attr">onItemAdded</span>: &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;page add :&quot;</span> + index);</span><br><span class="line">                <span class="built_in">console</span>.log(parent.width, parent.height, parent.x, parent.y);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="attr">onItemRemoved</span>: &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;page remove:&quot;</span> + index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下图：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BQuick%5D/usage/pic/qml_tabwidget.gif?raw=true"></p>
]]></content>
      <categories>
        <category>Qt</category>
        <category>QtQuick</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 Window 和 Viewport</title>
    <url>/2022/07/21/qtwidget_painter_viewport_window/</url>
    <content><![CDATA[<p><a href="https://doc.qt.io/qt-6/coordsys.html#window-viewport-conversion">官方文档</a>对 Window 和 Viewport 有了概念性的解释，但要理解这个概念还是要实践一下。</p>
<span id="more"></span>

<h1 id="理解概念"><a href="#理解概念" class="headerlink" title="理解概念"></a>理解概念</h1><p>根据文档，可以得到最为核心的说明：Viewport 对应物理坐标系，Window 对应逻辑坐标系，默认二者一致，Window 对应 Viewport 是一一线性映射的关系。</p>
<p>根据这个说明可以知道：</p>
<ol>
<li>默认情况下，Viewport 和 Window 坐标系是完全一致的</li>
<li>当 Viewport 固定，Window 不固定的情况下，绘制的固定大小图形会随着窗口反比例变化</li>
<li>当 Viewport 不固定，Window 固定的情况下，绘制的固定大小图形会随着窗口正比例变化</li>
<li>如果 Viewport 和 Window 设定的长和宽比例不一致，绘制的固定大小图形会发生失真</li>
</ol>
<p>要理解以上 2、3、4 点就需要明白 Window 和 Viewport 是线性映射关系，也就说说它们存在一个比例关系，那么：</p>
<ul>
<li>当 Viewport 固定而 Window 不固定的情况下，Window 越大，Window 与 Viewport 的比值就越大。而原来绘制的固定大小图形要转换为物理坐标，就要除以更大的值。所以我们会看到更小的图形，反之亦然。</li>
<li>当 Window 固定而 Viewport 不固定的情况下，Viewport 越大，Window 与 Viewport 的比值就越小。而原来绘制的固定大小图形要转换为物理坐标，就要除以更小的值。所以我们会看到更大的图形，反之亦然。</li>
<li>转换是按照长和宽比例来分别映射的，所以如果物理坐标系和逻辑坐标系的长宽比不一致，就会看到显示的图形长宽比和逻辑坐标系不一致。</li>
</ul>
<h1 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h1><p>按如下代码测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;viewport -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">viewport</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;window -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">window</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;rect -&gt;&quot;</span> &lt;&lt; <span class="built_in">rect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/default_small.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/default_big.jpg?raw=true"><br>可以看到：</p>
<ol>
<li>窗口的缩放并不会影响实际显示的图形</li>
<li>Viewport 和 Window 的大小和窗口保持一致</li>
</ol>
<p>也就验证了上面说的：默认情况下二者的坐标系是完全一致的</p>
<h1 id="Viewport-固定"><a href="#Viewport-固定" class="headerlink" title="Viewport 固定"></a>Viewport 固定</h1><p>按下面代码测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;viewport -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">viewport</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;window -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">window</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;rect -&gt;&quot;</span> &lt;&lt; <span class="built_in">rect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/fix_viewport_small.jpg?raw=true"><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/fix_viewport_big.jpg?raw=true"><br>可以看到：</p>
<ol>
<li>Window 随窗口大小而变化</li>
<li>显示的图形随窗口大小反比例变化</li>
</ol>
<p>这个现象就证实了上面第二点说明：由于比值的正向变化，导致转换到物理坐标系的显示反向变化</p>
<h1 id="Window-固定"><a href="#Window-固定" class="headerlink" title="Window 固定"></a>Window 固定</h1><p>按下面代码测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;viewport -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">viewport</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;window -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">window</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;rect -&gt;&quot;</span> &lt;&lt; <span class="built_in">rect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/fix_window_small.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/fix_window_big.jpg?raw=true"><br>可以看到：</p>
<ol>
<li>Viewport 随窗口大小而变化</li>
<li>显示的图形岁窗口大小正比例变化</li>
</ol>
<p>这个现象就证实了上面第三点说明：由于比值的反向变化，导致转换到物理坐标系的显示正向变化</p>
<h1 id="正确的使用方式"><a href="#正确的使用方式" class="headerlink" title="正确的使用方式"></a>正确的使用方式</h1><p>首先要明白是哪种情况下需要用到来设置 Viewport 和 Window？</p>
<p>当 Window 固定，Viewport 不固定的情况下，显示的绘图随窗口正比例变化。这在需要窗口随意放大缩小时比较有用。</p>
<p>假设没有设置 Viewport 和 Window 时，要满足上面的需求就要：</p>
<ol>
<li>当<code>paintEvent</code>被调用时，获取当前窗口的尺寸</li>
<li>根据当前尺寸，重新计算需要绘制图形的坐标和长宽</li>
</ol>
<p>这是个比较繁琐的工作，而且在绘制复杂图形时更为头痛。</p>
<p>但如果设置 Viewport 和 Window 时，则需要：</p>
<ol>
<li>当<code>paintEvent</code>被调用时，获取当前窗口的尺寸</li>
<li>设置 Window 为固定大小，设置 Viewport 为与 Window 比例一致且符合窗口尺寸的大小</li>
<li>绘制的图形坐标不变</li>
</ol>
<p>很明显，这种方式更为优雅简单，用户不需要知道当前窗口的尺寸，对于逻辑坐标而言，它永远是固定的。</p>
<p>使用下面代码测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line"></span><br><span class="line">    qint16 side = <span class="built_in">qMin</span>(<span class="built_in">width</span>(), <span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>((<span class="built_in">width</span>() - side) / <span class="number">2</span>, (<span class="built_in">height</span>() - side) / <span class="number">2</span>,</span><br><span class="line">                        side, side);</span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">-512</span>, <span class="number">-512</span>, <span class="number">1024</span>, <span class="number">1024</span>);</span><br><span class="line">    painter.<span class="built_in">drawRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;viewport -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">viewport</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;window -&gt; &quot;</span> &lt;&lt; painter.<span class="built_in">window</span>();</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;rect -&gt;&quot;</span> &lt;&lt; <span class="built_in">rect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/usage_small.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BQt%5D/%5BWidget%5D/painter/viewport_window/pic/usage_big.jpg?raw=true"><br>可以看到：</p>
<ol>
<li>Viewport 随着窗口大小而变化，但是是和 Window 正比例的正方形尺寸</li>
<li>图形随着窗口大小而正比例变化，且不会失真</li>
<li>逻辑绘图不用关心窗口的大小变化</li>
</ol>
<p>通过这种方式，就可以绘制随着窗口大小而自由缩放的图形了。</p>
<p>只是有一点需要注意：逻辑绘图下的图形分辨率不能太低，否则放大以后就会有锯齿。</p>
]]></content>
      <categories>
        <category>Qt</category>
        <category>QtWidget</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>初步认识 FM/PM 调制</title>
    <url>/2023/07/20/rf_dsp_modulation_fm_hello/</url>
    <content><![CDATA[<p>先以最简单的方式来认识 FM/PM 调制。</p>
<p>因为频率或相位的变化都是载波余弦角度的变化，所以调频和调相统称为<strong>角度调制</strong>。</p>
<blockquote>
<p>频率和相位之间存在密切的关系，调频必调相，调相必调频。</p>
</blockquote>
<p>因为调频和调相信号的频谱不再是线性搬移，而是频谱的非线性变换，产生新的频率成分，<br>因此调频和调相属于非线性调制。</p>
<span id="more"></span>

<h1 id="认识角度调制"><a href="#认识角度调制" class="headerlink" title="认识角度调制"></a>认识角度调制</h1><p>任何一个正余弦型时间函数，如果它的幅度不变，则可用下式表示：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/freq_and_phase1.jpg?raw=true"><br>如果加上了初相，就是：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/freq_and_initphase.jpg?raw=true"></p>
<h2 id="相位调制"><a href="#相位调制" class="headerlink" title="相位调制"></a>相位调制</h2><p>调相指的是：瞬时相位偏移与调制信号成正比。</p>
<p>其公式为：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_formula.jpg?raw=true">从前面的<strong>瞬时频率</strong>公式可以看出，相位的变换也会导致频率的变化，那么：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_formula2.jpg?raw=true"></p>
<h2 id="频率调制"><a href="#频率调制" class="headerlink" title="频率调制"></a>频率调制</h2><p>调频指的是：载波的瞬时频率偏移与调制信号成比例：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/fm_formula.jpg?raw=true">## 频率与相位的比较</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_fm_cmp1.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_fm_cmp2.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_fm_cmp3.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_fm_cmp4.jpg?raw=true"></p>
<h1 id="几种典型的角度调制"><a href="#几种典型的角度调制" class="headerlink" title="几种典型的角度调制"></a>几种典型的角度调制</h1><h2 id="单音调相"><a href="#单音调相" class="headerlink" title="单音调相"></a>单音调相</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><p>对于基带信号，其表示为：</p>
<p>$$<br>m(t) = A_{m}cosω_{m}t<br>$$<br>而对于调相，其表示为：</p>
<p>$$<br>S_{PM}(t) = A_{0}cos[ω_{c}t+k_{p}m(t)]<br>= A_{0}cos[ω_{c}t+k_{p}A_{m}cosω_{m}t]<br>$$<br>上式中的 $k_{p}A_{m}cosω_{m}t$ 就是瞬时频偏，其中的 $m_{p}=k_{p}A_{m}$ 就叫做调相指数，表示最大的相偏。</p>
<p>那么对其做微分，以求得瞬时频偏：</p>
<p>$$<br>\frac{d[ω_{c}t+m_{p}cosω_{m}t]}{dt} = ω_{c}-m_{p}ω_{m}sinω_{m}t<br>$$</p>
<ul>
<li>其瞬时频偏就是 $-m_{p}ω_{m}sinω_{m}t$</li>
<li>其最大频偏就是 $\Delta_{max} = m_{p}ω_{m}$</li>
</ul>
<p>从上面的公式也可以看出，$m_{p}$ 也表示最大相对频偏：</p>
<p>$$<br>m_{p} = \frac{\Delta_{max}}{\omega_{m}} = \frac{\Delta f_{max}}{f_{m}}<br>$$</p>
<p>比如基带信号的频率为 <code>10Hz</code>，其幅度为 <code>3</code>，那么可以被表示为：</p>
<p>$$<br>S_{m}t=A_{0}cos[ω_{c}t+3cosω_{m}t]<br>$$<br>根据上面的推导，其最大相偏就是 $m_{p}=3$ 弧度。</p>
<p>而最大频偏就是：</p>
<p>$$<br>\frac{d[ω_{c}t+3cosω_{m}t]}{dt} = ω_{c}-3ω_{m}sinω_{m}t<br>$$<br>又由于当前基带频率是 <code>10Hz</code>，那么最大频偏就是 <code>30Hz</code>。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>下面通过 matlab 来进行验证。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">base_freq = <span class="number">10</span>;</span><br><span class="line">base_amp = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">carry_freq = <span class="number">100</span>;</span><br><span class="line">carry_amp = <span class="number">1</span>;</span><br><span class="line">fs = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>:fs];</span><br><span class="line"></span><br><span class="line">pm_signal = carry_amp * <span class="built_in">cos</span>(<span class="number">2</span> * pi * carry_freq * n / fs + ...</span><br><span class="line">    base_amp * <span class="built_in">cos</span>(<span class="number">2</span> * pi * base_freq * n / fs));</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">plot(pm_signal);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">plot(<span class="number">20</span>* <span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(pm_signal)) ./ fs));</span><br></pre></td></tr></table></figure>

<p>其效果如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_single_tone.jpg?raw=true"></p>
<h2 id="单音调频"><a href="#单音调频" class="headerlink" title="单音调频"></a>单音调频</h2><h3 id="理论-1"><a href="#理论-1" class="headerlink" title="理论"></a>理论</h3><p>单音调频的表示为：</p>
<p>$$<br>\begin{aligned}<br>S_{FM}(t) &amp;= A_{0} cos[\omega_{c}t + k_{f}\int_{-\infty}^\tau m(\tau)d\tau]\<br>&amp;= A_{0} cos[\omega_{c}t + k_{f}\int_{-\infty}^\tau A_{m}cos\omega_{m}\tau d\tau]\<br>&amp;= A_{0} cos[\omega_{c}t + \frac{k_{f}A_{m}sin\omega_{m}t}{\omega_{m}}]\<br>&amp;= A_{0} cos[\omega_{c}t + m_{f}sin\omega_{m}t]\<br>\end{aligned}<br>$$</p>
<p>上式子中 $m_{f} = \frac{k_{f}A_{m}}{\omega_{m}}$ 叫做调频指数，以表示<strong>最大相偏</strong>。</p>
<blockquote>
<p>上面式子经过化简后，就和调相的公式一致了（sin 和 cos 只是有个相位偏移的差异罢了）<br>这也就是为什么将调频和调相放在一起看。</p>
</blockquote>
<p>为了求<strong>最大频偏</strong>，就需要对公式求微分，得到瞬时频率：</p>
<p>$$<br>\frac{d[\omega_{c}t + m_{f}sin\omega_{m}t]}{dt} = \omega_{c} +<br>m_{f}\omega_{m}cos\omega_{m}t<br>$$<br>那么就可以得出其最大频偏（rad/s）是 $m_{f}\omega_{m}=k_{f}A_{m}$，将该值除以 2Π，得到的就是最大频偏（Hz /s）。</p>
<p>$m_{f}$ 也表示最大相对频偏：</p>
<p>$$<br>m = \Phi_{max} (最大相偏) = \frac{\Delta\omega_{max}}{\omega_{m}} = \frac{\Delta f_{max}}{f_{m}} (最大相对频偏)<br>$$</p>
<p>比如基带信号为<code>1kHz</code>，其幅值为 $4*10^3\pi$，<code>kf</code> 为 2，那么其最大频偏就是：</p>
<p>$$<br>m_{f} \omega_{m} = k_{f} * A_{m} = 8 * 10^3\pi<br>$$</p>
<p>该值再除以 $2\pi$ 就是就是 4kHz 的频偏。</p>
<h3 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h3><p>matlab 脚本如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">clear <span class="built_in">all</span>;</span><br><span class="line">clc;</span><br><span class="line">close <span class="built_in">all</span>;</span><br><span class="line"></span><br><span class="line">kf = <span class="number">2</span>;</span><br><span class="line">Am = <span class="number">4e3</span>*pi;</span><br><span class="line">base_freq = <span class="number">1e3</span>;</span><br><span class="line">carry_freq = <span class="number">10e3</span>;</span><br><span class="line">fs = <span class="number">10e4</span>;</span><br><span class="line"></span><br><span class="line">n = [<span class="number">1</span>:fs];</span><br><span class="line"></span><br><span class="line">fm_signal = <span class="built_in">cos</span>(<span class="number">2</span>*pi*carry_freq*n/fs + ...</span><br><span class="line">    kf * Am * <span class="built_in">sin</span>(<span class="number">2</span> * pi * base_freq * n / fs) / (<span class="number">2</span> * pi * base_freq));</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">plot(fm_signal);</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">plot(<span class="number">20</span> * <span class="built_in">log10</span>(<span class="built_in">abs</span>(fft(fm_signal))./fs));</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BFM%5D/pic/pm_single_tone.jpg?raw=true"></p>
<h2 id="窄带调角"><a href="#窄带调角" class="headerlink" title="窄带调角"></a>窄带调角</h2><p>当最大相位偏移小于 $\frac{\pi}{6}$ （或 0.5）时，就称其为窄带角度调制，反之为宽带调角。</p>
]]></content>
      <categories>
        <category>DSP</category>
        <category>Modulation</category>
        <category>FM/PM</category>
      </categories>
      <tags>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>初步认识 AM 调制</title>
    <url>/2023/07/06/rf_dsp_modulation_am_hello/</url>
    <content><![CDATA[<p>先以最简单的方式来认识 AM 调制。</p>
<span id="more"></span>

<h1 id="实数混频"><a href="#实数混频" class="headerlink" title="实数混频"></a>实数混频</h1><h2 id="理解公式"><a href="#理解公式" class="headerlink" title="理解公式"></a>理解公式</h2><p>实数混频就是时域实信号的相乘，由于是实部所以取 cos 为信号产生函数：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/real_multiply_formula.jpg?raw=true">可以看到：两个实信号的混频得到的是其和频与差频。</p>
<p>这点通过欧拉公式也可以理解：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/real_multiply_euler_formula.jpg?raw=true">从上面的欧拉运算结果来看，其频谱图会出现两组对称的和频和差频。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将上面以 matlab 运算来看效果：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line">close <span class="built_in">all</span>;</span><br><span class="line"></span><br><span class="line">% 采样率及信号频率</span><br><span class="line">fs = <span class="number">10240</span>;</span><br><span class="line">f1 = <span class="number">100</span>;</span><br><span class="line">f2 = <span class="number">300</span>;</span><br><span class="line">n = [<span class="number">1</span>:fs];</span><br><span class="line"></span><br><span class="line">% 产生信号</span><br><span class="line">signal_f1 = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*n/fs);</span><br><span class="line">signal_f2 = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*n/fs);</span><br><span class="line"></span><br><span class="line">% 相乘</span><br><span class="line">signal_multiply = signal_f1 .* signal_f2;</span><br><span class="line"></span><br><span class="line">% 绘制</span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">plot(signal_f1);title(<span class="string">&quot;100Hz&quot;</span>);</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">plot(signal_f2);title(<span class="string">&quot;300Hz&quot;</span>);</span><br><span class="line">subplot(<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">plot(<span class="built_in">abs</span>(fft(signal_multiply))./fs);title(<span class="string">&quot;fft&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/multiply_fft.jpg?raw=true"></p>
<p>可以看到，得到的频率和幅度与欧拉公式推导结果一致。</p>
<blockquote>
<p>上面的脚本中，幅度除以了 N，是因为以整个频谱来看的。如果只看一半的话，那么就需要再乘以 2 做补偿。<br>DFT 运算中则需要除以 N/2 ，因为 DFT 只产生 N/2 +1 点，而 FFT 产生的是 N 个点。<br>但是对于直流和 N / 2 索引点处，都是除以 N！ </p>
</blockquote>
<h1 id="常规-AM-调制"><a href="#常规-AM-调制" class="headerlink" title="常规 AM 调制"></a>常规 AM 调制</h1><p>其实最简单的 AM 调制也就是上面信号相乘的过程，只不过是具备了直流偏移而已。直流偏移的目的是为了使得信号的值在任意时刻都为正。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_block.jpg?raw=true"><br>如果 A0 值小于 m(t) 的最大值，则会发生过调制的现象。</p>
<h2 id="单音调制"><a href="#单音调制" class="headerlink" title="单音调制"></a>单音调制</h2><p>那么对应上图（先忽略滤波器）的 matlab 脚本为：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t);</span><br><span class="line">% 产生载波信号</span><br><span class="line">carry_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t);</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (<span class="number">1</span> + base_cos).* carry_cos;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(base_cos);title(<span class="string">&quot;base band&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(carry_cos);title(<span class="string">&quot;carrier&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">plot(s_modulate);title(<span class="string">&quot;modulate&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对应的运行效果为：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_single_tone.jpg?raw=true"><br>上图的载波频率和幅度与 1.2 节的预期一致，载波的幅度比边带大，这点也可以通过欧拉公式来推导出来。</p>
<p>以上显示的是调制度为 100% 的情况，可以改变基带信号的幅度从 0<del>1，对应 0%</del>100% 调制深度。</p>
<blockquote>
<p>调制深度的计算是 Am/A0，也就是基带的幅度除以直流偏置。</p>
</blockquote>
<p>以上是实数混频的效果，当是复数混频时，频谱上就只会出现一个 载波及和频信号（这点通过欧拉公式也可以解释）：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t) + <span class="built_in">sin</span>(<span class="number">2</span>*pi*f1*t) * <span class="number">1</span>i;</span><br><span class="line">% 产生载波信号</span><br><span class="line">carry = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t) + <span class="built_in">sin</span>(<span class="number">2</span>*pi*f2*t) * <span class="number">1</span>i;</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (<span class="number">1</span> + base).* carry;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(<span class="keyword">real</span>(base));title(<span class="string">&quot;base band real&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(imag(base));title(<span class="string">&quot;base band imag&quot;</span>);</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(<span class="keyword">real</span>(carry));title(<span class="string">&quot;carrier real&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(imag(carry));title(<span class="string">&quot;carrier imag&quot;</span>);</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(<span class="keyword">real</span>(s_modulate));title(<span class="string">&quot;modulate real&quot;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(imag(s_modulate));title(<span class="string">&quot;modulate imag&quot;</span>);</span><br><span class="line"></span><br><span class="line">figure;plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_cplx_single_tone.jpg?raw=true"></p>
<h2 id="WAV-音频调制"><a href="#WAV-音频调制" class="headerlink" title="WAV 音频调制"></a>WAV 音频调制</h2><p>由于上面的是单音，所以可以很明显的区分出调制后的载波和上下边带。</p>
<p>单如果是 WAV 音频，则会看到的是一个宽频谱：因为基带信号的频率和幅度是在一直变化的，我们就会看到一个宽频信号，且幅度也在不断变化。</p>
<p>下面这段脚本是将双通道的 WAV 音频信号提取为 IQ 信号的过程：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">[audio_data, fs] = audioread(<span class="string">&quot;./audio.wav&quot;</span>);</span><br><span class="line"></span><br><span class="line">% 加入直流偏置</span><br><span class="line">data_left = audio_data(:,<span class="number">1</span>) .+ <span class="number">1</span>;</span><br><span class="line">data_right = audio_data(:,<span class="number">2</span>) .+ <span class="number">1</span>;</span><br><span class="line">out_fs = <span class="number">220500</span>;</span><br><span class="line"></span><br><span class="line">% 重采样到高采样率以满足 SDR 发送的本振频率范围</span><br><span class="line">resample_left = resample(data_left(<span class="number">500000</span>:<span class="number">700000</span>), out_fs, fs);</span><br><span class="line">resample_right = resample(data_right(<span class="number">500000</span>:<span class="number">700000</span>), out_fs, fs);</span><br><span class="line"></span><br><span class="line">data_iq = <span class="keyword">complex</span>(resample_left, resample_right);</span><br><span class="line">audiowrite(<span class="string">&quot;./audio_out.wav&quot;</span>, data_iq, out_fs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后只使用其 I 路信号发送：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_gnuradio_tx.jpg?raw=true">由于在前面的脚本已经进行了偏置，所以在 gnuradio 中就不用加入偏置了。</p>
<p>接收后的信号如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_gnuradio_rx.jpg?raw=true"><br>这里就无法明显区分出来载波和两个边带了，因为边带的频率是在不断变化了。</p>
<h2 id="过调制"><a href="#过调制" class="headerlink" title="过调制"></a>过调制</h2><p>下面看看过调制的现象：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_gnuradio_tx_overmodulation.jpg?raw=true"><br>上面的框图中直流偏置只有 0.5，运行结果如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_gnuradio_tx_overmodulation_wave.jpg?raw=true"><br>可以看到，这种波形通过解调以后，必然会产生失真。</p>
<h2 id="解调"><a href="#解调" class="headerlink" title="解调"></a>解调</h2><p>常规调幅方式效率很低，原因在于直流成分 A0 在已调信号中成为“空载波”，浪费的能量超过了有用信号。如果没有直流成分 A0 效率将会达到百分之百。但如果没有直流成分，解调后信号会发生严重的失真。只要有办法解决解调后信号的失真问题，就能大大提高调制效率。</p>
<p>这就引出了相干解调与双边带调制。</p>
<h2 id="非相干解调"><a href="#非相干解调" class="headerlink" title="非相干解调"></a>非相干解调</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_envelope_detection.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_envelope_detection2.jpg?raw=true"></p>
<h2 id="相干解调"><a href="#相干解调" class="headerlink" title="相干解调"></a>相干解调</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_dm_demodu_method.jpg?raw=true"></p>
<p>相干解调就是使用同频同相的载波与调制信号再次混频：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_cohernet_demodu.jpg?raw=true"><br>从最下面展开的公式有：</p>
<ol>
<li>直流：可以通过减去平均值滤除</li>
<li>载波的 2 倍频：可以通过低通滤波器滤除</li>
<li>基带和载波的 2 倍频的混频：可以通过低通滤波器滤除</li>
</ol>
<p>只是需要注意的是：基带和载波 2 倍频的差频是会低于载波二倍频的频率。这就需要载波的频率与基带的频率不能相离较劲，否则会导致滤波器无法滤除而形成噪音。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t);</span><br><span class="line">% 产生载波信号</span><br><span class="line">carry_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t);</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (<span class="number">1</span> + base_cos).* carry_cos;</span><br><span class="line">% 解调后的信号</span><br><span class="line">s_demodulate = s_modulate.* carry_cos;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">s_demodu_fft = fft(s_demodulate);</span><br><span class="line">s_demodu_fft_abs = <span class="built_in">abs</span>(s_demodu_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(base_cos);title(<span class="string">&quot;base band&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(carry_cos);title(<span class="string">&quot;carrier&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">plot(s_modulate);title(<span class="string">&quot;modulate&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">plot(s_demodu_fft_abs);title(<span class="string">&quot;demodu fft&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/normal_am_cohernet_demodu_fft.jpg?raw=true"></p>
<h2 id="调制深度"><a href="#调制深度" class="headerlink" title="调制深度"></a>调制深度</h2><p>调制深度在公式上来说就是基带的幅度除以偏移的值乘以百分之百，那么在频谱图上，当看到双边带后又如何在对数域反算出调制深度呢？</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/depth_dB_formula.jpg?raw=true"></p>
<h1 id="双边带调制（DSB）"><a href="#双边带调制（DSB）" class="headerlink" title="双边带调制（DSB）"></a>双边带调制（DSB）</h1><p>双边带相比单边带，那就是不加直流电压，相当于产生了过调制的现象，</p>
<p>不加直流就不会有载波，只会有合频与差频。</p>
<h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/DSB_formula.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/dsb_wave.jpg?raw=true"><br>通过 matlab 也可以仿真：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t);</span><br><span class="line">% 产生载波信号</span><br><span class="line">carry_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t);</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (base_cos).* carry_cos;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(base_cos);title(<span class="string">&quot;base band&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(carry_cos);title(<span class="string">&quot;carrier&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">plot(s_modulate);title(<span class="string">&quot;modulate&quot;</span>);</span><br><span class="line">subplot(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/matlab_dsb_out.jpg?raw=true"></p>
<h2 id="解调-1"><a href="#解调-1" class="headerlink" title="解调"></a>解调</h2><p>由于已经产生了过调制，所以无法使用包络检波的方式进行解调，而只能使用相干解调：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/dsb_demodu_method.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/dsb_demodu_method2.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/dsb_demodu_method3.jpg?raw=true"></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t);</span><br><span class="line">% 产生载波信号</span><br><span class="line">carry_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t);</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (base_cos).* carry_cos;</span><br><span class="line">% 解调后的信号</span><br><span class="line">s_demodulate = s_modulate.* carry_cos;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">s_fft_demodu = fft(s_demodulate);</span><br><span class="line">s_fft_demodu_abs = <span class="built_in">abs</span>(s_fft_demodu)./fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(base_cos);title(<span class="string">&quot;base band&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(carry_cos);title(<span class="string">&quot;carrier&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">plot(s_modulate);title(<span class="string">&quot;modulate&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br><span class="line">subplot(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">plot(s_fft_demodu_abs);title(<span class="string">&quot;fft demodu&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/dsb_demodulate_wave.jpg?raw=true"></p>
<h1 id="单边带调制（SSB）"><a href="#单边带调制（SSB）" class="headerlink" title="单边带调制（SSB）"></a>单边带调制（SSB）</h1><p>虽然双边带相比普通 AM 节省了能量，但其占用了两倍带宽，而 SSB 只占用一倍带宽，提高了信道的利用率。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/ssb_pic.jpg?raw=true"></p>
<h2 id="调制-1"><a href="#调制-1" class="headerlink" title="调制"></a>调制</h2><p>可以使用低通或高通滤波器在 DSB 的基础上产生 SSB ，但对滤波器的设计要求较高。</p>
<p>所以一般是通过矢量调制的方式来做到：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/ssb_method1.jpg?raw=true"><br>上图直流通过欧拉公式的乘除法就更加好理解。</p>
<h2 id="解调-2"><a href="#解调-2" class="headerlink" title="解调"></a>解调</h2><p>解调也是通过相干解调来完成：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/ssb_demodu_method.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/ssb_memory.jpg?raw=true"></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">close <span class="built_in">all</span>;</span><br><span class="line">clear;</span><br><span class="line">clc;</span><br><span class="line"></span><br><span class="line">fs=<span class="number">1024</span>;</span><br><span class="line">f1=<span class="number">10</span>;</span><br><span class="line">f2=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>:<span class="number">1</span>/fs:(fs-<span class="number">1</span>)/fs;</span><br><span class="line"></span><br><span class="line">% 产生基带信号</span><br><span class="line">base_signal = hilbert(<span class="built_in">cos</span>(<span class="number">2</span>*pi*f1*t));</span><br><span class="line"></span><br><span class="line">% 产生载波信号</span><br><span class="line">carry_cos = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t);</span><br><span class="line">carry_signal = <span class="built_in">cos</span>(<span class="number">2</span>*pi*f2*t) + <span class="built_in">sin</span>(<span class="number">2</span>*pi*f2*t)*<span class="number">1</span>i;</span><br><span class="line">% 调制后的信号</span><br><span class="line">s_modulate = (base_signal).* carry_signal;</span><br><span class="line">% 解调后的信号</span><br><span class="line">s_demodulate = s_modulate.* carry_cos;</span><br><span class="line"></span><br><span class="line">s_fft = fft(s_modulate);</span><br><span class="line">s_fft_abs = <span class="built_in">abs</span>(s_fft) ./ fs;</span><br><span class="line"></span><br><span class="line">s_fft_demodu = fft(s_demodulate);</span><br><span class="line">s_fft_demodu_abs = <span class="built_in">abs</span>(s_fft_demodu)./fs;</span><br><span class="line"></span><br><span class="line">figure;</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">plot(<span class="keyword">real</span>(s_modulate));title(<span class="string">&quot;modulate&quot;</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">plot(s_fft_abs);title(<span class="string">&quot;fft&quot;</span>);</span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">plot(s_fft_demodu_abs);title(<span class="string">&quot;fft demodu&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/ssb_demodu_wave.jpg?raw=true"></p>
<h1 id="残留边带调制（VSB）"><a href="#残留边带调制（VSB）" class="headerlink" title="残留边带调制（VSB）"></a>残留边带调制（VSB）</h1><p>单边带调制的滤波器法，需要理想的低通或高通滤波器，但实际中是难以实现的。如果上、下边带虽然都不是那么完整，但可以互补，合起来仍然能够得到完整的信息。</p>
<p>从双边带出发，巧妙地设计滤波器，使上、下两块不那么完整的边带互补，这样的调制方法称为残留边带调制。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/vsb_method.jpg?raw=true"><br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5BDSP%5D/%5BModulation%5D/%5BAM%5D/pic/vsb_method2.jpg?raw=true"></p>
<h1 id="一些概念的理解"><a href="#一些概念的理解" class="headerlink" title="一些概念的理解"></a>一些概念的理解</h1><h2 id="为什么-AM-调制称之为线性调制？"><a href="#为什么-AM-调制称之为线性调制？" class="headerlink" title="为什么 AM 调制称之为线性调制？"></a>为什么 AM 调制称之为线性调制？</h2><p>已调信号 s(t) 的频谱和输入基带信号 m(t) 的频谱之间满足线性搬移的关系。</p>
<p>由于频率或相位的变化都是载波的余弦角度的变化，故调频和调相统称为角度调制。</p>
<p>调频和调相的已调信号频谱不再是原调制信号频谱的线性搬移，而是频谱的非线性变化，会产生新的频率成分。因此调频和调相属于非线性调制。</p>
]]></content>
      <categories>
        <category>DSP</category>
        <category>Modulation</category>
        <category>AM</category>
      </categories>
      <tags>
        <tag>DSP</tag>
      </tags>
  </entry>
  <entry>
    <title>如何绘制 smith chart？</title>
    <url>/2022/09/03/rf_smith_chart_draw/</url>
    <content><![CDATA[<p>Smith chart 对于射频领域的重要性不言而喻，但我们应该如何通过 CPU 将其绘制出来呢？</p>
<span id="more"></span>

<h1 id="绘制的理论"><a href="#绘制的理论" class="headerlink" title="绘制的理论"></a>绘制的理论</h1><p>在 <a href="https://www.maximintegrated.com/en/design/technical-documents/tutorials/7/742.html">这篇文章</a> 中已经说明了，对于史密斯圆图，其核心公式是：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/simple_expression.jpg?raw=true"><br>由于其是复数，所以展开是：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/complex_expression.jpg?raw=true"><br>最终经过展开后，便可以得到标准的圆方程：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/circle_expression.jpg?raw=true"></p>
<p>也就是说：</p>
<ul>
<li>对于电阻圆，圆心是<code>[r/(r+1), 0]</code>，半径是<code>1/(1+r)</code></li>
<li>对于电抗圆，圆心是<code>[1,1/x]</code>，半径是<code>1/|x|</code></li>
</ul>
<p>比如当电阻 r 为<strong>归一化</strong>的 0 时，得到的圆心就是（0，0），半径就是 1，也就是最大的理论极限圆：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/resistance.jpg?raw=true"><br>当电抗 x 为归一化的<code>1</code>时，圆心就是（1，1），半径就是 1：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/reactance.jpg?raw=true"><br>有了上面的理论，圆就好画了。</p>
<h1 id="绘制弧线"><a href="#绘制弧线" class="headerlink" title="绘制弧线"></a>绘制弧线</h1><p>由于电抗圆是弧线，所以有两种办法来绘制电抗部分：</p>
<ol>
<li>仍然以圆的方式进行绘制，绘制完成后再来擦除多余的部分</li>
<li>计算要绘制圆的起始和终止角度，仅绘制需要的弧度部分</li>
</ol>
<p>第一种办法虽然画圆很简单，但是擦除的时候由于需要计算擦除的部分，也是需要避开最外面的极限圆。</p>
<p>所以用第二种办法显然是更为合理的方式。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/get_phase.jpg?raw=true"><br>如上图所示：</p>
<ul>
<li>由于已知电抗圆、电阻圆的圆心和半径，所以可以根据<strong>勾股定理</strong>求得斜边 b</li>
<li>由于已知三角形的三个边，那么根据<strong>余弦定理</strong>就可以求得弧线的角度了</li>
</ul>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><p>以下便是使用 Qt 绘制示例的主要代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M_PI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI    (3.141592653)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGIC_WIDTH     (435)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGIC_HEIGHT    (435)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVIDER_CNT     (50)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::paintEvent</span><span class="params">(QPaintEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="function">QPainter <span class="title">painter</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(Qt::red));</span><br><span class="line">    qint16 side = <span class="built_in">qMin</span>(<span class="built_in">width</span>(), <span class="built_in">height</span>());</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setViewport</span>((<span class="built_in">width</span>() - side) / <span class="number">2</span>,</span><br><span class="line">                        (<span class="built_in">height</span>() - side) / <span class="number">2</span>,</span><br><span class="line">                        side,</span><br><span class="line">                        side);</span><br><span class="line">    painter.<span class="built_in">setWindow</span>(<span class="number">0</span>, <span class="number">0</span>, LOGIC_WIDTH, LOGIC_HEIGHT);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">253</span>, <span class="number">189</span>, <span class="number">19</span>));</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(LOGIC_WIDTH / <span class="number">2</span>, <span class="number">0</span>, LOGIC_WIDTH / <span class="number">2</span>, LOGIC_HEIGHT - <span class="number">1</span>);</span><br><span class="line">    painter.<span class="built_in">drawLine</span>(<span class="number">0</span>, LOGIC_WIDTH / <span class="number">2</span>, LOGIC_WIDTH - <span class="number">1</span>, LOGIC_WIDTH / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">165</span>, <span class="number">206</span>, <span class="number">57</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">0.25</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">DrawResistance</span>(painter, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">setPen</span>(<span class="built_in">QColor</span>(<span class="number">165</span>, <span class="number">35</span>, <span class="number">142</span>));</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">0.25</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">-0.25</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">DrawReactance</span>(painter, <span class="number">-4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::DrawResistance</span><span class="params">(QPainter&amp; painter, <span class="keyword">float</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = val / (val + <span class="number">1</span>) * LOGIC_WIDTH / <span class="number">2</span> + LOGIC_WIDTH / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> y = LOGIC_HEIGHT / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span> / (<span class="number">1</span> + val) * LOGIC_HEIGHT / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawCircle</span>(painter, x, y, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::DrawReactance</span><span class="params">(QPainter&amp; painter, <span class="keyword">float</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = LOGIC_WIDTH - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = LOGIC_HEIGHT / <span class="number">2</span> - <span class="number">1</span> / val * LOGIC_HEIGHT / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span> / <span class="built_in">abs</span>(val) * LOGIC_HEIGHT / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> r2 = LOGIC_HEIGHT / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> d = <span class="built_in">sqrt</span>(r * r + r2 * r2);</span><br><span class="line">    <span class="keyword">float</span> phase = <span class="built_in">acos</span>((r2 * r2 - d * d - r * r) /</span><br><span class="line">                       (<span class="number">-2</span> * d * r)) * <span class="number">2</span>;</span><br><span class="line">    phase = phase * <span class="number">180</span> / M_PI;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> start = (<span class="number">-90</span> - phase) * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          start = <span class="number">90</span> * <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    painter.<span class="built_in">drawArc</span>(x - r, y - r, <span class="number">2</span> * r, <span class="number">2</span> * r,</span><br><span class="line">                    start, phase * <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::DrawCircle</span><span class="params">(QPainter&amp; painter, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> step = <span class="number">2</span> * M_PI / DEVIDER_CNT;</span><br><span class="line">    <span class="keyword">float</span> phase = step;</span><br><span class="line">    <span class="keyword">int</span> prev_x = x + <span class="built_in">cos</span>(<span class="number">0</span>) * r;</span><br><span class="line">    <span class="keyword">int</span> prev_y = y + <span class="built_in">sin</span>(<span class="number">0</span>) * r;</span><br><span class="line">    <span class="keyword">int</span> cur_x, cur_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= DEVIDER_CNT; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff_x = <span class="built_in">cos</span>(phase) * r;</span><br><span class="line">        <span class="keyword">int</span> diff_y = <span class="built_in">sin</span>(phase) * r;</span><br><span class="line">        cur_x = x + diff_x;</span><br><span class="line">        cur_y = y + diff_y;</span><br><span class="line"></span><br><span class="line">        painter.<span class="built_in">drawLine</span>(prev_x, prev_y, cur_x, cur_y);</span><br><span class="line"></span><br><span class="line">        phase += step;</span><br><span class="line">        prev_x = cur_x;</span><br><span class="line">        prev_y = cur_y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下图：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5BRF%5D/%5Bimplement%5D/%5Bsmith_chart%5D/pic/chart.jpg?raw=true"></p>
]]></content>
      <categories>
        <category>RF</category>
        <category>Smith chart</category>
      </categories>
      <tags>
        <tag>RF</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32 SPI 作为从机的注意事项</title>
    <url>/2022/03/31/stm32spi_as_slave/</url>
    <content><![CDATA[<p>两个 stm32 通过 SPI 进行通信，一主一从，但从机不能使用 CubeMX 的默认配置，不然会被带进坑……</p>
<span id="more"></span>

<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>目前我两个 stm32f4 芯片通过 SPI 进行主从通信，但从机获取的<strong>第一帧</strong>数据会丢失一个位，其配置如下：</p>
<p>主机：</p>
<ul>
<li>CPOL = 0，CPHA = 0</li>
<li>软件片选</li>
</ul>
<p>从机：</p>
<ul>
<li>CPOL = 0，CPHA = 0</li>
<li>硬件片选</li>
</ul>
<p>其现象如下：</p>
<ul>
<li>当主机启动，第一次发送 <code>0xA5</code> 时，从机会接收到<code>0xD2</code></li>
<li>当主机启动，第一次发送 <code>0x53</code> 时，从机会接收到<code>0x29</code></li>
</ul>
<p>经过二进制对比可以发现：从机接收到的数据相比主机右移了一位，也就是说<strong>从机相比主机更早的接收到了一个时钟</strong>。</p>
<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>要找到这个问题，首先就需要缩小范围，判断是主机的问题还是从机的问题。</p>
<p>逻辑分析仪抓取主机发送时序如下：<br><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5Bstm32%5D/%5Bperipheral%5D/pic/spi_master_send.jpg?raw=true"><br>可以看到，SCK 在 MOSI 发送数据前，居然被拉高了！</p>
<blockquote>
<p>前面的配置中，CPOL = 0，那么此时 SCK 应该保持低电平才对。</p>
</blockquote>
<p>那可以猜想：从机判断 SCK 拉高了，误认为这是一个信号，所以从机会比主机提前接收一个 bit。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>有以下几种解决办法：</p>
<h2 id="配置管脚状态"><a href="#配置管脚状态" class="headerlink" title="配置管脚状态"></a>配置管脚状态</h2><p>既然主机会莫名其妙的提前将 SCK 拉高，那么我们在从机端也可以将 SCK 管脚配置为 <code>GPIO_PULLDOWN</code> 模式（默认 CubeMX 生成的代码是 <code>GPIO_NOPULL</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SCK Pin should be pulled down when CPOL = 0</span></span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLDOWN;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;</span><br><span class="line">GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;</span><br><span class="line"><span class="built_in">HAL_GPIO_Init</span>(GPIOB, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>
<p>经测试，这下就可以正常稳定的通信了。</p>
<p>在解决后，我尝试搜索是否别人也遇到了这个问题，还是我这个是个例。</p>
<p>最终发送在<a href="https://electronics.stackexchange.com/questions/492271/stm32f4-spi-communication-fails-when-polarity-is-low">stackexchange</a> 上也遇到了同样的问题，而且其逻辑分析仪结果与我的一致，看来这个是 ST 的锅了……</p>
<h2 id="配置时钟极性"><a href="#配置时钟极性" class="headerlink" title="配置时钟极性"></a>配置时钟极性</h2><p>既然主机会莫名其妙的提前将 SCK 拉高，那么我们也可以将主从机 SCK 极性配置为高，已掩盖掉此问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">hspi3.Instance = SPI3;</span><br><span class="line">hspi3.Init.Mode = SPI_MODE_MASTER;</span><br><span class="line">hspi3.Init.Direction = SPI_DIRECTION_2LINES;</span><br><span class="line">hspi3.Init.DataSize = SPI_DATASIZE_8BIT;</span><br><span class="line">hspi3.Init.CLKPolarity = SPI_POLARITY_HIGH;<span class="comment">//SPI_POLARITY_HIGH;//SPI_POLARITY_LOW;</span></span><br><span class="line">hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;<span class="comment">//SPI_PHASE_1EDGE;</span></span><br><span class="line">hspi3.Init.NSS = SPI_NSS_SOFT;</span><br><span class="line">hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;</span><br><span class="line">hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;</span><br><span class="line">hspi3.Init.TIMode = SPI_TIMODE_DISABLE;</span><br><span class="line">hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;</span><br><span class="line">hspi3.Init.CRCPolynomial = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">HAL_SPI_Init</span>(&amp;hspi3) != HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Error_Handler</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个经过测试，也是可以稳定通信的。</p>
]]></content>
      <categories>
        <category>processor</category>
        <category>stm32</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>ZynqMP 的启动和配置</title>
    <url>/2024/12/31/zynqmp_boot/</url>
    <content><![CDATA[<p>这里记录 ZynqMP 的启动和配置过程。</p>
<span id="more"></span>

<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>zynqmp 的启动及配置过程由 PMU（Platform management unit）和 CSU（configuration security unit）来管理，其大体上包含以下 3 个过程：</p>
<ol>
<li><p>Pre-confituration stage：系统上电启动时会复位 CSU 和 PMU，PMU 会执行 PMU ROM Code 来设置系统。主要是用于基本的初始化和唤醒处理器。</p>
</li>
<li><p>Configuration stage：CSU ROM 会分析<code>boot.bin</code>的文件头，配置系统。然后将 FSBL 加载到内部的 on-chip RAM 执行安全或非安全启动。CSU 还会加载 PMU 用户固件（PMU FW）到 PMU RAM，用于对系统硬件进行管理配置。</p>
</li>
<li><p>Post-configuration stage：当 FSBL 开始执行后，CSU ROM 就会进入 post-configuration 阶段。这个阶段是 CSU 硬件提供对文件的校验、配置 PL 、解密等功能。</p>
</li>
</ol>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>PMU 启动时会执行一些必须和可选的流程：</p>
<ul>
<li><p>清零低功耗域（LPD）寄存器（可选）：当 LPD_SC eFUSEs 被编程，则会执行该步骤</p>
</li>
<li><p>清零全功耗域（FPD）寄存器（可选）：当 FPD_SC eFUSEs 被编程，则会执行该步骤</p>
</li>
<li><p>清零 PMU RAM：先将 RAM 写 0 然后回读验证，以确保写入成功</p>
</li>
<li><p>清零 PMU 处理器的 TLB 内存</p>
</li>
<li><p>电压检测：PMU 会检查 LPD、AUX、专用 I/O 的电压，以确保可以正常工作</p>
</li>
<li><p>清零内存：PMU 会清零 CSU、LPD、FPD 的内存</p>
</li>
</ul>
<p>PMU 的职责之一就是在硬件上电复位后，对系统各部分进行正确的上电，然后进入后台模式（管理其他部分的上电、睡眠、唤醒等），其上电复位后 PMU ROM code 执行流程为：</p>
<ol>
<li><p>初始化 PS SYSMON 单元以及 PLL</p>
</li>
<li><p>清空 PMU RAM 和 CSU RAM</p>
</li>
<li><p>检查 PLL 是否锁定</p>
</li>
<li><p>通过 PS SYSMON 单元检查 LPD，AUX 以及 I/O 电压是否在正常范围内</p>
</li>
<li><p>清空低功耗域以及全功耗域</p>
</li>
<li><p>当以上步骤无误后，进入到 CSU 阶段，并且自己进入服务模式（如果 PMUFW 没有被使用，则 PMU 模块进入睡眠模式）</p>
</li>
</ol>
<p>CSU 启动后，其执行流程为：</p>
<ol>
<li><p>初始化片内 RAM</p>
</li>
<li><p>PMU 在复位阶段获取到了启动引脚的配置，CSU 根据该配置来确定应该从哪里读取启动代码</p>
</li>
<li><p>CSU 将 FSBL 加载到片内 RAM 执行。</p>
</li>
<li><p>CSU 将 PMU FW 加载到 PMU RAM 进行执行</p>
</li>
</ol>
<p>PMU FW 主要用于对硬件进行管理，它与 FSBL 进行结合使用。</p>
<p>CSU 主要用于加密和非加密的系统配置、密钥管理、PS/PL 编程接口等，它主要由以下两个部分组成：</p>
<ol>
<li><p>三重冗余的安全处理器</p>
</li>
<li><p>加密接口，包括 AES、RSA、SHA3 等</p>
</li>
</ol>
<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/bootmode.jpg?raw=true"><br>zynqmp 支持 multi-boot 搜寻，其搜寻范围如下：</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_search_limit.jpg?raw=true"><br>那么很明显，在 QSPI 中，应该使用 32bit 模式以支持更大的范围。</p>
<h2 id="启动代码的搜寻"><a href="#启动代码的搜寻" class="headerlink" title="启动代码的搜寻"></a>启动代码的搜寻</h2><p>CSU 运行 BootROM 来搜寻合法的 boot header 并运行启动代码，是根据搜寻头中是否有字符串<code>XLNX</code>来判断头的合法性。一旦找到该字符串，就会对头进行校验和。如果校验和成功则会从启动代码中载入 FSBL 到 OCM 执行。</p>
<p>启动代码存放的位置需要以 32KB 对齐，因为 BootROM 会以 32KB 的步进来搜寻合法的启动头。</p>
<p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_search.jpg?raw=true"><br>在 FSBL 中，可以将备份的启动代码位置除以 32KB 写入<code>CSU.csu_multi_boot</code>寄存器，在热复位以后就可以从该寄存器获取地址然后乘以 32KB得到启动代码的位置。</p>
<p>如果该备份启动代码头不合法，则会通过常规的方式来查找合法的启动代码头。</p>
<h1 id="启动镜像的结构"><a href="#启动镜像的结构" class="headerlink" title="启动镜像的结构"></a>启动镜像的结构</h1><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/normal_boot_image_format.jpg?raw=true"><br>上图是普通启动镜像的结构，无论镜像是否加密，它们的<code>boot header</code>和<code>partition header</code>都是一样的。</p>
<h2 id="Boot-Header-Format"><a href="#Boot-Header-Format" class="headerlink" title="Boot Header Format"></a>Boot Header Format</h2><table>
<thead>
<tr>
<th>偏移</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x00~0x1C</td>
<td>为支持 XIP 方式的 Flash 而保留的中断向量表</td>
</tr>
<tr>
<td>0x20</td>
<td>指定 QSPI 的位宽</td>
</tr>
<tr>
<td>0x24</td>
<td>启动镜像的头<code>XNLX</code></td>
</tr>
<tr>
<td>0x28</td>
<td>加密状态</td>
</tr>
<tr>
<td>0x2C</td>
<td>FSBL 的执行地址</td>
</tr>
<tr>
<td>0x30</td>
<td>PMU FW 和 FSBL 的存放起始地址</td>
</tr>
<tr>
<td>0x34</td>
<td>PMU FW 的原始镜像大小</td>
</tr>
<tr>
<td>0x38</td>
<td>总共 PMU FW 镜像的大小</td>
</tr>
<tr>
<td>0x3c</td>
<td>FSBL 原始镜像大小</td>
</tr>
<tr>
<td>0x40</td>
<td>总共 FSBL 镜像大小</td>
</tr>
<tr>
<td>0x44</td>
<td>镜像的属性</td>
</tr>
<tr>
<td>0x48</td>
<td>头的检验和从 0x20~0x44</td>
</tr>
<tr>
<td>0x4c-0x68</td>
<td>混淆密钥，只在加密状态为A35C_7CA5h 才有效</td>
</tr>
<tr>
<td>0x6c</td>
<td>保留</td>
</tr>
<tr>
<td>0x70~0x9c</td>
<td>FSBL/User 定义</td>
</tr>
<tr>
<td>0xa0~0xa8</td>
<td>加密镜像的初始向量</td>
</tr>
<tr>
<td>0xac~0xb4</td>
<td></td>
</tr>
<tr>
<td>0xb8~0x8b4</td>
<td>系统寄存器的初始化值</td>
</tr>
<tr>
<td>0x8b8~0xec0</td>
<td>PUF 帮助数据</td>
</tr>
</tbody></table>
<h2 id="QSPI-的位宽判定"><a href="#QSPI-的位宽判定" class="headerlink" title="QSPI 的位宽判定"></a>QSPI 的位宽判定</h2><p>如果启动设备是 QSPI 的话，BootROM 会先以 X1 的方式读取启动镜像的头，如果地址<code>0x20</code>处的位宽值为<code>0xAA995566</code>，则表示 flash 位宽为 4 位位宽。然后 BootROM 会切换为 X4 模式读取镜像文件内容（如果 X4 失败了，则会依次尝试 X2、X1 模式）。</p>
<h2 id="镜像文件的属性"><a href="#镜像文件的属性" class="headerlink" title="镜像文件的属性"></a>镜像文件的属性</h2><p><img src="https://github.com/KcMeterCEC/explore/blob/master/%5Bprocessor%5D/%5BZynq%5D/%5BWhat%5DZynqmp-boot/pic/boot_image_format.jpg?raw=true"></p>
]]></content>
      <categories>
        <category>processor</category>
        <category>zynq</category>
      </categories>
      <tags>
        <tag>zynq</tag>
      </tags>
  </entry>
</search>
